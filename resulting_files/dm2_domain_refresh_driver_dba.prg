CREATE PROGRAM dm2_domain_refresh_driver:dba
 SET trace progcachesize 255
 IF ((validate(dcr_max_stack_size,- (1))=- (1))
  AND (validate(dcr_max_stack_size,- (2))=- (2)))
  DECLARE dcr_max_stack_size = i4 WITH protect, constant(30)
 ENDIF
 IF (validate(dm_err->ecode,- (1)) < 0
  AND validate(dm_err->ecode,722)=722)
  FREE RECORD dm_err
  IF (currev >= 8)
   RECORD dm_err(
     1 logfile = vc
     1 debug_flag = i2
     1 ecode = i4
     1 emsg = vc
     1 eproc = vc
     1 err_ind = i2
     1 user_action = vc
     1 asterisk_line = c80
     1 tempstr = vc
     1 errfile = vc
     1 errtext = vc
     1 unique_fname = vc
     1 disp_msg_emsg = vc
     1 disp_dcl_err_ind = i2
   )
  ELSE
   RECORD dm_err(
     1 logfile = vc
     1 debug_flag = i2
     1 ecode = i4
     1 emsg = c132
     1 eproc = vc
     1 err_ind = i2
     1 user_action = vc
     1 asterisk_line = c80
     1 tempstr = vc
     1 errfile = vc
     1 errtext = vc
     1 unique_fname = vc
     1 disp_msg_emsg = vc
     1 disp_dcl_err_ind = i2
   )
  ENDIF
  SET dm_err->asterisk_line = fillstring(80,"*")
  SET dm_err->ecode = 0
  IF (validate(dm2_debug_flag,- (1)) > 0)
   SET dm_err->debug_flag = dm2_debug_flag
  ELSE
   SET dm_err->debug_flag = 0
  ENDIF
  SET dm_err->err_ind = 0
  SET dm_err->user_action = "NONE"
  SET dm_err->tempstr = " "
  SET dm_err->errfile = "NONE"
  SET dm_err->logfile = "NONE"
  SET dm_err->unique_fname = "NONE"
  SET dm_err->disp_dcl_err_ind = 1
 ENDIF
 IF (validate(dm2_sys_misc->cur_os,"X")="X"
  AND validate(dm2_sys_misc->cur_os,"Y")="Y")
  FREE RECORD dm2_sys_misc
  RECORD dm2_sys_misc(
    1 cur_os = vc
    1 cur_db_os = vc
  )
  SET dm2_sys_misc->cur_os = validate(cursys2,cursys)
  SET dm2_sys_misc->cur_db_os = validate(currdbsys,cursys)
  IF (size(dm2_sys_misc->cur_db_os) != 3)
   SET dm2_sys_misc->cur_db_os = substring(1,(findstring(":",dm2_sys_misc->cur_db_os,1,1) - 1),
    dm2_sys_misc->cur_db_os)
  ENDIF
 ENDIF
 IF (validate(dm2_install_schema->process_option," ")=" "
  AND validate(dm2_install_schema->process_option,"NOTTHERE")="NOTTHERE")
  FREE RECORD dm2_install_schema
  RECORD dm2_install_schema(
    1 process_option = vc
    1 file_prefix = vc
    1 schema_loc = vc
    1 schema_prefix = vc
    1 target_dbase_name = vc
    1 dbase_name = vc
    1 u_name = vc
    1 p_word = vc
    1 connect_str = vc
    1 v500_p_word = vc
    1 v500_connect_str = vc
    1 cdba_p_word = vc
    1 cdba_connect_str = vc
    1 run_id = i4
    1 menu_driver = vc
    1 oragen3_ignore_dm_columns_doc = i2
    1 last_checkpoint = vc
    1 gen_id = i4
    1 restart_method = i2
    1 appl_id = vc
    1 hostname = vc
    1 ccluserdir = vc
    1 cer_install = vc
    1 servername = vc
    1 frmt_servername = vc
    1 default_fg_name = vc
    1 curprog = vc
    1 adl_username = vc
    1 tgt_sch_cleanup = i2
    1 special_ih_process = i2
    1 dbase_type = vc
    1 data_to_move = c30
    1 percent_tspace = i4
    1 src_dbase_name = vc
    1 src_v500_p_word = vc
    1 src_v500_connect_str = vc
    1 logfile_prefix = vc
    1 src_run_id = f8
    1 src_op_id = f8
    1 target_env_name = vc
    1 dm2_updt_task_value = i2
  )
  SET dm2_install_schema->process_option = "NONE"
  SET dm2_install_schema->file_prefix = "NONE"
  SET dm2_install_schema->schema_loc = "NONE"
  SET dm2_install_schema->schema_prefix = "NONE"
  SET dm2_install_schema->target_dbase_name = "NONE"
  SET dm2_install_schema->dbase_name = "NONE"
  SET dm2_install_schema->u_name = "NONE"
  SET dm2_install_schema->p_word = "NONE"
  SET dm2_install_schema->connect_str = "NONE"
  SET dm2_install_schema->v500_p_word = "NONE"
  SET dm2_install_schema->v500_connect_str = "NONE"
  SET dm2_install_schema->cdba_p_word = "NONE"
  SET dm2_install_schema->cdba_connect_str = "NONE"
  SET dm2_install_schema->run_id = 0
  SET dm2_install_schema->menu_driver = "NONE"
  SET dm2_install_schema->oragen3_ignore_dm_columns_doc = 0
  SET dm2_install_schema->last_checkpoint = "NONE"
  SET dm2_install_schema->gen_id = 0
  SET dm2_install_schema->restart_method = 0
  SET dm2_install_schema->appl_id = "NONE"
  SET dm2_install_schema->hostname = "NONE"
  SET dm2_install_schema->servername = "NONE"
  SET dm2_install_schema->default_fg_name = "NONE"
  SET dm2_install_schema->curprog = "NONE"
  SET dm2_install_schema->adl_username = "NONE"
  SET dm2_install_schema->tgt_sch_cleanup = 0
  SET dm2_install_schema->special_ih_process = 0
  SET dm2_install_schema->dbase_type = "NONE"
  SET dm2_install_schema->data_to_move = "NONE"
  SET dm2_install_schema->percent_tspace = 0
  SET dm2_install_schema->src_dbase_name = "NONE"
  SET dm2_install_schema->src_v500_p_word = "NONE"
  SET dm2_install_schema->src_v500_connect_str = "NONE"
  SET dm2_install_schema->logfile_prefix = "NONE"
  SET dm2_install_schema->src_run_id = 0
  SET dm2_install_schema->src_op_id = 0
  SET dm2_install_schema->target_env_name = "NONE"
  SET dm2_install_schema->dm2_updt_task_value = 15301
  IF ((dm2_sys_misc->cur_os="WIN"))
   SET dm2_install_schema->ccluserdir = build(logical("ccluserdir"),"\")
   SET dm2_install_schema->cer_install = build(logical("cer_install"),"\")
  ELSEIF ((dm2_sys_misc->cur_os="AXP"))
   SET dm2_install_schema->ccluserdir = logical("ccluserdir")
   SET dm2_install_schema->cer_install = logical("cer_install")
  ELSE
   SET dm2_install_schema->ccluserdir = build(logical("ccluserdir"),"/")
   SET dm2_install_schema->cer_install = build(logical("cer_install"),"/")
  ENDIF
 ENDIF
 IF (validate(inhouse_misc->inhouse_domain,- (1)) < 0
  AND validate(inhouse_misc->inhouse_domain,722)=722)
  FREE RECORD inhouse_misc
  RECORD inhouse_misc(
    1 inhouse_domain = i2
    1 fk_err_ind = i2
    1 nonfk_err_ind = i2
    1 fk_parent_table = vc
    1 tablespace_err_code = f8
    1 foreignkey_err_code = f8
  )
  SET inhouse_misc->inhouse_domain = - (1)
  SET inhouse_misc->fk_err_ind = 0
  SET inhouse_misc->nonfk_err_ind = 0
  SET inhouse_misc->fk_parent_table = ""
  SET inhouse_misc->tablespace_err_code = 93
  SET inhouse_misc->foreignkey_err_code = 94
 ENDIF
 IF (validate(program_stack_rs->cnt,1)=1
  AND validate(program_stack_rs->cnt,2)=2)
  FREE RECORD program_stack_rs
  RECORD program_stack_rs(
    1 cnt = i4
    1 qual[*]
      2 name = vc
  )
  SET stat = alterlist(program_stack_rs->qual,dcr_max_stack_size)
 ENDIF
 DECLARE dm2_push_cmd(sbr_dpcstr=vc,sbr_cmd_end=i2) = i2
 DECLARE dm2_push_dcl(sbr_dpdstr=vc) = i2
 DECLARE get_unique_file(sbr_fprefix=vc,sbr_fext=vc) = i2
 DECLARE parse_errfile(sbr_errfile=vc) = i2
 DECLARE check_error(sbr_ceprocess=vc) = i2
 DECLARE disp_msg(sbr_demsg=vc,sbr_dlogfile=vc,sbr_derr_ind=i2) = null
 DECLARE init_logfile(sbr_logfile=vc,sbr_header_msg=vc) = i2
 DECLARE check_logfile(sbr_lprefix=vc,sbr_lext=vc,sbr_hmsg=vc) = i2
 DECLARE final_disp_msg(sbr_log_prefix=vc) = null
 DECLARE dm2_set_autocommit(sbr_dsa_flag=i2) = i2
 DECLARE dm2_prg_maint(sbr_maint_type=vc) = i2
 DECLARE dm2_set_inhouse_domain() = i2
 DECLARE dm2_table_exists(dte_table_name=vc) = c1
 DECLARE dm2_table_and_ccldef_exists(dtace_table_name=vc,dtace_found_ind=i2(ref)) = i2
 DECLARE dm2_table_column_exists(dtce_owner=vc,dtce_table_name=vc,dtce_column_name=vc,
  dtce_col_chk_ind=i2,dtce_coldef_chk_ind=i2,
  dtce_ccldef_mode=i2,dtce_col_fnd_ind=i2(ref),dtce_coldef_fnd_ind=i2(ref),dtce_data_type=vc(ref)) =
 i2
 DECLARE dm2_disp_file(ddf_fname=vc,ddf_desc=vc) = i2
 DECLARE dm2_get_program_stack(null) = vc
 SUBROUTINE dm2_push_cmd(sbr_dpcstr,sbr_cmd_end)
   IF ((dm_err->debug_flag > 0))
    CALL echo("*")
    CALL echo(concat("dm2_push_cmd executing: ",sbr_dpcstr))
    CALL echo("*")
   ENDIF
   CALL parser(sbr_dpcstr,1)
   SET dm_err->tempstr = concat(dm_err->tempstr," ",sbr_dpcstr)
   IF (sbr_cmd_end=1)
    IF ((dm_err->err_ind=0))
     IF (check_error(concat("dm2_push_cmd executing: ",dm_err->tempstr))=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      SET dm_err->tempstr = " "
      RETURN(0)
     ENDIF
    ENDIF
    SET dm_err->tempstr = " "
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_push_dcl(sbr_dpdstr)
   DECLARE dpd_stat = i4 WITH protect, noconstant(0)
   DECLARE newstr = vc WITH protect
   DECLARE strloc = i4 WITH protect, noconstant(0)
   DECLARE temp_file = vc WITH protect, noconstant(" ")
   DECLARE str2 = vc WITH protect, noconstant(" ")
   DECLARE posx = i4 WITH protect, noconstant(0)
   DECLARE sql_warn_ind = i2 WITH protect, noconstant(0)
   DECLARE dpd_disp_dcl_err_ind = i2 WITH protect, noconstant(1)
   IF ((validate(dm_err->disp_dcl_err_ind,- (1))=- (1))
    AND (validate(dm_err->disp_dcl_err_ind,- (2))=- (2)))
    SET dpd_disp_dcl_err_ind = 1
   ELSE
    SET dpd_disp_dcl_err_ind = dm_err->disp_dcl_err_ind
    SET dm_err->disp_dcl_err_ind = 1
   ENDIF
   IF ((dm_err->errfile="NONE"))
    IF (get_unique_file("dm2_",".err")=0)
     RETURN(0)
    ELSE
     SET dm_err->errfile = dm_err->unique_fname
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os IN ("AXP")))
    SET strloc = findstring(">",sbr_dpdstr,1,0)
    IF (strloc > 0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Cannot support additional piping outside of push dcl subroutine"
     SET dm_err->eproc = "Check push dcl command for piping character (>)."
     RETURN(0)
    ENDIF
    SET newstr = concat("pipe ",sbr_dpdstr," > ccluserdir:",dm_err->errfile)
   ELSE
    SET strloc = findstring(">",sbr_dpdstr,1,0)
    IF (strloc > 0)
     SET strlength = size(trim(sbr_dpdstr))
     IF (findstring("2>&1",sbr_dpdstr) > 0)
      SET temp_file = build(substring((strloc+ 1),((strlength - strloc) - 4),sbr_dpdstr))
     ELSE
      SET temp_file = build(substring((strloc+ 1),(strlength - strloc),sbr_dpdstr))
     ENDIF
     SET newstr = sbr_dpdstr
    ELSE
     SET newstr = concat(sbr_dpdstr," > ",dm2_install_schema->ccluserdir,dm_err->errfile," 2>&1")
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo("*")
    CALL echo(concat("dm2_push_dcl executing: ",newstr))
    CALL echo("*")
   ENDIF
   CALL dcl(newstr,size(newstr),dpd_stat)
   IF (dpd_stat=0)
    IF (temp_file > " ")
     CASE (dm2_sys_misc->cur_os)
      OF "WIN":
       SET str2 = concat("copy ",temp_file," ",dm_err->errfile)
      ELSE
       IF ((dm2_sys_misc->cur_os != "AXP"))
        SET str2 = concat("cp ",temp_file," ",dm_err->errfile)
       ENDIF
     ENDCASE
     CALL dcl(str2,size(str2),dpd_stat)
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (sql_warn_ind=true)
     SET dm_err->user_action = "NONE"
     SET dm_err->eproc = concat("Warning Encountered:",dm_err->errtext)
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET dm_err->disp_msg_emsg = dm_err->errtext
     SET dm_err->emsg = dm_err->disp_msg_emsg
     IF (dpd_disp_dcl_err_ind=1)
      SET dm_err->eproc = concat("dm2_push_dcl executing: ",newstr)
      SET dm_err->err_ind = 1
      CALL disp_msg("dm_err->disp_msg_emsg",dm_err->logfile,1)
     ELSE
      IF ((dm_err->debug_flag > 1))
       CALL echo("Call dcl failed- error handling done by calling script")
      ENDIF
     ENDIF
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echo(concat("PARSING THROUGH - ",dm_err->errfile))
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE get_unique_file(sbr_fprefix,sbr_fext)
   DECLARE guf_return_val = i4 WITH protect, noconstant(1)
   DECLARE fini = i2 WITH protect, noconstant(0)
   DECLARE fname = vc WITH protect
   DECLARE unique_tempstr = vc WITH protect
   WHILE (fini=0)
     IF ((((validate(systimestamp,- (999.00))=- (999.00))
      AND validate(systimestamp,999.00)=999.00) OR (validate(dm2_bypass_unique_file,- (1))=1)) )
      SET unique_tempstr = substring(1,6,cnvtstring((datetimediff(cnvtdatetime(curdate,curtime3),
         cnvtdatetime(curdate,000000)) * 864000)))
     ELSEIF ((validate(systimestamp,- (999.00)) != - (999.00))
      AND validate(systimestamp,999.00) != 999.00
      AND (validate(dm2_bypass_unique_file,- (1))=- (1))
      AND (validate(dm2_bypass_unique_file,- (2))=- (2)))
      SET unique_tempstr = format(systimestamp,"hhmmsscccccc;;q")
     ENDIF
     SET fname = cnvtlower(build(sbr_fprefix,unique_tempstr,sbr_fext))
     IF (findfile(fname)=0)
      SET fini = 1
     ENDIF
   ENDWHILE
   IF (check_error(concat("Getting unique file name using prefix: ",sbr_fprefix," and ext: ",sbr_fext
     ))=1)
    SET guf_return_val = 0
   ENDIF
   IF (guf_return_val=0)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo(concat("Error occurred in ",dm_err->eproc))
    CALL echo("*")
    CALL echo(trim(dm_err->emsg))
    CALL echo("*")
    IF ((dm_err->user_action != "NONE"))
     CALL echo(dm_err->user_action)
     CALL echo("*")
    ENDIF
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
   ELSE
    SET dm_err->unique_fname = fname
    CALL echo(concat("**Unique filename = ",dm_err->unique_fname))
   ENDIF
   RETURN(guf_return_val)
 END ;Subroutine
 SUBROUTINE parse_errfile(sbr_errfile)
   SET dm_err->errtext = " "
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(sbr_errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("TEXT = ",r.line))
     ENDIF
     dm_err->errtext = build(dm_err->errtext,r.line)
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(concat("Parsing error file ",dm_err->errfile))=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE check_error(sbr_ceprocess)
   DECLARE return_val = i4 WITH protect, noconstant(0)
   IF ((dm_err->err_ind=1))
    SET return_val = 1
   ELSE
    SET dm_err->ecode = error(dm_err->emsg,1)
    IF ((dm_err->ecode != 0))
     SET dm_err->eproc = sbr_ceprocess
     SET dm_err->err_ind = 1
     SET return_val = 1
    ENDIF
   ENDIF
   RETURN(return_val)
 END ;Subroutine
 SUBROUTINE disp_msg(sbr_demsg,sbr_dlogfile,sbr_derr_ind)
   DECLARE dm_txt = c132 WITH protect
   DECLARE dm_ecode = i4 WITH protect
   DECLARE dm_emsg = c132 WITH protect
   DECLARE dm_full_emsg = vc WITH protect
   DECLARE dm_eproc_length = i4 WITH protect
   DECLARE dm_full_emsg_length = i4 WITH protect
   DECLARE dm_user_action_length = i4 WITH protect
   IF (sbr_demsg="dm_err->disp_msg_emsg")
    SET dm_full_emsg = dm_err->disp_msg_emsg
   ELSE
    SET dm_full_emsg = sbr_demsg
   ENDIF
   SET dm_eproc_length = textlen(dm_err->eproc)
   SET dm_full_emsg_length = textlen(dm_full_emsg)
   SET dm_user_action_length = textlen(dm_err->user_action)
   IF ( NOT (sbr_dlogfile IN ("NONE", "DM2_LOGFILE_NOTSET"))
    AND trim(sbr_dlogfile) != ""
    AND sbr_derr_ind IN (0, 1, 10))
    SELECT INTO value(sbr_dlogfile)
     FROM (dummyt d  WITH seq = 1)
     HEAD REPORT
      beg_pos = 1, end_pos = 132, not_done = 1
     DETAIL
      row + 1, curdate"mm/dd/yyyy;;d", " ",
      curtime3"hh:mm:ss;3;m"
      IF (sbr_derr_ind=1)
       row + 1, "* Component Name:  ", curprog,
       row + 1, "* Process Description:  "
      ENDIF
      dm_txt = substring(beg_pos,end_pos,dm_err->eproc)
      WHILE (not_done=1)
        row + 1, col 0, dm_txt
        IF (end_pos > dm_eproc_length)
         not_done = 0
        ELSE
         beg_pos = (end_pos+ 1), end_pos = (end_pos+ 132), dm_txt = substring(beg_pos,132,dm_err->
          eproc)
        ENDIF
      ENDWHILE
      IF (sbr_derr_ind=1)
       row + 1, "* Error Message:  ", beg_pos = 1,
       end_pos = 132, dm_txt = substring(beg_pos,132,dm_full_emsg), not_done = 1
       WHILE (not_done=1)
         row + 1, col 0, dm_txt
         IF (end_pos > dm_full_emsg_length)
          not_done = 0
         ELSE
          beg_pos = (end_pos+ 1), end_pos = (end_pos+ 132), dm_txt = substring(beg_pos,132,
           dm_full_emsg)
         ENDIF
       ENDWHILE
      ENDIF
      IF ((dm_err->user_action != "NONE"))
       row + 1, "* Recommended Action(s):  ", beg_pos = 1,
       end_pos = 132, dm_txt = substring(beg_pos,132,dm_err->user_action), not_done = 1
       WHILE (not_done=1)
         row + 1, col 0, dm_txt
         IF (end_pos > dm_user_action_length)
          not_done = 0
         ELSE
          beg_pos = (end_pos+ 1), end_pos = (end_pos+ 132), dm_txt = substring(beg_pos,132,dm_err->
           user_action)
         ENDIF
       ENDWHILE
      ENDIF
      row + 1
     WITH nocounter, format = variable, formfeed = none,
      maxrow = 1, maxcol = 200, append
    ;end select
    SET dm_ecode = error(dm_emsg,1)
   ELSEIF (sbr_dlogfile != "DM2_LOGFILE_NOTSET")
    SET dm_ecode = 1
    SET dm_emsg = "Message couldn't write to log file since name passed in was invalid."
   ENDIF
   IF (dm_ecode > 0)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo(concat("Component Name:  ",curprog))
    CALL echo("*")
    CALL echo(concat("Process Description:  Writing message to log file."))
    CALL echo("*")
    CALL echo(concat("Error Message:  ",trim(dm_emsg)))
    CALL echo("*")
    IF ( NOT (sbr_dlogfile IN ("NONE", "DM2_LOGFILE_NOTSET")))
     CALL echo(concat("Log file is ccluserdir:",sbr_dlogfile))
     CALL echo("*")
    ENDIF
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
   ENDIF
   IF (sbr_derr_ind=1)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo(concat("Component Name:  ",curprog))
    CALL echo("*")
    CALL echo(concat("Process Description:  ",dm_err->eproc))
    CALL echo("*")
    CALL echo(concat("Error Message:  ",trim(dm_full_emsg)))
    CALL echo("*")
    IF ((dm_err->user_action != "NONE"))
     CALL echo(concat("Recommended Action(s):  ",trim(dm_err->user_action)))
     CALL echo("*")
    ENDIF
    IF ( NOT (sbr_dlogfile IN ("NONE", "DM2_LOGFILE_NOTSET")))
     CALL echo(concat("Log file is ccluserdir:",sbr_dlogfile))
     CALL echo("*")
    ENDIF
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
   ELSEIF (sbr_derr_ind IN (0, 20))
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo(dm_err->eproc)
    CALL echo("*")
    IF ((dm_err->user_action != "NONE"))
     CALL echo(concat("Recommended Action(s):  ",trim(dm_err->user_action)))
     CALL echo("*")
    ENDIF
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
   ENDIF
   SET dm_err->user_action = "NONE"
 END ;Subroutine
 SUBROUTINE init_logfile(sbr_logfile,sbr_header_msg)
   DECLARE init_return_val = i4 WITH protect, noconstant(1)
   IF (sbr_logfile != "NONE"
    AND trim(sbr_logfile) != "")
    SELECT INTO value(sbr_logfile)
     FROM (dummyt d  WITH seq = 1)
     DETAIL
      row + 1, curdate"mm/dd/yyyy;;d", " ",
      curtime3"hh:mm:ss;;m", row + 1, sbr_header_msg,
      row + 1, row + 1
     WITH nocounter, format = variable, formfeed = none,
      maxrow = 1, maxcol = 512
    ;end select
    IF (check_error(concat("Creating log file ",trim(sbr_logfile)))=1)
     SET init_return_val = 0
    ELSE
     SET dm_err->eproc = concat("Log file created.  Log file name is: ",sbr_logfile)
     CALL disp_msg(" ",sbr_logfile,0)
    ENDIF
   ELSE
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Creating log file ",trim(sbr_logfile))
    SET dm_err->emsg = concat("Log file name passed is invalid.  Name passed in is: ",trim(
      sbr_logfile))
    SET init_return_val = 0
   ENDIF
   IF (init_return_val=0)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo(concat("Error occurred in ",dm_err->eproc))
    CALL echo("*")
    CALL echo(trim(dm_err->emsg))
    CALL echo("*")
    CALL echo(dm_err->asterisk_line)
    CALL echo("*")
    CALL echo("*")
    CALL echo("*")
   ENDIF
   RETURN(init_return_val)
 END ;Subroutine
 SUBROUTINE check_logfile(sbr_lprefix,sbr_lext,sbr_hmsg)
   IF ((dm_err->logfile IN ("NONE", "DM2_LOGFILE_NOTSET")))
    IF ((dm_err->debug_flag > 9))
     SET trace = echoprogsub
     IF (((currev > 8) OR (currev=8
      AND currevminor >= 1)) )
      SET trace = echosub
     ENDIF
    ENDIF
    IF (get_unique_file(sbr_lprefix,sbr_lext)=0)
     RETURN(0)
    ENDIF
    SET dm_err->logfile = dm_err->unique_fname
    IF (init_logfile(dm_err->logfile,sbr_hmsg)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dm2_prg_maint("BEGIN")=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE final_disp_msg(sbr_log_prefix)
   DECLARE plength = i2
   SET plength = textlen(sbr_log_prefix)
   IF (dm2_prg_maint("END")=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->err_ind=0))
    IF (cnvtlower(sbr_log_prefix)=substring(1,plength,dm_err->logfile))
     SET dm_err->eproc = concat(dm_err->eproc,"  Log file is ccluserdir:",dm_err->logfile)
     CALL disp_msg(" ",dm_err->logfile,0)
    ELSE
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_set_autocommit(sbr_dsa_flag)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_prg_maint(sbr_maint_type)
   IF ( NOT (cnvtupper(trim(sbr_maint_type,3)) IN ("BEGIN", "END")))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Invalid maintenance type"
    SET dm_err->eproc = "Performing program maintenance"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echo("********************************************************")
    CALL echo("* CCL current resource usage statistics                *")
    CALL echo("********************************************************")
    CALL trace(7)
   ENDIF
   IF (cnvtupper(trim(sbr_maint_type,3))="BEGIN")
    IF ((program_stack_rs->cnt < dcr_max_stack_size))
     SET program_stack_rs->cnt = (program_stack_rs->cnt+ 1)
     SET program_stack_rs->qual[program_stack_rs->cnt].name = curprog
    ENDIF
    SET dm_err->ecode = error(dm_err->emsg,1)
    IF (dm2_set_autocommit(0)=0)
     RETURN(0)
    ENDIF
    SET dm2_install_schema->curprog = curprog
   ELSE
    FOR (i = 0 TO (program_stack_rs->cnt - 1))
      IF ((program_stack_rs->qual[(program_stack_rs->cnt - i)].name=curprog))
       FOR (j = (program_stack_rs->cnt - i) TO program_stack_rs->cnt)
         SET program_stack_rs->qual[j].name = ""
       ENDFOR
       SET program_stack_rs->cnt = ((program_stack_rs->cnt - i) - 1)
       SET i = program_stack_rs->cnt
      ENDIF
    ENDFOR
    IF (dm2_set_autocommit(0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(dm2_get_program_stack(null))
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_set_inhouse_domain(null)
   DECLARE dsid_tbl_ind = c1 WITH protect, noconstant(" ")
   IF (validate(dm2_inhouse_flag,- (1)) > 0)
    SET dm_err->eproc = "Inhouse Domain Detected."
    CALL disp_msg(" ",dm_err->logfile,0)
    SET inhouse_misc->inhouse_domain = 1
    RETURN(1)
   ENDIF
   IF ((inhouse_misc->inhouse_domain=- (1)))
    SET dm_err->eproc = "Determining whether table dm_info exists"
    SET dsid_tbl_ind = dm2_table_exists("DM_INFO")
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (dsid_tbl_ind="F")
     SELECT INTO "nl:"
      FROM dm_info di
      WHERE di.info_domain="DATA MANAGEMENT"
       AND di.info_name="INHOUSE DOMAIN"
      WITH nocounter
     ;end select
     IF (check_error("Determine if process running in an in-house domain")=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSEIF (curqual=1)
      SET inhouse_misc->inhouse_domain = 1
     ELSE
      SET inhouse_misc->inhouse_domain = 0
     ENDIF
    ENDIF
   ELSE
    RETURN(1)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_table_exists(dte_table_name)
  SELECT INTO "nl:"
   FROM dm2_dba_tab_columns dutc
   WHERE dutc.table_name=trim(cnvtupper(dte_table_name))
    AND dutc.owner=value(currdbuser)
   WITH nocounter
  ;end select
  IF (check_error(dm_err->eproc)=1)
   CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
   RETURN("E")
  ELSE
   IF (curqual > 0
    AND checkdic(cnvtupper(dte_table_name),"T",0)=2)
    RETURN("F")
   ELSE
    RETURN("N")
   ENDIF
  ENDIF
 END ;Subroutine
 SUBROUTINE dm2_table_and_ccldef_exists(dtace_table_name,dtace_found_ind)
   SET dtace_found_ind = 0
   SELECT INTO "nl:"
    FROM dba_tab_cols dtc
    WHERE dtc.table_name=trim(cnvtupper(dtace_table_name))
     AND dtc.owner=value(currdbuser)
    WITH nocounter
   ;end select
   IF (check_error(concat("Checking if ",trim(cnvtupper(dtace_table_name)),
     " table and ccl def exists"))=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    IF (curqual > 0
     AND checkdic(cnvtupper(dtace_table_name),"T",0)=2)
     SET dtace_found_ind = 1
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_table_column_exists(dtce_owner,dtce_table_name,dtce_column_name,dtce_col_chk_ind,
  dtce_coldef_chk_ind,dtce_ccldef_mode,dtce_col_fnd_ind,dtce_coldef_fnd_ind,dtce_data_type)
   DECLARE dtce_type = vc WITH protect, noconstant("")
   DECLARE dtce_len = i4 WITH protect, noconstant(0)
   SET dtce_col_fnd_ind = 0
   SET dtce_coldef_fnd_ind = 0
   SET dtce_data_type = ""
   IF (dtce_col_chk_ind=1)
    SELECT INTO "nl:"
     FROM dba_tab_cols dtc
     WHERE dtc.owner=trim(dtce_owner)
      AND dtc.table_name=trim(dtce_table_name)
      AND dtc.column_name=trim(dtce_column_name)
     WITH nocounter
    ;end select
    IF (check_error(concat("Checking if ",trim(dtce_owner),".",trim(dtce_table_name),".",
      trim(dtce_column_name)," exists"))=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     IF (curqual > 0)
      SET dtce_col_fnd_ind = 1
     ENDIF
    ENDIF
   ENDIF
   IF (dtce_coldef_chk_ind=1)
    IF (checkdic(cnvtupper(concat(dtce_table_name,".",dtce_column_name)),"A",0)=2)
     SET dtce_coldef_fnd_ind = 1
     IF (dtce_ccldef_mode=2)
      IF (((currev=8
       AND ((((currev * 10000)+ (currevminor * 100))+ currevminor2) >= 81401)) OR (currev > 8
       AND ((((currev * 10000)+ (currevminor * 100))+ currevminor2) >= 90201))) )
       CALL parser(concat(" set dtce_data_type = reflect(",dtce_table_name,".",dtce_column_name,
         ",1) go "),1)
       CALL parser(concat(" free range ",dtce_table_name," go "),1)
       SET dtce_len = cnvtint(cnvtalphanum(dtce_data_type,1))
       SET dtce_type = cnvtalphanum(dtce_data_type,2)
       IF (textlen(dtce_type)=2)
        SET dtce_type = substring(2,2,dtce_type)
       ENDIF
       SET dtce_data_type = concat(dtce_type,trim(cnvtstring(dtce_len)))
      ELSE
       SELECT INTO "nl:"
        FROM dtable t,
         dtableattr ta,
         dtableattrl tl
        WHERE t.table_name=cnvtupper(dtce_table_name)
         AND t.table_name=ta.table_name
         AND tl.attr_name=cnvtupper(dtce_column_name)
         AND tl.structtype="F"
         AND btest(tl.stat,11)=0
        DETAIL
         dtce_data_type = concat(tl.type,trim(cnvtstring(tl.len)))
        WITH nocounter
       ;end select
       IF (check_error(concat("Retrieving",trim(dtce_table_name),".",trim(dtce_column_name),
         " data type"))=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_disp_file(ddf_fname,ddf_desc)
   DECLARE ddf_row = i4 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os="WIN"))
    SET message = window
    SET width = 132
    CALL clear(1,1)
    CALL video(n)
    SET ddf_row = 3
    CALL box(1,1,5,132)
    CALL text(ddf_row,48,"***  REPORT GENERATED  ***")
    SET ddf_row = (ddf_row+ 4)
    CALL text(ddf_row,2,"The following report was generated in CCLUSERDIR... ")
    SET ddf_row = (ddf_row+ 2)
    CALL text(ddf_row,5,concat("File Name:   ",trim(ddf_fname)))
    SET ddf_row = (ddf_row+ 1)
    CALL text(ddf_row,5,concat("Description: ",trim(ddf_desc)))
    SET ddf_row = (ddf_row+ 2)
    CALL text(ddf_row,2,"Review report in CCLUSERDIR before continuing.")
    SET ddf_row = (ddf_row+ 2)
    CALL text(ddf_row,2,"Enter 'C' to continue or 'Q' to quit:  ")
    CALL accept(ddf_row,41,"A;cu","C"
     WHERE curaccept IN ("C", "Q"))
    IF (curaccept="Q")
     CALL clear(1,1)
     SET message = nowindow
     SET dm_err->emsg = "User elected to quit from report prompt."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    CALL clear(1,1)
    SET message = nowindow
   ELSE
    SET dm_err->eproc = concat("Displaying ",ddf_desc)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    FREE SET file_loc
    SET logical file_loc value(ddf_fname)
    FREE DEFINE rtl2
    DEFINE rtl2 "file_loc"
    SELECT INTO mine
     t.line
     FROM rtl2t t
     HEAD REPORT
      col 30,
      CALL print(ddf_desc), row + 1
     DETAIL
      col 0, t.line, row + 1
     FOOT REPORT
      row + 0
     WITH nocounter, maxcol = 5000
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    FREE DEFINE rtl2
    FREE SET file_loc
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_program_stack(null)
   DECLARE stack = vc WITH protect, noconstant("PROGRAM STACK:")
   FOR (i = 1 TO (program_stack_rs->cnt - 1))
     SET stack = build(stack,program_stack_rs->qual[i].name,"->")
   ENDFOR
   IF (program_stack_rs->cnt)
    RETURN(build(stack,program_stack_rs->qual[program_stack_rs->cnt].name))
   ELSE
    RETURN(stack)
   ENDIF
 END ;Subroutine
 DECLARE dm2_get_env_data(dged_use_admin_ind=i2,dged_environment_id=f8(ref)) = i2
 SUBROUTINE dm2_get_env_data(dged_use_admin_ind,dged_environment_id)
   DECLARE dged_local_env_id = f8 WITH protect, noconstant(0.0)
   IF ( NOT (dged_use_admin_ind IN (1, 0)))
    SET dged_use_admin_ind = 0
   ENDIF
   SET dm_err->eproc = "Retrieving environment id."
   IF ((dm_err->debug_flag > 1))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT
    IF (dged_use_admin_ind=0)
     FROM dm_info d
     WHERE d.info_domain="DATA MANAGEMENT"
      AND d.info_name="DM_ENV_ID"
    ELSE
     FROM dm_info d,
      dm_environment de
     PLAN (d
      WHERE d.info_domain="DATA MANAGEMENT"
       AND d.info_name="DM_ENV_ID")
      JOIN (de
      WHERE d.info_number=de.environment_id)
    ENDIF
    INTO "nl:"
    DETAIL
     dged_local_env_id = d.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->emsg = "Unable to retrieve environment data."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ELSE
    SET dged_environment_id = dged_local_env_id
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE dm2_get_dbase_name(dgdn_name_out=vc(ref)) = i2
 SUBROUTINE dm2_get_dbase_name(dgdn_name_out)
   SET dm_err->eproc = "Get database name from currdbname."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (validate(currdbhandle," ")=" ")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "currdbhandle is not set."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    IF (validate(currdbname," ") != " ")
     SET dgdn_name_out = currdbname
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "currdbname is not set."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echo(concat("dgdn_name_out =",dgdn_name_out))
   ENDIF
   RETURN(1)
 END ;Subroutine
 IF (validate(dm2_rdbms_version->level1,- (1)) < 0)
  FREE RECORD dm2_rdbms_version
  RECORD dm2_rdbms_version(
    1 version = vc
    1 level1 = i2
    1 level2 = i2
    1 level3 = i2
    1 level4 = i2
    1 level5 = i2
  )
 ENDIF
 DECLARE dm2_get_rdbms_version() = i2
 SUBROUTINE dm2_get_rdbms_version(null)
   DECLARE dgrv_level = i2 WITH protect, noconstant(0)
   DECLARE dgrv_loc = i2 WITH protect, noconstant(0)
   DECLARE dgrv_prev_loc = i2 WITH protect, noconstant(0)
   DECLARE dgrv_loop = i2 WITH protect, noconstant(0)
   DECLARE dgrv_len = i2 WITH protect, noconstant(0)
   IF (currdb IN ("DB2UDB", "SQLSRV"))
    RETURN(1)
   ENDIF
   SELECT
    IF (currdbver < 19)
     FROM (
      (
      (SELECT
       orcl_version = t1.version
       FROM product_component_version t1
       WHERE cnvtupper(t1.product)="ORACLE*"
       WITH sqltype("VC80")))
      t)
    ELSE
     FROM (
      (
      (SELECT
       orcl_version = t1.version_full
       FROM product_component_version t1
       WHERE cnvtupper(t1.product)="ORACLE*"
       WITH sqltype("VC160")))
      t)
    ENDIF
    INTO "nl:"
    DETAIL
     dm2_rdbms_version->version = t.orcl_version
    WITH nocounter
   ;end select
   IF (check_error("Getting product component version")=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    SET dm_err->err_ind = 1
    RETURN(0)
   ELSEIF (curqual=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Product component version not found."
    SET dm_err->eproc = "Getting product component version"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   WHILE (dgrv_loop=0)
     SET dgrv_level = (dgrv_level+ 1)
     SET dgrv_prev_loc = dgrv_loc
     SET dgrv_loc = 0
     SET dgrv_loc = findstring(".",dm2_rdbms_version->version,(dgrv_prev_loc+ 1),0)
     IF (((dgrv_loc > 0) OR (dgrv_loc=0
      AND dgrv_level > 1)) )
      IF (dgrv_loc=0
       AND dgrv_level > 1)
       SET dgrv_len = (textlen(dm2_rdbms_version->version) - dgrv_prev_loc)
       SET dgrv_loop = 1
      ELSE
       SET dgrv_len = ((dgrv_loc - dgrv_prev_loc) - 1)
      ENDIF
      CASE (dgrv_level)
       OF 1:
        SET dm2_rdbms_version->level1 = cnvtint(substring(1,dgrv_len,dm2_rdbms_version->version))
       OF 2:
        SET dm2_rdbms_version->level2 = cnvtint(substring((dgrv_prev_loc+ 1),dgrv_len,
          dm2_rdbms_version->version))
       OF 3:
        SET dm2_rdbms_version->level3 = cnvtint(substring((dgrv_prev_loc+ 1),dgrv_len,
          dm2_rdbms_version->version))
       OF 4:
        SET dm2_rdbms_version->level4 = cnvtint(substring((dgrv_prev_loc+ 1),dgrv_len,
          dm2_rdbms_version->version))
       OF 5:
        SET dm2_rdbms_version->level5 = cnvtint(substring((dgrv_prev_loc+ 1),dgrv_len,
          dm2_rdbms_version->version))
       ELSE
        SET dgrv_loop = 1
      ENDCASE
     ELSE
      IF (dgrv_level=1)
       SET dm_err->err_ind = 1
       SET dm_err->emsg = "Product component version not in expected format."
       SET dm_err->eproc = "Getting product component version"
       CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
       RETURN(0)
      ENDIF
      SET dgrv_loop = 1
     ENDIF
   ENDWHILE
   RETURN(1)
 END ;Subroutine
 DECLARE dm2ceil(dc_numin) = null
 DECLARE dm2floor(dc_numin) = null
 SUBROUTINE dm2ceil(dc_numin)
   SET dc_numin_save = dc_numin
   DECLARE dc_numin_vc = vc WITH noconstant("")
   DECLARE dc_numin_precision = i4 WITH noconstant(0)
   DECLARE dc_numin_decpos = i2 WITH noconstant(0)
   DECLARE dc_numin_whole = f8 WITH protect, noconstant(0.0)
   SET dc_numin_vc = cnvtstring(dc_numin_save,30,9,"R")
   SET dc_numin_decpos = findstring(".",dc_numin_vc)
   SET dc_numin_whole = cnvtreal(substring(1,(dc_numin_decpos - 1),dc_numin_vc))
   IF (dc_numin_decpos <= 0)
    RETURN(dc_numin)
   ELSE
    SET dc_numin_precision = cnvtint(substring((dc_numin_decpos+ 1),9,dc_numin_vc))
    IF (dc_numin_precision > 0)
     IF (dc_numin < 0)
      SET dc_numin_save = dc_numin_whole
     ELSE
      SET dc_numin_save = (dc_numin_whole+ 1)
     ENDIF
    ELSE
     SET dc_numin_save = dc_numin_whole
    ENDIF
    RETURN(dc_numin_save)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2floor(dc_numin)
   SET dc_numin_save = dc_numin
   DECLARE dc_numin_vc = vc WITH noconstant("")
   DECLARE dc_numin_precision = i4 WITH noconstant(0)
   DECLARE dc_numin_decpos = i2 WITH noconstant(0)
   DECLARE dc_numin_whole = f8 WITH protect, noconstant(0.0)
   SET dc_numin_vc = cnvtstring(dc_numin_save,30,9,"R")
   SET dc_numin_decpos = findstring(".",dc_numin_vc)
   SET dc_numin_whole = cnvtreal(substring(1,(dc_numin_decpos - 1),dc_numin_vc))
   IF (dc_numin_decpos <= 0)
    RETURN(dc_numin)
   ELSE
    SET dc_numin_precision = cnvtint(substring((dc_numin_decpos+ 1),9,dc_numin_vc))
    IF (dc_numin_precision > 0)
     IF (dc_numin < 0)
      SET dc_numin_save = (dc_numin_whole - 1)
     ELSE
      SET dc_numin_save = dc_numin_whole
     ENDIF
    ELSE
     SET dc_numin_save = dc_numin_whole
    ENDIF
    RETURN(dc_numin_save)
   ENDIF
 END ;Subroutine
 DECLARE val_user_privs(sbr_dummy_param=i2) = i2
 SUBROUTINE val_user_privs(sbr_dummy_param)
   SET dm_err->eproc = "Retrieving CCL user data from duaf."
   SELECT INTO "nl:"
    d.group
    FROM duaf d
    WHERE cnvtupper(d.user_name)=cnvtupper(curuser)
     AND d.group=0
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0
    AND cnvtupper(curuser) != "P30INS")
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating user privileges"
    CALL disp_msg(concat("Current user, ",curuser,", does not have CCL DBA privileges required",
      " to run this program. Please contact your system administrator."),dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE dm2_findfile(sbr_file_path=vc) = i2
 SUBROUTINE dm2_findfile(sbr_file_path)
   DECLARE dff_cmd_txt = vc WITH protect, noconstant(" ")
   DECLARE dff_err_str = vc WITH protect, noconstant(" ")
   DECLARE dff_err_str2 = vc WITH protect, noconstant(" ")
   DECLARE dff_tmp_err_ind = i2 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    CALL dm2_push_dcl(concat('@cer_install:dm2_findfile_os.com "',sbr_file_path,'"'))
    IF ((dm_err->err_ind=1))
     SET dm_err->err_ind = 0
     SET dff_tmp_err_ind = 1
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->errtext="NOT FOUND"))
     IF ((dm_err->debug_flag > 1))
      SET dm_err->eproc = concat("File ",sbr_file_path," not found.")
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(0)
    ELSEIF ((dm_err->errtext="FOUND"))
     IF ((dm_err->debug_flag > 1))
      SET dm_err->eproc = concat("File ",sbr_file_path," found.")
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(1)
    ELSEIF (((dff_tmp_err_ind=1) OR ( NOT ((dm_err->errtext IN ("FOUND", "NOT FOUND"))))) )
     SET dm_err->emsg = dm_err->errtext
     SET dm_err->eproc = "Error in DM2_FINDFILE"
     SET dm_err->err_ind = 1
     RETURN(0)
    ENDIF
   ELSE
    SET dff_cmd_txt = concat("test -e ",sbr_file_path,";echo $?")
    CALL dm2_push_dcl(dff_cmd_txt)
    SET dm_err->err_ind = 0
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (cnvtint(dm_err->errtext)=0)
     IF ((dm_err->debug_flag > 1))
      SET dm_err->eproc = concat("File ",sbr_file_path," found.")
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(1)
    ELSE
     IF ((dm_err->debug_flag > 1))
      SET dm_err->eproc = concat("File ",sbr_file_path," not found.")
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE dm2_system_defs_init(sbr_sdi_regen_ind=i2) = i2
 SUBROUTINE dm2_system_defs_init(sbr_sdi_regen_ind)
   DECLARE sdi_def_cur_user = vc WITH protect, constant(cnvtupper(currdbuser))
   DECLARE sdi_def1_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_def2_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_def3_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_def4_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_def5_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_vue2_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_vue3_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE sdi_vue4_exists_ind = i2 WITH protect, noconstant(0)
   IF (checkdic("USER_VIEWS","T",0)=2)
    SET sdi_def1_exists_ind = 1
   ENDIF
   IF (checkdic("DM2_DBA_TAB_COLUMNS","T",0)=2)
    SET sdi_def2_exists_ind = 1
   ENDIF
   IF (checkdic("DM2_DBA_TAB_COLS","T",0)=2)
    SET sdi_def3_exists_ind = 1
   ENDIF
   IF (checkdic("DM2_USER_TAB_COLS","T",0)=2)
    SET sdi_def4_exists_ind = 1
   ENDIF
   IF (checkdic("PRODUCT_COMPONENT_VERSION","T",0)=2)
    SET sdi_def5_exists_ind = 1
   ENDIF
   IF (((sdi_def1_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_def1_exists_ind=1)
     DROP TABLE user_views
     IF (check_error("Dropping USER_VIEWS definition.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    DROP DDLRECORD user_views FROM DATABASE v500 WITH deps_deleted
    CREATE DDLRECORD user_views FROM DATABASE v500
 TABLE user_views
  1 view_name  = c30 CCL(view_name)
  1 text_length  = f8 CCL(text_length)
  1 text  = vc32000 CCL(text)
  1 type_text_length  = f8 CCL(type_text_length)
  1 type_text  = vc4000 CCL(type_text)
  1 oid_text_length  = f8 CCL(oid_text_length)
  1 oid_text  = vc4000 CCL(oid_text)
  1 view_type_owner  = c30 CCL(view_type_owner)
  1 view_type  = c30 CCL(view_type)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE user_views
    IF (check_error("Generating USER_VIEWS CCL definition.")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SELECT INTO "nl:"
    FROM user_views uv
    WHERE uv.view_name IN ("DM2_DBA_TAB_COLUMNS", "DM2_DBA_TAB_COLS", "DM2_USER_TAB_COLS")
    DETAIL
     CASE (uv.view_name)
      OF "DM2_DBA_TAB_COLUMNS":
       sdi_vue2_exists_ind = 1
      OF "DM2_DBA_TAB_COLS":
       sdi_vue3_exists_ind = 1
      OF "DM2_USER_TAB_COLS":
       sdi_vue4_exists_ind = 1
     ENDCASE
    WITH nocounter
   ;end select
   IF (check_error("Determining whether DM2_DBA_TAB_COLUMNS or DM2_DBA_TAB_COLS views already exist."
    )=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((sdi_vue2_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_vue2_exists_ind=1)
     RDB drop view dm2_dba_tab_columns
     END ;Rdb
     IF (check_error("Dropping DM2_DBA_TAB_COLUMNS view.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    RDB asis ( "create view dm2_dba_tab_columns (" ) asis (
    "  OWNER,            TABLE_NAME,        COLUMN_NAME,      DATA_TYPE," ) asis (
    "  DATA_LENGTH,      DATA_PRECISION,    DATA_SCALE,       NULLABLE," ) asis (
    "  COLUMN_ID,        DEFAULT_LENGTH,    DATA_DEFAULT,     NUM_DISTINCT," ) asis (
    "  LOW_VALUE,        HIGH_VALUE,        DENSITY,          NUM_NULLS," ) asis (
    "  NUM_BUCKETS,      LAST_ANALYZED,     SAMPLE_SIZE,      LOGGED," ) asis (
    "  COMPACT,          IDENTITY_IND,      GENERATED" ) asis ( ") as select" ) asis (
    "  c.owner,          c.table_name,      c.column_name,    c.data_type," ) asis (
    "  c.data_length,    c.data_precision,  c.data_scale,     c.nullable," ) asis (
    "  c.column_id,      c.default_length,  c.data_default,   c.num_distinct," ) asis (
    "  c.low_value,      c.high_value,      c.density,        c.num_nulls," ) asis (
    "  c.num_buckets,    c.last_analyzed,   c.sample_size,    'N/A'," ) asis (
    "  'N/A',            'N/A',             'N/A'" ) asis ( "from dba_tab_columns c" ) asis (
    "union all" ) asis ( "select" ) asis (
    "  dc.owner,         ds.synonym_name,   dc.column_name,   dc.data_type," ) asis (
    "  dc.data_length,   dc.data_precision, dc.data_scale,    dc.nullable," ) asis (
    "  dc.column_id,     dc.default_length, dc.data_default,  dc.num_distinct," ) asis (
    "  dc.low_value,     dc.high_value,     dc.density,       dc.num_nulls," ) asis (
    "  dc.num_buckets,   dc.last_analyzed,  dc.sample_size,   'N/A'," ) asis (
    "  'N/A',            'N/A',             'N/A'" ) asis (
    "from dba_tab_columns dc, dba_synonyms ds" ) asis ( "where ds.table_name = dc.table_name" ) asis
    ( "  and ds.synonym_name != ds.table_name" ) asis ( "  and not exists " ) asis (
    "     (select c.synonym_name, count(*) " ) asis ( "          from dba_synonyms c " ) asis (
    "          where c.synonym_name = ds.synonym_name " ) asis ( "          group by c.synonym_name "
     ) asis ( "          having count(*) > 1) " )
    END ;Rdb
    IF (check_error("CREATING DM2_DBA_TAB_COLUMNS VIEW")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_def2_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_def2_exists_ind=1)
     DROP TABLE dm2_dba_tab_columns
     IF (check_error("Dropping DM2_DBA_TAB_COLUMNS table def.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    DROP DDLRECORD dm2_dba_tab_columns FROM DATABASE v500 WITH deps_deleted
    CREATE DDLRECORD dm2_dba_tab_columns FROM DATABASE v500
 TABLE dm2_dba_tab_columns
  1 owner  = c30 CCL(owner)
  1 table_name  = c30 CCL(table_name)
  1 column_name  = c30 CCL(column_name)
  1 data_type  = vc106 CCL(data_type)
  1 data_length  = f8 CCL(data_length)
  1 data_precision  = f8 CCL(data_precision)
  1 data_scale  = f8 CCL(data_scale)
  1 nullable  = c1 CCL(nullable)
  1 column_id  = f8 CCL(column_id)
  1 default_length  = f8 CCL(default_length)
  1 data_default  = vc2000 CCL(data_default)
  1 num_distinct  = f8 CCL(num_distinct)
  1 low_value  = gc32 CCL(low_value)
  1 high_value  = gc32 CCL(high_value)
  1 density  = f8 CCL(density)
  1 num_nulls  = f8 CCL(num_nulls)
  1 num_buckets  = f8 CCL(num_buckets)
  1 last_analyzed  = di8 CCL(last_analyzed)
  1 sample_size  = f8 CCL(sample_size)
  1 logged  = c3 CCL(logged)
  1 compact  = c3 CCL(compact)
  1 identity_ind  = c3 CCL(identity_ind)
  1 generated  = c3 CCL(generated)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE dm2_dba_tab_columns
    IF (check_error("Creating DM2_DBA_TAB_COLUMNS table def.")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_vue3_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_vue3_exists_ind=1)
     RDB drop view dm2_dba_tab_cols
     END ;Rdb
     IF (check_error("Dropping DM2_DBA_TAB_COLS view.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    RDB asis ( "create view dm2_dba_tab_cols (" ) asis (
    "  OWNER,            TABLE_NAME,        COLUMN_NAME,      DATA_TYPE," ) asis (
    "  DATA_LENGTH,      DATA_PRECISION,    DATA_SCALE,       NULLABLE," ) asis (
    "  COLUMN_ID,        DEFAULT_LENGTH,    DATA_DEFAULT,     NUM_DISTINCT," ) asis (
    "  LOW_VALUE,        HIGH_VALUE,        DENSITY,          NUM_NULLS," ) asis (
    "  NUM_BUCKETS,      LAST_ANALYZED,     SAMPLE_SIZE,      LOGGED," ) asis (
    "  COMPACT,          IDENTITY_IND,      GENERATED" ) asis ( ") as select" ) asis (
    "  c.owner,          c.table_name,      c.column_name,    c.data_type," ) asis (
    "  c.data_length,    c.data_precision,  c.data_scale,     c.nullable," ) asis (
    "  c.column_id,      c.default_length,  c.data_default,   c.num_distinct," ) asis (
    "  c.low_value,      c.high_value,      c.density,        c.num_nulls," ) asis (
    "  c.num_buckets,    c.last_analyzed,   c.sample_size,    'N/A'," ) asis (
    "  'N/A',            'N/A',             'N/A'" ) asis ( "from dba_tab_columns c" )
    END ;Rdb
    IF (check_error("CREATING DM2_DBA_TAB_COLS VIEW")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_def3_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_def3_exists_ind=1)
     DROP TABLE dm2_dba_tab_cols
     IF (check_error("Dropping DM2_DBA_TAB_COLS table def.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    DROP DDLRECORD dm2_dba_tab_cols FROM DATABASE v500 WITH deps_deleted
    CREATE DDLRECORD dm2_dba_tab_cols FROM DATABASE v500
 TABLE dm2_dba_tab_cols
  1 owner  = c30 CCL(owner)
  1 table_name  = c30 CCL(table_name)
  1 column_name  = c30 CCL(column_name)
  1 data_type  = vc106 CCL(data_type)
  1 data_length  = f8 CCL(data_length)
  1 data_precision  = f8 CCL(data_precision)
  1 data_scale  = f8 CCL(data_scale)
  1 nullable  = c1 CCL(nullable)
  1 column_id  = f8 CCL(column_id)
  1 default_length  = f8 CCL(default_length)
  1 data_default  = vc2000 CCL(data_default)
  1 num_distinct  = f8 CCL(num_distinct)
  1 low_value  = gc32 CCL(low_value)
  1 high_value  = gc32 CCL(high_value)
  1 density  = f8 CCL(density)
  1 num_nulls  = f8 CCL(num_nulls)
  1 num_buckets  = f8 CCL(num_buckets)
  1 last_analyzed  = di8 CCL(last_analyzed)
  1 sample_size  = f8 CCL(sample_size)
  1 logged  = c3 CCL(logged)
  1 compact  = c3 CCL(compact)
  1 identity_ind  = c3 CCL(identity_ind)
  1 generated  = c3 CCL(generated)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE dm2_dba_tab_cols
    IF (check_error("Creating DM2_DBA_TAB_COLS table def.")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_vue4_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_vue4_exists_ind=1)
     RDB drop view dm2_user_tab_cols
     END ;Rdb
     IF (check_error("Dropping DM2_USER_TAB_COLS view.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    CALL parser("rdb create view dm2_user_tab_cols")
    CALL parser("as select * from dm2_dba_tab_cols")
    CALL parser(concat("where owner = '",trim(currdbuser),"'"))
    CALL parser("go")
    IF (check_error("CREATING DM2_USER_TAB_COLS VIEW")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_def4_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_def4_exists_ind=1)
     DROP TABLE dm2_user_tab_cols
     IF (check_error("Dropping DM2_USER_TAB_COLS table def.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    DROP DDLRECORD dm2_user_tab_cols FROM DATABASE v500 WITH deps_deleted
    CREATE DDLRECORD dm2_user_tab_cols FROM DATABASE v500
 TABLE dm2_user_tab_cols
  1 owner  = c30 CCL(owner)
  1 table_name  = c30 CCL(table_name)
  1 column_name  = c30 CCL(column_name)
  1 data_type  = vc106 CCL(data_type)
  1 data_length  = f8 CCL(data_length)
  1 data_precision  = f8 CCL(data_precision)
  1 data_scale  = f8 CCL(data_scale)
  1 nullable  = c1 CCL(nullable)
  1 column_id  = f8 CCL(column_id)
  1 default_length  = f8 CCL(default_length)
  1 data_default  = vc32000 CCL(data_default)
  1 num_distinct  = f8 CCL(num_distinct)
  1 low_value  = gc32 CCL(low_value)
  1 high_value  = gc32 CCL(high_value)
  1 density  = f8 CCL(density)
  1 num_nulls  = f8 CCL(num_nulls)
  1 num_buckets  = f8 CCL(num_buckets)
  1 last_analyzed  = dq8 CCL(last_analyzed)
  1 sample_size  = f8 CCL(sample_size)
  1 logged  = c3 CCL(logged)
  1 compact  = c3 CCL(compact)
  1 identity_ind  = c3 CCL(identity_ind)
  1 generated  = c3 CCL(generated)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE dm2_user_tab_cols
    IF (check_error("Creating DM2_USER_TAB_COLS table def.")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((sdi_def5_exists_ind=0) OR (sbr_sdi_regen_ind=1)) )
    IF (sdi_def5_exists_ind=1)
     DROP TABLE product_component_version
     IF (check_error("Dropping PRODUCT_COMPONENT_VERSION table def.")=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    DROP TABLE product_component_version
    DROP DDLRECORD product_component_version FROM DATABASE v500 WITH deps_deleted
    IF (currdbver < 19)
     CREATE DDLRECORD product_component_version FROM DATABASE v500
 TABLE product_component_version
  1 product  = vc80 CCL(product)
  1 version  = vc80 CCL(version)
  1 status  = vc80 CCL(status)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE product_component_version
    ELSE
     CREATE DDLRECORD product_component_version FROM DATABASE v500
 TABLE product_component_version
  1 product  = vc80 CCL(product)
  1 version  = vc80 CCL(version)
  1 version_full  = vc160 CCL(version_full)
  1 status  = vc80 CCL(status)
  1 rowid CCL(rowid)
    2 rowid_fld  = c18
 END TABLE product_component_version
    ENDIF
    IF (check_error("Creating PRODUCT_COMPONENT_VERSION table def.")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   COMMIT
   RETURN(1)
 END ;Subroutine
 DECLARE dm2_binary_search(search_item,record_structure,record_field) = i4
 SUBROUTINE dm2_binary_search(search_item,record_structure,record_field)
   DECLARE dbs_v_low = i4 WITH protect, noconstant(1)
   DECLARE dbs_v_mid = i4 WITH protect, noconstant(0)
   DECLARE dbs_v_high = i4 WITH protect, noconstant(0)
   CALL parser(concat("set dbs_v_high = size(",record_structure,",5) go"))
   WHILE (dbs_v_low <= dbs_v_high)
    SET dbs_v_mid = cnvtint(((dbs_v_high+ dbs_v_low)/ 2))
    IF (search_item=parser(build(record_structure,"[",dbs_v_mid,"]->",record_field)))
     RETURN(dbs_v_mid)
    ELSEIF (search_item < parser(build(record_structure,"[",dbs_v_mid,"]->",record_field)))
     SET dbs_v_high = (dbs_v_mid - 1)
    ELSE
     SET dbs_v_low = (dbs_v_mid+ 1)
    ENDIF
   ENDWHILE
   RETURN(0)
 END ;Subroutine
 IF (validate(retrieve_data->result_status,- (1)) < 0)
  FREE RECORD retrieve_data
  RECORD retrieve_data(
    1 result_str = vc
    1 result_status = i2
  )
  SET retrieve_data->result_status = 0
  SET retrieve_data->result_str = " "
 ENDIF
 DECLARE retrieve_data(sbr_srch_str=vc,sbr_sprtr=vc,sbr_rd_str=vc) = i2
 DECLARE dm2parse_output(sbr_attr_nbr=i4,sbr_parse_fname=vc,sbr_orientation=vc) = i2
 SUBROUTINE dm2parse_output(sbr_nbr_attr,sbr_parse_fname,sbr_orientation)
   DECLARE select_str = vc WITH protect, noconstant(" ")
   DECLARE foot_str = vc WITH protect, noconstant(" ")
   DECLARE buf_cnt = i4 WITH protect, noconstant(0)
   DECLARE cnt = i4 WITH protect, noconstant(0)
   DECLARE dm2_stat = i4 WITH protect, noconstant(0)
   DECLARE dm2_str = vc WITH protect, noconstant(" ")
   RECORD dm2parse_buf(
     1 qual[*]
       2 str = vc
   )
   SET select_str = concat('select into "nl:" r.line'," from rtlt r",' where r.line > " "'," detail "
    )
   FOR (attr_nbr = 1 TO sbr_nbr_attr)
     SET buf_cnt = (buf_cnt+ 1)
     IF (mod(buf_cnt,10)=1)
      SET stat = alterlist(dm2parse_buf->qual,(buf_cnt+ 9))
     ENDIF
     IF (attr_nbr=1)
      SET dm2parse_buf->qual[buf_cnt].str = concat(" if (findstring(dm2parse->attr1, r.line))",
       " cnt = cnt + 1"," if(mod(cnt,10) = 1)"," stat = alterlist(dm2parse->qual, cnt +9)"," endif",
       " if(retrieve_data(dm2parse->attr1, dm2parse->attr1sep, r.line))",
       " dm2parse->qual[cnt]->attr1val = retrieve_data->result_str"," endif")
     ELSE
      IF (sbr_orientation="V")
       SET dm2parse_buf->qual[buf_cnt].str = concat(" elseif (findstring( dm2parse->attr",trim(
         cnvtstring(attr_nbr),3)," , r.line))"," if (retrieve_data(dm2parse->attr",trim(cnvtstring(
          attr_nbr),3),
        ",dm2parse->attr",trim(cnvtstring(attr_nbr),3),"sep , r.line)) dm2parse->qual[cnt]->attr",
        trim(cnvtstring(attr_nbr),3),"val = retrieve_data->result_str endif")
      ELSE
       SET dm2parse_buf->qual[buf_cnt].str = concat(" endif if (findstring( dm2parse->attr",trim(
         cnvtstring(attr_nbr),3)," , r.line))"," if (retrieve_data(dm2parse->attr",trim(cnvtstring(
          attr_nbr),3),
        ",dm2parse->attr",trim(cnvtstring(attr_nbr),3),"sep , r.line)) dm2parse->qual[cnt]->attr",
        trim(cnvtstring(attr_nbr),3),"val = retrieve_data->result_str endif")
      ENDIF
     ENDIF
     IF (attr_nbr=sbr_nbr_attr)
      SET dm2parse_buf->qual[buf_cnt].str = concat(dm2parse_buf->qual[buf_cnt].str," endif")
     ENDIF
   ENDFOR
   SET stat = alterlist(dm2parse_buf->qual,buf_cnt)
   SET foot_str = concat(" foot report"," stat = alterlist(dm2parse->qual, cnt)"," with nocounter go"
    )
   SET dm2_stat = dm2_push_cmd("free define rtl go",1)
   IF ( NOT (dm2_stat))
    RETURN(0)
   ENDIF
   SET dm2_stat = dm2_push_cmd("free set file_loc go",1)
   IF ( NOT (dm2_stat))
    RETURN(0)
   ENDIF
   SET dm2_str = concat('set logical = file_loc "',sbr_parse_fname,'" go')
   SET dm2_stat = dm2_push_cmd(dm2_str,1)
   IF ( NOT (dm2_stat))
    RETURN(0)
   ENDIF
   SET dm2_stat = dm2_push_cmd('define rtl is "file_loc" go',1)
   IF ( NOT (dm2_stat))
    RETURN(0)
   ENDIF
   IF (dm2_push_cmd(select_str,0))
    FOR (parse_cnt = 1 TO size(dm2parse_buf->qual,5))
     SET dm2_stat = dm2_push_cmd(dm2parse_buf->qual[parse_cnt].str,0)
     IF ( NOT (dm2_stat))
      RETURN(0)
     ENDIF
    ENDFOR
    IF (dm2_push_cmd(foot_str,1))
     RETURN(1)
    ELSE
     RETURN(0)
    ENDIF
   ELSE
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE retrieve_data(sbr_srch_str,sbr_sprtr,sbr_rd_str)
   SET retrieve_data->result_str = " "
   SET retrieve_data->result_status = 0
   DECLARE str_loc = i4 WITH protect, noconstant(0)
   DECLARE str_len = i4 WITH protect, noconstant(0)
   DECLARE srch_str_len = i4 WITH protect, noconstant(0)
   DECLARE sstart = i4 WITH protect, noconstant(0)
   DECLARE slength = i4 WITH protect, noconstant(0)
   IF ( NOT (sbr_sprtr IN (" ", "=")))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Separator parameter invalid.  Must be either ' ' or '='."
    SET dm_err->eproc = "Separator validation."
    RETURN(0)
   ENDIF
   SET str_loc = findstring(sbr_srch_str,sbr_rd_str)
   IF (str_loc > 0)
    IF (sbr_sprtr="=")
     SET str_len = textlen(trim(sbr_rd_str))
     SET str_loc = findstring(sbr_sprtr,sbr_rd_str)
     IF (str_loc=0)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = "Separator not found.  DB2 List output contains invalid/outdated info."
      SET dm_err->eproc = concat("Locating '",sbr_sprtr,"' on line containing '",sbr_srch_str,"'.")
      RETURN(0)
     ELSE
      SET sstart = (str_loc+ 1)
      SET slength = (str_len - str_loc)
      SET retrieve_data->result_str = trim(substring(sstart,slength,sbr_rd_str),3)
      SET retrieve_data->result_status = 1
      RETURN(1)
     ENDIF
    ELSE
     SET str_len = textlen(trim(sbr_rd_str))
     SET srch_str_len = textlen(sbr_srch_str)
     SET sstart = (str_loc+ srch_str_len)
     SET slength = (((str_len - str_loc) - srch_str_len)+ 1)
     SET retrieve_data->result_str = trim(substring(sstart,slength,sbr_rd_str),3)
     SET retrieve_data->result_status = 1
     RETURN(1)
    ENDIF
   ELSE
    RETURN(1)
   ENDIF
 END ;Subroutine
 DECLARE check_concurrent_snapshot(sbr_ccs_mode=c1) = i2
 DECLARE dir_row_count(rrc_table_name=vc,rrc_row_cnt=f8(ref)) = i2
 DECLARE dm2_get_appl_status(gas_appl_id=vc) = c1
 DECLARE dir_row_count(rrc_table_name=vc,rrc_row_cnt=f8(ref)) = i2
 DECLARE dir_ddl_token_replacement(ddtr_text_str=vc(ref)) = i2
 DECLARE dm2_fill_seq_list(alias=vc,col_name=vc) = vc
 DECLARE dir_add_silmode_entry(entry_name=vc,entry_filename=vc) = i2
 DECLARE dm2_cleanup_stranded_appl() = i2
 DECLARE dir_setup_batch_queue(dsbq_queue_name=vc) = i2
 DECLARE dir_sea_sch_files(directory=vc,file_prefix=vc,schema_date=vc(ref)) = i2
 DECLARE dm2_val_sch_date_str(sbr_datestr=vc) = i2
 DECLARE dm2_fill_sch_except(sbr_dfse_from=vc) = i2
 DECLARE dm2_push_adm_maint(sbr_maint_str=vc) = i2
 DECLARE dm2_setup_dbase_env(null) = i2
 DECLARE dm2_get_suffixed_tablename(tbl_name=vc) = i2
 DECLARE prompt_for_host(sbr_host_db=vc) = i2
 DECLARE dm2_val_file_prefix(sbr_file_prefix=vc) = i2
 DECLARE dm2_toolset_usage(null) = i2
 DECLARE dir_get_obsolete_objects(null) = i2
 DECLARE dir_find_data_file(dfdf_file_found=i2(ref)) = i2
 DECLARE dir_dm2_tables_tspace_assign(null) = i2
 DECLARE dir_get_debug_trace_data(null) = i2
 DECLARE dir_managed_ddl_setup(dmds_runid=f8) = i2
 DECLARE dir_perform_wait_interval(null) = i2
 DECLARE dir_get_storage_type(dgst_db_link=vc) = i2
 DECLARE dir_check_in_parse(dcp_owner=vc,dcp_table_name=vc,dcp_in_parse_ind=i2(ref),dcp_ret_msg=vc(
   ref)) = i2
 DECLARE dir_get_ddl_gen_retry(dgr_retry_ceiling=i2(ref)) = i2
 DECLARE dir_load_users_pwds(dlup_user_pwd=vc) = i2
 DECLARE dir_check_dm_ocd_setup_admin(dcdosa_requires_execution=i2(ref),dcdosa_install_mode=vc) = i2
 DECLARE dir_check_for_package(dcfp_valid_ind=i2(ref),dcfp_env_id=f8(ref)) = i2
 DECLARE dir_get_dg_data(dgdd_assign_dg_ind=i2,dgdd_dg_override=vc,dgdd_dg_out=vc(ref)) = i2
 DECLARE dir_submit_jobs(dsj_plan_id=f8,dsj_install_mode=vc,dsj_user=vc,dsj_pword=vc,dsj_cnnct_str=vc,
  dsj_queue_name=vc,dsj_background_ind=i2) = i2
 DECLARE dir_get_adm_appl_status(dgaps_dblink=vc,dgaps_audsid=vc,dgaps_status=vc(ref)) = i2
 DECLARE dir_upd_adm_upgrade_info(null) = i2
 DECLARE dir_get_custom_constraints(null) = i2
 DECLARE dir_alert_killed_appl(daka_load_ind=i2,daka_fmt_appl_id=vc,daka_kill_ind=i2(ref)) = i2
 DECLARE dir_get_admin_db_link(dgadl_report_fail_ind=i2,dgadl_admin_db_link=vc(ref),dgadl_fail_ind=i2
  (ref)) = i2
 IF (validate(dm2_db_options->lob_build_ind," ")=" ")
  FREE RECORD dm2_db_options
  RECORD dm2_db_options(
    1 load_ind = i2
    1 dm2_toolset_usage = vc
    1 cursor_commit_cnt = vc
    1 new_tspace_type = vc
    1 dmt_freelist_grp = vc
    1 lob_storage_bp = vc
    1 lob_pctversion = vc
    1 lob_build_ind = vc
    1 lob_chunk = vc
    1 lob_cache = vc
    1 lob_securefile_ind = vc
    1 lob_retention = vc
    1 lob_maxsize = vc
    1 table_monitoring = vc
    1 table_monitoring_maxretry = vc
    1 db_optimizer_category = vc
    1 dbstats_gather_method = vc
    1 cbf_maxrangegroups = vc
    1 resource_busy_maxretry = vc
    1 dbstats_chk_rpt = vc
    1 readme_space_calc = vc
    1 recompile_after_alter_tbl = vc
    1 add_nn_col_nobf_ind = vc
    1 create_index_invisible = vc
    1 use_initprm_assign_dg_ind = vc
    1 assign_dg_override = vc
    1 degree_of_parallel_max = vc
    1 degree_of_parallel = vc
  )
  SET dm2_db_options->load_ind = 0
  SET dm2_db_options->dm2_toolset_usage = "NOT_SET"
  SET dm2_db_options->cursor_commit_cnt = "NOT_SET"
  SET dm2_db_options->dmt_freelist_grp = "NOT_SET"
  SET dm2_db_options->lob_pctversion = "NOT_SET"
  SET dm2_db_options->lob_chunk = "NOT_SET"
  SET dm2_db_options->lob_cache = "NOT_SET"
  SET dm2_db_options->lob_build_ind = "NOT_SET"
  SET dm2_db_options->new_tspace_type = "NOT_SET"
  SET dm2_db_options->lob_storage_bp = "NOT_SET"
  SET dm2_db_options->table_monitoring = "NOT_SET"
  SET dm2_db_options->table_monitoring_maxretry = "NOT_SET"
  SET dm2_db_options->db_optimizer_category = "NOT_SET"
  SET dm2_db_options->dbstats_gather_method = "NOT_SET"
  SET dm2_db_options->cbf_maxrangegroups = "NOT_SET"
  SET dm2_db_options->resource_busy_maxretry = "NOT_SET"
  SET dm2_db_options->dbstats_chk_rpt = "NOT_SET"
  SET dm2_db_options->readme_space_calc = "NOT_SET"
  SET dm2_db_options->recompile_after_alter_tbl = "NOT_SET"
  SET dm2_db_options->add_nn_col_nobf_ind = "NOT_SET"
  SET dm2_db_options->create_index_invisible = "NOT_SET"
  SET dm2_db_options->lob_securefile_ind = "NOT_SET"
  SET dm2_db_options->lob_retention = "NOT_SET"
  SET dm2_db_options->lob_maxsize = "NOT_SET"
  SET dm2_db_options->use_initprm_assign_dg_ind = "NOT_SET"
  SET dm2_db_options->assign_dg_override = "NOT_SET"
  SET dm2_db_options->degree_of_parallel_max = "NOT_SET"
  SET dm2_db_options->degree_of_parallel = "NOT_SET"
 ENDIF
 IF (validate(dm2_table->full_table_name," ")=" ")
  FREE RECORD dm2_table
  RECORD dm2_table(
    1 full_table_name = vc
    1 suffixed_table_name = vc
    1 table_suffix = vc
  )
  SET dm2_table->full_table_name = " "
  SET dm2_table->suffixed_table_name = " "
  SET dm2_table->table_suffix = " "
 ENDIF
 IF (validate(dm2_common1->snapshot_id,5)=5)
  FREE RECORD dm2_common1
  RECORD dm2_common1(
    1 snapshot_id = i2
  )
  SET dm2_common1->snapshot_id = 0
 ENDIF
 IF (validate(dm2_sch_except->tcnt,- (1)) < 0)
  FREE RECORD dm2_sch_except
  RECORD dm2_sch_except(
    1 tcnt = i4
    1 tbl[*]
      2 tbl_name = vc
    1 seq_cnt = i4
    1 seq[*]
      2 seq_name = vc
  )
  SET dm2_sch_except->tcnt = 0
  SET dm2_sch_except->seq_cnt = 0
 ENDIF
 IF ((validate(dm2_install_rec->snapshot_dt_tm,- (1))=- (1)))
  FREE RECORD dm2_install_rec
  RECORD dm2_install_rec(
    1 snapshot_dt_tm = f8
  )
 ENDIF
 IF (validate(dir_install_misc->ddl_failed_ind,1)=1
  AND validate(dir_install_misc->ddl_failed_ind,2)=2)
  FREE RECORD dir_install_misc
  RECORD dir_install_misc(
    1 ddl_failed_ind = i2
  )
  SET dir_install_misc->ddl_failed_ind = 0
 ENDIF
 IF ((validate(dir_silmode_requested_ind,- (1))=- (1))
  AND (validate(dir_silmode_requested_ind,- (2))=- (2)))
  DECLARE dir_silmode_requested_ind = i2 WITH public, noconstant(0)
 ENDIF
 IF (validate(dir_silmode->cnt,1)=1
  AND validate(dir_silmode->cnt,2)=2)
  FREE RECORD dir_silmode
  RECORD dir_silmode(
    1 cnt = i4
    1 qual[*]
      2 name = vc
      2 filename = vc
  )
  SET dir_silmode->cnt = 0
 ENDIF
 IF (validate(dir_batch_queue,"X")="X"
  AND validate(dir_batch_queue,"Y")="Y")
  DECLARE dir_batch_queue = vc WITH public, constant(cnvtlower(build("INSTALL$",logical("environment"
      ))))
 ENDIF
 IF (validate(dm_ocd_setup_admin_data->dm_ocd_setup_admin_date,1.0)=1.0
  AND validate(dm_ocd_setup_admin_data->dm_ocd_setup_admin_date,2.0)=2.0)
  FREE RECORD dm_ocd_setup_admin_data
  RECORD dm_ocd_setup_admin_data(
    1 dm_ocd_setup_admin_date = dq8
    1 dm2_create_system_defs = dq8
    1 dm2_set_adm_cbo = f8
  )
 ENDIF
 IF ((validate(dir_obsolete_objects->tbl_cnt,- (2))=- (2))
  AND (validate(dir_obsolete_objects->tbl_cnt,- (1))=- (1)))
  FREE RECORD dir_obsolete_objects
  RECORD dir_obsolete_objects(
    1 tbl_cnt = i4
    1 tbl[*]
      2 table_name = vc
    1 ind_cnt = i4
    1 ind[*]
      2 index_name = vc
    1 con_cnt = i4
    1 con[*]
      2 constraint_name = vc
  )
 ENDIF
 IF ((validate(dir_dropped_objects->obj_cnt,- (1))=- (1))
  AND (validate(dir_dropped_objects->obj_cnt,- (2))=- (2)))
  FREE RECORD dir_dropped_objects
  RECORD dir_dropped_objects(
    1 obj_cnt = i4
    1 rpt_drp_obj_ind = i2
    1 obj[*]
      2 table_name = vc
      2 name = vc
      2 type = vc
      2 reason = vc
  )
 ENDIF
 IF ((validate(dir_env_maint_rs->src_env_id,- (1))=- (1))
  AND (validate(dir_env_maint_rs->src_env_id,- (2))=- (2)))
  FREE RECORD dir_env_maint_rs
  RECORD dir_env_maint_rs(
    1 src_env_id = f8
    1 tgt_env_id = f8
    1 tgt_hist_fnd = i2
    1 process = vc
  )
  SET dir_env_maint_rs->src_env_id = 0
  SET dir_env_maint_rs->tgt_env_id = 0
  SET dir_env_maint_rs->tgt_hist_fnd = 0
  SET dir_env_maint_rs->process = "DM2NOTSET"
 ENDIF
 IF (validate(dir_tools_tspaces->data_tspace,"X")="X"
  AND validate(dir_tools_tspaces->data_tspace,"Y")="Y")
  FREE RECORD dir_tools_tspaces
  RECORD dir_tools_tspaces(
    1 data_tspace = vc
    1 index_tspace = vc
    1 lob_tspace = vc
  )
  SET dir_tools_tspaces->data_tspace = "NONE"
  SET dir_tools_tspaces->index_tspace = "NONE"
  SET dir_tools_tspaces->lob_tspace = "NONE"
 ENDIF
 IF (validate(dir_managed_ddl->setup_complete,1)=1
  AND validate(dir_managed_ddl->setup_complete,2)=2)
  FREE RECORD dir_managed_ddl
  RECORD dir_managed_ddl(
    1 setup_complete = i2
    1 managed_ddl_ind = i2
    1 oraversion = vc
    1 priority_cnt = i4
    1 priorities[*]
      2 priority = i4
    1 table_cnt = i4
    1 tables[*]
      2 table_name = vc
  )
  SET dir_managed_ddl->setup_complete = 0
  SET dir_managed_ddl->managed_ddl_ind = 0
  SET dir_managed_ddl->oraversion = "DM2NOTSET"
  SET dir_managed_ddl->priority_cnt = 0
  SET dir_managed_ddl->table_cnt = 0
 ENDIF
 IF (validate(dir_ui_misc->dm_process_event_id,1)=1
  AND validate(dir_ui_misc->dm_process_event_id,2)=2)
  FREE RECORD dir_ui_misc
  RECORD dir_ui_misc(
    1 dm_process_event_id = f8
    1 parent_script_name = vc
    1 background_ind = i2
    1 install_status = i2
    1 auto_install_ind = i2
    1 tspace_dg = vc
    1 debug_level = i4
    1 trace_flag = i2
  )
 ENDIF
 IF (validate(dir_storage_misc->src_storage_type,"x")="x"
  AND validate(dir_storage_misc->src_storage_type,"y")="y")
  FREE RECORD dir_storage_misc
  RECORD dir_storage_misc(
    1 src_storage_type = vc
    1 tgt_storage_type = vc
    1 cur_storage_type = vc
  )
  SET dir_storage_misc->src_storage_type = "DM2NOTSET"
  SET dir_storage_misc->tgt_storage_type = "DM2NOTSET"
  SET dir_storage_misc->cur_storage_type = "DM2NOTSET"
 ENDIF
 IF (validate(dir_db_users_pwds->cnt,1)=1
  AND validate(dir_db_users_pwds->cnt,2)=2)
  FREE RECORD dir_db_users_pwds
  RECORD dir_db_users_pwds(
    1 cnt = i4
    1 qual[*]
      2 user = vc
      2 pwd = vc
  )
  SET dir_db_users_pwds->cnt = 0
 ENDIF
 IF (validate(dir_custom_constraints->con_cnt,1)=1
  AND validate(dir_custom_constraints->con_cnt,2)=2)
  FREE RECORD dir_custom_constraints
  RECORD dir_custom_constraints(
    1 con_cnt = i4
    1 con[*]
      2 constraint_name = vc
  )
  SET dir_custom_constraints->con_cnt = 0
 ENDIF
 IF (validate(dir_killed_appl->appl_cnt,1)=1
  AND validate(dir_killed_appl->appl_cnt,2)=2)
  FREE RECORD dir_killed_appl
  RECORD dir_killed_appl(
    1 appl_cnt = i4
    1 appl[*]
      2 appl_id = vc
  )
  SET dir_killed_appl->appl_cnt = 0
 ENDIF
 IF (validate(dm2_dft_extsize,- (1)) < 0)
  DECLARE dm2_dft_extsize = i4 WITH public, constant(163840)
  DECLARE dm2_dft_clin_tspace = vc WITH public, constant("D_A_SMALL")
  DECLARE dm2_dft_clin_itspace = vc WITH public, constant("I_A_SMALL")
  DECLARE dm2_dft_clin_ltspace = vc WITH public, constant("L_A_SMALL")
 ENDIF
 IF (validate(dir_kill_clause,"z")="z"
  AND validate(dir_kill_clause,"y")="y")
  DECLARE dir_kill_clause = vc WITH public, constant(
   "Session was killed by V500.DM2MONPKG.KILL_IF_BLOCKING procedure.")
 ENDIF
 SUBROUTINE dir_dm2_tables_tspace_assign(null)
   IF ((dir_tools_tspaces->data_tspace != "NONE")
    AND (dir_tools_tspaces->index_tspace != "NONE")
    AND (dir_tools_tspaces->lob_tspace != "NONE"))
    RETURN(1)
   ENDIF
   IF ((dir_tools_tspaces->data_tspace="NONE"))
    SET dm_err->eproc =
    "Determining data_tspace from dm2_user_tables for DM2_DDL_OPS1/DM2_DDL_OPS_LOG1."
    SELECT INTO "nl:"
     FROM dm2_user_tables dut
     WHERE dut.table_name IN ("DM2_DDL_OPS1", "DM2_DDL_OPS_LOG1")
     ORDER BY dut.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->data_tspace = dut.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->data_tspace="NONE"))
    SET dm_err->eproc = "Determining data_tspace from dm2_user_tables for DM_INFO/DM_ENVIRONMENT."
    SELECT INTO "nl:"
     FROM dm2_user_tables dut
     WHERE dut.table_name IN ("DM_INFO", "DM_ENVIRONMENT")
     ORDER BY dut.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->data_tspace = dut.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->data_tspace="NONE"))
    SET dm_err->eproc = "Determining data_tspace from dm2_user_tablespaces."
    SELECT INTO "nl:"
     FROM dm2_user_tablespaces dut
     WHERE dut.tablespace_name IN ("D_TOOLKIT", "D_SYS_MGMT", "D_A_SMALL")
     ORDER BY dut.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->data_tspace = dut.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->data_tspace="NONE"))
    RETURN(1)
   ENDIF
   IF ((dir_tools_tspaces->index_tspace="NONE"))
    SET dm_err->eproc =
    "Determining index_tspace from dm2_user_indexes for DM2_DDL_OPS1/DM2_DDL_OPS_LOG1."
    SELECT INTO "nl:"
     FROM dm2_user_indexes dui
     WHERE dui.table_name IN ("DM2_DDL_OPS1", "DM2_DDL_OPS_LOG1")
     ORDER BY dui.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->index_tspace = dui.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->index_tspace="NONE"))
    SET dm_err->eproc = "Determining index_tspace from dm2_user_indexes for DM_INFO/DM_ENVIRONMENT."
    SELECT INTO "nl:"
     FROM dm2_user_indexes dui
     WHERE dui.table_name IN ("DM_INFO", "DM_ENVIRONMENT")
     ORDER BY dui.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->index_tspace = dui.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->index_tspace="NONE"))
    SET dm_err->eproc = "Determining index_tspace from dm2_user_tablespaces."
    SELECT INTO "nl:"
     FROM dm2_user_tablespaces dut
     WHERE dut.tablespace_name IN ("I_TOOLKIT", "I_SYS_MGMT", "I_A_SMALL")
     ORDER BY dut.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->index_tspace = dut.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_tools_tspaces->index_tspace="NONE"))
    RETURN(1)
   ENDIF
   IF ((dir_tools_tspaces->lob_tspace="NONE"))
    SET dir_tools_tspaces->lob_tspace = dir_tools_tspaces->data_tspace
    SET dm_err->eproc = "Determining lob_tspace from dm2_user_tablespaces."
    SELECT INTO "nl:"
     FROM dm2_user_tablespaces dut
     WHERE dut.tablespace_name IN ("L_SYS_MGMT", "L_A_SMALL")
     ORDER BY dut.tablespace_name
     HEAD REPORT
      dir_tools_tspaces->lob_tspace = dut.tablespace_name
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_debug_trace_data(null)
   SET dir_ui_misc->debug_level = 0
   SET dir_ui_misc->trace_flag = 0
   SET dm_err->eproc = "Query for debug flag/level"
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info i
    WHERE i.info_domain="DM2_AUTO_INSTALL"
     AND i.info_name="DEBUG_FLAG"
    DETAIL
     dir_ui_misc->debug_level = i.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Query for trace status"
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info i
    WHERE i.info_domain="DM2_AUTO_INSTALL"
     AND i.info_name="TRACE_FLAG"
    DETAIL
     IF (i.info_char="ON")
      dir_ui_misc->trace_flag = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_obsolete_objects(null)
   SET dm_err->eproc = "Selecting obsolete tables and indexes from dm_info."
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "OBSOLETE_OBJECT"=di.info_domain
    ORDER BY di.info_name
    HEAD REPORT
     dir_obsolete_objects->tbl_cnt = 0, stat = alterlist(dir_obsolete_objects->tbl,
      dir_obsolete_objects->tbl_cnt), dir_obsolete_objects->ind_cnt = 0,
     stat = alterlist(dir_obsolete_objects->ind,dir_obsolete_objects->ind_cnt)
    DETAIL
     CASE (build(di.info_char))
      OF "TABLE":
       dir_obsolete_objects->tbl_cnt = (dir_obsolete_objects->tbl_cnt+ 1),
       IF (mod(dir_obsolete_objects->tbl_cnt,10)=1)
        stat = alterlist(dir_obsolete_objects->tbl,(dir_obsolete_objects->tbl_cnt+ 9))
       ENDIF
       ,dir_obsolete_objects->tbl[dir_obsolete_objects->tbl_cnt].table_name = di.info_name
      OF "INDEX":
       dir_obsolete_objects->ind_cnt = (dir_obsolete_objects->ind_cnt+ 1),
       IF (mod(dir_obsolete_objects->ind_cnt,10)=1)
        stat = alterlist(dir_obsolete_objects->ind,(dir_obsolete_objects->ind_cnt+ 9))
       ENDIF
       ,dir_obsolete_objects->ind[dir_obsolete_objects->ind_cnt].index_name = di.info_name
     ENDCASE
    FOOT REPORT
     stat = alterlist(dir_obsolete_objects->tbl,dir_obsolete_objects->tbl_cnt), stat = alterlist(
      dir_obsolete_objects->ind,dir_obsolete_objects->ind_cnt)
    WITH nocounter, nullreport
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Selecting obsolete constraints from dm_info."
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "OBSOLETE_CONSTRAINT"=di.info_domain
    ORDER BY di.info_name
    HEAD REPORT
     dir_obsolete_objects->con_cnt = 0, stat = alterlist(dir_obsolete_objects->con,
      dir_obsolete_objects->con_cnt)
    DETAIL
     dir_obsolete_objects->con_cnt = (dir_obsolete_objects->con_cnt+ 1)
     IF (mod(dir_obsolete_objects->con_cnt,10)=1)
      stat = alterlist(dir_obsolete_objects->con,(dir_obsolete_objects->con_cnt+ 9))
     ENDIF
     dir_obsolete_objects->con[dir_obsolete_objects->con_cnt].constraint_name = di.info_name
    FOOT REPORT
     stat = alterlist(dir_obsolete_objects->con,dir_obsolete_objects->con_cnt)
    WITH nocounter, nullreport
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echorecord(dir_obsolete_objects)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_fill_sch_except(sbr_dfse_from)
   IF ( NOT (cnvtupper(sbr_dfse_from) IN ("REMOTE", "LOCAL")))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Invalid from table indicator (should be either REMOTE or LOCAL)."
    SET dm_err->eproc = "Building exception list of tables"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm2_sch_except->tcnt=0))
    IF (dm2_set_autocommit(1)=0)
     RETURN(0)
    ENDIF
    IF (cnvtupper(sbr_dfse_from)="REMOTE")
     SELECT INTO "nl:"
      t.table_name
      FROM dm2_src_tables t
      WHERE ((t.table_name IN ("DM2_DDL_OPS*", "DM2_TSPACE_SIZE*", "DM2_TSPACE_OBJ_SIZE*")) OR (t
      .table_name="DM_STAT_TABLE"))
      DETAIL
       dm2_sch_except->tcnt = (dm2_sch_except->tcnt+ 1), stat = alterlist(dm2_sch_except->tbl,
        dm2_sch_except->tcnt), dm2_sch_except->tbl[dm2_sch_except->tcnt].tbl_name = t.table_name
      WITH nocounter
     ;end select
    ELSE
     SELECT INTO "nl:"
      t.table_name
      FROM dm2_user_tables t
      WHERE ((t.table_name IN ("DM2_DDL_OPS*", "DM2_TSPACE_SIZE*", "DM2_TSPACE_OBJ_SIZE*")) OR (t
      .table_name="DM_STAT_TABLE"))
      DETAIL
       dm2_sch_except->tcnt = (dm2_sch_except->tcnt+ 1), stat = alterlist(dm2_sch_except->tbl,
        dm2_sch_except->tcnt), dm2_sch_except->tbl[dm2_sch_except->tcnt].tbl_name = t.table_name
      WITH nocounter
     ;end select
    ENDIF
    IF (check_error("Determining tables that should be in dm2_sch_except record structure")=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dm2_set_autocommit(0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sch_except->seq_cnt=0))
    SET dm2_sch_except->seq_cnt = 1
    SET stat = alterlist(dm2_sch_except->seq,1)
    SET dm2_sch_except->seq[1].seq_name = "DM_SEQ"
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_val_sch_date_str(sbr_datestr)
   DECLARE bad_sd_ind = i2 WITH protect, noconstant(0)
   DECLARE cnvt_datestr = vc WITH protect, noconstant(cnvtupper(sbr_datestr))
   IF (textlen(cnvt_datestr) != 11)
    SET bad_sd_ind = 1
   ELSEIF (substring(3,1,cnvt_datestr) != "-")
    SET bad_sd_ind = 1
   ELSEIF (substring(7,1,cnvt_datestr) != "-")
    SET bad_sd_ind = 1
   ELSEIF (cnvtint(substring(1,2,cnvt_datestr)) > 31)
    SET bad_sd_ind = 1
   ELSEIF (cnvtint(substring(1,2,cnvt_datestr)) <= 0)
    SET bad_sd_ind = 1
   ELSEIF (cnvtint(substring(8,4,cnvt_datestr)) <= 0)
    SET bad_sd_ind = 1
   ENDIF
   IF (bad_sd_ind=1)
    SET dm_err->eproc = "Validating schema date"
    SET dm_err->err_ind = 1
    SET dm_err->user_action =
    'Please specify a valid date in the format "DD-MON-YYYY", e.g. "15-JAN-2002" '
    CALL disp_msg(concat('Invalid schema date of "',sbr_datestr,'" was passed in'),dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_ddl_token_replacement(ddtr_text_str)
   DECLARE ddtr_pword = vc WITH protect, noconstant("NONE")
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("Before token replacement",ddtr_text_str))
   ENDIF
   IF (currdbuser="CDBA")
    IF ( NOT ((dm2_install_schema->cdba_p_word="NONE")))
     SET ddtr_pword = dm2_install_schema->cdba_p_word
    ENDIF
   ELSE
    IF ( NOT ((dm2_install_schema->v500_p_word="NONE")))
     SET ddtr_pword = dm2_install_schema->v500_p_word
    ENDIF
   ENDIF
   SET ddtr_text_str = replace(ddtr_text_str,"%DCL1%","",0)
   SET ddtr_text_str = replace(ddtr_text_str,"%DCL2%","",0)
   SET ddtr_text_str = replace(ddtr_text_str,"%DCL3%","",0)
   SET ddtr_text_str = replace(ddtr_text_str,"%FLOC%",dm2_install_schema->cer_install,0)
   SET ddtr_text_str = replace(ddtr_text_str,"%FLOC2%",dm2_install_schema->ccluserdir,0)
   IF ((dm2_install_schema->servername != "NONE"))
    SET ddtr_text_str = replace(ddtr_text_str,"%SNAME%",dm2_install_schema->servername,0)
   ENDIF
   SET ddtr_text_str = replace(ddtr_text_str,"%UNAME%",trim(currdbuser),0)
   IF (ddtr_pword != "NONE")
    SET ddtr_text_str = replace(ddtr_text_str,"%PWD%",ddtr_pword,0)
   ENDIF
   SET ddtr_text_str = replace(ddtr_text_str,"%DBASE%",trim(validate(currdbname," ")),0)
   IF ( NOT ((dm2_install_schema->src_v500_p_word="NONE")))
    SET ddtr_text_str = replace(ddtr_text_str,"%SRCPWD%",dm2_install_schema->src_v500_p_word,0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("After token replacement",ddtr_text_str))
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE check_concurrent_snapshot(sbr_ccs_mode)
   DECLARE ccs_appl_id = vc WITH protect, noconstant(" ")
   DECLARE ccs_appl_status = vc WITH protect, noconstant(" ")
   IF (cnvtupper(sbr_ccs_mode)="I")
    SET dm_err->eproc = "Determining if another upgrade process is running."
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dm_info di
     WHERE di.info_domain="DM2 INSTALL PROCESS"
      AND di.info_name="CONCURRENCY CHECKPOINT"
     DETAIL
      ccs_appl_id = di.info_char
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual > 0)
     IF ((ccs_appl_id=dm2_install_schema->appl_id))
      SET dm_err->eproc = "Deleting concurrency row from dm_info - same application is restart mode."
      CALL disp_msg(" ",dm_err->logfile,0)
      DELETE  FROM dm_info di
       WHERE di.info_domain="DM2 INSTALL PROCESS"
        AND di.info_name="CONCURRENCY CHECKPOINT"
       WITH nocounter
      ;end delete
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       ROLLBACK
       RETURN(0)
      ELSE
       COMMIT
      ENDIF
     ELSE
      SET dm_err->eproc = "Determining if upgrade process found in dm_info is still active."
      CALL disp_msg(" ",dm_err->logfile,0)
      SET ccs_appl_status = dm2_get_appl_status(ccs_appl_id)
      IF (ccs_appl_status="E")
       RETURN(0)
      ELSE
       IF (ccs_appl_status="A")
        SET dm_err->err_ind = 1
        SET dm_err->emsg = "Another upgrade process is currently taking a schema snapshot."
        SET dm_err->eproc = "Determining if upgrade process found in dm_info is still active."
        SET dm_err->user_action = "Please wait until other process completes and try again."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ELSE
        SET dm_err->eproc = "Deleting concurrency row from dm_info - process inactive."
        CALL disp_msg(" ",dm_err->logfile,0)
        DELETE  FROM dm_info di
         WHERE di.info_domain="DM2 INSTALL PROCESS"
          AND di.info_name="CONCURRENCY CHECKPOINT"
         WITH nocounter
        ;end delete
        IF (check_error(dm_err->eproc)=1)
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         ROLLBACK
         RETURN(0)
        ELSE
         COMMIT
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
    SET dm2_install_rec->snapshot_dt_tm = cnvtdatetime(curdate,curtime3)
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("Time of snapshot = ",format(dm2_install_rec->snapshot_dt_tm,
        "mm/dd/yyyy hh:mm:ss;;d")))
    ENDIF
    SET dm_err->eproc = "Inserting concurrency row in dm_info."
    CALL disp_msg(" ",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2 INSTALL PROCESS", di.info_name = "CONCURRENCY CHECKPOINT", di
      .info_char = dm2_install_schema->appl_id,
      di.info_date = cnvtdatetime(dm2_install_rec->snapshot_dt_tm), di.updt_dt_tm = cnvtdatetime(
       curdate,curtime3), di.updt_applctx = 0,
      di.updt_cnt = 0, di.updt_id = 0, di.updt_task = 0
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ELSE
    SET dm_err->eproc = "Deleting concurrency row from dm_info."
    CALL disp_msg(" ",dm_err->logfile,0)
    DELETE  FROM dm_info di
     WHERE di.info_domain="DM2 INSTALL PROCESS"
      AND di.info_name="CONCURRENCY CHECKPOINT"
     WITH nocounter
    ;end delete
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_row_count(rrc_table_name,rrc_row_cnt)
   DECLARE rrc_local_row_cnt = f8 WITH protect, noconstant(0.0)
   SET dm_err->eproc = concat("Retrieving row count for table ",trim(rrc_table_name),".")
   SELECT INTO "nl:"
    FROM dm_user_tables_actual_stats t
    WHERE t.table_name=rrc_table_name
    DETAIL
     rrc_local_row_cnt = t.num_rows
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET rrc_row_cnt = 0.0
   ELSE
    SET rrc_row_cnt = rrc_local_row_cnt
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_setup_dbase_env(null)
   DECLARE max_env_id = f8 WITH protect, noconstant(0.0)
   DECLARE new_env_id = f8 WITH protect, noconstant(0.0)
   DECLARE dsdes_connect_str = vc WITH protect, noconstant(" ")
   IF (currdb="ORACLE")
    SET dsdes_cnnct_str = cnvtlower(build("v500","/",dm2_install_schema->v500_p_word,"@",
      dm2_install_schema->v500_connect_str))
   ELSE
    SET dsdes_cnnct_str = build("v500","/",dm2_install_schema->v500_p_word,"/",dm2_install_schema->
     v500_connect_str)
   ENDIF
   SET dm_err->eproc = "Determining if environment already set up."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_set_autocommit(1)=0)
    RETURN(0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_environment e
    WHERE cnvtupper(e.environment_name)=cnvtupper(dm2_install_schema->target_env_name)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->eproc = "Determining next environment id."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (currdb="ORACLE")
     SELECT INTO "nl:"
      y = seq(dm_seq,nextval)"##################;rp0"
      FROM dual
      DETAIL
       new_env_id = cnvtreal(y)
      WITH format, nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echo(dm_err->asterisk_line)
      CALL echo(build("new_env_id=",new_env_id))
      CALL echo(dm_err->asterisk_line)
     ENDIF
    ELSE
     SELECT INTO "nl:"
      FROM dm_environment e
      FOOT REPORT
       max_env_id = max(e.environment_id)
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET new_env_id = (max_env_id+ 1)
     IF ((dm_err->debug_flag > 0))
      CALL echo(dm_err->asterisk_line)
      CALL echo(build("max_env_id=",max_env_id))
      CALL echo(build("new_env_id=",new_env_id))
      CALL echo(dm_err->asterisk_line)
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Inserting dm_environment row for database ",dm2_install_schema->
     target_dbase_name,".")
    CALL disp_msg(" ",dm_err->logfile,0)
    SET adm_maint_str = concat("insert into dm_environment de ",
     " set de.environment_id =  new_env_id ",
     ", de.environment_name =  cnvtupper(dm2_install_schema->target_env_name)",
     ", de.database_name = ' '",", de.admin_dbase_link_name = 'ADMIN1'",
     ", de.schema_version = 0.0",", de.from_schema_version = 0.0",
     ", de.v500_connect_string = dsdes_cnnct_str",", de.volume_group = 'N/A'",
     ", de.root_dir_name = 'N/A'",
     ", de.target_operating_system = dm2_sys_misc->cur_db_os ",", de.updt_applctx = 0 ",
     ", de.updt_dt_tm = cnvtdatetime(curdate,curtime3) ",", de.updt_cnt = 0 ",", de.updt_id = 0 ",
     ", de.updt_task = 0 ","  with nocounter go")
    IF (dm2_push_adm_maint(adm_maint_str)=0)
     ROLLBACK
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ELSE
    SET dm_err->eproc = "Updating environment id with current information."
    CALL disp_msg(" ",dm_err->logfile,0)
    SET adm_maint_str = concat("update from dm_environment de ",
     "set  de.admin_dbase_link_name = 'ADMIN1'",", de.schema_version = 0.0",
     ", de.from_schema_version = 0.0",", de.v500_connect_string =  dsdes_cnnct_str",
     ", de.updt_dt_tm = cnvtdatetime(curdate,curtime3) ",", de.updt_cnt = 0 ",", de.updt_id = 0 ",
     ", de.updt_task = 0 ",
     "  where de.environment_name = cnvtupper(dm2_install_schema->target_env_name) ",
     "  with nocounter go")
    IF (dm2_push_adm_maint(adm_maint_str)=0)
     ROLLBACK
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   IF (dm2_set_autocommit(1)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Prompt to confirm environment name"
   CALL disp_msg(" ",dm_err->logfile,0)
   EXECUTE dm_set_env_id
   SET message = nowindow
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_set_autocommit(0)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Determining if 'INHOUSE DOMAIN' dm_info row exists."
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DATA MANAGEMENT"
     AND di.info_name="INHOUSE DOMAIN"
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (curqual > 0)
    SET dm_err->eproc = "Deleting 'INHOUSE DOMAIN' row from dm_info."
    CALL disp_msg(" ",dm_err->logfile,0)
    DELETE  FROM dm_info di
     WHERE di.info_domain="DATA MANAGEMENT"
      AND di.info_name="INHOUSE DOMAIN"
     WITH nocounter
    ;end delete
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE prompt_for_host(sbr_host_db)
   DECLARE pfah_choice = vc WITH protect, noconstant(" ")
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL video(n)
   CALL text(2,1,concat("Creating a database connection to the ",cnvtupper(sbr_host_db)," database: "
     ),w)
   IF (currdb IN ("ORACLE", "DB2UDB"))
    CALL text(4,1,
     ">>> In the Host Name field, type the database server system's host name or IP address.")
   ELSE
    CALL text(4,1,
     ">>> In the Host Name field, type the database's server name (include named instance).")
   ENDIF
   CALL box(6,5,8,120)
   CALL text(7,7,"Host Name: ")
   CALL text(10,1,">>> Enter 'C' to continue or 'Q' to quit (C or Q) :")
   CALL accept(7,18,"P(100);C"," "
    WHERE  NOT (curaccept=" "))
   SET dm2_install_schema->hostname = trim(curaccept,3)
   CALL accept(10,53,"A;cu","C"
    WHERE curaccept IN ("Q", "C"))
   SET pfah_choice = curaccept
   SET message = nowindow
   IF (pfah_choice="Q")
    RETURN(0)
   ELSE
    RETURN(1)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_val_file_prefix(sbr_file_prefix)
   DECLARE sbr_vfp_sch_date_fmt = f8 WITH protect
   DECLARE sbr_vfp_dir = vc WITH protect
   IF ((dm2_install_schema->process_option="DDL GEN"))
    SET dm2_install_schema->schema_prefix = ""
    SET dm2_install_schema->file_prefix = sbr_file_prefix
   ELSEIF (findstring("-",sbr_file_prefix) IN (0, 1))
    SET dm2_install_schema->schema_prefix = "dm2o"
    SET dm2_install_schema->file_prefix = sbr_file_prefix
   ELSE
    IF ((dm2_install_schema->process_option IN ("ADMIN CREATE", "ADMIN UPGRADE")))
     SET dm2_install_schema->schema_prefix = "dm2a"
    ELSE
     SET dm2_install_schema->schema_prefix = "dm2c"
    ENDIF
    IF (dm2_val_sch_date_str(sbr_file_prefix)=0)
     RETURN(0)
    ELSE
     SET sbr_vfp_sch_date_fmt = cnvtdate2(sbr_file_prefix,"DD-MMM-YYYY")
     SET dm2_install_schema->file_prefix = cnvtalphanum(format(sbr_vfp_sch_date_fmt,"MM/DD/YYYY;;D"))
    ENDIF
   ENDIF
   IF ((((dm2_install_schema->schema_prefix="dm2o")) OR ((dm2_install_schema->process_option IN (
   "DDL GEN", "INHOUSE")))) )
    SET sbr_vfp_dir = dm2_install_schema->ccluserdir
    SET dm2_install_schema->schema_loc = "ccluserdir"
   ELSE
    SET sbr_vfp_dir = dm2_install_schema->cer_install
    SET dm2_install_schema->schema_loc = "cer_install"
   ENDIF
   IF ((dm2_install_schema->schema_prefix="dm2a"))
    IF (findfile(build(sbr_vfp_dir,cnvtlower(trim(dm2_install_schema->schema_prefix)),cnvtlower(trim(
        dm2_install_schema->file_prefix)),"_t.csv"))=0)
     SET dm_err->emsg = concat("CSV Schema files not found for file prefix ",sbr_file_prefix," in ",
      sbr_vfp_dir)
     SET dm_err->eproc = "File Prefix Validation"
     SET dm_err->user_action = "CSV Schema files not found.  Please enter a valid file prefix."
     RETURN(0)
    ENDIF
   ELSE
    IF (findfile(build(sbr_vfp_dir,cnvtlower(trim(dm2_install_schema->schema_prefix)),cnvtlower(trim(
        dm2_install_schema->file_prefix)),cnvtlower(dm2_sch_file->qual[1].file_suffix),".dat"))=0)
     SET dm_err->emsg = concat("Schema files not found for file prefix ",sbr_file_prefix," in ",
      sbr_vfp_dir)
     SET dm_err->eproc = "File Prefix Validation"
     SET dm_err->user_action = "Schema files not found.  Please enter a valid file prefix."
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_toolset_usage(null)
   DECLARE dtu_use_dm2_toolset = i2
   DECLARE dtu_use_dm_toolset = i2
   SET dtu_use_dm2_toolset = 1
   SET dtu_use_dm_toolset = 2
   SET dm_err->eproc = "Determining if DM_INFO exists."
   SELECT INTO "nl:"
    FROM user_tab_columns utc
    WHERE utc.table_name="DM_INFO"
    WITH nocounter
   ;end select
   SET dm_err->ecode = error(dm_err->emsg,1)
   IF ((dm_err->ecode != 0))
    SET dm_err->err_ind = 1
    RETURN(0)
   ENDIF
   IF (curqual > 0
    AND checkdic("DM_INFO","T",0)=2)
    SET dm_err->eproc = "Determining if database option exists."
    FREE RECORD dtu_db_option
    RECORD dtu_db_option(
      1 info_char = vc
      1 info_date = dq8
    )
    SELECT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain=concat("DM2_",trim(currdb),"_DB_OPTION")
      AND d.info_name="DM2_TOOLSET_USAGE"
     DETAIL
      dtu_db_option->info_char = d.info_char, dtu_db_option->info_date = d.info_date
     WITH nocounter
    ;end select
    SET dm_err->ecode = error(dm_err->emsg,1)
    IF ((dm_err->ecode != 0))
     SET dm_err->err_ind = 1
     FREE RECORD dtu_db_option
     RETURN(0)
    ENDIF
    IF (curqual=1)
     IF ((dtu_db_option->info_char IN ("Y", "N"))
      AND (dtu_db_option->info_date=cnvtdatetime("22-JUN-1996 00:00:00")))
      IF ((dtu_db_option->info_char="Y"))
       FREE RECORD dtu_db_option
       IF ((dm_err->debug_flag > 0))
        CALL echo("Using DM2 toolset because database option designates dm2 toolset usage")
       ENDIF
       RETURN(dtu_use_dm2_toolset)
      ELSE
       FREE RECORD dtu_db_option
       IF ((dm_err->debug_flag > 0))
        CALL echo("Using DM toolset because database option designates dm toolset usage")
       ENDIF
       RETURN(dtu_use_dm_toolset)
      ENDIF
     ELSE
      IF ((dtu_db_option->info_char != "CERNER_DEFAULT"))
       IF ((dm_err->debug_flag > 0))
        CALL echo("Not using the database option because it is not set up correctly.")
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo("Defaulting to DM2 toolset")
   ENDIF
   RETURN(dtu_use_dm2_toolset)
 END ;Subroutine
 SUBROUTINE dm2_get_suffixed_tablename(tbl_name)
   IF (dm2_set_autocommit(1)=0)
    RETURN(0)
   ENDIF
   DECLARE dm2_str = vc WITH protect, noconstant(" ")
   SET dm2_str = concat("select into 'nl:'"," from dm_tables_doc dtd ",
    " where dtd.table_name = cnvtupper('",tbl_name,"')",
    " detail"," dm2_table->suffixed_table_name = dtd.suffixed_table_name",
    " dm2_table->table_suffix = dtd.table_suffix"," dm2_table->full_table_name = dtd.full_table_name",
    " with nocounter",
    " go")
   IF ( NOT (dm2_push_cmd(dm2_str,1)))
    RETURN(0)
   ELSE
    RETURN(1)
   ENDIF
   IF (dm2_set_autocommit(0)=0)
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_push_adm_maint(sbr_maint_str)
   DECLARE adm_maint_err = i4 WITH protect, noconstant(1)
   IF (dm2_set_autocommit(1)=0)
    RETURN(0)
   ENDIF
   SET adm_maint_err = dm2_push_cmd(sbr_maint_str,1)
   IF (adm_maint_err=0)
    ROLLBACK
   ELSE
    COMMIT
   ENDIF
   IF (dm2_set_autocommit(0)=0)
    RETURN(0)
   ENDIF
   RETURN(adm_maint_err)
 END ;Subroutine
 SUBROUTINE dm2_get_appl_status(gas_appl_id)
   DECLARE gas_error_status = c1 WITH protect, constant("E")
   DECLARE gas_active_status = c1 WITH protect, constant("A")
   DECLARE gas_inactive_status = c1 WITH protect, constant("I")
   DECLARE gas_text = vc WITH protect, noconstant(" ")
   DECLARE gas_currdblink = vc WITH protect, noconstant(cnvtupper(trim(currdblink,3)))
   DECLARE gas_appl_id_cvt = vc WITH protect, noconstant(" ")
   IF (currdb="DB2UDB")
    SET gas_appl_id_cvt = replace(trim(gas_appl_id,3),"*","\*",0)
    SELECT INTO "nl:"
     FROM dm2_user_views
     WHERE view_name="DM2_SNAP_APPL_INFO"
     WITH nocounter
    ;end select
    IF (check_error("Selecting from dm2_user_views in subroutine DM2_GET_APPL_STATUS")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ENDIF
    IF (curqual=0)
     SET gas_text = concat("RDB ASIS (^ ","CREATE VIEW DM2_SNAP_APPL_INFO AS ",
      " ( SELECT * FROM TABLE(SNAPSHOT_APPL_INFO('",gas_currdblink,"',-1 )) AS SNAPSHOT_APPL_INFO )",
      " ^) GO ")
     IF (dm2_push_cmd(gas_text,1) != 1)
      ROLLBACK
      RETURN(gas_error_status)
     ELSE
      COMMIT
      EXECUTE oragen3 "DM2_SNAP_APPL_INFO"
      IF ((dm_err->err_ind=1))
       RETURN(gas_error_status)
      ENDIF
     ENDIF
    ENDIF
    SELECT INTO "nl:"
     FROM dtable
     WHERE table_name="DM2_SNAP_APPL_INFO"
     WITH nocounter
    ;end select
    IF (check_error("Selecting from dtable in subroutine DM2_GET_APPL_STATUS")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ENDIF
    IF (curqual != 1)
     EXECUTE oragen3 "DM2_SNAP_APPL_INFO"
     IF ((dm_err->err_ind=1))
      RETURN(gas_error_status)
     ENDIF
    ENDIF
    SET gas_text = concat('select into "nl:" from DM2_SNAP_APPL_INFO where appl_id = "',
     gas_appl_id_cvt,'" with nocounter go')
    IF (dm2_push_cmd(gas_text,1) != 1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ENDIF
    IF (curqual=1)
     RETURN(gas_active_status)
    ELSE
     RETURN(gas_inactive_status)
    ENDIF
   ELSEIF (currdb="SQLSRV")
    DECLARE gas_str_loc1 = i4 WITH protect, noconstant(0)
    DECLARE gas_str_loc2 = i4 WITH protect, noconstant(0)
    DECLARE gas_str_loc3 = i4 WITH protect, noconstant(0)
    DECLARE gas_spid = i4 WITH protect, noconstant(0)
    DECLARE gas_login_date = vc WITH protect, noconstant(" ")
    DECLARE gas_login_time = i4 WITH protect, noconstant(0)
    SET gas_str_loc1 = findstring("-",trim(gas_appl_id,3),1,0)
    SET gas_str_loc2 = findstring(" ",trim(gas_appl_id,3),1,1)
    SET gas_str_loc3 = findstring(":",trim(gas_appl_id,3),1,1)
    IF (((gas_str_loc1=0) OR (((gas_str_loc2=0) OR (gas_str_loc3=0)) )) )
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Invalid application handle"
     SET dm_err->eproc =
     "Parsing through application handle to determine spid and login date and time"
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ELSE
     SET gas_spid = cnvtint(build(substring(1,(gas_str_loc1 - 1),trim(gas_appl_id,3))))
     SET gas_login_date = cnvtupper(cnvtalphanum(substring((gas_str_loc1+ 1),(gas_str_loc2 -
        gas_str_loc1),trim(gas_appl_id,3))))
     SET gas_login_time = cnvtint(cnvtalphanum(substring(gas_str_loc2,(gas_str_loc3 - gas_str_loc2),
        trim(gas_appl_id,3))))
    ENDIF
    SELECT INTO "nl:"
     FROM sysprocesses p
     WHERE p.spid=gas_spid
      AND p.login_time=cnvtdatetime(cnvtdate2(gas_login_date,"DDMMMYYYY"),gas_login_time)
     WITH nocounter
    ;end select
    IF (check_error("Selecting from sysprocesses in subroutine DM2_GET_APPL_STATUS")=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ELSEIF (curqual=0)
     RETURN(gas_inactive_status)
    ELSE
     RETURN(gas_active_status)
    ENDIF
   ELSE
    IF (cnvtupper(gas_appl_id)="-15301")
     RETURN(gas_active_status)
    ENDIF
    SELECT INTO "nl:"
     FROM gv$session s
     WHERE s.audsid=cnvtint(gas_appl_id)
     WITH nocounter
    ;end select
    IF (check_error("Selecting from gv$session in subroutine DM2_GET_APPL_STATUS")=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(gas_error_status)
    ELSEIF (curqual=0)
     SELECT INTO "nl:"
      FROM v$session s
      WHERE s.audsid=cnvtint(gas_appl_id)
      WITH nocounter
     ;end select
     IF (check_error("Selecting from v$session in subroutine DM2_GET_APPL_STATUS")=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(gas_error_status)
     ENDIF
     IF (curqual > 0)
      RETURN(gas_active_status)
     ELSE
      RETURN(gas_inactive_status)
     ENDIF
    ELSE
     RETURN(gas_active_status)
    ENDIF
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_fill_seq_list(alias,col_name)
   DECLARE in_clause = vc WITH protect, noconstant("")
   SET in_clause = concat(alias,".",col_name," IN ('DM_PLAN_ID_SEQ', 'REPORT_SEQUENCE','DM_SEQ') ")
   RETURN(in_clause)
 END ;Subroutine
 SUBROUTINE dir_add_silmode_entry(entry_name,entry_filename)
   SET dir_silmode->cnt = (dir_silmode->cnt+ 1)
   SET stat = alterlist(dir_silmode->qual,dir_silmode->cnt)
   SET dir_silmode->qual[dir_silmode->cnt].name = entry_name
   SET dir_silmode->qual[dir_silmode->cnt].filename = entry_filename
 END ;Subroutine
 SUBROUTINE dm2_cleanup_stranded_appl(null)
   DECLARE dcsa_applx = i4 WITH protect, noconstant(0)
   DECLARE dcsa_fmt_appl_id = vc WITH protect, noconstant(" ")
   DECLARE dcsa_error_msg = vc WITH protect, noconstant(" ")
   DECLARE dcsa_load_ind = i2 WITH protect, noconstant(1)
   DECLARE dcsa_kill_ind = i2 WITH protect, noconstant(0)
   FREE RECORD dcsa_appl_rs
   RECORD dcsa_appl_rs(
     1 dcsa_appl_cnt = i4
     1 dcsa_appl[*]
       2 dcsa_appl_id = vc
   )
   SELECT INTO "nl:"
    FROM dm2_user_tables ut
    WHERE ut.table_name="DM2_DDL_OPS_LOG*"
    WITH nocounter
   ;end select
   IF (check_error("Find_Stranded_Runner - DDL_OPS_LOG table existence check")=true)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(false)
   ENDIF
   IF (curqual=0)
    CALL echo(
     "dm2_ddl_ops_log table not found in dm2_user_tables, bypassing dm2_cleanup_stranded_appl logic..."
     )
    RETURN(1)
   ELSE
    IF ((dm_err->debug_flag > 1))
     CALL echo("Curqual from user_tables for dm2_ddl_ops_log* returned != 0")
    ENDIF
   ENDIF
   SELECT DISTINCT INTO "nl:"
    ddol_appl_id = ddol.appl_id
    FROM dm2_ddl_ops_log ddol
    WHERE ddol.status IN ("RUNNING", null)
     AND ddol.op_type != "*(REMOTE)*"
    HEAD REPORT
     dcsa_applx = 0
    DETAIL
     dcsa_applx = (dcsa_applx+ 1)
     IF (mod(dcsa_applx,10)=1)
      stat = alterlist(dcsa_appl_rs->dcsa_appl,(dcsa_applx+ 9))
     ENDIF
     dcsa_appl_rs->dcsa_appl[dcsa_applx].dcsa_appl_id = ddol_appl_id
    FOOT REPORT
     dcsa_appl_rs->dcsa_appl_cnt = dcsa_applx, stat = alterlist(dcsa_appl_rs->dcsa_appl,dcsa_applx)
    WITH nocounter
   ;end select
   IF (check_error("Find_Stranded_Runner - Select")=true)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(false)
   ENDIF
   IF ((dcsa_appl_rs->dcsa_appl_cnt > 0))
    SET dcsa_applx = 1
    WHILE ((dcsa_applx <= dcsa_appl_rs->dcsa_appl_cnt))
      SET dcsa_fmt_appl_id = dcsa_appl_rs->dcsa_appl[dcsa_applx].dcsa_appl_id
      CASE (dm2_get_appl_status(value(dcsa_appl_rs->dcsa_appl[dcsa_applx].dcsa_appl_id)))
       OF "I":
        IF (dir_alert_killed_appl(dcsa_load_ind,dcsa_fmt_appl_id,dcsa_kill_ind)=0)
         RETURN(0)
        ENDIF
        SET dcsa_load_ind = 0
        IF (dcsa_kill_ind=1)
         SET dcsa_error_msg = dir_kill_clause
        ELSE
         SET dcsa_error_msg = concat("Application ID ",trim(dcsa_fmt_appl_id)," is no longer active."
          )
        ENDIF
        UPDATE  FROM dm2_ddl_ops_log ddol
         SET ddol.status = "ERROR", ddol.error_msg =
          "IMPORT operation set to ERROR since session executing no longer exists.", ddol.end_dt_tm
           = cnvtdatetime(curdate,curtime3)
         WHERE ddol.appl_id=dcsa_fmt_appl_id
          AND ddol.status="RUNNING"
          AND ddol.op_type="IMPORT*"
          AND ddol.op_type != "*(REMOTE)*"
        ;end update
        UPDATE  FROM dm2_ddl_ops_log ddol
         SET ddol.status = "ERROR", ddol.error_msg = dcsa_error_msg, ddol.end_dt_tm = cnvtdatetime(
           curdate,curtime3)
         WHERE ddol.appl_id=dcsa_fmt_appl_id
          AND ddol.status IN (null, "RUNNING")
          AND ddol.op_type != "*(REMOTE)*"
        ;end update
        IF (check_error("Find_Stranded_Processes - Update")=true)
         ROLLBACK
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(false)
        ELSE
         COMMIT
        ENDIF
       OF "A":
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("Application Id ",dcsa_fmt_appl_id," is active."))
        ENDIF
       OF "E":
        IF ((dm_err->debug_flag > 0))
         CALL echo("Error Detected in dm2_get_appl_status")
        ENDIF
        RETURN(false)
      ENDCASE
      SET dcsa_applx = (dcsa_applx+ 1)
    ENDWHILE
   ELSE
    IF ((dm_err->debug_flag > 0))
     CALL echo("********** No Application Ids Detected **********")
    ENDIF
   ENDIF
   RETURN(true)
 END ;Subroutine
 SUBROUTINE dir_alert_killed_appl(daka_load_ind,daka_fmt_appl_id,daka_kill_ind)
   DECLARE daka_audsid = vc WITH protect, noconstant(" ")
   DECLARE daka_audsid_start = i4 WITH protect, noconstant(0)
   DECLARE daka_audsid_end = i4 WITH protect, noconstant(0)
   DECLARE daka_applx = i4 WITH protect, noconstant(0)
   DECLARE daka_info_exists = i4 WITH protect, noconstant(0)
   SET daka_kill_ind = 0
   IF (daka_load_ind=1)
    IF (dm2_table_and_ccldef_exists("DM_INFO",daka_info_exists)=0)
     RETURN(0)
    ELSEIF (daka_info_exists=0)
     RETURN(1)
    ENDIF
    SELECT DISTINCT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain="DM2MONPKG_LOGGER"
      AND d.updt_dt_tm BETWEEN cnvtdatetime((curdate - 7),curtime3) AND cnvtdatetime(curdate,curtime3
      )
      AND d.info_char="*AUDSID:*"
     HEAD REPORT
      dir_killed_appl->appl_cnt = 0
     DETAIL
      daka_audsid_start = findstring("AUDSID:",d.info_char,1,0), daka_audsid_end = findstring(",",d
       .info_char,daka_audsid_start,0)
      IF (daka_audsid_end=0)
       daka_audsid = substring(daka_audsid_start,((size(d.info_char)+ 1) - daka_audsid_start),d
        .info_char)
      ELSE
       daka_audsid = substring(daka_audsid_start,(daka_audsid_end - daka_audsid_start),d.info_char)
      ENDIF
      daka_audsid = trim(replace(daka_audsid,"AUDSID:","",0),3)
      IF (isnumeric(daka_audsid))
       dir_killed_appl->appl_cnt += 1
       IF (mod(dir_killed_appl->appl_cnt,10)=1)
        stat = alterlist(dir_killed_appl->appl,(dir_killed_appl->appl_cnt+ 9))
       ENDIF
       dir_killed_appl->appl[dir_killed_appl->appl_cnt].appl_id = daka_audsid
      ENDIF
     FOOT REPORT
      stat = alterlist(dir_killed_appl->appl,dir_killed_appl->appl_cnt)
     WITH nocounter
    ;end select
    IF (check_error("Obtain killed application IDs.")=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dir_killed_appl->appl_cnt > 0))
    SET daka_applx = locateval(daka_applx,1,dir_killed_appl->appl_cnt,daka_fmt_appl_id,
     dir_killed_appl->appl[daka_applx].appl_id)
    IF (daka_applx > 0)
     SET daka_kill_ind = 1
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echorecord(dir_killed_appl)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_setup_batch_queue(dsbq_queue_name)
   DECLARE dsbq_env_name = vc WITH protect, noconstant(" ")
   DECLARE dsbq_cmd = vc WITH protect, noconstant(" ")
   DECLARE dsbq_start_pos = i4 WITH protect, noconstant(0)
   DECLARE dsbq_end_pos = i4 WITH protect, noconstant(0)
   DECLARE dsbq_domain_user = vc WITH protect, noconstant(" ")
   DECLARE dsbq_err_str = vc WITH protect, constant("no such queue")
   IF ((dm2_sys_misc->cur_os != "AXP"))
    RETURN(1)
   ENDIF
   IF (((dsbq_queue_name=" ") OR (dsbq_queue_name="")) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating input batch queue name."
    SET dm_err->emsg = "Invalid batch queue name."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dsbq_env_name = logical("environment")
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("Environment Name = ",dsbq_env_name))
   ENDIF
   IF (((dsbq_env_name=" ") OR (dsbq_env_name="")) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating environment name."
    SET dm_err->emsg = "Invalid environment name."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dsbq_cmd = concat("lreg -getp environment\",dsbq_env_name,
    " LocalUserName ;show symbol LREG_RESULT")
   IF ((dm_err->debug_flag > 0))
    CALL echo("*")
    CALL echo(concat("call dcl executing: ",dsbq_cmd))
    CALL echo("*")
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(dsbq_cmd)=0)
    IF ((dm_err->err_ind=1))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   SET dm_err->errtext = replace(dm_err->errtext,'LREG_RESULT = "',"",0)
   SET dm_err->errtext = replace(dm_err->errtext,'"',"",1)
   IF (findstring("%DCL-W-UNDSYM",dm_err->errtext) > 0)
    SET dsbq_domain_user = " "
   ELSE
    SET dsbq_domain_user = trim(dm_err->errtext,3)
   ENDIF
   IF (dsbq_domain_user=" ")
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Retreiving domain user from registry."
    SET dm_err->emsg = "Unable to retrieive domain user from registry."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(curuser) != cnvtupper(dsbq_domain_user))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Making sure current user is the domain user."
    SET dm_err->emsg = "Current user is not the domain user."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dsbq_cmd = concat("sho queue /full ",dsbq_queue_name)
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(dsbq_cmd)=0)
    IF ((dm_err->err_ind=1))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF (findstring(dsbq_err_str,cnvtlower(dm_err->errtext),1,0) > 0)
    SET dsbq_queue_fnd = 0
   ELSEIF (findstring(cnvtlower(dsbq_queue_name),cnvtlower(dm_err->errtext),1,0)=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Determining if queue ",dsbq_queue_name," exists.")
    SET dm_err->emsg = dm_err->errtext
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET dsbq_queue_fnd = 1
   ENDIF
   IF (dsbq_queue_fnd=1)
    IF (findstring("idle",cnvtlower(dm_err->errtext),1,0)=0
     AND findstring("executing",cnvtlower(dm_err->errtext),1,0)=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Make sure queue ",dsbq_queue_name,
      " is idle or is currently executing jobs.")
     SET dm_err->emsg = dm_err->errtext
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET dsbq_cmd = concat("init/queue/batch/start/job_limit=20 ",dsbq_queue_name)
    IF ((dm_err->debug_flag > 0))
     CALL echo("*")
     CALL echo(concat("call dcl executing: ",dsbq_cmd))
     CALL echo("*")
    ENDIF
    IF (dm2_push_dcl(dsbq_cmd)=0)
     RETURN(0)
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("Results of create queue command: ",dm_err->errtext))
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_sea_sch_files(directory,file_prefix,schema_date)
   DECLARE dgns_dcl_find = vc WITH protect, noconstant("")
   DECLARE dgns_err_str = vc WITH protect, noconstant("")
   SET schema_date = "01-JAN-1800"
   IF ( NOT (file_prefix IN ("dm2a", "dm2o", "dm2c")))
    SET dm_err->eproc = "Validating file_prefix."
    SET dm_err->emsg = "file_prefix must be IN ('dm2a', 'dm2o', 'dm2c')"
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    IF (file_prefix="dm2a")
     SET dgns_dcl_find = concat("dir/columns=1  ",build(directory),file_prefix,"%%%2*")
    ELSE
     SET dgns_dcl_find = concat("dir/columns=1  ",build(directory),file_prefix,"*")
    ENDIF
    SET dgns_err_str = "no files found"
   ELSEIF ((dm2_sys_misc->cur_os="WIN"))
    IF (file_prefix="dm2a")
     SET dgns_dcl_find = concat("dir ",build(directory),"\",file_prefix,"???3????_*")
    ELSE
     SET dgns_dcl_find = concat("dir ",build(directory),"\",file_prefix,"*")
    ENDIF
    SET dgns_err_str = "file not found"
   ELSE
    IF (file_prefix="dm2a")
     IF ((dm2_sys_misc->cur_os="LNX"))
      SET dgns_dcl_find = concat("ls -t ",build(directory),"/",file_prefix,"???4* | wc -w")
     ELSE
      SET dgns_dcl_find = concat("ls -t ",build(directory),"/",file_prefix,"???1* | wc -w")
     ENDIF
    ELSE
     SET dgns_dcl_find = concat("ls -t ",build(directory),"/",file_prefix,"* | wc -w")
    ENDIF
    SET dgns_err_str = "0"
   ENDIF
   IF (dm2_push_dcl(dgns_dcl_find)=0)
    IF (findstring(dgns_err_str,cnvtlower(dm_err->errtext)) > 0)
     SET dm_err->eproc = "Find schema date."
     SET dm_err->emsg = "No schema date was found."
     SET dm_err->err_ind = 0
     RETURN(1)
    ENDIF
    RETURN(0)
   ELSE
    IF ((dm2_sys_misc->cur_os IN ("AIX", "HPX", "LNX")))
     IF (file_prefix="dm2a")
      IF ((dm2_sys_misc->cur_os="LNX"))
       SET dgns_dcl_find = concat("ls -l ",build(directory),"/",file_prefix,"???4* ")
      ELSE
       SET dgns_dcl_find = concat("ls -l ",build(directory),"/",file_prefix,"???1* ")
      ENDIF
     ELSE
      SET dgns_dcl_find = concat("ls - ",build(directory),"/",file_prefix,"* ")
     ENDIF
     SET dm_err->eproc = "Building list of schema files to gather schema date"
     IF (dm2_push_dcl(dgns_dcl_find)=0)
      RETURN(0)
     ENDIF
    ENDIF
    FREE DEFINE rtl
    FREE SET file_loc
    SET logical file_loc value(dm_err->errfile)
    DEFINE rtl "file_loc"
    SELECT INTO "nl:"
     r.line
     FROM rtlt r
     HEAD REPORT
      compare_date = cnvtdate("01011800"), stripped_date = cnvtdate("01011800")
     DETAIL
      IF ((dm2_sys_misc->cur_os="AXP"))
       starting_pos = findstring(cnvtupper(file_prefix),r.line)
      ELSE
       starting_pos = findstring(file_prefix,r.line)
      ENDIF
      stripped_date = cnvtdate(substring((starting_pos+ 4),8,r.line))
      IF (stripped_date > compare_date)
       schema_date = format(stripped_date,"DD-MMM-YYYY;;d"), compare_date = stripped_date
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_list_of_files(dglf_prefix)
   DECLARE dglf_str = vc WITH protect
   SET dm_err->eproc = "Getting help list of schema files to select from."
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dglf_str = concat("dir/version=1/columns=1 cer_install:",dglf_prefix,"*_h.dat ")
   ELSEIF ((dm2_sys_misc->cur_os="WIN"))
    SET dglf_str = concat("dir ",dm2_install_schema->cer_install,"\",dglf_prefix,"*_h.dat /B")
   ELSE
    SET dglf_str = concat('find $cer_install -name "',dglf_prefix,'*_h.dat" -print')
   ENDIF
   IF (dm2_push_dcl(value(dglf_str))=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtlt r
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    SET message = nowindow
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_find_data_file(dfdf_file_found)
   DECLARE dtd_data_file = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Finding data files"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dba_data_files ddf
    DETAIL
     dtd_data_file = ddf.file_name
    WITH maxqual(ddf,1), nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dfdf_file_found = findfile(dtd_data_file)
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("file found ind =",dfdf_file_found))
    CALL echo(build("file name =",dtd_data_file))
   ENDIF
   IF (dfdf_file_found=0)
    SET dm_err->eproc = "Datafile not visible at operating system level"
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_managed_ddl_setup(dmds_runid)
   DECLARE dmds_rowcnt = f8 WITH protect, noconstant(0.0)
   DECLARE dmds_ndx = i4 WITH protect, noconstant(0)
   DECLARE dmds_priority = i4 WITH protect, noconstant(0)
   SET dir_managed_ddl->setup_complete = 0
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Check if Managed DDL oracle version"
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info d
    WHERE d.info_domain="DM2_MANAGED_DDL_ORAVER"
    DETAIL
     IF (d.info_name=build(dm2_rdbms_version->level1,".",dm2_rdbms_version->level2,".",
      dm2_rdbms_version->level3,
      ".",dm2_rdbms_version->level4))
      dir_managed_ddl->oraversion = d.info_name, dir_managed_ddl->managed_ddl_ind = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dir_managed_ddl->managed_ddl_ind=1))
    SET dm_err->eproc = "Check for row_cnt override for Managed DDL"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain="DM2_MANAGED_DDL_ROWCNT"
     DETAIL
      dmds_rowcnt = d.info_number
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dmds_rowcnt > 0.0)
     SET dm_err->eproc = concat("Managed DDL Rowcnt Override: ",build(dmds_rowcnt))
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET dmds_rowcnt = 10000
    ENDIF
    SET dm_err->eproc = "Load Managed DDL Priorities"
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dm2_ddl_ops_log d,
      dm_dba_tables_actual_stats t
     WHERE d.run_id=dmds_runid
      AND d.op_type IN (
     (SELECT
      di.info_name
      FROM dm_info di
      WHERE di.info_domain="DM2_MANAGED_DDL_OP_TYPE"))
      AND d.table_name != "DM*"
      AND d.table_name=t.table_name
      AND t.num_rows > dmds_rowcnt
      AND (( EXISTS (
     (SELECT
      "x"
      FROM dm_info di
      WHERE di.info_domain="DM2_MIXED_TABLE-EXPORT-REFERENCE"
       AND di.info_name=d.table_name))) OR ( EXISTS (
     (SELECT
      "x"
      FROM dm_tables_doc dtd
      WHERE dtd.reference_ind=0
       AND dtd.table_name=d.table_name))))
      AND ((d.status != "COMPLETE") OR (d.status = null))
     ORDER BY d.priority, d.table_name
     HEAD d.priority
      dmds_ndx = 0, dmds_priority = d.priority
      IF ((dir_managed_ddl->priority_cnt > 0))
       dmds_ndx = locateval(dmds_ndx,1,dir_managed_ddl->priority_cnt,dmds_priority,dir_managed_ddl->
        priorities[dmds_ndx].priority)
      ENDIF
      IF (dmds_ndx=0)
       dir_managed_ddl->priority_cnt = (dir_managed_ddl->priority_cnt+ 1)
       IF (mod(dir_managed_ddl->priority_cnt,100)=1)
        stat = alterlist(dir_managed_ddl->priorities,(dir_managed_ddl->priority_cnt+ 99))
       ENDIF
       dir_managed_ddl->priorities[dir_managed_ddl->priority_cnt].priority = d.priority
      ENDIF
     HEAD d.table_name
      dmds_ndx = 0
      IF ((dir_managed_ddl->table_cnt > 0))
       dmds_ndx = locateval(dmds_ndx,1,dir_managed_ddl->table_cnt,d.table_name,dir_managed_ddl->
        tables[dmds_ndx].table_name)
      ENDIF
      IF (dmds_ndx=0)
       dir_managed_ddl->table_cnt = (dir_managed_ddl->table_cnt+ 1)
       IF (mod(dir_managed_ddl->table_cnt,100)=1)
        stat = alterlist(dir_managed_ddl->tables,(dir_managed_ddl->table_cnt+ 99))
       ENDIF
       dir_managed_ddl->tables[dir_managed_ddl->table_cnt].table_name = d.table_name
      ENDIF
     FOOT REPORT
      stat = alterlist(dir_managed_ddl->tables,dir_managed_ddl->table_cnt), stat = alterlist(
       dir_managed_ddl->priorities,dir_managed_ddl->priority_cnt)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual=0)
     SET dir_managed_ddl->managed_ddl_ind = 0
    ENDIF
   ENDIF
   SET dir_managed_ddl->setup_complete = 1
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dir_managed_ddl)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_perform_wait_interval(null)
   DECLARE dpwi_pause_interval = i4 WITH protect, noconstant(1)
   SET dm_err->eproc = "Obtain pause interval"
   SELECT INTO "nl:"
    FROM dm_info d
    WHERE d.info_domain="DM2_INSTALL_PKG"
     AND d.info_name="PAUSE_INTERVAL"
    DETAIL
     dpwi_pause_interval = d.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Pausing for ",build(dpwi_pause_interval)," minutes.")
   CALL disp_msg("",dm_err->logfile,0)
   CALL pause((dpwi_pause_interval * 60))
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_storage_type(dgst_db_link)
   IF ((dm2_sys_misc->cur_db_os="AXP"))
    SET dir_storage_misc->cur_storage_type = "AXP"
    SET dir_storage_misc->tgt_storage_type = "AXP"
    SET dir_storage_misc->src_storage_type = "AXP"
   ELSE
    IF (dgst_db_link > " "
     AND dgst_db_link != "DM2NOTSET")
     SET dm_err->eproc = "Determine source storage type from dba_data_files"
     CALL disp_msg("",dm_err->logfile,0)
     SELECT INTO "nl:"
      FROM (parser(concat("dba_data_files@",dgst_db_link)) ddf)
      WHERE ddf.tablespace_name="SYSTEM"
       AND ddf.file_name=patstring("/dev/*")
      DETAIL
       dir_storage_misc->src_storage_type = "RAW"
      WITH nocounter, maxqual = 1
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (curqual=0)
      SET dir_storage_misc->src_storage_type = "ASM"
     ENDIF
    ENDIF
    SET dm_err->eproc = "Determine target storage type from dba_data_files"
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dba_data_files ddf
     WHERE ddf.tablespace_name="SYSTEM"
     DETAIL
      IF (ddf.file_name=patstring("/dev/*"))
       dir_storage_misc->cur_storage_type = "RAW", dir_storage_misc->tgt_storage_type = "RAW"
      ELSEIF (ddf.file_name=patstring("+*"))
       dir_storage_misc->cur_storage_type = "ASM", dir_storage_misc->tgt_storage_type = "ASM"
      ELSE
       dir_storage_misc->cur_storage_type = "RAW", dir_storage_misc->tgt_storage_type = "RAW"
      ENDIF
     WITH nocounter, maxqual = 1
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dir_storage_misc)
   ENDIF
   IF (validate(dm2_tgt_storage_type,"XXX") IN ("RAW", "ASM"))
    SET dir_storage_misc->cur_storage_type = dm2_tgt_storage_type
    SET dir_storage_misc->tgt_storage_type = dm2_tgt_storage_type
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dir_storage_misc)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_check_dm_ocd_setup_admin(dcdosa_requires_execution,dcdosa_install_mode)
   DECLARE dcdosa_compare_date = vc WITH protect, noconstant("")
   DECLARE dcdosa_cer_install = vc WITH protect, noconstant("")
   DECLARE dcdosa_schema_date = i4 WITH protect, noconstant(0)
   DECLARE dcdosa_dm_info_dm_ocd_setup_admin_date = dq8 WITH protect, noconstant(0.0)
   DECLARE dcdosa_dm_info_dm2_create_system_defs_date = dq8 WITH protect, noconstant(0.0)
   DECLARE dcdosa_dm_info_schema_date = i4 WITH protect, noconstant(0)
   DECLARE dcdosa_dm_info_dm2_set_adm_cbo_date = dq8 WITH protect, noconstant(0.0)
   SET dcdosa_requires_execution = 0
   IF (currdb != "ORACLE")
    SET dm_err->eproc = "Admin Setup Bypassed - Database must be on Oracle to perform Admin setup."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    RETURN(1)
   ELSEIF ( NOT ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "AXP", "LNX", "WIN"))))
    SET dm_err->eproc =
    "Admin Setup Bypassed - o/s must be HPX, AIX, VMS, LNX or WIN to perform Admin Setup."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    RETURN(1)
   ELSEIF ( NOT (dcdosa_install_mode IN ("UPTIME", "BATCHUP", "PREVIEW", "BATCHPREVIEW", "EXPRESS",
   "BATCHEXPRESS")))
    SET dm_err->eproc = "Checking install mode"
    SET dm_err->eproc = concat("Admin Setup Bypassed - Install mode needs to be ",
     " UPTIME, BATCHUP, PREVIEW, BATCHPREVIEW, EXPRESS or BATCHEXPRESS to perform Admin Setup.")
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    RETURN(1)
   ENDIF
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("clinical database version : ",dm2_rdbms_version->level1))
   ENDIF
   SET dm_err->eproc = "Selecting dm_info rows."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DM_OCD_SETUP_ADMIN COMPLETE"
     AND di.info_name IN ("SCHEMA_DATE", "DM_OCD_SETUP_ADMIN_DATE", "DM2_CREATE_SYSTEM_DEFS_DATE",
    "DM2_SET_ADM_CBO_DATE")
    HEAD REPORT
     dcdosa_dm_info_schema_date = 0, dcdosa_dm_info_dm_ocd_setup_admin_date = 0.0,
     dcdosa_dm_info_dm2_create_system_defs_date = 0.0,
     dcdosa_dm_info_dm2_set_adm_cbo_date = 0.0
    DETAIL
     CASE (di.info_name)
      OF "SCHEMA_DATE":
       dcdosa_dm_info_schema_date = cnvtdate2(di.info_char,"DD-MMM-YYYY")
      OF "DM_OCD_SETUP_ADMIN_DATE":
       dcdosa_dm_info_dm_ocd_setup_admin_date = cnvtdatetime(di.info_char)
      OF "DM2_CREATE_SYSTEM_DEFS_DATE":
       dcdosa_dm_info_dm2_create_system_defs_date = cnvtdatetime(di.info_char)
      OF "DM2_SET_ADM_CBO_DATE":
       dcdosa_dm_info_dm2_set_adm_cbo_date = cnvtdatetime(di.info_char)
     ENDCASE
    WITH nocounter, nullreport
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Finding newest schema file."
   CALL disp_msg("",dm_err->logfile,0)
   SET dcdosa_cer_install = cnvtlower(trim(logical("cer_install"),3))
   IF (dcfr_sea_csv_files(dcdosa_cer_install,"dm2a",dcdosa_compare_date)=0)
    RETURN(0)
   ELSE
    IF (dcdosa_compare_date="01-JAN-1800")
     SET dm_err->eproc = "Searching for Schema files."
     SET dm_err->emsg = "No schema files present in cer_install."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET dcdosa_schema_date = cnvtdate2(dcdosa_compare_date,"DD-MMM-YYYY")
    ENDIF
   ENDIF
   SET dm_err->eproc = "Selecting date/timestamps from dprotect."
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dprotect dp
    WHERE dp.object="P"
     AND dp.object_name IN ("DM_OCD_SETUP_ADMIN", "DM2_CREATE_SYSTEM_DEFS", "DM2_SET_ADM_CBO")
    DETAIL
     CASE (dp.object_name)
      OF "DM_OCD_SETUP_ADMIN":
       dm_ocd_setup_admin_data->dm_ocd_setup_admin_date = cnvtdatetime(dp.datestamp,dp.timestamp)
      OF "DM2_CREATE_SYSTEM_DEFS":
       dm_ocd_setup_admin_data->dm2_create_system_defs = cnvtdatetime(dp.datestamp,dp.timestamp)
      OF "DM2_SET_ADM_CBO":
       dm_ocd_setup_admin_data->dm2_set_adm_cbo = cnvtdatetime(dp.datestamp,dp.timestamp)
     ENDCASE
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echo(build("dcdosa_dm_info_schema_date:",dcdosa_dm_info_schema_date))
    CALL echo(build("dcdosa_schema_date:",dcdosa_schema_date))
    CALL echo(build("dcdosa_dm_info_dm_ocd_setup_admin_date:",dcdosa_dm_info_dm_ocd_setup_admin_date)
     )
    CALL echo(build("dm_ocd_setup_admin_data->dm_ocd_setup_admin_date:",dm_ocd_setup_admin_data->
      dm_ocd_setup_admin_date))
    CALL echo(build("dcdosa_dm_info_dm2_create_system_defs_date:",
      dcdosa_dm_info_dm2_create_system_defs_date))
    CALL echo(build("dm_ocd_setup_admin_data->dm2_create_system_defs:",dm_ocd_setup_admin_data->
      dm2_create_system_defs))
    CALL echo(build("dcdosa_dm_info_dm2_set_adm_cbo_date:",dcdosa_dm_info_dm2_set_adm_cbo_date))
    CALL echo(build("dm_ocd_setup_admin_data->dm2_set_adm_cbo:",dm_ocd_setup_admin_data->
      dm2_set_adm_cbo))
   ENDIF
   IF ((dm2_rdbms_version->level1 < 11))
    IF (((dcdosa_dm_info_schema_date < dcdosa_schema_date) OR ((((
    dcdosa_dm_info_dm_ocd_setup_admin_date < dm_ocd_setup_admin_data->dm_ocd_setup_admin_date)) OR ((
    dcdosa_dm_info_dm2_create_system_defs_date < dm_ocd_setup_admin_data->dm2_create_system_defs)))
    )) )
     SET dcdosa_requires_execution = 1
     RETURN(1)
    ENDIF
   ELSE
    IF (((dcdosa_dm_info_schema_date < dcdosa_schema_date) OR ((((
    dcdosa_dm_info_dm_ocd_setup_admin_date < dm_ocd_setup_admin_data->dm_ocd_setup_admin_date)) OR (
    (((dcdosa_dm_info_dm2_create_system_defs_date < dm_ocd_setup_admin_data->dm2_create_system_defs))
     OR ((dcdosa_dm_info_dm2_set_adm_cbo_date < dm_ocd_setup_admin_data->dm2_set_adm_cbo))) )) )) )
     SET dcdosa_requires_execution = 1
    ENDIF
    RETURN(1)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_check_for_package(dcfp_valid_ind,dcfp_env_id)
   SET dcfp_valid_ind = 0
   SET dcfp_env_id = 0.0
   IF (currdbuser != "V500")
    IF ((dm_err->debug_flag > 1))
     CALL echo("Bypassing check for package history.")
    ENDIF
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Find environment id."
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info i
    WHERE i.info_domain="DATA MANAGEMENT"
     AND i.info_name="DM_ENV_ID"
    DETAIL
     dcfp_env_id = i.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dcfp_valid_ind = 0
    RETURN(1)
   ENDIF
   SET dm_err->eproc = build("Look for package history for environment id :",dcfp_env_id)
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_ocd_log l
    WHERE l.environment_id=dcfp_env_id
    WITH nocounter, maxqual(l,1)
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dcfp_valid_ind = 0
   ELSE
    SET dcfp_valid_ind = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_dg_data(dgdd_assign_dg_ind,dgdd_dg_override,dgdd_dg_out)
   DECLARE dgdd_dskgrp_name = vc WITH protect, noconstant("")
   DECLARE dgdd_dskgrp_state = vc WITH protect, noconstant("")
   DECLARE dgdd_chck = i2 WITH protect, noconstant(1)
   SET dm_err->eproc = "Get diskgroup information"
   CALL disp_msg("",dm_err->logfile,0)
   SET dgdd_dg_out = "NOT_SET"
   IF ((dm_err->debug_flag >= 2))
    CALL echo(build("Use initprm assign dg ind->",dgdd_assign_dg_ind))
    CALL echo(build("Diskgroup override->",dgdd_dg_override))
   ENDIF
   IF (dgdd_dg_override != "NOT_SET")
    SET dm_err->eproc = "Query for state of disk group "
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM v$asm_diskgroup v
     WHERE v.name=dgdd_dg_override
     DETAIL
      dgdd_dskgrp_state = cnvtupper(v.state)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgdd_dskgrp_state IN ("MOUNTED", "CONNECTED"))
     SET dgdd_dg_out = dgdd_dg_override
     SET dgdd_chck = 0
    ENDIF
   ENDIF
   IF (dgdd_assign_dg_ind=1
    AND dgdd_chck=1)
    SET dm_err->eproc = "Query for disk group using db_create_file_dest"
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM v$parameter v
     WHERE v.name="db_create_file_dest"
     DETAIL
      dgdd_dskgrp_name = cnvtupper(v.value)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (findstring("+",dgdd_dskgrp_name,1,0) > 0)
     SET dgdd_dskgrp_name = trim(replace(dgdd_dskgrp_name,"+","",1),3)
    ENDIF
    SET dm_err->eproc = "Query to validate diskgroup"
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM v$asm_diskgroup v
     WHERE v.name=dgdd_dskgrp_name
     DETAIL
      dgdd_dskgrp_state = cnvtupper(v.state)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgdd_dskgrp_state IN ("MOUNTED", "CONNECTED"))
     SET dgdd_dg_out = dgdd_dskgrp_name
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag >= 2))
    CALL echo(build("Determined diskgroup->",dgdd_dg_out))
   ENDIF
   IF (dgdd_dg_out != "NOT_SET")
    SET dir_ui_misc->tspace_dg = dgdd_dg_out
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_submit_jobs(dsj_plan_id,dsj_install_mode,dsj_user,dsj_pword,dsj_cnnct_str,
  dsj_queue_name,dsj_background_ind)
   DECLARE dsj_wait_time_minutes = i2 WITH protect, noconstant(15)
   DECLARE dsj_wait_timestamp = f8 WITH protect, noconstant(0.0)
   DECLARE dsj_wait_for_start = i2 WITH protect, noconstant(0)
   FREE RECORD dsj_request
   RECORD dsj_request(
     1 plan_id = f8
     1 install_mode = vc
   )
   FREE RECORD dsj_reply
   RECORD dsj_reply(
     1 install_status = vc
     1 event = vc
     1 install_mode_ret = vc
     1 message = vc
     1 status_data
       2 status = c1
       2 subeventstatus[1]
         3 operationname = c25
         3 operationstatus = c1
         3 targetobjectname = c25
         3 targetobjectvalue = vc
   )
   SET dsj_request->plan_id = dsj_plan_id
   SET dsj_request->install_mode = "CURRENT"
   SET dsj_wait_timestamp = cnvtdatetime(curdate,curtime3)
   SET dm_err->eproc = "Get the status of auto installation"
   CALL disp_msg(" ",dm_err->logfile,0)
   EXECUTE dm2_auto_install_status  WITH replace("REQUEST",dsj_request), replace("REPLY",dsj_reply)
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ELSE
    IF ((dsj_reply->install_status="EXECUTING"))
     SET dm_err->eproc = "Checking the status of the auto install process"
     SET dm_err->emsg = concat("Active package install running for ",dsj_reply->install_mode_ret)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = "submit the package install to background"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (drr_submit_background_process(dsj_user,dsj_pword,dsj_cnnct_str,dsj_queue_name,
    dpl_package_install,
    dsj_plan_id,dsj_install_mode)=0)
    RETURN(0)
   ENDIF
   IF (dsj_install_mode="*ABG")
    SET dsj_install_mode = replace(dsj_install_mode,"ABG","",2)
   ENDIF
   SET dm_err->eproc = "Waiting for background installation process to begin."
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dm_err->eproc = "Check for wait time override"
   SELECT INTO "nl:"
    FROM dm_info d
    WHERE d.info_domain="DM2_SUBMIT_TIME_WAIT"
     AND d.info_name="MINUTES"
    DETAIL
     dsj_wait_time_minutes = d.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dsj_wait_for_start = 1
   WHILE (dsj_wait_for_start=1)
     IF (drr_cleanup_dm_info_runners(null)=0)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Wait for install to begin execution."
     SELECT INTO "nl:"
      FROM dm_process dp,
       dm_process_event dpe,
       dm_process_event_dtl dped1,
       dm_process_event_dtl dped2
      PLAN (dpe
       WHERE dpe.install_plan_id=dsj_plan_id
        AND dpe.begin_dt_tm >= cnvtdatetime(dsj_wait_timestamp))
       JOIN (dp
       WHERE dp.dm_process_id=dpe.dm_process_id
        AND dp.process_name=dpl_package_install
        AND dp.action_type=dpl_execution)
       JOIN (dped1
       WHERE dpe.dm_process_event_id=dped1.dm_process_event_id
        AND dped1.detail_type="INSTALL_MODE"
        AND dped1.detail_text=dsj_install_mode)
       JOIN (dped2
       WHERE dped1.dm_process_event_id=dped2.dm_process_event_id
        AND dped2.detail_type="UNATTENDED_IND")
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      RETURN(0)
     ENDIF
     IF (curqual > 0)
      SET dsj_wait_for_start = 0
     ENDIF
     IF (datetimediff(cnvtdatetimeutc(cnvtdatetime(curdate,curtime3)),cnvtdatetimeutc(cnvtdatetime(
        dsj_wait_timestamp)),4) > dsj_wait_time_minutes
      AND dsj_wait_for_start=1)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = "Wait time expired. Unable to detect background install process."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     CALL pause(5)
   ENDWHILE
   IF (drr_submit_background_process(dsj_user,dsj_pword,dsj_cnnct_str,dsj_queue_name,
    dpl_install_monitor,
    dsj_plan_id,dsj_install_mode)=0)
    RETURN(0)
   ENDIF
   IF (dsj_background_ind=0)
    SET width = 132
    SET message = window
    CALL clear(1,1)
    CALL text(1,1,concat("The ",dsj_install_mode,
      " Installation is now submitted as a background process."))
    CALL text(3,1,"This session/connection is no longer required.")
    CALL text(5,1,"Notification emails about Installation events will be sent as they occur.")
    CALL text(8,1,concat("To monitor, stop or pause the execution of the background ",
      dsj_install_mode," Installation process,"))
    CALL text(9,1,"you can execute the following in CCL:")
    CALL text(11,1,"ccl> dm2_install_plan_menu go ")
    CALL text(13,3,"Enter 'C' to continue.")
    CALL accept(13,34,"p;cduh"," "
     WHERE curaccept IN ("C"))
    CALL clear(1,1)
    SET message = nowindow
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_check_in_parse(dcp_owner,dcp_table_name,dcp_in_parse_ind,dcp_ret_msg)
   SET dcp_in_parse_ind = 0
   SET dcp_ret_msg = ""
   SET dm_err->eproc = concat("Check if ",dcp_table_name," table is involved in a hard parse event.")
   SELECT INTO "nl:"
    FROM dm2_objects_in_parse d
    WHERE d.to_owner=dcp_owner
     AND d.to_name=dcp_table_name
    DETAIL
     dcp_in_parse_ind = 1, dcp_ret_msg = concat("Encountered parse event against ",trim(dcp_owner),
      ".",dcp_table_name,". SQL_ID = ",
      trim(d.sql_id),", Session_Id:",trim(cnvtstring(d.session_id)),", Serial#: ",trim(cnvtstring(d
        .session_serial#)),
      ".")
    WITH nocounter, maxqual(d,1)
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_ddl_gen_retry(dgr_retry_ceiling)
   DECLARE dgr_di_exists = i2 WITH protect, noconstant(0)
   SET dgr_retry_ceiling = 10
   IF (dm2_table_and_ccldef_exists("DM_INFO",dgr_di_exists)=0)
    RETURN(0)
   ENDIF
   IF (dgr_di_exists=1)
    SET dm_err->eproc = "Check for retry ceiling override."
    SELECT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain="DM2_DDL_GEN"
      AND d.info_name="RETRY CEILING"
     DETAIL
      dgr_retry_ceiling = d.info_number
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgr_retry_ceiling <= 0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Retry ceiling is invalid (must be greater than zero)."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_load_users_pwds(dlup_users_for_pwd)
   DECLARE dlup_user = vc WITH protect, noconstant("")
   DECLARE dlup_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dlup_num = i4 WITH protect, noconstant(1)
   DECLARE dlup_idx = i2 WITH protect, noconstant(0)
   DECLARE dlup_choice = vc WITH protect, noconstant("")
   IF (size(dlup_users_for_pwd)=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Loading users into record structure for password prompt."
    SET dm_err->emsg = "No user specified."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Loading users into record structure for password prompt."
   CALL disp_msg(" ",dm_err->logfile,0)
   WHILE (dlup_user != dlup_notfnd)
     SET dlup_user = piece(dlup_users_for_pwd,",",dlup_num,dlup_notfnd)
     SET dlup_num = (dlup_num+ 1)
     IF (dlup_user != dlup_notfnd)
      SET dlup_idx = locateval(dlup_idx,1,dir_db_users_pwds->cnt,dlup_user,dir_db_users_pwds->qual[
       dlup_idx].user)
      IF (dlup_idx=0)
       SET dir_db_users_pwds->cnt = (dir_db_users_pwds->cnt+ 1)
       SET stat = alterlist(dir_db_users_pwds->qual,dir_db_users_pwds->cnt)
       SET dir_db_users_pwds->qual[dir_db_users_pwds->cnt].user = dlup_user
       CALL clear(1,1)
       CALL text(6,2,concat("Please enter password for user ",dir_db_users_pwds->qual[
         dir_db_users_pwds->cnt].user,": "))
       CALL text(10,1,"Enter 'C' to continue or 'Q' to exit process. (C or Q): ")
       CALL accept(6,50,"P(30);C"," "
        WHERE  NOT (curaccept=" "))
       SET dir_db_users_pwds->qual[dir_db_users_pwds->cnt].pwd = build(curaccept)
       CALL accept(10,60,"A;cu"," "
        WHERE curaccept IN ("Q", "C"))
       SET dlup_choice = curaccept
       IF (dlup_choice="Q")
        SET message = nowindow
        SET dm_err->err_ind = 1
        SET dm_err->emsg = "User quit process.  "
        SET dm_err->eproc = "Prompting for database user password."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
   ENDWHILE
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dir_db_users_pwds)
   ENDIF
   IF ((dir_db_users_pwds->cnt=0))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating user/password list."
    SET dm_err->emsg = "Database user/password not loaded into memory."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_adm_appl_status(dgaps_dblink,dgaps_audsid,dgaps_status)
   SET dgaps_status = "ACTIVE"
   IF (cnvtupper(dgaps_audsid)="-15301")
    RETURN(1)
   ENDIF
   SELECT INTO "nl:"
    FROM (value(concat("GV$SESSION@",dgaps_dblink)) s)
    WHERE s.audsid=cnvtint(dgaps_audsid)
    WITH nocounter
   ;end select
   IF (check_error("Selecting from gv$session in subroutine dir_get_adm_appl_status")=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SELECT INTO "nl:"
     FROM (value(concat("V$SESSION@",dgaps_dblink)) s)
     WHERE s.audsid=cnvtint(dgaps_audsid)
     WITH nocounter
    ;end select
    IF (check_error("Selecting from v$session in subroutine dir_get_adm_appl_status")=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual=0)
     SET dgaps_status = "INACTIVE"
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_upd_adm_upgrade_info(null)
   DECLARE duaui_schema_date = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Deleting from dm_info for dm_ocd_setup_admin."
   CALL disp_msg(" ",dm_err->logfile,0)
   DELETE  FROM dm_info di
    WHERE di.info_domain="DM_OCD_SETUP_ADMIN COMPLETE"
     AND di.info_name IN ("SCHEMA_DATE", "DM_OCD_SETUP_ADMIN_DATE", "DM2_CREATE_SYSTEM_DEFS_DATE",
    "DM2_SET_ADM_CBO_DATE")
    WITH nocounter
   ;end delete
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   IF (dcfr_sea_csv_files(cnvtlower(trim(logical("cer_install"),3)),"dm2a",duaui_schema_date)=0)
    RETURN(0)
   ELSE
    IF (duaui_schema_date="01-JAN-1800")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("Schema Date: ",duaui_schema_date))
   ENDIF
   SET dm_err->eproc = "Selecting date/timestamps from dprotect."
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dprotect dp
    WHERE dp.object="P"
     AND dp.object_name IN ("DM_OCD_SETUP_ADMIN", "DM2_CREATE_SYSTEM_DEFS", "DM2_SET_ADM_CBO")
    DETAIL
     CASE (dp.object_name)
      OF "DM_OCD_SETUP_ADMIN":
       dm_ocd_setup_admin_data->dm_ocd_setup_admin_date = cnvtdatetime(dp.datestamp,dp.timestamp)
      OF "DM2_CREATE_SYSTEM_DEFS":
       dm_ocd_setup_admin_data->dm2_create_system_defs = cnvtdatetime(dp.datestamp,dp.timestamp)
      OF "DM2_SET_ADM_CBO":
       dm_ocd_setup_admin_data->dm2_set_adm_cbo = cnvtdatetime(dp.datestamp,dp.timestamp)
     ENDCASE
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting schema_date row into dm_info."
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM_OCD_SETUP_ADMIN COMPLETE", di.info_name = "SCHEMA_DATE", di.info_char =
     duaui_schema_date,
     di.updt_dt_tm = cnvtdatetime(curdate,curtime3), di.updt_applctx = 0, di.updt_cnt = 0,
     di.updt_id = 0, di.updt_task = reqinfo->updt_task
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting dm_ocd_setup_admin_date row into dm_info."
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM_OCD_SETUP_ADMIN COMPLETE", di.info_name = "DM_OCD_SETUP_ADMIN_DATE", di
     .info_char = format(dm_ocd_setup_admin_data->dm_ocd_setup_admin_date,"DD-MMM-YYYY HH:MM:SS;;q"),
     di.updt_dt_tm = cnvtdatetime(curdate,curtime3), di.updt_applctx = 0, di.updt_cnt = 0,
     di.updt_id = 0, di.updt_task = reqinfo->updt_task
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting dm2_create_system_defs_date row into dm_info."
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM_OCD_SETUP_ADMIN COMPLETE", di.info_name = "DM2_CREATE_SYSTEM_DEFS_DATE",
     di.info_char = format(dm_ocd_setup_admin_data->dm2_create_system_defs,"DD-MMM-YYYY HH:MM:SS;;q"),
     di.updt_dt_tm = cnvtdatetime(curdate,curtime3), di.updt_applctx = 0, di.updt_cnt = 0,
     di.updt_id = 0, di.updt_task = reqinfo->updt_task
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting dm2_set_adm_cbo_date row into dm_info."
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM_OCD_SETUP_ADMIN COMPLETE", di.info_name = "DM2_SET_ADM_CBO_DATE", di
     .info_char = format(dm_ocd_setup_admin_data->dm2_set_adm_cbo,"DD-MMM-YYYY HH:MM:SS;;q"),
     di.updt_dt_tm = cnvtdatetime(curdate,curtime3), di.updt_applctx = 0, di.updt_cnt = 0,
     di.updt_id = 0, di.updt_task = reqinfo->updt_task
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   COMMIT
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_custom_constraints(null)
   DECLARE dgcc_constraint_index = i2 WITH protect, noconstant(0)
   SET dir_custom_constraints->con_cnt = 0
   SET stat = initrec(dir_custom_constraints)
   SET dm_err->eproc = "Retrieving custom constraints"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DM2_CUSTOM_CONSTRAINTS"
    DETAIL
     dgcc_constraint_index = (dgcc_constraint_index+ 1)
     IF (mod(dgcc_constraint_index,10)=1)
      stat = alterlist(dir_custom_constraints->con,(dgcc_constraint_index+ 9))
     ENDIF
     dir_custom_constraints->con[dgcc_constraint_index].constraint_name = di.info_name
    FOOT REPORT
     stat = alterlist(dir_custom_constraints->con,dgcc_constraint_index), dir_custom_constraints->
     con_cnt = dgcc_constraint_index
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgcc_constraint_index=0)
    SET stat = alterlist(dir_custom_constraints->con,2)
    SET dir_custom_constraints->con[1].constraint_name = "CUCIM_ACQUIRED_STUDY"
    SET dir_custom_constraints->con[2].constraint_name = "CUCIM_SERIES"
    SET dir_custom_constraints->con_cnt = 2
   ELSE
    SET dgcc_constraint_index = 0
    IF (locateval(dgcc_constraint_index,1,dir_custom_constraints->con_cnt,"CUCIM_ACQUIRED_STUDY",
     dir_custom_constraints->con[dgcc_constraint_index].constraint_name)=0)
     SET dir_custom_constraints->con_cnt = (dir_custom_constraints->con_cnt+ 1)
     SET stat = alterlist(dir_custom_constraints->con,dir_custom_constraints->con_cnt)
     SET dir_custom_constraints->con[dir_custom_constraints->con_cnt].constraint_name =
     "CUCIM_ACQUIRED_STUDY"
    ENDIF
    SET dgcc_constraint_index = 0
    IF (locateval(dgcc_constraint_index,1,dir_custom_constraints->con_cnt,"CUCIM_SERIES",
     dir_custom_constraints->con[dgcc_constraint_index].constraint_name)=0)
     SET dir_custom_constraints->con_cnt = (dir_custom_constraints->con_cnt+ 1)
     SET stat = alterlist(dir_custom_constraints->con,dir_custom_constraints->con_cnt)
     SET dir_custom_constraints->con[dir_custom_constraints->con_cnt].constraint_name =
     "CUCIM_SERIES"
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dir_get_admin_db_link(dgadl_report_fail_ind,dgadl_admin_db_link,dgadl_fail_ind)
   DECLARE dgadl_admin_env_id = f8 WITH protect, noconstant(0.0)
   DECLARE dgadl_admin_link_match = i2 WITH protect, noconstant(0)
   SET dgadl_fail_ind = 0
   SET dm_err->eproc = "Obtain Admin database link name"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_environment de,
     dm_info di
    WHERE di.info_domain="DATA MANAGEMENT"
     AND di.info_name="DM_ENV_ID"
     AND de.environment_id=di.info_number
    DETAIL
     dgadl_admin_db_link = de.admin_dbase_link_name, dgadl_admin_env_id = de.environment_id
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (textlen(dgadl_admin_db_link)=0)
    SET dgadl_fail_ind = 1
    IF (dgadl_report_fail_ind=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Admin database link is not valued in DM_ENVIRONMENT.admin_dbase_link_name."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dgadl_fail_ind=0)
    SET dm_err->eproc = "Validate Admin database link name"
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM (parser(concat("cdba.dm_environment@",dgadl_admin_db_link)) de)
     WHERE de.environment_id=dgadl_admin_env_id
     DETAIL
      IF (cnvtupper(dgadl_admin_db_link)=cnvtupper(de.admin_dbase_link_name))
       dgadl_admin_link_match = 1
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     SET dm_err->err_ind = 0
    ENDIF
    IF (dgadl_admin_link_match=0)
     SET dgadl_fail_ind = 1
     IF (dgadl_report_fail_ind=0)
      SET dm_err->err_ind = 1
      SET dm_err->emsg =
      "Admin database link does not exist in database or is causing data inconsistency when used."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE ops_get_version(_dblink=vc,_opsversion=f8(ref),_migrationinprogress=i2(ref),_errormessage=vc
  (ref)) = i2
 SUBROUTINE ops_get_version(_dblink,_opsversion,_migrationinprogress,_errormessage)
   IF (checkprg("OPS_GET_VERSION_INFO:DBA")=0)
    SET _opsversion = 1.0
    SET _migrationinprogress = 0
    SET _errormessage = ""
    RETURN(1)
   ENDIF
   FREE RECORD _versioninforequest
   RECORD _versioninforequest(
     1 db_link = vc
   )
   SET _versioninforequest->db_link = _dblink
   FREE RECORD _opsversioninfo
   RECORD _opsversioninfo(
     1 version = f8
     1 migration_in_progress = i2
     1 error = vc
   )
   EXECUTE ops_get_version_info  WITH replace("REPLY",_opsversioninfo), replace("REQUEST",
    _versioninforequest)
   DECLARE _errormsg = vc WITH protect, noconstant("")
   IF (error(_errormsg,0) != 0)
    SET _errormessage = concat("Failed to execute ops_get_version_info: ",_errormsg)
    RETURN(0)
   ENDIF
   IF ((_opsversioninfo->version=0))
    IF (trim(_opsversioninfo->error) != "")
     SET _errormessage = _opsversioninfo->error
    ELSE
     SET _errormessage = "Unknown error while executing ops_get_version_info."
    ENDIF
    RETURN(0)
   ENDIF
   SET _opsversion = _opsversioninfo->version
   SET _migrationinprogress = _opsversioninfo->migration_in_progress
   SET _errormessage = ""
   RETURN(1)
 END ;Subroutine
 IF ((validate(ddr_domain_data->tgt_exists,- (1))=- (1))
  AND validate(ddr_domain_data->tgt_exists,1)=1)
  FREE RECORD ddr_domain_data
  RECORD ddr_domain_data(
    1 process = vc
    1 get_ccluserdir = i2
    1 get_warehouse = i2
    1 get_invalid_tables = i2
    1 data_file_name = vc
    1 imp_parfile_prefix = vc
    1 exp_parfile_prefix = vc
    1 process = vc
    1 tgt_tmp_src_dir_exists = i2
    1 tgt_cer_config_dir = vc
    1 tgt_ccldir = vc
    1 tgt_ocdtools_dir = vc
    1 tgt_ccluserdir_dir = vc
    1 tgt_warehouse_dir = vc
    1 tgt_cer_install_dir = vc
    1 tgt_auth_server_id = i4
    1 tgt_auth_server_desc = vc
    1 tgt_scp_server_id = i4
    1 tgt_scp_server_desc = vc
    1 tgt_sec_server_master_id = i4
    1 tgt_sec_server_slave_id = i4
    1 tgt_sec_server_master_desc = vc
    1 tgt_sec_server_slave_desc = vc
    1 tgt_sec_server_master_lrl = vc
    1 tgt_sec_server_slave_lrl = vc
    1 tgt_tdb_server_master_id = i4
    1 tgt_tdb_server_slave_id = i4
    1 tgt_tdb_server_master_desc = vc
    1 tgt_tdb_server_slave_desc = vc
    1 tgt_tdb_count = i4
    1 tgt_server_count = i4
    1 tgt_restart_ind = i2
    1 tgt_exists = i2
    1 tgt_domain_name = vc
    1 tgt_env = vc
    1 tgt_node = vc
    1 tgt_tmp_dev = vc
    1 tgt_tmp_dir = vc
    1 tgt_tmp_dir_exists = i2
    1 tgt_tmp_full_dir = vc
    1 tgt_priv = vc
    1 tgt_priv_pwd = vc
    1 tgt_revision_level = vc
    1 tgt_user = vc
    1 tgt_pwd = vc
    1 tgt_ora_home = vc
    1 tgt_cer_data_dev = vc
    1 tgt_wh = vc
    1 tgt_wh_device = vc
    1 tgt_mng = vc
    1 tgt_mng_pwd = vc
    1 tgt_system = vc
    1 tgt_system_pwd = vc
    1 tgt_v500_pwd = vc
    1 tgt_uic = vc
    1 tgt_login_dir = vc
    1 tgt_preserve_fnd = i2
    1 tgt_preserve_ts = f8
    1 tgt_forms_fnd = i2
    1 tgt_forms_ts = f8
    1 tgt_dbas_fnd = i2
    1 tgt_dbas_ts = f8
    1 tgt_users_fnd = i2
    1 tgt_users_ts = f8
    1 tgt_sys_reg_fnd = i2
    1 tgt_sys_reg_ts = f8
    1 tgt_wh_fnd = i2
    1 tgt_wh_ts = f8
    1 tgt_ccluserdir_fnd = i2
    1 tgt_ccluserdir_ts = f8
    1 tgt_nodes_cnt = i2
    1 tgt_data_fnd = i2
    1 tgt_data_ts = f8
    1 tgt_ind_data_fnd = i2
    1 tgt_dict_fnd = i2
    1 tgt_dict_ts = f8
    1 tgt_tdb_fnd = i2
    1 tgt_tdb_ts = f8
    1 tgt_srv_def_fnd = i2
    1 tgt_srv_def_ts = f8
    1 tgt_local_user_name = vc
    1 tgt_local_group_name = vc
    1 tgt_sec_user_name = vc
    1 tgt_sec_user_fnd = i2
    1 tgt_sec_user_ts = f8
    1 tgt_env_reg_fnd = i2
    1 tgt_env_reg_ts = f8
    1 tgt_sysdef_reg_fnd = i2
    1 tgt_sysdef_reg_ts = f8
    1 tgt_invalid_tbls_fnd = i2
    1 tgt_invalid_tbls_ts = f8
    1 tgt_node_flag = i2
    1 tgt_was_arch_ind = i2
    1 tgt_preserve_pwds_cnt = i2
    1 tgt_ccl_grants_ind = i2
    1 tgt_nodes[*]
      2 node_name = vc
    1 src_ccldir = vc
    1 src_cer_config_dir = vc
    1 src_ocdtools_dir = vc
    1 src_ccluserdir_dir = vc
    1 src_warehouse_dir = vc
    1 src_cer_install_dir = vc
    1 src_auth_server_id = i4
    1 src_auth_server_desc = vc
    1 src_scp_server_id = i4
    1 src_scp_server_desc = vc
    1 src_sec_server_master_id = i4
    1 src_sec_server_slave_id = i4
    1 src_sec_server_master_desc = vc
    1 src_sec_server_slave_desc = vc
    1 src_sec_server_master_lrl = vc
    1 src_sec_server_slave_lrl = vc
    1 src_tdb_server_master_id = i4
    1 src_tdb_server_slave_id = i4
    1 src_tdb_server_master_desc = vc
    1 src_tdb_server_slave_desc = vc
    1 src_tdb_count = i4
    1 src_server_count = i4
    1 src_restart_ind = i2
    1 src_data_fnd = i2
    1 src_domain_name = vc
    1 src_db_env_name = vc
    1 src_data_ts = f8
    1 src_ind_data_fnd = i2
    1 src_dict_fnd = i2
    1 src_dict_ts = f8
    1 src_tdb_fnd = i2
    1 src_tdb_ts = f8
    1 src_srv_def_fnd = i2
    1 src_srv_def_ts = f8
    1 src_local_user_name = vc
    1 src_local_group_name = vc
    1 src_sec_user_name = vc
    1 src_sec_user_fnd = i2
    1 src_sec_user_ts = f8
    1 src_env_reg_fnd = i2
    1 src_env_reg_ts = f8
    1 src_sysdef_reg_fnd = i2
    1 src_sysdef_reg_ts = f8
    1 src_invalid_tbls_fnd = i2
    1 src_invalid_tbls_ts = f8
    1 src_wh_fnd = i2
    1 src_wh_ts = f8
    1 src_ocd_tools_fnd = i2
    1 src_ocd_tools_ts = f8
    1 src_ccldir_fnd = i2
    1 src_ccldir_ts = f8
    1 src_config_fnd = i2
    1 src_config_ts = f8
    1 src_tmp_full_dir = vc
    1 src_tmp_dir = vc
    1 src_tmp_dev = vc
    1 src_tmp_dir_exists = i2
    1 src_env = vc
    1 src_cer_data_dev = vc
    1 src_wh = vc
    1 src_wh_device = vc
    1 src_revision_level = vc
    1 src_system = vc
    1 src_system_pwd = vc
    1 src_mng = vc
    1 src_mng_pwd = vc
    1 src_priv = vc
    1 src_priv_pwd = vc
    1 src_match_tgt_node = vc
    1 src_adm_env_csv_fnd = i2
    1 src_adm_env_csv_ts = f8
    1 src_was_arch_ind = i2
    1 offline_dict_ind = i2
    1 src_nodes_cnt = i2
    1 src_ccl_grants_ind = i2
    1 src_nodes[*]
      2 node_name = vc
    1 standalone_expimp_mode = i2
    1 preserve_ind = i2
    1 preserve_user_ind = i2
    1 src_tdb_curpages = vc
    1 src_tdb_maxpages = vc
    1 src_tdb_init_size = vc
    1 src_ldap_ind = i2
    1 tgt_ldap_ind = i2
    1 src_interrogator_ind = i2
    1 src_interrogator_node = vc
    1 src_interrogator_fnd = i2
    1 src_interrogator_ts = f8
    1 src_ops_ver = f8
  )
  SET ddr_domain_data->process = "DM2NOTSET"
  SET ddr_domain_data->src_env = "DM2NOTSET"
  SET ddr_domain_data->src_tmp_dir = "DM2NOTSET"
  SET ddr_domain_data->src_tmp_full_dir = "DM2NOTSET"
  SET ddr_domain_data->src_tmp_dev = "DM2NOTSET"
  SET ddr_domain_data->src_cer_data_dev = "DM2NOTSET"
  SET ddr_domain_data->src_wh = "DM2NOTSET"
  SET ddr_domain_data->src_wh_device = "DM2NOTSET"
  SET ddr_domain_data->src_revision_level = "DM2NOTSET"
  SET ddr_domain_data->src_system = "DM2NOTSET"
  SET ddr_domain_data->src_system_pwd = "DM2NOTSET"
  SET ddr_domain_data->src_priv = "DM2NOTSET"
  SET ddr_domain_data->src_priv_pwd = "DM2NOTSET"
  SET ddr_domain_data->src_mng = "DM2NOTSET"
  SET ddr_domain_data->src_mng_pwd = "DM2NOTSET"
  SET ddr_domain_data->src_local_user_name = "DM2NOTSET"
  SET ddr_domain_data->src_local_group_name = "DM2NOTSET"
  SET ddr_domain_data->src_sec_user_name = "DM2NOTSET"
  SET ddr_domain_data->src_nodes_cnt = 0
  SET ddr_domain_data->src_ccldir = "DM2NOTSET"
  SET ddr_domain_data->src_ocdtools_dir = "DM2NOTSET"
  SET ddr_domain_data->src_ccluserdir_dir = "DM2NOTSET"
  SET ddr_domain_data->src_warehouse_dir = "DM2NOTSET"
  SET ddr_domain_data->src_cer_config_dir = "DM2NOTSET"
  SET ddr_domain_data->src_sec_server_master_lrl = "DM2NOTSET"
  SET ddr_domain_data->src_sec_server_slave_lrl = "DM2NOTSET"
  SET stat = alterlist(ddr_domain_data->src_nodes,0)
  SET ddr_domain_data->tgt_ccldir = "DM2NOTSET"
  SET ddr_domain_data->tgt_ocdtools_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_ccluserdir_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_warehouse_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_cer_config_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_env = "DM2NOTSET"
  SET ddr_domain_data->tgt_tmp_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_tmp_full_dir = "DM2NOTSET"
  SET ddr_domain_data->tgt_tmp_dev = "DM2NOTSET"
  SET ddr_domain_data->tgt_cer_data_dev = "DM2NOTSET"
  SET ddr_domain_data->tgt_wh = "DM2NOTSET"
  SET ddr_domain_data->tgt_wh_device = "DM2NOTSET"
  SET ddr_domain_data->tgt_revision_level = "DM2NOTSET"
  SET ddr_domain_data->tgt_system = "DM2NOTSET"
  SET ddr_domain_data->tgt_system_pwd = "DM2NOTSET"
  SET ddr_domain_data->tgt_priv = "DM2NOTSET"
  SET ddr_domain_data->tgt_priv_pwd = "DM2NOTSET"
  SET ddr_domain_data->tgt_mng = "DM2NOTSET"
  SET ddr_domain_data->tgt_mng_pwd = "DM2NOTSET"
  SET ddr_domain_data->tgt_local_user_name = "DM2NOTSET"
  SET ddr_domain_data->tgt_local_group_name = "DM2NOTSET"
  SET ddr_domain_data->tgt_sec_user_name = "DM2NOTSET"
  SET ddr_domain_data->tgt_sec_server_master_lrl = "DM2NOTSET"
  SET ddr_domain_data->tgt_sec_server_slave_lrl = "DM2NOTSET"
  SET ddr_domain_data->tgt_nodes_cnt = 0
  SET ddr_domain_data->tgt_node_flag = 0
  SET ddr_domain_data->tgt_domain_name = "DM2NOTSET"
  SET ddr_domain_data->tgt_auth_server_desc = "DM2NOTSET"
  SET ddr_domain_data->tgt_scp_server_desc = "DM2NOTSET"
  SET ddr_domain_data->tgt_sec_server_master_desc = "DM2NOTSET"
  SET ddr_domain_data->tgt_sec_server_slave_desc = "DM2NOTSET"
  SET ddr_domain_data->tgt_tdb_server_master_desc = "DM2NOTSET"
  SET ddr_domain_data->tgt_tdb_server_slave_desc = "DM2NOTSET"
  SET ddr_domain_data->src_auth_server_desc = "DM2NOTSET"
  SET ddr_domain_data->src_scp_server_desc = "DM2NOTSET"
  SET ddr_domain_data->src_sec_server_master_desc = "DM2NOTSET"
  SET ddr_domain_data->src_sec_server_slave_desc = "DM2NOTSET"
  SET ddr_domain_data->src_tdb_server_master_desc = "DM2NOTSET"
  SET ddr_domain_data->src_tdb_server_slave_desc = "DM2NOTSET"
  SET ddr_domain_data->src_db_env_name = "DM2NOTSET"
  SET stat = alterlist(ddr_domain_data->tgt_nodes,0)
  SET ddr_domain_data->offline_dict_ind = - (1)
  SET ddr_domain_data->imp_parfile_prefix = "inv_imp_"
  SET ddr_domain_data->exp_parfile_prefix = "inv_exp_"
  SET ddr_domain_data->data_file_name = "misc_data.dat"
  SET ddr_domain_data->standalone_expimp_mode = 0
  SET ddr_domain_data->preserve_ind = 0
  SET ddr_domain_data->src_was_arch_ind = 0
  SET ddr_domain_data->tgt_was_arch_ind = 0
  SET ddr_domain_data->tgt_preserve_pwds_cnt = 0
  SET ddr_domain_data->preserve_user_ind = 0
  SET ddr_domain_data->src_tdb_curpages = "DM2NOTSET"
  SET ddr_domain_data->src_tdb_maxpages = "DM2NOTSET"
  SET ddr_domain_data->src_tdb_init_size = "DM2NOTSET"
  SET ddr_domain_data->src_ldap_ind = 0
  SET ddr_domain_data->tgt_ldap_ind = 0
  SET ddr_domain_data->src_interrogator_ind = 0
  SET ddr_domain_data->src_interrogator_node = "DM2NOTSET"
  SET ddr_domain_data->src_ops_ver = 0
 ENDIF
 IF (validate(ddr_reg->src_reg_file,"x")="x"
  AND validate(ddr_reg->src_reg_file,"y")="y")
  FREE RECORD ddr_reg
  RECORD ddr_reg(
    1 src_reg_file = vc
    1 skcnt = i4
    1 skey[*]
      2 skeyname = vc
      2 spcnt = i4
      2 sprop[*]
        3 spropname_orig = vc
        3 spropname = vc
        3 spropval = vc
    1 tgt_reg_file = vc
    1 tkcnt = i4
    1 tkey[*]
      2 tkeyname = vc
      2 tpcnt = i4
      2 tprop[*]
        3 tpropname_orig = vc
        3 tpropname = vc
        3 tpropval = vc
    1 cur_reg_file = vc
    1 cstr_fnd = i2
    1 ckcnt = i4
    1 ckey[*]
      2 ckeyname = vc
      2 cstr_fnd = i2
      2 cpcnt = i4
      2 cprop[*]
        3 cpropname_orig = vc
        3 cpropname = vc
        3 cpropval = vc
        3 cstr_fnd = i2
  )
 ENDIF
 IF ((validate(ddr_tbl_list->owner_cnt,- (1))=- (1))
  AND validate(ddr_tbl_list->owner_cnt,1)=1)
  FREE RECORD ddr_tbl_list
  RECORD ddr_tbl_list(
    1 owner_cnt = i4
    1 logs[*]
      2 log_name = vc
    1 owner[*]
      2 owner_name = vc
      2 par_file_cnt = i2
      2 tbl_cnt = i4
      2 tbl[*]
        3 tbl_name = vc
        3 par_group = i2
  )
  SET ddr_tbl_list->owner_cnt = 0
 ENDIF
 IF (validate(ddr_scp_data->location,"x")="x"
  AND validate(ddr_scp_data->location,"y")="y")
  FREE RECORD ddr_scp_data
  RECORD ddr_scp_data(
    1 location = vc
    1 tmp_file = vc
    1 new_file = vc
  )
  SET ddr_scp_data->location = "DM2NOTSET"
  SET ddr_scp_data->tmp_file = "DM2NOTSET"
  SET ddr_scp_data->new_file = "DM2NOTSET"
 ENDIF
 IF (validate(ddr_space_needs->src_gen_loc,"x")="x"
  AND validate(ddr_space_needs->src_gen_loc,"y")="y")
  FREE RECORD ddr_space_needs
  RECORD ddr_space_needs(
    1 src_gen_loc = vc
    1 sec_cer_install_loc = vc
    1 src_dicdat_size = vc
    1 src_dicidx_size = vc
    1 src_wh_size = vc
    1 src_ocd_tools_size = vc
    1 src_ccldir_size = vc
    1 src_cer_config_size = vc
    1 src_cer_forms_size = vc
    1 src_tdb_exp_size = vc
    1 src_srv_def_size = vc
    1 src_sec_user_exp_size = vc
    1 src_env_reg_size = vc
    1 src_sys_reg_size = vc
    1 src_link_data_size = vc
    1 src_misc_data_size = vc
    1 src_ccluserdir_size = vc
    1 tgt_gen_loc = vc
    1 tgt_cer_install_loc = vc
    1 tgt_expimp_loc = vc
    1 tgt_misc_data_size = vc
    1 tgt_srv_bkup_size = vc
    1 tgt_ccluserdir_size = vc
    1 tgt_wh_size = vc
    1 tgt_tdb_exp_size = vc
    1 tgt_srv_def_size = vc
    1 tgt_sec_user_exp_size = vc
    1 tgt_env_reg_size = vc
    1 tgt_sys_reg_size = vc
    1 tgt_sys_reg_cpy_size = vc
    1 tgt_cer_forms_size = vc
    1 tgt_preserve_tbl_size = vc
    1 tgt_preserve_tbl_loc = vc
    1 tgt_dicdat_size = vc
    1 tgt_dicidx_size = vc
    1 tgt_link_data_size = vc
    1 tgt_ocd_tools_size = vc
    1 tgt_ccldir_size = vc
    1 tgt_cer_config_size = vc
    1 tgt_preserve_tbl_size = vc
    1 tot_src_temp_dir_size = vc
    1 tot_tgt_temp_dir_size = vc
    1 opt_tgt_temp_dir_size = vc
    1 tot_src_cer_install_size = vc
    1 tot_tgt_cer_install_size = vc
    1 opt_tgt_cer_install_size = vc
    1 tot_expimp_dir_size = vc
    1 src_interrogator_size = vc
  )
  SET ddr_space_needs->tgt_srv_def_size = "0.0"
  SET ddr_space_needs->tgt_env_reg_size = "0.0"
  SET ddr_space_needs->tgt_sys_reg_size = "0.0"
  SET ddr_space_needs->tgt_sys_reg_cpy_size = "0.0"
  SET ddr_space_needs->tgt_link_data_size = "0.0"
  SET ddr_space_needs->tgt_misc_data_size = "0.0"
  SET ddr_space_needs->tgt_srv_bkup_size = "0.0"
  SET ddr_space_needs->tgt_wh_size = "0.0"
  SET ddr_space_needs->tgt_ocd_tools_size = "0.0"
  SET ddr_space_needs->tgt_ccldir_size = "0.0"
  SET ddr_space_needs->tgt_ccluserdir_size = "0.0"
  SET ddr_space_needs->tgt_cer_config_size = "0.0"
  SET ddr_space_needs->tgt_cer_forms_size = "0.0"
  SET ddr_space_needs->tgt_tdb_exp_size = "0.0"
  SET ddr_space_needs->tgt_sec_user_exp_size = "0.0"
  SET ddr_space_needs->tgt_dicdat_size = "0.0"
  SET ddr_space_needs->tgt_dicidx_size = "0.0"
  SET ddr_space_needs->tgt_preserve_tbl_size = "0.0"
  SET ddr_space_needs->src_srv_def_size = "0.0"
  SET ddr_space_needs->src_env_reg_size = "0.0"
  SET ddr_space_needs->src_sys_reg_size = "0.0"
  SET ddr_space_needs->src_link_data_size = "0.0"
  SET ddr_space_needs->src_misc_data_size = "0.0"
  SET ddr_space_needs->src_wh_size = "0.0"
  SET ddr_space_needs->src_ocd_tools_size = "0.0"
  SET ddr_space_needs->src_ccldir_size = "0.0"
  SET ddr_space_needs->src_cer_config_size = "0.0"
  SET ddr_space_needs->src_cer_forms_size = "0.0"
  SET ddr_space_needs->src_tdb_exp_size = "0.0"
  SET ddr_space_needs->src_srv_def_size = "0.0"
  SET ddr_space_needs->src_sec_user_exp_size = "0.0"
  SET ddr_space_needs->src_env_reg_size = "0.0"
  SET ddr_space_needs->src_sys_reg_size = "0.0"
  SET ddr_space_needs->src_link_data_size = "0.0"
  SET ddr_space_needs->src_misc_data_size = "0.0"
  SET ddr_space_needs->tot_tgt_temp_dir_size = "0.0"
  SET ddr_space_needs->tot_tgt_cer_install_size = "0.0"
  SET ddr_space_needs->opt_tgt_temp_dir_size = "0.0"
  SET ddr_space_needs->opt_tgt_cer_install_size = "0.0"
  SET ddr_space_needs->tot_src_temp_dir_size = "0.0"
  SET ddr_space_needs->tot_src_cer_install_size = "0.0"
  SET ddr_space_needs->tot_expimp_dir_size = "0.0"
  SET ddr_space_needs->src_interrogator_size = "0.0"
 ENDIF
 IF ((validate(ddr_opsexec_servers->cnt,- (1))=- (1))
  AND validate(ddr_opsexec_servers->cnt,1)=1)
  FREE RECORD ddr_opsexec_servers
  RECORD ddr_opsexec_servers(
    1 cnt = i4
    1 servers[*]
      2 server_nbr = i4
      2 server_name = vc
      2 protect = vc
  )
  SET ddr_opsexec_servers->cnt = 0
 ENDIF
 IF ((validate(ddr_opsexec_cgs->cnt,- (1))=- (1))
  AND validate(ddr_opsexec_cgs->cnt,1)=1)
  FREE RECORD ddr_opsexec_cgs
  RECORD ddr_opsexec_cgs(
    1 cnt = i4
    1 cgs[*]
      2 server_nbr = i4
      2 cg_name = vc
      2 ocg_id = f8
  )
  SET ddr_opsexec_cgs->cnt = 0
 ENDIF
 IF ((validate(ddr_opsexec_nodes->src_node_cnt,- (1))=- (1))
  AND validate(ddr_opsexec_nodes->src_node_cnt,1)=1)
  FREE RECORD ddr_opsexec_nodes
  RECORD ddr_opsexec_nodes(
    1 src_node_cnt = i4
    1 src_nodes[*]
      2 node_name = vc
      2 tgt_map_node = vc
      2 ignore_ind = i2
      2 ocg_cnt = i4
      2 ocg_list[*]
        3 ocg_id = f8
  )
  SET ddr_opsexec_nodes->src_node_cnt = 0
 ENDIF
 IF ((validate(ddr_lreg_servers->cnt,- (1))=- (1))
  AND validate(ddr_lreg_servers->cnt,1)=1)
  FREE RECORD ddr_lreg_servers
  RECORD ddr_lreg_servers(
    1 cnt = i4
    1 qual[*]
      2 srv_nbr = i4
  )
  SET ddr_lreg_servers->cnt = 0
 ENDIF
 IF (validate(ddr_ops_info->version,1.0)=1.0
  AND validate(ddr_ops_info->version,2.0)=2.0)
  FREE RECORD ddr_ops_info
  RECORD ddr_ops_info(
    1 version = f8
    1 migration_in_progress = i2
    1 error = vc
    1 tbl_name = vc
    1 col_host = vc
    1 col_group_id = vc
    1 col_group_name = vc
    1 col_server_nbr = vc
  )
  SET ddr_ops_info->version = 0.0
  SET ddr_ops_info->migration_in_progress = 0
  SET ddr_ops_info->error = ""
  SET ddr_ops_info->tbl_name = ""
  SET ddr_ops_info->col_host = ""
  SET ddr_ops_info->col_group_id = ""
  SET ddr_ops_info->col_group_name = ""
  SET ddr_ops_info->col_server_nbr = ""
 ENDIF
 IF ((validate(ddr_backup_file_content->tgt_backup_list_cnt,- (1))=- (1))
  AND validate(ddr_backup_file_content->tgt_backup_list_cnt,1)=1)
  FREE RECORD ddr_backup_file_content
  RECORD ddr_backup_file_content(
    1 tgt_backup_list_cnt = i4
    1 tgt_backup_list[*]
      2 token = vc
      2 mode = vc
      2 fdir = vc
      2 fvalue = vc
      2 dest_dir = vc
      2 dest_fname = vc
      2 options = vc
      2 req_ind = i2
    1 src_backup_list_cnt = i4
    1 src_backup_list[*]
      2 token = vc
      2 mode = vc
      2 fdir = vc
      2 fvalue = vc
      2 dest_dir = vc
      2 dest_fname = vc
      2 options = vc
      2 req_ind = i2
  )
  SET ddr_backup_file_content->tgt_backup_list_cnt = 0
  SET stat = alterlist(ddr_backup_file_content->tgt_backup_list,0)
  SET ddr_backup_file_content->src_backup_list_cnt = 0
  SET stat = alterlist(ddr_backup_file_content->src_backup_list,0)
 ENDIF
 IF ((validate(ddr_backup_reg_content->tgt_backup_list_cnt,- (1))=- (1))
  AND validate(ddr_backup_reg_content->tgt_backup_list_cnt,1)=1)
  FREE RECORD ddr_backup_reg_content
  RECORD ddr_backup_reg_content(
    1 tgt_backup_list_cnt = i4
    1 tgt_backup_list[*]
      2 token = vc
      2 mode = vc
      2 key = vc
      2 prop = vc
      2 dest_dir = vc
      2 dest_fname = vc
      2 req_ind = i2
      2 cre_key_ind = i2
  )
  SET ddr_backup_reg_content->tgt_backup_list_cnt = 0
  SET stat = alterlist(ddr_backup_reg_content->tgt_backup_list,0)
 ENDIF
 IF ((validate(ddr_backup_srvreg_content->tgt_backup_list_cnt,- (1))=- (1))
  AND validate(ddr_backup_srvreg_content->tgt_backup_list_cnt,1)=1)
  FREE RECORD ddr_backup_srvreg_content
  RECORD ddr_backup_srvreg_content(
    1 tgt_backup_list_cnt = i4
    1 tgt_backup_list[*]
      2 token = vc
      2 mode = vc
      2 entry = vc
      2 dest_dir = vc
      2 dest_fname = vc
      2 options = vc
      2 req_ind = i2
  )
  SET ddr_backup_srvreg_content->tgt_backup_list_cnt = 0
  SET stat = alterlist(ddr_backup_srvreg_content->tgt_backup_list,0)
 ENDIF
 DECLARE max_reg_env_len = i2 WITH protect, constant(12)
 DECLARE ddr_collect_source_data(null) = i2
 DECLARE ddr_collect_target_data(null) = i2
 DECLARE ddr_get_users(null) = i2
 DECLARE ddr_get_cerforms(null) = i2
 DECLARE ddr_get_ccldbas(null) = i2
 DECLARE ddr_get_ccluserdir(dgc_prompt_only=i2) = i2
 DECLARE ddr_get_new_source_data(null) = i2
 DECLARE ddr_get_new_target_data(null) = i2
 DECLARE ddr_get_preserved_data(null) = i2
 DECLARE ddr_get_ocdtools(null) = i2
 DECLARE ddr_get_config(null) = i2
 DECLARE ddr_get_ccldir(null) = i2
 DECLARE ddr_reset_36(null) = i2
 DECLARE ddr_pop_reg_struct(dprs_type=i2,dprs_file=vc,dprs_reset=i2) = i2
 DECLARE ddr_get_misc_data(dgmd_src_ind=i2,dgmd_tgt_ind=i2) = i2
 DECLARE ddr_create_dir(dcd_dir_name=vc) = i2
 DECLARE ddr_get_env_logical(dgel_log_ret=vc(ref)) = i2
 DECLARE ddr_env_confirm(dec_src_env=i2,dec_tgt_env=i2,dec_env_to_chk=vc,dec_env_ok_ret=i2(ref)) = i2
 DECLARE ddr_node_prompt(dnp_src_node=i2,dnp_tgt_node=i2,dnp_node_ret=vc(ref)) = i2
 DECLARE ddr_dev_prompt(ddp_src_dev=i2,ddp_tgt_dev=i2,ddp_dev_ret=vc(ref)) = i2
 DECLARE ddr_dir_prompt(ddp_src_dir=i2,ddp_tgt_dir=i2,ddp_dir_ret=vc(ref)) = i2
 DECLARE ddr_clear_dir(ddd_dir_name=vc) = i2
 DECLARE ddr_read_misc_data(drmd_src_ind=i2,drmd_tgt_ind=i2) = i2
 DECLARE ddr_write_misc_data(dwmd_src_ind=i2,dwmd_tgt_ind=i2) = i2
 DECLARE ddr_get_file_date(dgfd_file_name=vc,dgfd_file_date=f8(ref)) = i2
 DECLARE ddr_lreg_oper(dlo_parm_op_type=vc,dlo_parm_req=vc,dlo_parm_ret=vc(ref)) = i2
 DECLARE ddr_summary(ds_src_ind=i2,ds_tgt_ind=i2) = i2
 DECLARE ddr_get_wh(dgw_src_ind=i2,dgw_tgt_ind=i2,dgw_prompt_only=i2) = i2
 DECLARE ddr_prompt_node_names(dpnn_src_ind=i2,dpnn_tgt_ind=i2) = i2
 DECLARE ddr_get_dicdat(dgd_src_ind=i2,dgd_tgt_ind=i2) = i2
 DECLARE ddr_get_tdb(dgt_src_ind=i2,dgt_tgt_ind=i2) = i2
 DECLARE ddr_get_srv_def(dgsd_src_ind=i2,dgsd_tgt_ind=i2) = i2
 DECLARE ddr_get_sec_user(dgsu_src_ind=i2,dgsu_tgt_ind=i2,dgsu_is_primary=i2) = i2
 DECLARE ddr_get_env_reg(dger_src_ind=i2,dger_tgt_ind=i2,dger_type=vc,dger_current=i2) = i2
 DECLARE ddr_get_invalid_tbls(dgit_src_ind=i2,dgit_tgt_ind=i2,dgit_prompt_only=i2) = i2
 DECLARE ddr_build_parfile(dbp_dir=vc,dbp_exp_prefix=vc,dbp_imp_prefix=vc) = i2
 DECLARE ddr_build_expimp_cmds(dbec_src_ind=i2,dbec_tgt_ind=i2,dbec_dir=vc,dbec_type=vc,
  dbec_cmd_file_ret=vc(ref)) = i2
 DECLARE ddr_validate_user(dvu_env_name=vc) = i2
 DECLARE ddr_validate_source_env(dvse_chk_dir=i2) = i2
 DECLARE ddr_validate_target_data(null) = i2
 DECLARE ddr_validate_source_data(null) = i2
 DECLARE ddr_create_tar_routine(dctr_dir=vc,dctr_tar_name=vc,dctr_cmd_file=vc(ref),dctr_type=vc) = i2
 DECLARE ddr_get_nodes(dgn_src_ind=i2,dgn_tgt_ind=i2) = i2
 DECLARE ddr_get_srv_id(dgsi_type=vc,dgsi_desc=vc,dgsi_server_id=vc(ref)) = i2
 DECLARE ddr_get_srv_info(dgsi_type=vc,dgsi_desc=vc,dgsi_server_id=vc(ref),dgsi_server_desc=vc(ref))
  = i2
 DECLARE ddr_get_srv_details(dgsi_type=vc,dgsi_id=vc,dgsi_desc=vc(ref),dgsd_srv_found=i2(ref)) = i2
 DECLARE ddr_get_mng_userpass(dgmu_src_ind=i2,dgmu_tgt_ind=i2) = i2
 DECLARE ddr_get_from_dir(dgfd_src_ind=i2,dgfd_logical=vc,dgfd_from_dir=vc(ref)) = i2
 DECLARE ddr_check_mng_accnt_privs(dgmu_src_ind=i2,dgmu_tgt_ind=i2,dcmap_user=vc,dcmap_pass=vc,
  dcmap_has_privs=i2(ref)) = i2
 DECLARE ddr_get_local_user_name(dglun_src_ind=i2,dglun_tgt_ind=i2) = i2
 DECLARE ddr_get_local_group_name(dglgn_src_ind=i2,dglgn_tgt_ind=i2) = i2
 DECLARE ddr_get_sec_user_name(dgsun_src_ind=i2,dgsun_tgt_ind=i2) = i2
 DECLARE ddr_scp_apply(dsa_server_id=vc,dsa_src_ind=i2,dsa_tgt_ind=i2) = i2
 DECLARE ddr_set_tgt_node_flag(null) = i2
 DECLARE ddr_get_srv_status(dgss_id=i4,dgss_desc=vc,dgss_srv_status=i2(ref)) = i2
 DECLARE ddr_backup_servers(null) = i2
 DECLARE ddr_continue_prompt(null) = i2
 DECLARE ddr_get_tgt_node_flag(null) = i2
 DECLARE ddr_parse_count(dpc_file_name=vc,dpc_count=i4(ref)) = i2
 DECLARE ddr_preserve_prompt(dpp_preserve=i2(ref)) = i2
 DECLARE ddr_preserve_check_prompt(dpcp_preserve=i2(ref)) = i2
 DECLARE ddr_get_link_data(null) = i2
 DECLARE ddr_rpt_reg_issues(null) = i2
 DECLARE ddr_check_sqlnet(dcs_src_ind=i2,dcs_tgt_ind=i2,dcs_oracle_home=vc) = i2
 DECLARE ddr_data_collection_space_needs(ddcsn_src_ind=i2,ddcsn_tgt_ind=i2) = i2
 DECLARE ddr_add_tar_error(date_src_ind=i2,date_tgt_ind=i2,date_type=vc) = i2
 DECLARE ddr_get_tar_errors(dgte_src_ind=i2,dgte_tgt_ind=i2,dgte_tar_errors_ind=i2(ref),
  dgte_tar_errors_list=vc(ref)) = i2
 DECLARE ddr_get_tdb_file(dgtf_src_ind=i2,dgtf_tgt_ind=i2,dgtf_server_id=i4,dgtf_file_ret=vc(ref)) =
 i2
 DECLARE ddr_get_adm_env(null) = i2
 DECLARE ddr_prompt_tgt_backups(null) = i2
 DECLARE ddr_lnx_findfile(dlf_file_path=vc) = i2
 DECLARE ddr_validate_preserve_pwds(null) = i2
 DECLARE ddr_get_opsexec_servers(dgos_src_ind=i2,dgos_tgt_ind=i2,dgos_set_protect_ind=i2) = i2
 DECLARE ddr_get_opsexec_node_map(null) = i2
 DECLARE ddr_update_opsexec_mapping(null) = i2
 DECLARE ddr_assign_opsexec_servers(null) = i2
 DECLARE ddr_validate_opsexec_hosts(null) = i2
 DECLARE ddr_validate_mapping(dvm_mapping_applied=i2(ref),dvm_invalid_ind=i2(ref)) = i2
 DECLARE ddr_cleanup_opsexec_mapping(null) = i2
 DECLARE ddr_get_nodes_dns(null) = i2
 DECLARE ddr_get_lreg_servers(dgls_path=vc,dgls_domain=vc) = i2
 DECLARE ddr_get_tdb_data(dgtd_file_name=vc) = i2
 DECLARE ddr_identify_ldap_usage(dilu_env=vc,dilu_domain=vc,dilu_mng=vc,dilu_mng_pwd=vc,dilu_system=
  vc,
  dilu_priv=vc,dilu_was_ind=i2,dilu_ldap_ind=i2(ref)) = i2
 DECLARE ddr_interrogator_usage(diu_interrogator_ind=i2(ref),diu_interrogator_node=vc(ref)) = i2
 DECLARE ddr_interrogator_backup(dib_mode=vc) = i2
 DECLARE ddr_get_ops_version(dgov_db_link=vc) = i2
 DECLARE ddr_backup_file_content_load(dbfcl_src_ind=i2,dbfcl_tgt_ind=i2) = i2
 DECLARE ddr_backup_file_content(dbfc_mode=vc,dbfc_fdir=vc,dbfc_fvalue=vc,dbfc_dest_dir=vc,
  dbfc_dest_fname=vc,
  dbfc_options=vc,dbfc_req_ind=i2) = i2
 DECLARE ddr_backup_reg_content_load(null) = i2
 DECLARE ddr_backup_reg_content(dbrc_mode=vc,dbrc_key=vc,dbrc_prop=vc,dbrc_dest_dir=vc,
  dbrc_dest_fname=vc,
  dbrc_req_ind=i2,dbrc_cre_key_ind=i2) = i2
 DECLARE ddr_restore_reg_content(null) = i2
 DECLARE ddr_backup_srvreg_content_load(null) = i2
 DECLARE ddr_backup_srvreg_content(dbsc_mode=vc,dbsc_entry=vc,dbsc_dest_dir=vc,dbsc_dest_fname=vc,
  dbsc_options=vc,
  dbsc_req_ind=i2) = i2
 DECLARE ddr_val_client_mnemonic(dvcm_src_ind=i2,dvcm_tgt_ind=i2,dvcm_inform_only_ind=i2,
  dvcm_invalid_data_ind=i2(ref)) = i2
 SUBROUTINE ddr_get_mng_userpass(dgmu_src_ind,dgmu_tgt_ind)
   DECLARE dgmu_ok = i2 WITH protect, noconstant(0)
   DECLARE dgmu_user = vc WITH protect, noconstant("")
   DECLARE dgmu_pass = vc WITH protect, noconstant("")
   DECLARE dgmu_has_privs = i2 WITH protect, noconstant(1)
   DECLARE dgmu_pass_mismatch = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Prompt user for ManageAccounts user/pass."
   CALL disp_msg(" ",dm_err->logfile,0)
   WHILE (dgmu_ok=0)
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,20,131)
     CALL text(2,2,concat(
       "Provide the username and password for a high-privileged Millennium account containing ",
       "the ManageAccounts, ManageServers,"))
     CALL text(3,2,
      "ManageResources and ModifyServers privileges (i.e.  Cerner account is often granted these privileges)."
      )
     CALL text(5,2,"IMPORTANT:  Do not use system or systemoe user.")
     CALL text(6,2,"            Ensure that user has not expired before proceeding.")
     CALL text(8,2,"Username:")
     CALL text(9,2,"Password:")
     CALL text(13,2,"Continue/Exit [C/E]:")
     IF (dgmu_has_privs=2)
      CALL text(15,2,"The account provided could not be validated. Please retry.")
     ELSEIF (dgmu_has_privs=0)
      CALL text(15,2,
       "The account provided does not have required privileges. Please choose another account.")
     ENDIF
     CALL accept(8,12,"P(30);C"," "
      WHERE curaccept > " "
       AND  NOT (curaccept IN ("system", "systemoe", "SYSTEM", "SYSTEMOE")))
     SET dgmu_user = curaccept
     CALL accept(9,12,"P(30);C"," "
      WHERE curaccept > " ")
     SET dgmu_pass = curaccept
     CALL accept(13,23,"A;cu"," "
      WHERE curaccept IN ("C", "E"))
     IF (curaccept="E")
      CALL clear(1,1)
      SET message = nowindow
      SET dm_err->emsg = "User elected to quit from managed account user/password entry."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      IF (ddr_check_mng_accnt_privs(dgmu_src_ind,dgmu_tgt_ind,dgmu_user,dgmu_pass,dgmu_has_privs)=0)
       RETURN(0)
      ENDIF
      IF (dgmu_has_privs=1)
       SET dgmu_ok = 1
      ENDIF
     ENDIF
   ENDWHILE
   CALL clear(1,1)
   SET message = nowindow
   IF (dgmu_src_ind=1)
    SET ddr_domain_data->src_mng = dgmu_user
    SET ddr_domain_data->src_mng_pwd = dgmu_pass
   ELSE
    SET ddr_domain_data->tgt_mng = dgmu_user
    SET ddr_domain_data->tgt_mng_pwd = dgmu_pass
   ENDIF
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_check_mng_accnt_privs(dcmap_src_ind,dcmap_tgt_ind,dcmap_user,dcmap_pass,
  dcmap_has_privs)
   DECLARE dcmap_file_name = vc WITH protect, noconstant("")
   DECLARE dcmap_cmd = vc WITH protect, noconstant("")
   DECLARE dcmap_ret = vc WITH protect, noconstant("")
   DECLARE dcmap_dir = vc WITH protect, noconstant("")
   DECLARE dcmap_domain = vc WITH protect, noconstant("")
   SET message = nowindow
   SET dm_err->eproc = "Verify that managed account provided has sufficient privileges"
   CALL disp_msg("",dm_err->logfile,0)
   IF (dcmap_src_ind=1)
    SET dcmap_dir = ddr_domain_data->src_tmp_full_dir
    SET dcmap_domain = ddr_domain_data->src_domain_name
   ELSE
    SET dcmap_dir = ddr_domain_data->tgt_tmp_full_dir
    SET dcmap_domain = ddr_domain_data->tgt_domain_name
   ENDIF
   SET dcmap_file_name = concat(dcmap_dir,"check_mng_accnt",evaluate(dm2_sys_misc->cur_os,"AXP",
     ".com",".ksh"))
   IF (dm2_findfile(dcmap_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dcmap_cmd = concat("del ",dcmap_file_name,";*")
    ELSE
     SET dcmap_cmd = concat("rm ",dcmap_file_name)
    ENDIF
    IF (dm2_push_dcl(dcmap_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to check managed account privileges :",dcmap_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dcmap_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!check_mng_accnt.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('$tgt_node = f$getsyi("nodename") '), row + 1,
      dcmap_cmd = concat('$if f$search("',dcmap_dir,'check_mng_accnt.dat") .nes. "" then delete ',
       dcmap_dir,"check_mng_accnt.dat;*"),
      CALL print(dcmap_cmd), row + 1,
      CALL print(concat("$define/user_mode sys$output ",dcmap_dir,"check_mng_accnt.dat")), row + 1,
      CALL print("$mcr cer_exe:authview"),
      row + 1,
      CALL print("$DECK"), row + 1,
      CALL print(dcmap_user), row + 1,
      CALL print(dcmap_domain),
      row + 1,
      CALL print(dcmap_pass), row + 1,
      CALL print(concat("show ",dcmap_user)), row + 1,
      CALL print("exit"),
      row + 1,
      CALL print("$EOD"), row + 1,
      CALL print("$mng_srv_priv = 0"), row + 1,
      CALL print("$mod_srv_priv = 0"),
      row + 1,
      CALL print("$mng_act_priv = 0"), row + 1,
      CALL print("$mng_res_priv = 0"), row + 1,
      CALL print("$not_valid = 0"),
      row + 1,
      CALL print(concat("$open/read PRIVS_LIST ",dcmap_dir,"check_mng_accnt.dat")), row + 1,
      CALL print("$READ_PRIVS_LIST:"), row + 1,
      CALL print("$   read/end_of_file=END_READ_PRIVS_LIST PRIVS_LIST record"),
      row + 1,
      CALL print('$   record = f$edit(record, "lowercase")'), row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print('$   pos = f$locate("manageservers", record)'),
      row + 1,
      CALL print("$   if (pos .gt. 0) .and. (pos .ne. length)"), row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      mng_srv_priv = 1"),
      row + 1,
      CALL print("$   endif"), row + 1,
      CALL print('$   pos = f$locate("modifyservers", record)'), row + 1,
      CALL print("$   if (pos .gt. 0) .and. (pos .ne. length)"),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      mod_srv_priv = 1"), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print('$   pos = f$locate("manageaccounts", record)'), row + 1,
      CALL print("$   if (pos .gt. 0) .and. (pos .ne. length)"), row + 1,
      CALL print("$   then"),
      row + 1,
      CALL print("$      mng_act_priv = 1"), row + 1,
      CALL print("$   endif"), row + 1,
      CALL print('$   pos = f$locate("manageresources", record)'),
      row + 1,
      CALL print("$   if (pos .gt. 0) .and. (pos .ne. length)"), row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      mng_res_priv = 1"),
      row + 1,
      CALL print("$   endif"), row + 1,
      CALL print('$   pos = f$locate("user authorization failure", record)'), row + 1,
      CALL print("$   if (pos .ge. 0) .and. (pos .ne. length)"),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      not_valid = 1"), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print("$  write sys$output record "), row + 1,
      CALL print("$   goto READ_PRIVS_LIST "), row + 1,
      CALL print("$END_READ_PRIVS_LIST: "),
      row + 1,
      CALL print("$   close PRIVS_LIST  "), row + 1,
      CALL print("$if (not_valid .eq. 1)"), row + 1,
      CALL print("$then"),
      row + 1,
      CALL print('$   write sys$output "Managed Account provided could NOT be validated"'), row + 1,
      CALL print("$   exit 2"), row + 1,
      CALL print("$endif"),
      row + 1,
      CALL print(
      "$if (mng_srv_priv .eq. 0) .or. (mod_srv_priv .eq. 0) .or. (mng_act_priv .eq. 0) .or. (mng_res_priv .eq. 0)"
      ), row + 1,
      CALL print("$then"), row + 1,
      CALL print(
      '$   write sys$output "Managed Account provided does NOT have sufficient privileges."'),
      row + 1,
      CALL print("$   exit 2"), row + 1,
      CALL print("$else"), row + 1,
      CALL print('$   write sys$output "Managed Account provided does have sufficient privileges."'),
      row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$endif"), row + 1,
      CALL print("$exit 1"),
      row + 1
     ELSE
      CALL print("#!/usr/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("# check_mng_accnt.ksh"), row + 1,
      CALL print("#"), row + 1,
      CALL print("tgt_node=`hostname`"),
      row + 1,
      CALL print(concat("pwd='",dcmap_pass,"'")), row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       dcmap_cmd = concat('echo "',dcmap_user,"\n",dcmap_domain,"\n",
        "$pwd",'\n" | authview "show ',dcmap_user,'" > ',dcmap_dir,
        "check_mng_accnt.dat")
      ELSE
       dcmap_cmd = concat('echo -e "',dcmap_user,"\n",dcmap_domain,"\n",
        "$pwd",'\n" | authview "show ',dcmap_user,'" > ',dcmap_dir,
        "check_mng_accnt.dat")
      ENDIF
      CALL print(dcmap_cmd), row + 1, row + 1,
      dcmap_cmd = concat("   tr '[:upper:]' '[:lower:]' < ",dcmap_dir,
       'check_mng_accnt.dat |grep "user authorization failure" '),
      CALL print(dcmap_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Managed Account provided could NOT be validated"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("fi"),
      row + 1, row + 1, dcmap_cmd = concat("   tr '[:upper:]' '[:lower:]' < ",dcmap_dir,
       'check_mng_accnt.dat |grep "manageservers" '),
      CALL print(dcmap_cmd), row + 1,
      CALL print("if [[ $? -ne 0 ]]"),
      row + 1,
      CALL print("then"), row + 1,
      CALL print('   echo "Managed Account provided does NOT have sufficient privileges"'), row + 1,
      CALL print("   exit 1"),
      row + 1,
      CALL print("fi"), row + 1,
      row + 1, dcmap_cmd = concat("   tr '[:upper:]' '[:lower:]' < ",dcmap_dir,
       'check_mng_accnt.dat |grep "modifyservers" '),
      CALL print(dcmap_cmd),
      row + 1,
      CALL print("if [[ $? -ne 0 ]]"), row + 1,
      CALL print("then"), row + 1,
      CALL print('   echo "Managed Account provided does NOT have sufficient privileges"'),
      row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("fi"), row + 1, row + 1,
      dcmap_cmd = concat("   tr '[:upper:]' '[:lower:]' < ",dcmap_dir,
       'check_mng_accnt.dat |grep "manageaccounts" '),
      CALL print(dcmap_cmd), row + 1,
      CALL print("if [[ $? -ne 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Managed Account provided does NOT have sufficient privileges"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("fi"),
      row + 1, row + 1, dcmap_cmd = concat("   tr '[:upper:]' '[:lower:]' < ",dcmap_dir,
       'check_mng_accnt.dat |grep "manageresources" '),
      CALL print(dcmap_cmd), row + 1,
      CALL print("if [[ $? -ne 0 ]]"),
      row + 1,
      CALL print("then"), row + 1,
      CALL print('   echo "Managed Account provided does NOT have sufficient privileges"'), row + 1,
      CALL print("   exit 1"),
      row + 1,
      CALL print("fi"), row + 1,
      row + 1,
      CALL print('echo "Managed Account provided does have sufficient privileges"'), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ",dcmap_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcmap_cmd = concat("@",dcmap_file_name)
   ELSE
    SET dcmap_cmd = concat("chmod 777 ",dcmap_file_name)
    IF (dm2_push_dcl(dcmap_cmd)=0)
     RETURN(0)
    ENDIF
    SET dcmap_cmd = concat(". ",dcmap_file_name)
   ENDIF
   IF (dm2_push_dcl(dcmap_cmd)=0)
    IF (findstring("Managed Account provided could NOT be validated",dm_err->errtext,1,1) > 0)
     SET dcmap_has_privs = 2
    ELSEIF (findstring("Managed Account provided does NOT have sufficient privileges",dm_err->errtext,
     1,1) > 0)
     SET dcmap_has_privs = 0
    ELSE
     RETURN(0)
    ENDIF
   ELSE
    SET dcmap_has_privs = 1
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_sec_user_name(dgsun_src_ind,dgsun_tgt_ind)
   DECLARE dgsun_sec_user_logical = vc WITH protect, noconstant("")
   DECLARE dgsun_sec_user_name = vc WITH protect, noconstant("")
   DECLARE dgsun_end_pos = i2 WITH protect, noconstant(0)
   DECLARE dgsun_length = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = "Get Sec User File Name from logical sec_user."
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dgsun_sec_user_logical = trim(logical("sec_user"))
   SET dgsun_length = size(dgsun_sec_user_logical,1)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsun_end_pos = findstring(":",dgsun_sec_user_logical,1,1)
   ELSE
    SET dgsun_end_pos = findstring("/",dgsun_sec_user_logical,1,1)
   ENDIF
   SET dgsun_sec_user_name = trim(substring((dgsun_end_pos+ 1),(dgsun_length - dgsun_end_pos),
     dgsun_sec_user_logical))
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("Sec User Logical: ",dgsun_sec_user_logical))
    CALL echo(concat("Sec User Name: ",dgsun_sec_user_name))
   ENDIF
   IF (dgsun_sec_user_name="")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Could not retrieve sec user file name from logical 'sec_user'"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgsun_src_ind=1)
    SET ddr_domain_data->src_sec_user_name = dgsun_sec_user_name
   ELSE
    SET ddr_domain_data->tgt_sec_user_name = dgsun_sec_user_name
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_local_user_name(dglun_src_ind,dglun_tgt_ind)
   DECLARE dglun_str = vc WITH protect, noconstant("")
   DECLARE dglun_reg_ret = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Get Local User Name from registry."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dglun_str = concat("\environment\",logical("environment")," LocalUserName")
   ELSE
    SET dglun_str = concat("\\environment\\",logical("environment")," LocalUserName")
   ENDIF
   IF (ddr_lreg_oper("GET",dglun_str,dglun_reg_ret)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("Registry Property: ",dglun_str))
    CALL echo(concat("Local User Name: ",dglun_reg_ret))
   ENDIF
   IF (((trim(dglun_reg_ret)="") OR (trim(dglun_reg_ret)="NOPARMRETURNED")) )
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Could not retrieve local user name from registry entry"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dglun_src_ind=1)
    SET ddr_domain_data->src_local_user_name = dglun_reg_ret
   ELSE
    SET ddr_domain_data->tgt_local_user_name = dglun_reg_ret
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_local_group_name(dglgn_src_ind,dglgn_tgt_ind)
   DECLARE dglgn_cmd = vc WITH protect, noconstant("")
   DECLARE dglgn_group = vc WITH protect, noconstant("")
   DECLARE dglgn_user = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Get Local Group Name for current user from OS."
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dglgn_user = evaluate(dglgn_src_ind,1,ddr_domain_data->src_local_user_name,ddr_domain_data->
    tgt_local_user_name)
   SET dglgn_cmd = concat("id -gn ",trim(dglgn_user))
   IF (dm2_push_dcl(dglgn_cmd)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF (((findstring("user not found",cnvtlower(dm_err->errtext),1,1) > 0) OR ((dm_err->errtext="")))
   )
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Could not retrieve local group name for user: ",dglgn_user)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dglgn_group = trim(dm_err->errtext)
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
    CALL echo(dglgn_group)
   ENDIF
   IF (dglgn_src_ind=1)
    SET ddr_domain_data->src_local_group_name = dglgn_group
   ELSE
    SET ddr_domain_data->tgt_local_group_name = dglgn_group
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_reset_36(dr3_node,dr3_env)
   DECLARE dr3_str = vc WITH protect, noconstant("")
   DECLARE dr3_ret = vc WITH protect, noconstant("")
   DECLARE dr3_err = i2 WITH protect, noconstant(0)
   DECLARE dr3_src_ind = i2 WITH protect, noconstant(0)
   DECLARE dr3_tgt_ind = i2 WITH protect, noconstant(0)
   SET dr3_err = dm_err->err_ind
   SET dm_err->err_ind = 0
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dr3_str = concat("\node\",dr3_node,"\domain\",dr3_env,'\servers\36 Protect "Y"')
   ELSE
    SET dr3_str = concat("\\node\\",dr3_node,"\\domain\\",dr3_env,'\\servers\\36 Protect "Y"')
   ENDIF
   IF (ddr_lreg_oper("SET",dr3_str,dr3_ret)=0)
    RETURN(0)
   ENDIF
   SET dm_err->err_ind = dr3_err
   IF (trim(dr3_env)=trim(ddr_domain_data->src_domain_name)
    AND trim(dr3_node)=trim(ddr_domain_data->src_nodes[1].node_name))
    SET dr3_src_ind = 1
   ELSE
    SET dr3_tgt_ind = 1
   ENDIF
   IF (ddr_scp_apply("36",dr3_src_ind,dr3_tgt_ind)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_scp_apply(dsa_server_id,dsa_src_ind,dsa_tgt_ind)
   DECLARE dsa_str = vc WITH protect, noconstant("")
   DECLARE dsa_file_name = vc WITH protect, noconstant("")
   DECLARE dsa_cmd = vc WITH protect, noconstant("")
   DECLARE dsa_ret = vc WITH protect, noconstant("")
   DECLARE dsa_node = vc WITH protect, noconstant(trim(cnvtlower(curnode)))
   DECLARE dsa_mng = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Apply registry changes for server: ",dsa_server_id)
   CALL disp_msg("",dm_err->logfile,0)
   IF (dsa_src_ind=1)
    SET dsa_mng = ddr_domain_data->src_mng
   ELSE
    IF ((ddr_domain_data->process="REPLICATE"))
     SET dsa_mng = ddr_domain_data->src_mng
    ELSE
     SET dsa_mng = ddr_domain_data->tgt_mng
    ENDIF
   ENDIF
   IF (get_unique_file("dsa_scp_apply",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dsa_file_name = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to apply registry changes :",dsa_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dsa_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print(concat("$mcr cer_exe:scpview ",dsa_node)), row + 1,
      CALL print("$DECK"),
      row + 1
     ELSE
      IF (dsa_src_ind=1)
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
      ELSE
       IF ((ddr_domain_data->process="REPLICATE"))
        CALL print(concat("tgt_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
       ELSE
        CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1
       ENDIF
      ENDIF
      CALL print(concat("$cer_exe/scpview  ",dsa_node," <<!")), row + 1
     ENDIF
     IF (dsa_src_ind=1)
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
     ELSE
      CALL print(dsa_mng), row + 1,
      CALL print(ddr_domain_data->tgt_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       IF ((ddr_domain_data->process="REPLICATE"))
        CALL print(ddr_domain_data->src_mng_pwd), row + 1
       ELSE
        CALL print(ddr_domain_data->tgt_mng_pwd), row + 1
       ENDIF
      ELSE
       CALL print("$tgt_mng_pwd"), row + 1
      ENDIF
     ENDIF
     CALL print(concat("apply ",dsa_server_id)), row + 1,
     CALL print("exit"),
     row + 1
     IF ((dm2_sys_misc->cur_os != "AXP"))
      CALL print("!"), row + 1
     ELSE
      CALL print("$EOD"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ",dsa_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dsa_cmd = concat("@",dsa_file_name)
   ELSE
    SET dsa_cmd = concat("chmod 777 ",dsa_file_name)
    IF (dm2_push_dcl(dsa_cmd)=0)
     RETURN(0)
    ENDIF
    SET dsa_cmd = concat(". $CCLUSERDIR/",dsa_file_name)
   ENDIF
   IF (dm2_push_dcl(dsa_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_create_tar_routine(dctr_dir,dctr_tar_name,dctr_cmd_file,dctr_type)
   DECLARE dctr_file = vc WITH protect, noconstant("")
   DECLARE dctr_wildcard = vc WITH protect, noconstant("*")
   IF (get_unique_file("ddr_tar",".ksh")=0)
    RETURN(0)
   ELSE
    SET dctr_file = dm_err->unique_fname
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("TAR directory:",dctr_dir))
   ENDIF
   SET dm_err->eproc = concat("Create file for tar file operation:",dctr_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dctr_file)
    DETAIL
     IF (dctr_type="CCLUSERDIR")
      CALL print(concat("cd ",dctr_dir)), row + 1,
      CALL print(concat("tar -chf ",dctr_tar_name," ",dctr_dir)),
      row + 1
     ELSEIF (dctr_type="CERFORMS")
      CALL print(concat("cd ",trim(logical("cer_forms")))), row + 1,
      CALL print(concat("tar -chf ",dctr_tar_name," ",dctr_dir)),
      row + 1
     ELSEIF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "LNX"))
      AND dctr_type="WAREHOUSE")
      CALL print(concat("cd ",dctr_dir)), row + 1,
      CALL print(concat("tar -cf ",dctr_tar_name," ",dctr_wildcard)),
      row + 1
     ELSEIF (dctr_type="CCLDIR")
      CALL print(concat("cd ",dctr_dir)), row + 1,
      CALL print("if [[ -f tar_file_list.dat ]]"),
      row + 1,
      CALL print("then"), row + 1,
      CALL print("   rm tar_file_list.dat"), row + 1,
      CALL print("fi"),
      row + 1,
      CALL print("for L_FILE in `ls $CCLDIR`"), row + 1,
      CALL print("do"), row + 1,
      CALL print(
      "  if [[ $L_FILE != 'dic.dat' && $L_FILE != 'dic.idx' && $L_FILE != 'tar_file_list.dat' ]]"),
      row + 1,
      CALL print("  then"), row + 1,
      CALL print("    echo $L_FILE >> tar_file_list.dat"), row + 1,
      CALL print("  fi"),
      row + 1,
      CALL print("done"), row + 1,
      CALL print("chmod -R 777 tar_file_list.dat"), row + 1,
      CALL print(concat("tar -chf ",dctr_tar_name," $(cat tar_file_list.dat)")),
      row + 1
     ELSE
      CALL print(concat("cd ",dctr_dir)), row + 1,
      CALL print(concat("tar -chf ",dctr_tar_name," ",dctr_wildcard)),
      row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dctr_cmd_file = dctr_file
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_config(null)
   DECLARE dgc_cmd = vc WITH protect, noconstant("")
   DECLARE dgc_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgc_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgc_str = vc WITH protect, noconstant("")
   DECLARE dgc_to_dir = vc WITH protect, noconstant("")
   DECLARE dgc_from_dir = vc WITH protect, noconstant("")
   DECLARE dgc_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->src_env,"_config.sav")
    )
   DECLARE dgc_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgc_cmd_file_ret = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgc_to_dir = ddr_domain_data->src_tmp_full_dir
   ELSE
    SET dgc_to_dir = ddr_domain_data->src_tmp_full_dir
   ENDIF
   IF (ddr_get_from_dir(1,"cer_config",dgc_from_dir)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("from_dir = ",dgc_from_dir))
   ENDIF
   SET dm_err->eproc = concat("Create backup of config to ",dgc_to_dir)
   CALL disp_msg("",dm_err->logfile,0)
   SET dgc_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgc_to_dir,evaluate(
     dm2_sys_misc->cur_os,"AXP",concat(dgc_file_name,dgc_suffix),dgc_file_name))
   IF (dm2_findfile(concat(dgc_to_dir,dgc_file_name)) > 0)
    IF (dm2_push_dcl(dgc_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   CASE (dm2_sys_misc->cur_os)
    OF "AXP":
     SET dgc_cmd = concat("$ backup/ignore=interlock ",dgc_from_dir," ",dgc_to_dir,dgc_file_name,
      "/save")
    ELSE
     IF (ddr_create_tar_routine(dgc_from_dir,concat(dgc_to_dir,dgc_file_name),dgc_cmd_file_ret,
      "CONFIG")=0)
      RETURN(0)
     ENDIF
     SET dgc_cmd = concat(". $CCLUSERDIR/",dgc_cmd_file_ret)
   ENDCASE
   SET dm_err->eproc = concat("Copy config to ",dgc_file_name)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   SET dgc_no_error = dm2_push_dcl(dgc_cmd)
   IF (dgc_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND findstring("BACKUP-W",dm_err->errtext,1,1) > 0
    AND findstring("BACKUP-F",dm_err->errtext,1,1)=0)
    SET dgc_no_error = 1
   ELSE
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(1,0,"CER_CONFIG")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgc_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgc_str = cnvtalphanum(replace(dgc_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgc_str)=1)
     SET dgc_no_error = 1
    ENDIF
   ENDIF
   IF (dgc_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(concat(dgc_to_dir,dgc_file_name))=0)
    SET dm_err->emsg = concat("Error copying config. Copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(concat(dgc_to_dir,dgc_file_name),dgc_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->src_config_ts = dgc_file_date
   SET ddr_domain_data->src_config_fnd = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_ccldir(null)
   DECLARE dgc_cmd = vc WITH protect, noconstant("")
   DECLARE dgc_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgc_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgc_str = vc WITH protect, noconstant("")
   DECLARE dgc_to_dir = vc WITH protect, noconstant("")
   DECLARE dgc_from_dir = vc WITH protect, noconstant("")
   DECLARE dgc_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->src_env,"_ccldir.sav")
    )
   DECLARE dgc_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgc_cmd_file_ret = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgc_to_dir = ddr_domain_data->src_tmp_full_dir
   ELSE
    SET dgc_to_dir = ddr_domain_data->src_tmp_full_dir
   ENDIF
   IF (ddr_get_from_dir(1,"ccldir",dgc_from_dir)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Create backup of ccldir to ",dgc_to_dir)
   CALL disp_msg("",dm_err->logfile,0)
   SET dgc_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgc_to_dir,evaluate(
     dm2_sys_misc->cur_os,"AXP",concat(dgc_file_name,dgc_suffix),dgc_file_name))
   IF (dm2_findfile(concat(dgc_to_dir,dgc_file_name)) > 0)
    IF (dm2_push_dcl(dgc_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   CASE (dm2_sys_misc->cur_os)
    OF "AXP":
     SET dgc_cmd = concat("$ backup/ignore=interlock ",dgc_from_dir," ",dgc_to_dir,dgc_file_name,
      "/save ","/exclude=dic.*;*")
    ELSE
     IF (ddr_create_tar_routine(dgc_from_dir,concat(dgc_to_dir,dgc_file_name),dgc_cmd_file_ret,
      "CCLDIR")=0)
      RETURN(0)
     ENDIF
     SET dgc_cmd = concat(". $CCLUSERDIR/",dgc_cmd_file_ret)
   ENDCASE
   SET dm_err->eproc = concat("Copy ccldir to ",dgc_file_name)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   SET dgc_no_error = dm2_push_dcl(dgc_cmd)
   IF (dgc_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND findstring("BACKUP-W",dm_err->errtext,1,1) > 0
    AND findstring("BACKUP-F",dm_err->errtext,1,1)=0)
    SET dgc_no_error = 1
   ELSE
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(1,0,"CCLDIR")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgc_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgc_str = cnvtalphanum(replace(dgc_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgc_str)=1)
     SET dgc_no_error = 1
    ENDIF
   ENDIF
   IF (dgc_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(concat(dgc_to_dir,dgc_file_name))=0)
    SET dm_err->emsg = concat("Error copying ccldir. Copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(concat(dgc_to_dir,dgc_file_name),dgc_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->src_ccldir_ts = dgc_file_date
   SET ddr_domain_data->src_ccldir_fnd = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_ocdtools(null)
   DECLARE dgo_cmd = vc WITH protect, noconstant("")
   DECLARE dgo_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgo_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgo_str = vc WITH protect, noconstant("")
   DECLARE dgo_to_dir = vc WITH protect, noconstant("")
   DECLARE dgo_from_dir = vc WITH protect, noconstant("")
   DECLARE dgo_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->src_env,"_ocds.sav"))
   DECLARE dgo_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgo_cmd_file_ret = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgo_to_dir = ddr_domain_data->src_tmp_full_dir
   ELSE
    SET dgo_to_dir = ddr_domain_data->src_tmp_full_dir
   ENDIF
   IF (ddr_get_from_dir(1,"cer_ocdtools",dgo_from_dir)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("from_dir = ",dgo_from_dir))
   ENDIF
   SET dm_err->eproc = concat("Create backup of ocd_tools to ",dgo_to_dir)
   CALL disp_msg("",dm_err->logfile,0)
   SET dgo_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgo_to_dir,evaluate(
     dm2_sys_misc->cur_os,"AXP",concat(dgo_file_name,dgo_suffix),dgo_file_name))
   IF (dm2_findfile(concat(dgo_to_dir,dgo_file_name)) > 0)
    IF (dm2_push_dcl(dgo_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   CASE (dm2_sys_misc->cur_os)
    OF "AXP":
     SET dgo_cmd = concat("$ backup/ignore=interlock ",dgo_from_dir," ",dgo_to_dir,dgo_file_name,
      "/save")
    ELSE
     IF (ddr_create_tar_routine(dgo_from_dir,concat(dgo_to_dir,dgo_file_name),dgo_cmd_file_ret,
      "OCDTOOLS")=0)
      RETURN(0)
     ENDIF
     SET dgo_cmd = concat(". $CCLUSERDIR/",dgo_cmd_file_ret)
   ENDCASE
   SET dm_err->eproc = concat("Copy ocd_tools to ",dgo_file_name)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   SET dgo_no_error = dm2_push_dcl(dgo_cmd)
   IF (dgo_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND findstring("BACKUP-W",dm_err->errtext,1,1) > 0
    AND findstring("BACKUP-F",dm_err->errtext,1,1)=0)
    SET dgo_no_error = 1
   ELSE
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(1,0,"OCD_TOOLS")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgo_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgo_str = cnvtalphanum(replace(dgo_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgo_str)=1)
     SET dgo_no_error = 1
    ENDIF
   ENDIF
   IF (dgo_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(concat(dgo_to_dir,dgo_file_name))=0)
    SET dm_err->emsg = concat("Error copying ocd_tools. Copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(concat(dgo_to_dir,dgo_file_name),dgo_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->src_ocd_tools_ts = dgo_file_date
   SET ddr_domain_data->src_ocd_tools_fnd = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_ccluserdir(dgc_prompt_only)
   DECLARE dgc_cmd = vc WITH protect, noconstant("")
   DECLARE dgc_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgc_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->tgt_tmp_full_dir,
     ddr_domain_data->tgt_env,"_ccluserdir.sav"))
   DECLARE dgc_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgc_str = vc WITH protect, noconstant("")
   DECLARE dgc_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgc_cmd_file_ret = vc WITH protect, noconstant("")
   DECLARE dgc_from_dir = vc WITH protect, noconstant("")
   SET dgc_str = concat(dgc_file_name,"? (Y)es or (N)o:")
   IF (dgc_prompt_only=1)
    SET message = window
    SET width = 132
    CALL clear(1,1)
    CALL box(1,1,11,131)
    CALL text(3,4,"Would you like CCLUSERDIR to be backed up to ")
    CALL text(4,8,dgc_str)
    CALL accept(4,(size(dgc_str)+ 10),"A;cu"," "
     WHERE curaccept IN ("Y", "N"))
    IF (curaccept="N")
     SET dm_err->eproc = "User elected to not backup CCLUSERDIR."
     CALL disp_msg(" ",dm_err->logfile,0)
     SET ddr_domain_data->get_ccluserdir = 0
     CALL clear(1,1)
     SET message = nowindow
     RETURN(1)
    ELSE
     SET ddr_domain_data->get_ccluserdir = 1
    ENDIF
    CALL clear(1,1)
    SET message = nowindow
    RETURN(1)
   ENDIF
   IF (ddr_get_from_dir(0,"ccluserdir",dgc_from_dir)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Create backup of CCLUSERDIR to ",dgc_file_name)
   CALL disp_msg("",dm_err->logfile,0)
   SET dgc_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc->
     cur_os,"AXP",concat(dgc_file_name,dgc_suffix),dgc_file_name))
   IF (dm2_findfile(dgc_file_name) > 0)
    IF (dm2_push_dcl(dgc_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   CASE (dm2_sys_misc->cur_os)
    OF "AXP":
     SET dgc_cmd = concat("$ backup/ignore=interlock ",dgc_from_dir," ",dgc_file_name,"/save")
    ELSE
     IF (ddr_create_tar_routine(dgc_from_dir,dgc_file_name,dgc_cmd_file_ret,"CCLUSERDIR")=0)
      RETURN(0)
     ENDIF
     SET dgc_cmd = concat(". $CCLUSERDIR/",dgc_cmd_file_ret)
   ENDCASE
   SET dm_err->eproc = concat("Copy CCLUSERDIR to ",dgc_file_name)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   SET dgc_no_error = dm2_push_dcl(dgc_cmd)
   IF (dgc_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND findstring("BACKUP-W",dm_err->errtext,1,1) > 0
    AND findstring("BACKUP-F",dm_err->errtext,1,1)=0)
    SET dgc_no_error = 1
   ELSE
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(0,1,"CCLUSERDIR")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgc_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgc_str = cnvtalphanum(replace(dgc_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgc_str)=1)
     SET dgc_no_error = 1
    ENDIF
   ENDIF
   IF (dgc_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dgc_file_name)=0)
    SET dm_err->emsg = concat("Error copying CCLUSERDIR. Copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(dgc_file_name,dgc_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->tgt_ccluserdir_ts = dgc_file_date
   SET ddr_domain_data->tgt_ccluserdir_fnd = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_users(null)
   DECLARE dgu_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->tgt_tmp_full_dir,
     ddr_domain_data->tgt_env,"_grp_users.dat"))
   DECLARE dgu_cmd = vc WITH protect, noconstant("")
   DECLARE dgu_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgu_suffix = vc WITH protect, noconstant(";*")
   SET dm_err->eproc = concat("Get users from Domain Group and copy to ",dgu_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(dgu_file_name) > 0)
    IF (dm2_push_dcl("rm"," ",dgu_file_name)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (ddr_get_local_group_name(0,1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET dgu_cmd = concat("lsgroup -f -a users ",ddr_domain_data->tgt_local_group_name,
     " | grep users | cut -f2 -d= > ",dgu_file_name)
   ELSE
    SET dgu_cmd = concat("/usr/sam/lbin/get_gr_mems ",ddr_domain_data->tgt_local_group_name,"  > ",
     dgu_file_name)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("ddr_get_users dcl command: ",dgu_cmd))
   ENDIF
   IF (dm2_push_dcl(dgu_cmd)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(dgu_file_name,dgu_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->tgt_users_fnd = 1
   SET ddr_domain_data->tgt_users_ts = dgu_file_date
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_ccldbas(null)
   DECLARE dgc_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->tgt_tmp_full_dir,
     ddr_domain_data->tgt_env,"_dbas.dat"))
   DECLARE dgc_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgc_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgc_str = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Get CCL group 0 users and copy to ",dgc_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dgc_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc->
     cur_os,"AXP",concat(dgc_file_name,dgc_suffix),dgc_file_name))
   IF (dm2_findfile(dgc_file_name) > 0)
    IF (dm2_push_dcl(dgc_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   FREE SET dgc_file_logical
   SET logical dgc_file_logical dgc_file_name
   SELECT INTO "dgc_file_logical"
    FROM duaf d
    WHERE d.group=0
    DETAIL
     dgc_str = trim(d.user_name), col 0, dgc_str,
     row + 1
    WITH noheading, nocounter, maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(dgc_file_name,dgc_file_date)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->tgt_dbas_fnd = 1
   SET ddr_domain_data->tgt_dbas_ts = dgc_file_date
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_cerforms(null)
   DECLARE dgc_find_str = vc WITH protect, noconstant("")
   DECLARE dgc_frm_found = i2 WITH protect, noconstant(0)
   DECLARE dgc_que_found = i2 WITH protect, noconstant(0)
   DECLARE dgc_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgc_str = vc WITH protect, noconstant("")
   DECLARE dgc_cmd = vc WITH protect, noconstant("")
   DECLARE dgc_file = vc WITH protect, noconstant("")
   DECLARE dgc_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgc_cmd_file_ret = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Copy TARGET cer_forms data to ",ddr_domain_data->tgt_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dgc_file = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,"_frmque.sav")
   SET dm_err->eproc = concat("Remove cer_forms data from ",ddr_domain_data->tgt_tmp_full_dir)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dgc_found = dm2_findfile(dgc_file)
   IF (dgc_found > 0)
    IF (dm2_push_dcl(concat("rm ",dgc_file))=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dgc_find_str = concat(trim(logical("cer_forms")),"/","form*")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    SET dgc_frm_found = dm2_findfile(dgc_find_str)
   ELSE
    SET dgc_frm_found = ddr_lnx_findfile(dgc_find_str)
   ENDIF
   IF (dgc_frm_found=1)
    SET dgc_str = "form*"
   ENDIF
   SET dgc_find_str = concat(trim(logical("cer_forms")),"/","queue*")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    SET dgc_que_found = dm2_findfile(dgc_find_str)
   ELSE
    SET dgc_que_found = ddr_lnx_findfile(dgc_find_str)
   ENDIF
   IF (dgc_que_found=1)
    IF (dgc_frm_found=1)
     SET dgc_str = concat(dgc_str," queue*")
    ELSE
     SET dgc_str = "queue*"
    ENDIF
   ENDIF
   IF (((dgc_que_found=1) OR (dgc_frm_found=1)) )
    IF (ddr_create_tar_routine(dgc_str,dgc_file,dgc_cmd_file_ret,"CERFORMS")=0)
     RETURN(0)
    ENDIF
    SET dgc_cmd = concat(". $CCLUSERDIR/",dgc_cmd_file_ret)
    SET dm_err->eproc = concat("Copy $cer_forms data to ",dgc_file)
    CALL disp_msg("",dm_err->logfile,0)
    SET dm_err->disp_dcl_err_ind = 0
    SET dgc_no_error = dm2_push_dcl(dgc_cmd)
    IF (dgc_no_error=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(dm_err)
     ENDIF
    ENDIF
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(0,1,"CER_FORMS")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgc_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgc_str = cnvtalphanum(replace(dgc_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgc_str)=1)
     SET dgc_no_error = 1
    ENDIF
    IF (dgc_no_error=0)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dm2_findfile(dgc_file)=0)
     SET dm_err->emsg = concat("Error copying $cer_forms data. Copy does not exist:",dgc_file)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (ddr_get_file_date(dgc_file,dgc_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_forms_ts = dgc_file_date
    SET ddr_domain_data->tgt_forms_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_preserved_data(null)
   DECLARE dgpd_file_full = vc WITH protect, noconstant("")
   DECLARE dgpd_file_date = f8 WITH protect, noconstant(0.0)
   SET dm_err->eproc = "Preserve data from TARGET"
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dgpd_file_full = concat(ddr_domain_data->tgt_tmp_full_dir,drr_clin_copy_data->preserve_tbl_pre,
    evaluate(dm2_sys_misc->cur_os,"AXP","*.*;*","*.*"))
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dgpd_file_full) > 0)
     IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgpd_file_full))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dgpd_file_full) > 0)
     IF (dm2_push_dcl(concat("rm ",dgpd_file_full))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dgpd_file_full = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2s",drr_clin_copy_data->
    preserve_sch_dt,evaluate(dm2_sys_misc->cur_os,"AXP","*.*;*","*.*"))
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dgpd_file_full) > 0)
     IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgpd_file_full))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dgpd_file_full) > 0)
     IF (dm2_push_dcl(concat("rm ",dgpd_file_full))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET drr_clin_copy_data->temp_location = ddr_domain_data->tgt_tmp_full_dir
   SET drr_clin_copy_data->standalone_expimp_process = ddr_domain_data->standalone_expimp_mode
   EXECUTE dm2_preserve_tables
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF ((ddr_domain_data->preserve_ind=1))
    SET ddr_domain_data->tgt_preserve_fnd = 1
    IF (ddr_get_file_date(dgpd_file_full,dgpd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_preserve_ts = dgpd_file_date
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_wh(dgw_src_ind,dgw_tgt_ind,dgw_prompt_only)
   DECLARE dgw_cmd_file = vc WITH protect, noconstant("")
   DECLARE dgw_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgw_cmd = vc WITH protect, noconstant("")
   DECLARE dgw_env = vc WITH protect, noconstant(evaluate(dgw_src_ind,1,ddr_domain_data->src_env,
     ddr_domain_data->tgt_env))
   DECLARE dgw_file_full = vc WITH protect, noconstant("")
   DECLARE dgw_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgw_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgw_str = vc WITH protect, noconstant("")
   DECLARE dgw_cmd_file_ret = vc WITH protect, noconstant("")
   DECLARE dgw_from_dir = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgw_file_full = concat(evaluate(dgw_src_ind,1,ddr_domain_data->src_tmp_full_dir,
      ddr_domain_data->tgt_tmp_full_dir),evaluate(dgw_src_ind,1,ddr_domain_data->src_env,
      ddr_domain_data->tgt_env),"_",evaluate(dgw_src_ind,1,ddr_domain_data->src_wh,ddr_domain_data->
      tgt_wh),".sav")
   ELSE
    SET dgw_file_full = concat(evaluate(dgw_src_ind,1,ddr_domain_data->src_tmp_full_dir,
      ddr_domain_data->tgt_tmp_full_dir),evaluate(dgw_src_ind,1,ddr_domain_data->src_env,
      ddr_domain_data->tgt_env),"_wh.sav")
   ENDIF
   IF (dgw_prompt_only=1)
    IF ((ddr_domain_data->get_warehouse=0))
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,20,131)
     CALL text(3,4,"Would you like to backup the warehouse (Y)es, (N)o?")
     CALL accept(3,60,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     IF (curaccept="Y")
      SET ddr_domain_data->get_warehouse = 1
     ELSE
      SET ddr_domain_data->get_warehouse = 0
     ENDIF
    ENDIF
    IF ((ddr_domain_data->get_warehouse=1))
     CALL box(1,1,20,131)
     CALL text(5,4,concat("The ",evaluate(dgw_src_ind,1,"SOURCE","TARGET"),
       " warehouse will be backed up to "))
     CALL text(6,8,dgw_file_full)
     CALL text(8,4,"Please verify you have sufficient space allocated to ")
     CALL text(9,8,concat(evaluate(dgw_src_ind,1,ddr_domain_data->src_tmp_full_dir,ddr_domain_data->
        tgt_tmp_full_dir)," before continuing."))
     CALL text(11,4,'Enter "C" to Continue or "Q" to Quit: ')
     CALL accept(11,43,"A;cu"," "
      WHERE curaccept IN ("C", "Q"))
     IF (curaccept="Q")
      CALL clear(1,1)
      SET message = nowindow
      SET dm_err->emsg = "User elected to quit from warehouse backup prompt."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    CALL clear(1,1)
    SET message = nowindow
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Warehouse Backup"
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dm_err->eproc = concat("Remove:",dgw_file_full)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dgw_file_full) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc
       ->cur_os,"AXP",concat(dgw_file_full,dgw_suffix),dgw_file_full)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    IF (ddr_get_from_dir(dgw_src_ind,"cer_wh",dgw_from_dir)=0)
     RETURN(0)
    ENDIF
    SET dgw_cmd = concat("$ backup/ignore=interlock ",dgw_from_dir," ",dgw_file_full,"/save")
   ELSE
    SET dgw_str = evaluate(dgw_src_ind,1,ddr_domain_data->src_wh_device,ddr_domain_data->
     tgt_wh_device)
    IF (ddr_create_tar_routine(dgw_str,dgw_file_full,dgw_cmd_file_ret,"WAREHOUSE")=0)
     RETURN(0)
    ENDIF
    SET dgw_cmd = concat(". $CCLUSERDIR/",dgw_cmd_file_ret)
   ENDIF
   SET dm_err->eproc = concat("Copy warehouse to ",dgw_file_full)
   CALL disp_msg("",dm_err->logfile,0)
   SET dm_err->disp_dcl_err_ind = 0
   SET dgw_no_error = dm2_push_dcl(dgw_cmd)
   IF (dgw_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND findstring("BACKUP-W",dm_err->errtext,1,1) > 0
    AND findstring("BACKUP-F",dm_err->errtext,1,1)=0)
    SET dgw_no_error = 1
   ELSE
    IF (findstring("tar: couldn't get",dm_err->errtext,1,0) > 0)
     IF (ddr_add_tar_error(dgw_src_ind,dgw_tgt_ind,"WAREHOUSE")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dgw_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
    SET dgw_str = cnvtalphanum(replace(dgw_str,"tar: couldn't get uname for uid ","",0))
    IF (isnumeric(dgw_str)=1)
     SET dgw_no_error = 1
    ENDIF
   ENDIF
   IF (dgw_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dgw_file_full)=0)
    SET dm_err->emsg = concat("Error copying ",evaluate(dgw_src_ind,1,"SOURCE","TARGET"),
     " warehouse. Copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(dgw_file_full,dgw_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dgw_src_ind=1)
    SET ddr_domain_data->src_wh_ts = dgw_file_date
    SET ddr_domain_data->src_wh_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_wh_ts = dgw_file_date
    SET ddr_domain_data->tgt_wh_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_lreg_oper(dlo_parm_op_type,dlo_parm_req,dlo_parm_ret)
   DECLARE dlo_cmd = vc WITH protect, noconstant("")
   DECLARE dlo_no_error = i2 WITH protect, noconstant(0)
   IF (get_unique_file("ddr_get_reg",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dlo_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to perform [",trim(dlo_parm_op_type),
    "] action in registry:",dlo_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dlo_file)
    DETAIL
     IF (dlo_parm_op_type="GET")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -getp ",dlo_parm_req)), row + 1,
       CALL print("$ write sys$output lreg_result"),
       row + 1
      ELSE
       dlo_cmd = concat("$cer_exe/lreg -getp ",dlo_parm_req),
       CALL print(concat("$cer_exe/lreg -getp ",dlo_parm_req)), row + 1
      ENDIF
     ELSEIF (dlo_parm_op_type="SET")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -setp ",dlo_parm_req)), row + 1,
       CALL print("$ write sys$output lreg_result"),
       row + 1
      ELSE
       dlo_cmd = concat("$cer_exe/lreg -setp ",dlo_parm_req),
       CALL print(concat("$cer_exe/lreg -setp ",dlo_parm_req)), row + 1
      ENDIF
     ELSEIF (dlo_parm_op_type="CREATE")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -crek ",dlo_parm_req)), row + 1
      ELSE
       dlo_cmd = concat("$cer_exe/lreg -crek ",dlo_parm_req),
       CALL print(concat("$cer_exe/lreg -crek ",dlo_parm_req)), row + 1
      ENDIF
     ELSEIF (dlo_parm_op_type="REMOVEKEY")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -remk ",dlo_parm_req)), row + 1,
       CALL print("$ write sys$output lreg_result"),
       row + 1
      ELSE
       dlo_cmd = concat("$cer_exe/lreg -remk ",dlo_parm_req),
       CALL print(concat("$cer_exe/lreg -remk ",dlo_parm_req)), row + 1
      ENDIF
     ELSE
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -delp ",dlo_parm_req)), row + 1,
       CALL print("$ write sys$output lreg_result"),
       row + 1
      ELSE
       dlo_cmd = concat("$cer_exe/lreg -delp ",dlo_parm_req),
       CALL print(concat("$cer_exe/lreg -delp ",dlo_parm_req)), row + 1
      ENDIF
     ENDIF
    WITH nocounter, maxcol = 2000, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dlo_cmd > "")
    SET dm_err->eproc = concat("Operation for registry: ",dlo_cmd)
   ELSE
    SET dm_err->eproc = concat("Operation for registry: ",dlo_parm_req)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgfd_cmd = concat("@",dlo_file)
   ELSE
    SET dgfd_cmd = concat(". $CCLUSERDIR/",dlo_file)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   SET dlo_no_error = dm2_push_dcl(dgfd_cmd)
   IF (dlo_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF (validate(dm2_lreg_allow_for_blanks,- (1))=1)
    SET dm2_lreg_allow_for_blanks = 0
    IF (((findstring("unable",dm_err->errtext,1,1)) OR (((findstring("key not found",dm_err->errtext,
     1,1)) OR (findstring("property not found",dm_err->errtext,1,1))) )) )
     SET dlo_no_error = 1
     SET dlo_parm_ret = "NOPARMRETURNED"
    ELSE
     SET dlo_parm_ret = dm_err->errtext
    ENDIF
   ELSE
    IF (((findstring("unable",dm_err->errtext,1,1)) OR ((((dm_err->errtext="")) OR (((findstring(
     "key not found",dm_err->errtext,1,1)) OR (findstring("property not found",dm_err->errtext,1,1)
    )) )) )) )
     SET dlo_no_error = 1
     SET dlo_parm_ret = "NOPARMRETURNED"
    ELSE
     SET dlo_parm_ret = dm_err->errtext
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("parm_value: <<",dlo_parm_ret,">>"))
   ENDIF
   IF (dlo_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_build_expimp_cmds(dbec_src_ind,dbec_tgt_ind,dbec_dir,dbec_type,dbec_cmd_file_ret)
   DECLARE dbec_file = vc WITH protect, noconstant("")
   DECLARE dbec_oraloc = vc WITH protect, noconstant("")
   DECLARE dbec_operation = vc WITH protect, noconstant("")
   DECLARE dbec_cnt = i4 WITH protect, noconstant(0)
   DECLARE dbec_user_cnt = i4 WITH protect, noconstant(0)
   DECLARE dbec_suffix = vc WITH protect, noconstant("")
   DECLARE dbec_log_cnt = i4 WITH protect, noconstant(0)
   DECLARE dbec_pword = vc WITH protect, noconstant("")
   DECLARE dbec_connect = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Building EXPORT/IMPORT command for Invalid tables"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dbec_src_ind=1)
    SET dbec_pword = dm2_install_schema->src_v500_p_word
    SET dbec_connect = dm2_install_schema->src_v500_connect_str
   ELSE
    SET dbec_pword = dm2_install_schema->v500_p_word
    SET dbec_connect = dm2_install_schema->v500_connect_str
   ENDIF
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   CASE (dm2_sys_misc->cur_os)
    OF "AXP":
     CASE (dm2_rdbms_version->level1)
      OF 8:
       SET dbec_oraloc = "ora_root:[rdbms]"
      OF 9:
       SET dbec_oraloc = "ora_root:[bin]"
      ELSE
       SET dbec_oraloc = "ora_root:[bin]"
     ENDCASE
    ELSE
     SET dbec_oraloc = trim(logical("oracle_home"))
     SET dbec_oraloc = trim(build(trim(dbec_oraloc),"/bin/"))
   ENDCASE
   IF (get_unique_file(concat("invalid_data_",cnvtlower(dbec_type)),evaluate(dm2_sys_misc->cur_os,
     "AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dbec_file = dm_err->unique_fname
   ENDIF
   SET dbec_file = concat(dbec_dir,dbec_file)
   SET dm_err->eproc = concat("Create operation file:",dbec_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET logical dbec_file_logical dbec_file
   SELECT INTO "dbec_file_logical"
    DETAIL
     FOR (dbec_user_cnt = 1 TO ddr_tbl_list->owner_cnt)
       FOR (dbec_cnt = 1 TO ddr_tbl_list->owner[dbec_user_cnt].par_file_cnt)
         dbec_log_cnt = (dbec_log_cnt+ 1), stat = alterlist(ddr_tbl_list->logs,dbec_log_cnt),
         dbec_suffix = concat(trim(cnvtstring(dbec_user_cnt)),trim(cnvtstring(dbec_cnt)))
         IF (dbec_type="EXP")
          ddr_tbl_list->logs[dbec_log_cnt].log_name = concat(dbec_dir,ddr_domain_data->
           exp_parfile_prefix,dbec_suffix,".log")
          IF ((dm2_sys_misc->cur_os="AXP"))
           dbec_operation = concat("$mcr ",dbec_oraloc,"exp ","v500/",dbec_pword,
            "@",dbec_connect," file=",dbec_dir,ddr_domain_data->exp_parfile_prefix,
            dbec_suffix,".dmp"," log=",ddr_tbl_list->logs[dbec_log_cnt].log_name," parfile=",
            dbec_dir,ddr_domain_data->exp_parfile_prefix,dbec_suffix,".par")
          ELSE
           dbec_operation = concat(dbec_oraloc,"exp ","v500/",dbec_pword,"@",
            dbec_connect," file=",dbec_dir,ddr_domain_data->exp_parfile_prefix,dbec_suffix,
            ".dmp"," log=",ddr_tbl_list->logs[dbec_log_cnt].log_name," parfile=",dbec_dir,
            ddr_domain_data->exp_parfile_prefix,dbec_suffix,".par")
          ENDIF
         ELSE
          ddr_tbl_list->logs[dbec_log_cnt].log_name = concat(dbec_dir,ddr_domain_data->
           imp_parfile_prefix,dbec_suffix)
          IF ((dm2_sys_misc->cur_os="AXP"))
           dbec_operation = concat("$mcr ",dbec_oraloc,"imp ","v500/",dbec_pword,
            "@",dbec_connect," file=",dbec_dir,ddr_domain_data->imp_parfile_prefix,
            dbec_suffix,".dmp"," log=",ddr_tbl_list->logs[dbec_log_cnt].log_name," parfile=",
            dbec_dir,ddr_domain_data->imp_parfile_prefix,dbec_suffix,".par")
          ELSE
           dbec_operation = concat(dbec_oraloc,"imp ","v500/",dbec_pword,"@",
            dbec_connect," file=",dbec_dir,ddr_domain_data->imp_parfile_prefix,dbec_suffix,
            ".dmp"," log=",ddr_tbl_list->logs[dbec_log_cnt].log_name," parfile=",dbec_dir,
            ddr_domain_data->imp_parfile_prefix,dbec_suffix,".par")
          ENDIF
         ENDIF
         col 0, dbec_operation, row + 1
       ENDFOR
     ENDFOR
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dbec_cmd_file_ret = dbec_file
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_build_parfile(dbp_dir,dbp_exp_prefix,dbp_imp_prefix)
   DECLARE dbp_par_file = vc WITH protect, noconstant("")
   DECLARE dbp_dat_file = vc WITH protect, noconstant("")
   DECLARE dbp_imp_par_file = vc WITH protect, noconstant("")
   DECLARE dbp_tbl_cnt = i4 WITH protect, noconstant(0)
   DECLARE dbp_user_cnt = i4 WITH protect, noconstant(0)
   DECLARE dbp_obj_name = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Building par files."
   CALL disp_msg(" ",dm_err->logfile,0)
   FOR (dbp_user_cnt = 1 TO ddr_tbl_list->owner_cnt)
     FOR (dbp_tbl_cnt = 1 TO ddr_tbl_list->owner[dbp_user_cnt].par_file_cnt)
       SET dbp_imp_par_file = build(dbp_dir,dbp_imp_prefix,dbp_user_cnt,dbp_tbl_cnt,".par")
       SET dbp_par_file = build(dbp_dir,dbp_exp_prefix,dbp_user_cnt,dbp_tbl_cnt,".par")
       SET dbp_dat_file = build(dbp_dir,dbp_exp_prefix,dbp_user_cnt,dbp_tbl_cnt,".dat")
       IF ((dm_err->debug_flag > 0))
        CALL echo(dbp_imp_par_file)
        CALL echo(dbp_par_file)
        CALL echo(dbp_dat_file)
       ENDIF
       SET dm_err->eproc = concat("Now creating the par file: <",dbp_par_file,">")
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg(" ",dm_err->logfile,0)
       ENDIF
       SELECT INTO value(dbp_par_file)
        FROM (dummyt d  WITH seq = ddr_tbl_list->owner[dbp_user_cnt].tbl_cnt)
        WHERE (ddr_tbl_list->owner[dbp_user_cnt].tbl[d.seq].par_group=dbp_tbl_cnt)
        HEAD REPORT
         col 0, "TABLES=(", char_cnt = 8
        DETAIL
         dbp_obj_name = concat(ddr_tbl_list->owner[dbp_user_cnt].owner_name,".",ddr_tbl_list->owner[
          dbp_user_cnt].tbl[d.seq].tbl_name), char_cnt = ((char_cnt+ size(dbp_obj_name,1))+ 3)
         IF (char_cnt >= 512)
          row + 1, char_cnt = (size(dbp_obj_name,1)+ 3)
         ENDIF
         col + 0, '"', dbp_obj_name,
         '"', ","
        FOOT REPORT
         col- (1), ")", row + 1,
         col 0, "direct=y", row + 1,
         col 0, "compress=n", row + 1
        WITH nocounter, format = variable, formfeed = none,
         maxrow = 1, maxcol = 512
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
       SET dm_err->eproc = concat("Now creating the dat file: <",dbp_dat_file,">")
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg(" ",dm_err->logfile,0)
       ENDIF
       SELECT INTO value(dbp_dat_file)
        FROM (dummyt d  WITH seq = ddr_tbl_list->owner[dbp_user_cnt].tbl_cnt)
        WHERE (ddr_tbl_list->owner[dbp_user_cnt].tbl[d.seq].par_group=dbp_tbl_cnt)
        DETAIL
         dbp_obj_name = concat(ddr_tbl_list->owner[dbp_user_cnt].owner_name,".",ddr_tbl_list->owner[
          dbp_user_cnt].tbl[d.seq].tbl_name), col 0, dbp_obj_name,
         row + 1
        WITH nocounter, format = variable, formfeed = none,
         maxrow = 1, maxcol = 512
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
       SET dm_err->eproc = concat("Creating import parfile: ",dbp_imp_par_file)
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg(" ",dm_err->logfile,0)
       ENDIF
       SELECT INTO value(dbp_imp_par_file)
        FROM (dummyt d  WITH seq = 1)
        DETAIL
         col 0, "buffer=100000", row + 1,
         col 0, "ignore=y ", row + 1,
         col 0, "commit=y", row + 1,
         col 0, "fromuser=", ddr_tbl_list->owner[dbp_user_cnt].owner_name,
         row + 1, col 0, "touser=",
         ddr_tbl_list->owner[dbp_user_cnt].owner_name, row + 1
        WITH nocounter, format = stream, maxrow = 1,
         maxcol = 512, formfeed = none
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
     ENDFOR
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_summary(ds_src_ind,ds_tgt_ind)
   DECLARE ds_line = vc WITH protect, noconstant(fillstring(129,"-"))
   DECLARE ds_rpt_file = vc WITH protect, noconstant("")
   DECLARE ds_str = vc WITH protect, noconstant("")
   DECLARE ds_cnt = i4 WITH protect, noconstant(0)
   DECLARE ds_tar_errors_ind = i2 WITH protect, noconstant(0)
   DECLARE ds_tar_errors_list = vc WITH protect, noconstant("NONE")
   DECLARE ds_reg_src_env = vc WITH protect, noconstant("")
   DECLARE ds_reg_tgt_env = vc WITH protect, noconstant("")
   IF (size(ddr_domain_data->src_env,1) > max_reg_env_len)
    SET ds_reg_src_env = substring(1,max_reg_env_len,ddr_domain_data->src_env)
   ELSE
    SET ds_reg_src_env = ddr_domain_data->src_env
   ENDIF
   IF (size(ddr_domain_data->tgt_env,1) > max_reg_env_len)
    SET ds_reg_tgt_env = substring(1,max_reg_env_len,ddr_domain_data->tgt_env)
   ELSE
    SET ds_reg_tgt_env = ddr_domain_data->tgt_env
   ENDIF
   IF (ddr_get_tar_errors(ds_src_ind,ds_tgt_ind,ds_tar_errors_ind,ds_tar_errors_list)=0)
    RETURN(0)
   ENDIF
   IF (get_unique_file("ddr_collect_data",".rpt")=0)
    RETURN(0)
   ELSE
    SET ds_rpt_file = dm_err->unique_fname
   ENDIF
   IF (ds_src_ind=1)
    SET ds_rpt_file = concat(ddr_domain_data->src_tmp_full_dir,ds_rpt_file)
   ELSE
    SET ds_rpt_file = concat(ddr_domain_data->tgt_tmp_full_dir,ds_rpt_file)
   ENDIF
   SET logical ds_rpt_file_logical ds_rpt_file
   SELECT INTO "ds_rpt_file_logical"
    HEAD REPORT
     col 0, "DATA COLLECTION SUMMARY", row + 1,
     ds_str = concat("Data collected from ",evaluate(ds_src_ind,1,ddr_domain_data->src_tmp_full_dir,
       ddr_domain_data->tgt_tmp_full_dir)), col 0, ds_str,
     row + 3, col 0, "Data",
     col 100, "Date Collected", row + 2,
     col 0, ds_line, row + 1
    DETAIL
     IF (ds_src_ind=1)
      IF (findstring("OCD_TOOLS",ds_tar_errors_list,1,0) > 0)
       ds_str = "**SOURCE OCD TOOLS:"
      ELSE
       ds_str = "SOURCE OCD TOOLS:"
      ENDIF
      col 0, ds_str, ds_str = concat(ddr_domain_data->src_env,"_ocds.sav"),
      col 40, ds_str, ds_str = evaluate(ddr_domain_data->src_ocd_tools_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->src_ocd_tools_ts,";;Q")),
      col 100, ds_str, row + 1,
      ds_str = "SOURCE DICTIONARY:", col 0, ds_str,
      col 40, "dic.dat", ds_str = evaluate(ddr_domain_data->src_dict_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->src_dict_ts,";;Q")),
      col 100, ds_str, row + 1
      IF (findstring("CCLDIR",ds_tar_errors_list,1,0) > 0)
       ds_str = "**SOURCE CCLDIR:"
      ELSE
       ds_str = "SOURCE CCLDIR:"
      ENDIF
      col 0, ds_str, ds_str = concat(ddr_domain_data->src_env,"_ccldir.sav"),
      col 40, ds_str, ds_str = evaluate(ddr_domain_data->src_ccldir_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->src_ccldir_ts,";;Q")),
      col 100, ds_str, row + 1
      IF (findstring("CER_CONFIG",ds_tar_errors_list,1,0) > 0)
       ds_str = "**SOURCE CER_CONFIG:"
      ELSE
       ds_str = "SOURCE CER_CONFIG:"
      ENDIF
      col 0, ds_str, col 40,
      ddr_domain_data->src_env, "_config.sav", ds_str = evaluate(ddr_domain_data->src_config_ts,0.0,
       "NOT COLLECTED",format(ddr_domain_data->src_config_ts,";;Q")),
      col 100, ds_str, row + 1,
      ds_str = "SOURCE TDB:", col 0, ds_str,
      col 40, ddr_domain_data->src_env, "_tdb.msg",
      ds_str = evaluate(ddr_domain_data->src_tdb_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        src_tdb_ts,";;Q")), col 100, ds_str,
      row + 1, ds_str = "SOURCE SERVER DEFINITIONS LIST:", col 0,
      ds_str
      FOR (cur_node = 1 TO ddr_domain_data->src_nodes_cnt)
        col 40, ddr_domain_data->src_domain_name, "_",
        ddr_domain_data->src_nodes[cur_node].node_name, "_save.scp", ds_str = evaluate(
         ddr_domain_data->src_srv_def_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->src_srv_def_ts,
          ";;Q")),
        col 100, ds_str, row + 1,
        ds_str = ""
      ENDFOR
      IF ((ddr_domain_data->src_was_arch_ind=0))
       ds_str = "SOURCE SEC USER", col 0, ds_str,
       col 40, ddr_domain_data->src_env, "_sec_user.dat",
       ds_str = evaluate(ddr_domain_data->src_sec_user_ts,0.0,"NOT COLLECTED",format(ddr_domain_data
         ->src_sec_user_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      ds_str = "SOURCE ENV REGISTRY:", col 0, ds_str,
      col 40, ds_reg_src_env, "_env.reg",
      ds_str = evaluate(ddr_domain_data->src_env_reg_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        src_env_reg_ts,";;Q")), col 100, ds_str,
      row + 1, ds_str = "SOURCE SYSTEM DEFINITION REGISTRY:", col 0,
      ds_str, col 40, ds_reg_src_env,
      "_sysdef.reg", ds_str = evaluate(ddr_domain_data->src_sysdef_reg_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->src_sysdef_reg_ts,";;Q")), col 100,
      ds_str, row + 1
      IF (findstring("WAREHOUSE",ds_tar_errors_list,1,0) > 0)
       col 0, "**SOURCE WAREHOUSE BACKUP:"
      ELSE
       col 0, "SOURCE WAREHOUSE BACKUP:"
      ENDIF
      IF ((dm2_sys_misc->cur_os="AXP"))
       col 40, ddr_domain_data->src_env, "_",
       ddr_domain_data->src_wh, ".sav"
      ELSE
       col 40, ddr_domain_data->src_env, "_wh.sav"
      ENDIF
      ds_str = evaluate(ddr_domain_data->src_wh_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        src_wh_ts,";;Q")), col 100, ds_str,
      row + 1, ds_str = "SOURCE ADMIN ENV CSV:", col 0,
      ds_str, col 40, "dm2_",
      ddr_domain_data->src_db_env_name, "_env_hist_summary.txt", ds_str = evaluate(ddr_domain_data->
       src_adm_env_csv_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->src_adm_env_csv_ts,";;Q")),
      col 100, ds_str, row + 1
      IF ((ddr_domain_data->src_invalid_tbls_fnd=1))
       ds_str = "SOURCE NON-STANDARD TABLES", col 0, ds_str,
       ds_str = concat(ddr_domain_data->exp_parfile_prefix,"*.dmp"), col 40, ds_str,
       ds_str = evaluate(ddr_domain_data->src_invalid_tbls_ts,0.0,"NOT COLLECTED",format(
         ddr_domain_data->src_invalid_tbls_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      IF ((ddr_domain_data->src_interrogator_fnd=1))
       ds_str = "SOURCE INRERROGATOR BACKUP DIRECTORY", col 0, ds_str,
       ds_str = concat(ddr_domain_data->src_env,"_dafsolr.sav"), col 40, ds_str,
       ds_str = evaluate(ddr_domain_data->src_interrogator_ts,0.0,"NOT COLLECTED",format(
         ddr_domain_data->src_interrogator_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      col 0, "GENERAL SOURCE DATA", ds_str = evaluate(ddr_domain_data->src_data_ts,0.0,
       "NOT COLLECTED",format(ddr_domain_data->src_data_ts,";;Q")),
      col 100, ds_str, row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       ds_str = "Warehouse Directory:", col 2, ds_str,
       ds_str = ddr_domain_data->src_warehouse_dir, col 40, ds_str,
       row + 1, ds_str = "CCLDIR Directory:", col 2,
       ds_str, ds_str = ddr_domain_data->src_ccldir, col 40,
       ds_str, row + 1, ds_str = "CER_CONFIG Directory:",
       col 2, ds_str, ds_str = ddr_domain_data->src_cer_config_dir,
       col 40, ds_str, row + 1,
       ds_str = "CCLUSERDIR Directory:", col 2, ds_str,
       ds_str = ddr_domain_data->src_ccluserdir_dir, col 40, ds_str,
       row + 1, ds_str = "OCDTOOLS Directory:", col 2,
       ds_str, ds_str = ddr_domain_data->src_ocdtools_dir, col 40,
       ds_str, row + 1
      ENDIF
      ds_str = "CER_DATA Device:", col 2, ds_str,
      ds_str = ddr_domain_data->src_cer_data_dev, col 40, ds_str,
      row + 1, ds_str = "Warehouse:", col 2,
      ds_str, ds_str = ddr_domain_data->src_wh, col 40,
      ds_str, row + 1, ds_str = "Warehouse Device:",
      col 2, ds_str, ds_str = ddr_domain_data->src_wh_device,
      col 40, ds_str, row + 1,
      ds_str = "Rev Level:", col 2, ds_str,
      ds_str = ddr_domain_data->src_revision_level, col 40, ds_str,
      row + 1, ds_str = "System User:", col 2,
      ds_str, ds_str = ddr_domain_data->src_system, col 40,
      ds_str, row + 1, ds_str = "System Password:",
      col 2, ds_str, ds_str = ddr_domain_data->src_system_pwd,
      col 40, ds_str, row + 1,
      ds_str = "Priv User:", col 2, ds_str,
      ds_str = ddr_domain_data->src_priv, col 40, ds_str,
      row + 1, ds_str = "Priv Password:", col 2,
      ds_str, ds_str = ddr_domain_data->src_priv_pwd, col 40,
      ds_str, row + 1, ds_str = "ManageAccount User:",
      col 2, ds_str, ds_str = ddr_domain_data->src_mng,
      col 40, ds_str, row + 1,
      ds_str = "ManageAccount Password:", col 2, ds_str,
      ds_str = ddr_domain_data->src_mng_pwd, col 40, ds_str,
      row + 1, ds_str = "Sec User File Name:", col 2,
      ds_str, ds_str = ddr_domain_data->src_sec_user_name, col 40,
      ds_str, row + 1, ds_str = "Local User Name:",
      col 2, ds_str, ds_str = ddr_domain_data->src_local_user_name,
      col 40, ds_str, row + 1,
      ds_str = "Authorize Server ID:", col 2, ds_str,
      ds_str = build(ddr_domain_data->src_auth_server_id), col 40, ds_str,
      row + 1, ds_str = "Authorize Server Description:", col 2,
      ds_str, ds_str = ddr_domain_data->src_auth_server_desc, col 40,
      ds_str, row + 1, ds_str = "SCP Server ID:",
      col 2, ds_str, ds_str = build(ddr_domain_data->src_scp_server_id),
      col 40, ds_str, row + 1,
      ds_str = "SCP Server Description:", col 2, ds_str,
      ds_str = ddr_domain_data->src_scp_server_desc, col 40, ds_str,
      row + 1, ds_str = "TDB Server Master ID:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->src_tdb_server_master_id,0,"NOT FOUND",build(
        ddr_domain_data->src_tdb_server_master_id)), col 40,
      ds_str, row + 1, ds_str = "TDB Server Master Description:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->src_tdb_server_master_id,0,"NOT FOUND",
       ddr_domain_data->src_tdb_server_master_desc),
      col 40, ds_str, row + 1,
      ds_str = "TDB Server Slave ID:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->src_tdb_server_slave_id,0,"NOT FOUND",build(ddr_domain_data
        ->src_tdb_server_slave_id)), col 40, ds_str,
      row + 1, ds_str = "TDB Server Slave Description:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->src_tdb_server_slave_id,0,"NOT FOUND",
       ddr_domain_data->src_tdb_server_slave_desc), col 40,
      ds_str, row + 1, ds_str = "Security Server Master ID:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->src_sec_server_master_id,0,"NOT FOUND",build(
        ddr_domain_data->src_sec_server_master_id)),
      col 40, ds_str, row + 1,
      ds_str = "Security Server Master Description:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->src_sec_server_master_id,0,"NOT FOUND",ddr_domain_data->
       src_sec_server_master_desc), col 40, ds_str,
      row + 1, ds_str = "Security Slave Server ID:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->src_sec_server_slave_id,0,"NOT FOUND",build(
        ddr_domain_data->src_sec_server_slave_id)), col 40,
      ds_str, row + 1, ds_str = "Security Slave Server Description:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->src_sec_server_slave_id,0,"NOT FOUND",
       ddr_domain_data->src_sec_server_slave_desc),
      col 40, ds_str, row + 1,
      ds_str = "WAS Security Architecture Enabled:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->src_was_arch_ind,1,"YES","NO"), col 40, ds_str,
      row + 1, ds_str = "Offline Dictionary Enabled:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->offline_dict_ind,1,"YES","NO"), col 40,
      ds_str, row + 1, ds_str = "Domain Name:",
      col 2, ds_str, col 40,
      ddr_domain_data->src_domain_name, row + 1, ds_str = "Application Node(s):",
      col 2, ds_str
      FOR (ds_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
        col 40, ddr_domain_data->src_nodes[ds_cnt].node_name, row + 1
      ENDFOR
      IF (ds_tar_errors_ind > 0)
       row + 1, ds_str = concat(
        "** TAR file(s) were generated with invalid user/group id warnings while gathering: ",
        ds_tar_errors_list), col 2,
       ds_str, row + 1
      ENDIF
      ds_str = "LDAP Enabled:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->src_ldap_ind,1,"YES","NO"), col 40, ds_str,
      row + 1
     ELSE
      ds_str = "TARGET DICTIONARY:", col 0, ds_str,
      col 40, "dic.dat", ds_str = evaluate(ddr_domain_data->tgt_dict_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->tgt_dict_ts,";;Q")),
      col 100, ds_str, row + 1,
      ds_str = "TARGET TDB:", col 0, ds_str,
      col 40, ddr_domain_data->tgt_env, "_tdb.msg",
      ds_str = evaluate(ddr_domain_data->tgt_tdb_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        tgt_tdb_ts,";;Q")), col 100, ds_str,
      row + 1, ds_str = "TARGET SERVER DEFINITIONS LIST:", col 0,
      ds_str
      FOR (cur_node = 1 TO ddr_domain_data->tgt_nodes_cnt)
        col 40, ddr_domain_data->tgt_domain_name, "_",
        ddr_domain_data->tgt_nodes[cur_node].node_name, "_save.scp", ds_str = evaluate(
         ddr_domain_data->tgt_srv_def_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->tgt_srv_def_ts,
          ";;Q")),
        col 100, ds_str, row + 1
      ENDFOR
      IF ((ddr_domain_data->tgt_was_arch_ind=0))
       ds_str = "TARGET SEC USER", col 0, ds_str,
       col 40, ddr_domain_data->tgt_env, "_sec_user.dat",
       ds_str = evaluate(ddr_domain_data->tgt_sec_user_ts,0.0,"NOT COLLECTED",format(ddr_domain_data
         ->tgt_sec_user_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      ds_str = "TARGET ENV REGISTRY:", col 0, ds_str,
      col 40, ds_reg_tgt_env, "_env.reg",
      ds_str = evaluate(ddr_domain_data->tgt_env_reg_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        tgt_env_reg_ts,";;Q")), col 100, ds_str,
      row + 1, ds_str = "TARGET SYSTEM DEFINITION REGISTRY:", col 0,
      ds_str, col 40, ds_reg_tgt_env,
      "_sysdef.reg", ds_str = evaluate(ddr_domain_data->tgt_sysdef_reg_ts,0.0,"NOT COLLECTED",format(
        ddr_domain_data->tgt_sysdef_reg_ts,";;Q")), col 100,
      ds_str, row + 1
      IF (findstring("WAREHOUSE",ds_tar_errors_list,1,0) > 0)
       col 0, "**TARGET WAREHOUSE BACKUP:"
      ELSE
       col 0, "TARGET WAREHOUSE BACKUP:"
      ENDIF
      IF ((dm2_sys_misc->cur_os="AXP"))
       col 40, ddr_domain_data->tgt_env, "_",
       ddr_domain_data->tgt_wh, ".sav"
      ELSE
       col 40, ddr_domain_data->tgt_env, "_wh.sav"
      ENDIF
      ds_str = evaluate(ddr_domain_data->tgt_wh_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
        tgt_wh_ts,";;Q")), col 100, ds_str,
      row + 1
      IF ((dm2_sys_misc->cur_os != "AXP"))
       col 0, "TARGET USERS BACKUP:", col 40,
       ddr_domain_data->tgt_env, "_grp_users.dat", ds_str = evaluate(ddr_domain_data->tgt_users_ts,
        0.0,"NOT COLLECTED",format(ddr_domain_data->tgt_users_ts,";;Q")),
       col 100, ds_str, row + 1
      ENDIF
      col 0, "TARGET DBAS BACKUP:", col 40,
      ddr_domain_data->tgt_env, "_dbas.dat", ds_str = evaluate(ddr_domain_data->tgt_dbas_ts,0.0,
       "NOT COLLECTED",format(ddr_domain_data->tgt_dbas_ts,";;Q")),
      col 100, ds_str, row + 1,
      col 0, "TARGET SYSTEM REGISTRY BACKUP:", col 40,
      ds_reg_tgt_env, "_sys.reg", ds_str = evaluate(ddr_domain_data->tgt_sys_reg_ts,0.0,
       "NOT COLLECTED",format(ddr_domain_data->tgt_sys_reg_ts,";;Q")),
      col 100, ds_str, row + 1
      IF (findstring("CCLUSERDIR",ds_tar_errors_list,1,0) > 0)
       col 0, "**TARGET CCLUSERDIR BACKUP:"
      ELSE
       col 0, "TARGET CCLUSERDIR BACKUP:"
      ENDIF
      col 40, ddr_domain_data->tgt_env, "_ccluserdir.sav",
      ds_str = evaluate(ddr_domain_data->tgt_ccluserdir_ts,0.0,"NOT COLLECTED",format(ddr_domain_data
        ->tgt_ccluserdir_ts,";;Q")), col 100, ds_str,
      row + 1
      IF ((ddr_domain_data->tgt_invalid_tbls_fnd=1))
       ds_str = "TARGET NON-STANDARD TABLES", col 0, ds_str,
       ds_str = concat(ddr_domain_data->exp_parfile_prefix,"*.dmp"), col 40, ds_str,
       ds_str = evaluate(ddr_domain_data->tgt_invalid_tbls_ts,0.0,"NOT COLLECTED",format(
         ddr_domain_data->tgt_invalid_tbls_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      IF ((ddr_domain_data->tgt_preserve_fnd=1))
       col 0, "TARGET PRESERVED TABLES:", col 40,
       "Preserved data found.", ds_str = evaluate(ddr_domain_data->tgt_preserve_ts,0.0,
        "NOT COLLECTED",format(ddr_domain_data->tgt_preserve_ts,";;Q")), col 100,
       ds_str, row + 1
      ENDIF
      IF ((ddr_domain_data->tgt_forms_fnd=1)
       AND (dm2_sys_misc->cur_os != "AXP")
       AND (ddr_domain_data->tgt_forms_ts != cnvtdatetime("22-JUL-1978")))
       ds_str = "TARGET CER_FORMS", col 0, ds_str,
       col 40, ddr_domain_data->tgt_env, "_frmque.sav",
       ds_str = evaluate(ddr_domain_data->tgt_forms_ts,0.0,"NOT COLLECTED",format(ddr_domain_data->
         tgt_forms_ts,";;Q")), col 100, ds_str,
       row + 1
      ENDIF
      col 0, "GENERAL TARGET DATA", ds_str = evaluate(ddr_domain_data->tgt_data_ts,0.0,
       "NOT COLLECTED",format(ddr_domain_data->tgt_data_ts,";;Q")),
      col 100, ds_str, row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       ds_str = "Warehouse Directory:", col 2, ds_str,
       ds_str = ddr_domain_data->tgt_warehouse_dir, col 40, ds_str,
       row + 1, ds_str = "CCLDIR Directory:", col 2,
       ds_str, ds_str = ddr_domain_data->tgt_ccldir, col 40,
       ds_str, row + 1, ds_str = "CER_CONFIG Directory:",
       col 2, ds_str, ds_str = ddr_domain_data->tgt_cer_config_dir,
       col 40, ds_str, row + 1,
       ds_str = "CCLUSERDIR Directory:", col 2, ds_str,
       ds_str = ddr_domain_data->tgt_ccluserdir_dir, col 40, ds_str,
       row + 1, ds_str = "OCDTOOLS Directory:", col 2,
       ds_str, ds_str = ddr_domain_data->tgt_ocdtools_dir, col 40,
       ds_str, row + 1
      ENDIF
      ds_str = "CER_DATA Device:", col 2, ds_str,
      ds_str = ddr_domain_data->tgt_cer_data_dev, col 40, ds_str,
      row + 1, ds_str = "Warehouse:", col 2,
      ds_str, ds_str = ddr_domain_data->tgt_wh, col 40,
      ds_str, row + 1, ds_str = "Warehouse Device:",
      col 2, ds_str, ds_str = ddr_domain_data->tgt_wh_device,
      col 40, ds_str, row + 1,
      ds_str = "Rev Level:", col 2, ds_str,
      ds_str = ddr_domain_data->tgt_revision_level, col 40, ds_str,
      row + 1, ds_str = "System User:", col 2,
      ds_str, ds_str = ddr_domain_data->tgt_system, col 40,
      ds_str, row + 1, ds_str = "System Password:",
      col 2, ds_str, ds_str = ddr_domain_data->tgt_system_pwd,
      col 40, ds_str, row + 1,
      ds_str = "Priv User:", col 2, ds_str,
      ds_str = ddr_domain_data->tgt_priv, col 40, ds_str,
      row + 1, ds_str = "Priv Password:", col 2,
      ds_str, ds_str = ddr_domain_data->tgt_priv_pwd, col 40,
      ds_str, row + 1, ds_str = "ManageAccount User:",
      col 2, ds_str, ds_str = ddr_domain_data->tgt_mng,
      col 40, ds_str, row + 1,
      ds_str = "ManageAccount Password:", col 2, ds_str,
      ds_str = ddr_domain_data->tgt_mng_pwd, col 40, ds_str,
      row + 1, ds_str = "Sec User File Name:", col 2,
      ds_str, ds_str = ddr_domain_data->tgt_sec_user_name, col 40,
      ds_str, row + 1, ds_str = "Local User Name:",
      col 2, ds_str, ds_str = ddr_domain_data->tgt_local_user_name,
      col 40, ds_str, row + 1,
      ds_str = "Authorize Server ID:", col 2, ds_str,
      ds_str = build(ddr_domain_data->tgt_auth_server_id), col 40, ds_str,
      row + 1, ds_str = "Authorize Server Description:", col 2,
      ds_str, ds_str = ddr_domain_data->tgt_auth_server_desc, col 40,
      ds_str, row + 1, ds_str = "SCP Server ID:",
      col 2, ds_str, ds_str = build(ddr_domain_data->tgt_scp_server_id),
      col 40, ds_str, row + 1,
      ds_str = "SCP Server Description:", col 2, ds_str,
      ds_str = ddr_domain_data->tgt_scp_server_desc, col 40, ds_str,
      row + 1, ds_str = "TDB Server Master ID:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->tgt_tdb_server_master_id,0,"NOT FOUND",build(
        ddr_domain_data->tgt_tdb_server_master_id)), col 40,
      ds_str, row + 1, ds_str = "TDB Server Master Description:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->tgt_tdb_server_master_id,0,"NOT FOUND",
       ddr_domain_data->tgt_tdb_server_master_desc),
      col 40, ds_str, row + 1,
      ds_str = "TDB Server Slave ID:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->tgt_tdb_server_slave_id,0,"NOT FOUND",build(ddr_domain_data
        ->tgt_tdb_server_slave_id)), col 40, ds_str,
      row + 1, ds_str = "TDB Server Slave Description:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->tgt_tdb_server_slave_id,0,"NOT FOUND",
       ddr_domain_data->tgt_tdb_server_slave_desc), col 40,
      ds_str, row + 1, ds_str = "Security Server Master ID:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->tgt_sec_server_master_id,0,"NOT FOUND",build(
        ddr_domain_data->tgt_sec_server_master_id)),
      col 40, ds_str, row + 1,
      ds_str = "Security Server Master Description:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->tgt_sec_server_master_id,0,"NOT FOUND",ddr_domain_data->
       tgt_sec_server_master_desc), col 40, ds_str,
      row + 1, ds_str = "Security Server Slave ID:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->tgt_sec_server_slave_id,0,"NOT FOUND",build(
        ddr_domain_data->tgt_sec_server_slave_id)), col 40,
      ds_str, row + 1, ds_str = "Security Server Slave Description:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->tgt_sec_server_slave_id,0,"NOT FOUND",
       ddr_domain_data->tgt_sec_server_slave_desc),
      col 40, ds_str, row + 1,
      ds_str = "WAS Security Architecture Enabled:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->tgt_was_arch_ind,1,"YES","NO"), col 40, ds_str,
      row + 1, ds_str = "Target Passwords Preserved Count:", col 2,
      ds_str, ds_str = evaluate(ddr_domain_data->tgt_preserve_pwds_cnt,0,"0",build(ddr_domain_data->
        tgt_preserve_pwds_cnt)), col 40,
      ds_str, row + 1, ds_str = "Offline Dictionary Enabled:",
      col 2, ds_str, ds_str = evaluate(ddr_domain_data->offline_dict_ind,1,"YES","NO"),
      col 40, ds_str, row + 1,
      ds_str = "Domain Name:", col 2, ds_str,
      col 40, ddr_domain_data->tgt_domain_name, row + 1,
      ds_str = "Application Node Type:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->tgt_node_flag,1,"Single Target Node",2,"Primary Target Node",
       "Secondary Target Node"), col 40, ds_str,
      row + 1, ds_str = "Application Node(s):", col 2,
      ds_str
      FOR (ds_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
        col 40, ddr_domain_data->tgt_nodes[ds_cnt].node_name, row + 1
      ENDFOR
      IF (ds_tar_errors_ind > 0)
       row + 1, ds_str = concat(
        "** TAR file(s) were generated with invalid user/group id warnings while gathering: ",
        ds_tar_errors_list), col 2,
       ds_str, row + 1
      ENDIF
      ds_str = "LDAP Enabled:", col 2, ds_str,
      ds_str = evaluate(ddr_domain_data->tgt_ldap_ind,1,"YES","NO"), col 40, ds_str,
      row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     formfeed = none, maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dm_err->eproc = concat("Skipping display of Data Collection Summary Report (",ds_rpt_file,")"
     )
    CALL disp_msg("",dm_err->logfile,0)
    IF ((drer_email_list->email_cnt > 0))
     SET drer_email_det->msgtype = "ACTIONREQ"
     SET drer_email_det->status = "REPORT"
     SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
     SET drer_email_det->step = "DATA COLLECTION SUMMARY REPORT"
     SET drer_email_det->email_level = 1
     SET drer_email_det->logfile = dm_err->logfile
     SET drer_email_det->err_ind = dm_err->err_ind
     SET drer_email_det->eproc = dm_err->eproc
     SET drer_email_det->emsg = dm_err->emsg
     SET drer_email_det->user_action = dm_err->user_action
     SET drer_email_det->attachment = ds_rpt_file
     CALL drer_add_body_text(concat("DATA COLLECTION SUMMARY REPORT was generated at ",format(
        drer_email_det->status_dt_tm,";;q")),1)
     CALL drer_add_body_text(concat("User Action : Please review the report to ensure ",
       "all the data has been collected."),0)
     CALL drer_add_body_text(concat("Report file name : ",trim(ds_rpt_file,3)),0)
     IF (drer_compose_email(null)=1)
      CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
       email_level)
     ENDIF
     CALL drer_reset_pre_err(null)
    ENDIF
   ELSE
    FREE DEFINE rtl2
    DEFINE rtl2 "ds_rpt_file_logical"
    SELECT INTO mine
     t.line
     FROM rtl2t t
     DETAIL
      col 0, t.line, row + 1
     FOOT REPORT
      row + 0
     WITH nocounter, maxcol = 5000
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_env_reg(dger_src_ind,dger_tgt_ind,dger_type,dger_current_ind)
   DECLARE dger_cmd_file = vc WITH protect, noconstant("")
   DECLARE dger_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dger_cmd = vc WITH protect, noconstant("")
   DECLARE dger_cer_reg = vc WITH protect, noconstant(trim(logical("cer_reg")))
   DECLARE dger_env = vc WITH protect, noconstant(evaluate(dger_src_ind,1,ddr_domain_data->src_env,
     ddr_domain_data->tgt_env))
   DECLARE dger_suffix = vc WITH protect, noconstant(";*")
   DECLARE dger_file_full = vc WITH protect, noconstant("")
   DECLARE dger_file_trim = vc WITH protect, noconstant("")
   DECLARE dger_reg_file = vc WITH protect, noconstant("")
   DECLARE dger_str = vc WITH protect, noconstant("")
   DECLARE dger_domain = vc WITH protect, noconstant("")
   DECLARE dger_ret_val = vc WITH protect, noconstant("")
   DECLARE dger_reg_src_env = vc WITH protect, noconstant("")
   DECLARE dger_reg_tgt_env = vc WITH protect, noconstant("")
   DECLARE dger_reg_cur_env = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Export registry information."
   CALL disp_msg("",dm_err->logfile,0)
   IF (size(ddr_domain_data->src_env,1) > max_reg_env_len)
    SET dger_reg_src_env = substring(1,max_reg_env_len,ddr_domain_data->src_env)
   ELSE
    SET dger_reg_src_env = ddr_domain_data->src_env
   ENDIF
   IF (size(ddr_domain_data->tgt_env,1) > max_reg_env_len)
    SET dger_reg_tgt_env = substring(1,max_reg_env_len,ddr_domain_data->tgt_env)
   ELSE
    SET dger_reg_tgt_env = ddr_domain_data->tgt_env
   ENDIF
   IF (dger_current_ind=0)
    SET dger_file_trim = concat(evaluate(dger_src_ind,1,dger_reg_src_env,dger_reg_tgt_env),evaluate(
      dger_type,"DEFINITION","_env","SYSTEM","_sys",
      "SYSTEM_DEFINITIONS","_sysdef"))
    SET dger_file_full = concat(evaluate(dger_src_ind,1,ddr_domain_data->src_tmp_full_dir,
      ddr_domain_data->tgt_tmp_full_dir),dger_file_trim,".reg")
   ELSE
    IF (ddr_get_env_logical(dger_env)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Get domain name."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET dger_str = concat("\\environment\\",dger_env," Domain")
    IF (ddr_lreg_oper("GET",dger_str,dger_ret_val)=0)
     RETURN(0)
    ENDIF
    SET dger_domain = dger_ret_val
    IF (dger_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve domain name property for ",dger_env)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (size(dger_env,1) > max_reg_env_len)
     SET dger_reg_cur_env = substring(1,max_reg_env_len,dger_env)
    ELSE
     SET dger_reg_cur_env = dger_env
    ENDIF
    SET dger_file_trim = concat(dger_reg_cur_env,evaluate(dger_type,"DEFINITION","_c_env","SYSTEM",
      "_c_sys",
      "SYSTEM_DEFINITIONS","_c_sysdef","NODE_DOMAIN","_c_node_dom"))
    SET dger_file_full = concat(evaluate(dm2_sys_misc->cur_os,"AXP",trim(logical("ccluserdir")),
      concat(trim(logical("ccluserdir")),"/")),dger_file_trim,".reg")
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    SET dger_cer_reg = concat(dger_cer_reg,"/")
   ENDIF
   SET dger_reg_file = concat(dger_cer_reg,dger_file_trim,".reg ")
   SET dm_err->eproc = concat("Remove:",dger_reg_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dger_reg_file) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc
       ->cur_os,"AXP",concat(dger_reg_file,dger_suffix),dger_reg_file)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Remove:",dger_file_full)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dger_file_full) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc
       ->cur_os,"AXP",concat(dger_file_full,dger_suffix),dger_file_full)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (get_unique_file("get_env_reg",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dger_cmd_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to export REGISTRY info:",dger_cmd_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dger_cmd_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$mcr cer_exe:lregview"), row + 1
     ELSE
      CALL print("$cer_exe/lregview <<!"), row + 1
     ENDIF
     IF (dger_type="DEFINITION")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("copy \environment\",dger_env,"\definitions \\",dger_file_trim," -sub")),
       row + 1
      ELSE
       CALL print(concat("copy \\\system\\environment\\",dger_env,"\\definitions \\\",dger_file_trim,
        " -sub")), row + 1
      ENDIF
     ELSEIF (dger_type="SYSTEM_DEFINITIONS")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("copy \definitions\vmsalpha\environment \\",dger_file_trim," -sub")), row +
       1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       CALL print(concat("copy \\\system\\definitions\\hpuxia64\\environment \\\",dger_file_trim,
        " -sub")), row + 1
      ELSEIF ((dm2_sys_misc->cur_os="AIX"))
       CALL print(concat("copy \\\system\\definitions\\aixrs6000\\environment \\\",dger_file_trim,
        " -sub")), row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       CALL print(concat("copy \\\system\\definitions\\linuxx86-64\\environment \\\",dger_file_trim,
        " -sub")), row + 1
      ENDIF
     ELSEIF (dger_type="NODE_DOMAIN")
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("copy \node\",trim(curnode),"\domain\",trim(dger_domain)," \\",
        dger_file_trim," -sub")), row + 1
      ELSE
       CALL print(concat("copy \\\system\\node\\",trim(curnode),"\\domain\\",trim(dger_domain)," \\\",
        dger_file_trim," -sub")), row + 1
      ENDIF
     ELSE
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("copy \\system \\",dger_file_trim," -sub")), row + 1
      ELSE
       CALL print(concat("copy \\\system \\\",dger_file_trim," -sub")), row + 1
      ENDIF
     ENDIF
     CALL print("exit")
     IF ((dm2_sys_misc->cur_os != "AXP"))
      row + 1,
      CALL print("!"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Export REGISTRY info to ",dger_reg_file)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dger_cmd = concat("@",dger_cmd_file)
   ELSE
    SET dger_cmd = concat(". $CCLUSERDIR/",dger_cmd_file)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(dger_cmd)=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (((findstring("bad syntax",dm_err->errtext,1,1) > 0) OR (findstring("key not found",dm_err->
    errtext,1,1) > 0)) )
    SET dm_err->emsg = concat("Error exporting REGISTRY:",dger_cmd)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Copy REGISTRY info to ",dger_file_full)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dger_cmd = concat(evaluate(dm2_sys_misc->cur_os,"AXP","backup/new ","cp -p "),dger_cer_reg,
    dger_file_trim,".reg ",dger_file_full)
   IF (dm2_push_dcl(dger_cmd)=0)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dger_file_full)=0)
    SET dm_err->emsg = concat("Error copying Registry keys. Registry copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dger_current_ind=0)
    IF (ddr_get_file_date(dger_file_full,dger_file_date)=0)
     RETURN(0)
    ENDIF
    IF (dger_type="DEFINITION")
     IF (dger_src_ind=1)
      SET ddr_domain_data->src_env_reg_ts = dger_file_date
      SET ddr_domain_data->src_env_reg_fnd = 1
     ELSE
      SET ddr_domain_data->tgt_env_reg_ts = dger_file_date
      SET ddr_domain_data->tgt_env_reg_fnd = 1
     ENDIF
    ELSEIF (dger_type="SYSTEM_DEFINITIONS")
     IF (dger_src_ind=1)
      SET ddr_domain_data->src_sysdef_reg_ts = dger_file_date
      SET ddr_domain_data->src_sysdef_reg_fnd = 1
     ELSE
      SET ddr_domain_data->tgt_sysdef_reg_ts = dger_file_date
      SET ddr_domain_data->tgt_sysdef_reg_fnd = 1
     ENDIF
    ELSE
     SET ddr_domain_data->tgt_sys_reg_ts = dger_file_date
     SET ddr_domain_data->tgt_sys_reg_fnd = 1
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_invalid_tbls(dgit_src_ind,dgit_tgt_ind,dgit_prompt_only)
   DECLARE dgit_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgit_dmpfile = vc WITH protect, noconstant("")
   DECLARE dgit_cmd_file = vc WITH protect, noconstant("")
   DECLARE dgit_cmd = vc WITH protect, noconstant("")
   DECLARE dgit_dir = vc WITH protect, noconstant("")
   DECLARE dgit_user_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgit_ndx = i4 WITH protect, noconstant(0)
   DECLARE dgit_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgit_log_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgit_error_ind = i2 WITH protect, noconstant(0)
   DECLARE dgit_rpt_errors = i4 WITH protect, noconstant(0)
   DECLARE dgit_accept = vc WITH proteect, noconstant("")
   DECLARE dgit_str = vc WITH protect, noconstant("")
   DECLARE dgit_rpt_file = vc WITH protect, noconstant("")
   DECLARE dgit_confirm_ret = i2 WITH protect, noconstant(0)
   DECLARE dgit_continue = i2 WITH protect, noconstant(1)
   DECLARE dgit_mng_cust_usrs_ind = i2 WITH protect, noconstant(1)
   IF (dgit_prompt_only=0)
    SET dgit_dir = evaluate(dgit_src_ind,1,ddr_domain_data->src_tmp_full_dir,ddr_domain_data->
     tgt_tmp_full_dir)
    SET dgit_dmpfile = evaluate(dm2_sys_misc->cur_os,"AXP",concat(dgit_dir,ddr_domain_data->
      exp_parfile_prefix,"*.dmp;*"),concat(dgit_dir,ddr_domain_data->exp_parfile_prefix,"*.dmp"))
    SET dm_err->eproc = concat("Remove:",dgit_dmpfile)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os != "LNX"))
     IF (dm2_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ELSE
     IF (ddr_lnx_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat("rm ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
    SET dgit_dir = evaluate(dgit_src_ind,1,ddr_domain_data->src_tmp_full_dir,ddr_domain_data->
     tgt_tmp_full_dir)
    SET dgit_dmpfile = evaluate(dm2_sys_misc->cur_os,"AXP",concat(dgit_dir,ddr_domain_data->
      exp_parfile_prefix,"*.par;*"),concat(dgit_dir,ddr_domain_data->exp_parfile_prefix,"*.par"))
    SET dm_err->eproc = concat("Remove:",dgit_dmpfile)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os != "LNX"))
     IF (dm2_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ELSE
     IF (ddr_lnx_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat("rm ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
    SET dgit_dir = evaluate(dgit_src_ind,1,ddr_domain_data->src_tmp_full_dir,ddr_domain_data->
     tgt_tmp_full_dir)
    SET dgit_dmpfile = evaluate(dm2_sys_misc->cur_os,"AXP",concat(dgit_dir,ddr_domain_data->
      exp_parfile_prefix,"*.dat;*"),concat(dgit_dir,ddr_domain_data->exp_parfile_prefix,"*.dat"))
    SET dm_err->eproc = concat("Remove:",dgit_dmpfile)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os != "LNX"))
     IF (dm2_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ELSE
     IF (ddr_lnx_findfile(concat(dgit_dmpfile)) > 0)
      IF (dm2_push_dcl(concat("rm ",dgit_dmpfile))=0)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   IF (dgit_prompt_only=1
    AND validate(drrr_responsefile_in_use,0)=1)
    SET drr_cleanup_drop_list->list_loaded_ind = 0
    EXECUTE dm2_invalid_tables_rpt
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
    SET ddr_domain_data->get_invalid_tables = 0
    RETURN(1)
   ENDIF
   IF (dgit_prompt_only=1)
    WHILE (dgit_continue=1)
      SET drr_cleanup_drop_list->list_loaded_ind = 0
      EXECUTE dm2_invalid_tables_rpt
      IF ((dm_err->err_ind > 0))
       RETURN(0)
      ENDIF
      IF ((drr_cleanup_drop_list->cnt > 0))
       IF (drr_confirm_invalid_tables(dgit_mng_cust_usrs_ind,dgit_confirm_ret)=0)
        RETURN(0)
       ENDIF
       CASE (dgit_confirm_ret)
        OF 0:
         SET dm_err->err_ind = 1
         SET dm_err->emsg = "User Chose to Quit from Invalid Tables Report Confirmation Prompt"
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        OF 1:
         SET dgit_continue = 0
        OF 2:
         EXECUTE dm2_manage_custom_users
         IF ((dm_err->err_ind > 0))
          RETURN(0)
         ENDIF
       ENDCASE
      ELSE
       SET dgit_continue = 0
      ENDIF
    ENDWHILE
    IF ((drr_cleanup_drop_list->list_loaded_ind=0))
     IF (drr_get_invalid_tables_list(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((drr_cleanup_drop_list->cnt > 0)
     AND (ddr_domain_data->standalone_expimp_mode=0))
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,5,131)
     CALL text(3,4,"Would you like to have the invalid tables exported for you? (Y)es or (N)o :")
     CALL accept(3,84,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="N")
      SET ddr_domain_data->get_invalid_tables = 0
      RETURN(1)
     ELSE
      SET ddr_domain_data->get_invalid_tables = 1
      RETURN(1)
     ENDIF
    ELSEIF ((drr_cleanup_drop_list->cnt > 0))
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,5,131)
     CALL text(3,4,concat("If you wish to take an export of any of the invalid tables, ",
       "exports should be taken at this time."))
     CALL text(4,4,"Press enter to continue.")
     CALL accept(4,30,"p;cu"," "
      WHERE curaccept IN (" "))
     CALL clear(1,1)
     SET message = nowindow
     SET ddr_domain_data->get_invalid_tables = 0
     RETURN(1)
    ELSE
     SET ddr_domain_data->get_invalid_tables = 0
     RETURN(1)
    ENDIF
   ENDIF
   SET dm_err->eproc = "User elected to export invalid tables."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   FOR (dgit_cnt = 1 TO drr_cleanup_drop_list->cnt)
     IF ((ddr_tbl_list->owner_cnt > 0))
      IF (locateval(dgit_ndx,1,size(ddr_tbl_list->owner,5),drr_cleanup_drop_list->qual[dgit_cnt].
       owner,ddr_tbl_list->owner[dgit_ndx].owner_name) > 0)
       SET dgit_user_cnt = dgit_ndx
      ELSE
       SET ddr_tbl_list->owner_cnt = (ddr_tbl_list->owner_cnt+ 1)
       SET dgit_user_cnt = ddr_tbl_list->owner_cnt
       SET stat = alterlist(ddr_tbl_list->owner,ddr_tbl_list->owner_cnt)
       SET ddr_tbl_list->owner[ddr_tbl_list->owner_cnt].owner_name = drr_cleanup_drop_list->qual[
       dgit_cnt].owner
      ENDIF
     ELSE
      SET ddr_tbl_list->owner_cnt = (ddr_tbl_list->owner_cnt+ 1)
      SET dgit_user_cnt = ddr_tbl_list->owner_cnt
      SET stat = alterlist(ddr_tbl_list->owner,ddr_tbl_list->owner_cnt)
      SET ddr_tbl_list->owner[ddr_tbl_list->owner_cnt].owner_name = drr_cleanup_drop_list->qual[
      dgit_cnt].owner
     ENDIF
     SET ddr_tbl_list->owner[dgit_user_cnt].tbl_cnt = (ddr_tbl_list->owner[dgit_user_cnt].tbl_cnt+ 1)
     SET stat = alterlist(ddr_tbl_list->owner[dgit_user_cnt].tbl,ddr_tbl_list->owner[dgit_user_cnt].
      tbl_cnt)
     IF (mod(ddr_tbl_list->owner[dgit_user_cnt].tbl_cnt,400)=1)
      SET ddr_tbl_list->owner[dgit_user_cnt].par_file_cnt = (ddr_tbl_list->owner[dgit_user_cnt].
      par_file_cnt+ 1)
     ENDIF
     SET ddr_tbl_list->owner[dgit_user_cnt].tbl[ddr_tbl_list->owner[dgit_user_cnt].tbl_cnt].tbl_name
      = drr_cleanup_drop_list->qual[dgit_cnt].table_name
     SET ddr_tbl_list->owner[dgit_user_cnt].tbl[ddr_tbl_list->owner[dgit_user_cnt].tbl_cnt].par_group
      = ddr_tbl_list->owner[dgit_user_cnt].par_file_cnt
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_tbl_list)
   ENDIF
   IF (ddr_build_parfile(dgit_dir,ddr_domain_data->exp_parfile_prefix,ddr_domain_data->
    imp_parfile_prefix)=0)
    RETURN(0)
   ENDIF
   IF (ddr_build_expimp_cmds(dgit_src_ind,dgit_tgt_ind,dgit_dir,"IMP",dgit_cmd_file)=0)
    RETURN(0)
   ENDIF
   IF (ddr_build_expimp_cmds(dgit_src_ind,dgit_tgt_ind,dgit_dir,"EXP",dgit_cmd_file)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Executing export file:",dgit_cmd_file)
   CALL disp_msg("",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgit_cmd = concat("@",dgit_cmd_file)
   ELSE
    SET dgit_cmd = concat(". ",dgit_cmd_file)
   ENDIF
   IF (dm2_push_dcl(dgit_cmd)=0)
    RETURN(0)
   ENDIF
   FOR (dgit_log_cnt = 1 TO size(ddr_tbl_list->logs,5))
     SET dm_err->eproc = concat("Checking logfile for errors:",ddr_tbl_list->logs[dgit_log_cnt].
      log_name)
     CALL disp_msg("",dm_err->logfile,0)
     IF (drr_check_log_for_errors(1.0,ddr_tbl_list->logs[dgit_log_cnt].log_name,0,dgit_error_ind)=0)
      RETURN(0)
     ENDIF
     IF (dgit_error_ind > 0)
      SET dgit_rpt_errors = 1
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(drr_errors_encountered)
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_tbl_list)
    CALL echorecord(drr_errors_encountered)
   ENDIF
   IF (dgit_rpt_errors=1)
    SET dm_err->eproc = "Report errors to User"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    WHILE ( NOT (dgit_accept IN ("C", "Q")))
      SET dm_err->eproc = "Report errors to User"
      SET dgit_accept = ""
      SET message = window
      SET width = 132
      CALL clear(1,1)
      CALL box(1,1,10,131)
      CALL text(3,4,"Errors occurred during Export:")
      CALL text(4,4,'  Enter "V" to view errors. ')
      CALL text(5,4,'  Enter "C" to continue and ignore errors. ')
      CALL text(6,4,'  Enter "Q" to quit and exit process. ')
      CALL accept(3,37,"A;cu"," "
       WHERE curaccept IN ("C", "Q", "V"))
      SET dgit_accept = curaccept
      CALL clear(1,1)
      SET message = nowindow
      IF (dgit_accept="Q")
       SET dm_err->emsg = "User elected to Quit after encountering Export errors."
       SET dm_err->err_ind = 1
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
      IF (dgit_accept="V")
       IF (get_unique_file("ddr_exp_err",".rpt")=0)
        RETURN(0)
       ELSE
        SET dgit_rpt_file = concat("ccluserdir:",dm_err->unique_fname)
       ENDIF
       SET logical dgit_rpt_file_logical dgit_rpt_file
       SELECT INTO "dgit_rpt_file_logical"
        HEAD REPORT
         col 0, "EXPORT ERROR REPORT", row + 3,
         dgit_str = concat("If error(s) are ignorable, add error(s) to ",
          "dm2_ignorable_errors.dat file located in ccluserdir."), col 0, dgit_str,
         row + 2, col 0, "Example: EXP-12345 would be added as 1 line in dm2_ignorable_errors.dat",
         row + 1
        DETAIL
         FOR (dgit_log_cnt = 1 TO drr_errors_encountered->cmd_cnt)
           row + 2, col 0, "Errors recorded in ",
           drr_errors_encountered->qual[dgit_log_cnt].logfile_name, row + 2, col 0,
           "_____________________________________________________________________________", row + 1
           FOR (dgit_cnt = 1 TO drr_errors_encountered->qual[dgit_log_cnt].error_cnt)
             dgit_str = concat(drr_errors_encountered->qual[dgit_log_cnt].qual[dgit_cnt].error,":",
              drr_errors_encountered->qual[dgit_log_cnt].qual[dgit_cnt].error_desc), col 0, dgit_str,
             row + 1
           ENDFOR
         ENDFOR
        WITH nocounter, formfeed = none, maxcol = 5000,
         format = variable
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       FREE DEFINE rtl2
       DEFINE rtl2 "dgit_rpt_file_logical"
       SELECT INTO mine
        t.line
        FROM rtl2t t
        DETAIL
         col 0, t.line, row + 1
        FOOT REPORT
         row + 0
        WITH nocounter, maxcol = 5000
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
    ENDWHILE
    CALL clear(1,1)
    SET message = nowindow
   ENDIF
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dgit_dmpfile)=0)
     SET dm_err->emsg = concat("Error exporting invalid tables. Dumpfile does not exist:",
      dgit_dmpfile)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dgit_dmpfile)=0)
     SET dm_err->emsg = concat("Error exporting invalid tables. Dumpfile does not exist:",
      dgit_dmpfile)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET dgit_dmpfile = concat(dgit_dir,ddr_domain_data->exp_parfile_prefix,"*.dmp")
   SET dgit_file_date = 0.0
   IF (ddr_get_file_date(dgit_dmpfile,dgit_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dgit_src_ind=1)
    SET ddr_domain_data->src_invalid_tbls_ts = dgit_file_date
    SET ddr_domain_data->src_invalid_tbls_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_invalid_tbls_ts = dgit_file_date
    SET ddr_domain_data->tgt_invalid_tbls_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_sec_user(dgsu_src_ind,dgsu_tgt_ind,dgsu_is_primary)
   DECLARE dgsu_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgsu_user_file = vc WITH protect, noconstant(concat(evaluate(dgsu_src_ind,1,
      ddr_domain_data->src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir),evaluate(dgsu_src_ind,1,
      ddr_domain_data->src_env,ddr_domain_data->tgt_env),"_sec_user.dat"))
   DECLARE dgsu_str = vc WITH protect, noconstant("")
   DECLARE dgsu_useri_file = vc WITH protect, noconstant("")
   DECLARE dgsu_cer_config = vc WITH protect, noconstant("")
   IF (dgsu_is_primary=1)
    SET dgsu_user_file = concat(ddr_domain_data->tgt_tmp_full_dir,"primary_sec_user.dat")
   ENDIF
   SET dgsu_useri_file = replace(dgsu_user_file,".dat",".idx")
   SET dm_err->eproc = "Copy cer_config sec user file to temporary directory."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(dgsu_user_file) > 0)
    SET dm_err->eproc = concat("Remove:",dgsu_user_file)
    CALL disp_msg("",dm_err->logfile,0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgsu_user_file))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (dm2_findfile(dgsu_useri_file) > 0)
     SET dm_err->eproc = concat("Remove:",dgsu_useri_file)
     CALL disp_msg("",dm_err->logfile,0)
     IF (dm2_push_dcl(concat("rm ",dgsu_useri_file))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF (ddr_get_from_dir(dgsu_src_ind,"cer_config",dgsu_cer_config)=0)
    RETURN(0)
   ENDIF
   IF (dgsu_src_ind=1)
    SET dgsu_str = "SOURCE"
   ELSE
    IF (dgsu_is_primary=1)
     SET dgsu_str = "PRIMARY TARGET"
    ELSE
     SET dgsu_str = "TARGET"
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Obtain ",dgsu_str," SEC USER copy.")
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","backup/ignore=interlock ","cp")," ",
     dgsu_cer_config,evaluate(dgsu_src_ind,1,ddr_domain_data->src_sec_user_name,ddr_domain_data->
      tgt_sec_user_name),".dat ",
     dgsu_user_file))=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","copy ","cp")," ",dgsu_cer_config,
      evaluate(dgsu_src_ind,1,ddr_domain_data->src_sec_user_name,ddr_domain_data->tgt_sec_user_name),
      ".idx ",
      dgsu_useri_file))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dm2_findfile(dgsu_user_file)=0)
    SET dm_err->emsg = concat("Error copying ",dgsu_str,
     " sec user. The sec user file does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (dm2_findfile(dgsu_useri_file)=0)
     SET dm_err->emsg = concat("Error copying ",dgsu_str,
      " sec user. The sec user index file does not exist.")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_file_date(dgsu_user_file,dgsu_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dgsu_src_ind=1)
    SET ddr_domain_data->src_sec_user_ts = dgsu_file_date
    SET ddr_domain_data->src_sec_user_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_sec_user_ts = dgsu_file_date
    SET ddr_domain_data->tgt_sec_user_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_nodes(dgn_src_ind,dgn_tgt_ind)
   DECLARE dgn_file = vc WITH protect, noconstant("")
   DECLARE dgn_cmd = vc WITH protect, noconstant("")
   DECLARE dgn_found_start = i2 WITH protect, noconstant(0)
   DECLARE dgn_errfile = vc WITH protect, noconstant("")
   DECLARE dgn_found_curnode = i2 WITH protect, noconstant(0)
   DECLARE dgn_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgn_ndx = i4 WITH protect, noconstant(0)
   IF (get_unique_file("get_nodes",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dgn_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to obtain listing of nodes from SCP:",dgn_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dgn_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$mcr cer_exe:scpview "), row + 1,
      CALL print("$DECK"),
      row + 1
     ELSE
      IF (dgn_src_ind=1)
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
      ELSE
       CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1
      ENDIF
      CALL print("$cer_exe/scpview  <<!"), row + 1
     ENDIF
     IF (dgn_src_ind=1)
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
     ELSE
      CALL print(ddr_domain_data->tgt_mng), row + 1,
      CALL print(ddr_domain_data->tgt_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->tgt_mng_pwd), row + 1
      ELSE
       CALL print("$tgt_mng_pwd"), row + 1
      ENDIF
     ENDIF
     CALL print("nodes"), row + 1,
     CALL print("exit"),
     row + 1
     IF ((dm2_sys_misc->cur_os != "AXP"))
      CALL print("!"), row + 1
     ELSE
      CALL print("$EOD"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Obtain node listing from SCP."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgn_cmd = concat("@",dgn_file)
   ELSE
    SET dgn_cmd = concat(". $CCLUSERDIR/",dgn_file)
   ENDIF
   IF (dm2_push_dcl(dgn_cmd)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (((findstring("bad command",dm_err->errtext,1,1) > 0) OR (findstring(
    "node not offering services",dm_err->errtext,1,1) > 0)) )
    SET dm_err->emsg = concat("Error exporting server definitions:",dgn_cmd)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgn_errfile = dm_err->errfile
   SET dm_err->eproc = concat("Parse node listing from:",dgn_errfile)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET logical dgn_data_file dgn_errfile
   FREE DEFINE rtl
   DEFINE rtl "dgn_data_file"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     IF ((dm_err->debug_flag > 0))
      CALL echo(t.line)
     ENDIF
     IF (dgn_found_start=1)
      IF (dgn_src_ind=1)
       ddr_domain_data->src_nodes_cnt = (ddr_domain_data->src_nodes_cnt+ 1), stat = alterlist(
        ddr_domain_data->src_nodes,ddr_domain_data->src_nodes_cnt), ddr_domain_data->src_nodes[
       ddr_domain_data->src_nodes_cnt].node_name = cnvtlower(trim(t.line,3))
      ELSE
       ddr_domain_data->tgt_nodes_cnt = (ddr_domain_data->tgt_nodes_cnt+ 1), stat = alterlist(
        ddr_domain_data->tgt_nodes,ddr_domain_data->tgt_nodes_cnt), ddr_domain_data->tgt_nodes[
       ddr_domain_data->tgt_nodes_cnt].node_name = cnvtlower(trim(t.line,3))
      ENDIF
      IF (cnvtlower(trim(t.line,3))=trim(cnvtlower(curnode)))
       dgn_found_curnode = 1
      ENDIF
     ENDIF
     IF (findstring("----",t.line,1,1) > 0)
      dgn_found_start = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_domain_data)
   ENDIF
   IF (((dgn_src_ind=1
    AND (ddr_domain_data->src_nodes_cnt=0)) OR (dgn_tgt_ind=1
    AND (ddr_domain_data->tgt_nodes_cnt=0))) )
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Unable to obtaing listing of nodes from SCP"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgn_found_curnode=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Current node,",trim(curnode)," not found via SCP nodes command.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgn_cnt = evaluate(dgn_src_ind,1,ddr_domain_data->src_nodes_cnt,ddr_domain_data->tgt_nodes_cnt
    )
   IF (dgn_cnt > 1)
    FREE RECORD dgn_work
    RECORD dgn_work(
      1 nodes_cnt = i4
      1 nodes[*]
        2 keep = i2
        2 node_name = vc
    )
    IF (dgn_src_ind=1)
     SET dgn_work->nodes_cnt = ddr_domain_data->src_nodes_cnt
    ELSE
     SET dgn_work->nodes_cnt = ddr_domain_data->tgt_nodes_cnt
    ENDIF
    SET stat = alterlist(dgn_work->nodes,dgn_work->nodes_cnt)
    FOR (dgn_ndx = 1 TO dgn_work->nodes_cnt)
      IF (dgn_src_ind=1)
       SET dgn_work->nodes[dgn_ndx].node_name = ddr_domain_data->src_nodes[dgn_ndx].node_name
       SET ddr_domain_data->src_nodes[dgn_ndx].node_name = ""
      ELSE
       SET dgn_work->nodes[dgn_ndx].node_name = ddr_domain_data->tgt_nodes[dgn_ndx].node_name
       SET ddr_domain_data->tgt_nodes[dgn_ndx].node_name = ""
      ENDIF
    ENDFOR
    FOR (dgn_ndx = 1 TO dgn_work->nodes_cnt)
      IF ((dgn_work->nodes[dgn_ndx].node_name=cnvtlower(trim(curnode))))
       IF (dgn_src_ind=1)
        SET ddr_domain_data->src_nodes[1].node_name = dgn_work->nodes[dgn_ndx].node_name
       ELSE
        SET ddr_domain_data->tgt_nodes[1].node_name = dgn_work->nodes[dgn_ndx].node_name
       ENDIF
      ENDIF
    ENDFOR
    SET dgn_cnt = 1
    FOR (dgn_ndx = 1 TO dgn_work->nodes_cnt)
      IF ((dgn_work->nodes[dgn_ndx].node_name != cnvtlower(trim(curnode))))
       SET dgn_cnt = (dgn_cnt+ 1)
       IF (dgn_src_ind=1)
        SET ddr_domain_data->src_nodes[dgn_cnt].node_name = dgn_work->nodes[dgn_ndx].node_name
       ELSE
        SET ddr_domain_data->tgt_nodes[dgn_cnt].node_name = dgn_work->nodes[dgn_ndx].node_name
       ENDIF
      ENDIF
    ENDFOR
    FREE RECORD dgn_work
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (dgn_src_ind=1)
     IF ((ddr_domain_data->src_nodes_cnt=drrr_misc_data->src_app_node_cnt))
      FOR (dgn_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
        IF (locateval(dgn_ndx,1,drrr_misc_data->src_app_node_cnt,ddr_domain_data->src_nodes[dgn_cnt].
         node_name,drrr_misc_data->src_app_nodes[dgn_ndx].node_name)=0)
         SET dm_err->eproc = concat(
          "Validating Source node list retrieved from scp to node list specified in response file.")
         SET dm_err->emsg = concat("SCP Source node (",trim(ddr_domain_data->src_nodes[dgn_cnt].
           node_name,3),") not found in list specified in response file.")
         SET dm_err->err_ind = 1
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
      ENDFOR
     ELSE
      SET dm_err->eproc = concat(
       "Validating Source node list retrieved from scp to node list specified in response file.")
      SET dm_err->emsg = concat("SCP Source node list count (",trim(cnvtstring(ddr_domain_data->
         src_nodes_cnt),3),") does not match node count in resposne file (",trim(cnvtstring(
         drrr_misc_data->src_app_node_cnt),3),").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ((ddr_domain_data->tgt_nodes_cnt=drrr_misc_data->tgt_app_node_cnt))
      FOR (dgn_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
        IF (locateval(dgn_ndx,1,drrr_misc_data->tgt_app_node_cnt,ddr_domain_data->tgt_nodes[dgn_cnt].
         node_name,drrr_misc_data->tgt_app_nodes[dgn_ndx].node_name)=0)
         SET dm_err->eproc = concat(
          "Validating Target node list retrieved from scp to node list specified in response file.")
         SET dm_err->emsg = concat("SCP Target node (",trim(ddr_domain_data->tgt_nodes[dgn_cnt].
           node_name,3),") not found in list specified in response file.")
         SET dm_err->err_ind = 1
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
      ENDFOR
     ELSE
      SET dm_err->eproc = concat(
       "Validating Target node list retrieved from scp to node list specified in response file.")
      SET dm_err->emsg = concat("SCP Target node list count (",trim(cnvtstring(ddr_domain_data->
         tgt_nodes_cnt),3),") does not match node count in resposne file (",trim(cnvtstring(
         drrr_misc_data->tgt_app_node_cnt),3),").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_set_tgt_node_flag(null)
   DECLARE dstnf_srv_status = i2 WITH protect, noconstant(0)
   DECLARE dstnf_ok = i2 WITH protect, noconstant(1)
   DECLARE dstnf_accept = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Determine type of target node"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (validate(dm2_refresh_force_secondary,0)=1)
    SET ddr_domain_data->tgt_node_flag = 3
    RETURN(1)
   ENDIF
   IF ((ddr_domain_data->tgt_nodes_cnt=1))
    SET ddr_domain_data->tgt_node_flag = 1
   ELSEIF ((ddr_domain_data->tgt_nodes_cnt > 1))
    SET ddr_domain_data->tgt_node_flag = 3
    IF ((ddr_domain_data->tgt_tdb_server_master_id > 0))
     IF (ddr_get_srv_status(ddr_domain_data->tgt_tdb_server_master_id,ddr_domain_data->
      tgt_tdb_server_master_desc,dstnf_srv_status)=0)
      RETURN(0)
     ENDIF
     IF (dstnf_srv_status=1)
      IF ((ddr_domain_data->tgt_was_arch_ind=1))
       SET ddr_domain_data->tgt_node_flag = 2
      ELSE
       IF ((ddr_domain_data->tgt_sec_server_master_id > 0))
        IF (ddr_get_srv_status(ddr_domain_data->tgt_sec_server_master_id,ddr_domain_data->
         tgt_sec_server_master_desc,dstnf_srv_status)=0)
         RETURN(0)
        ENDIF
        IF (dstnf_srv_status=1)
         SET ddr_domain_data->tgt_node_flag = 2
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("tgt_node_flag = ",ddr_domain_data->tgt_node_flag))
    ENDIF
    IF ((ddr_domain_data->tgt_node_flag IN (1, 2)))
     IF ((drrr_rf_data->tgt_primary_app_node != trim(cnvtlower(curnode))))
      SET dm_err->eproc = concat(
       "Validating Target node flag based on server configuration and specified primary app ",
       "node specified in response file.")
      SET dm_err->emsg = concat(
       "Primary node detected, but current node does not match primary app node specified in ",
       "response file.")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ((drrr_rf_data->tgt_primary_app_node=trim(cnvtlower(curnode))))
      SET dm_err->eproc = concat(
       "Validating Target node flag based on server configuration and specified primary app ",
       "node specified in response file.")
      SET dm_err->emsg = concat(
       "Secondary node detected, but current node matches primary app node specified in ",
       "response file.")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    IF ((ddr_domain_data->tgt_node_flag IN (2, 3)))
     SET dm_err->eproc = "Node Type confirmation"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     WHILE (dstnf_ok=1)
       IF ((dm_err->debug_flag != 511))
        SET message = window
       ENDIF
       SET width = 132
       CALL clear(1,1)
       CALL box(1,1,22,131)
       CALL text(1,2,"APPLICATION NODE TYPE CONFIRMATION SCREEN ")
       IF ((ddr_domain_data->tgt_node_flag=2))
        CALL text(3,2,
         "It has been determined that this node is the PRIMARY NODE of a multi-node target")
       ELSEIF ((ddr_domain_data->tgt_node_flag=3))
        CALL text(3,2,
         "It has been determined that this node is the SECONDARY NODE of a multi-node target")
       ENDIF
       CALL text(5,2,"Is this information correct: (Y)es,(N)o,(Q)uit?")
       CALL accept(5,50,"A;cu"," "
        WHERE curaccept IN ("Y", "N", "Q"))
       SET dstnf_accept = curaccept
       IF (dstnf_accept="N")
        CALL text(6,2,concat("The current node will now be changed to ",evaluate(ddr_domain_data->
           tgt_node_flag,2,"SECONDARY","PRIMARY")))
        CALL text(7,2,"Are you sure?: (Y)es,(N)o")
        CALL accept(7,28,"A;cu"," "
         WHERE curaccept IN ("Y", "N"))
        IF (curaccept="Y")
         SET dstnf_ok = 0
         IF ((ddr_domain_data->tgt_node_flag=2))
          SET ddr_domain_data->tgt_node_flag = 3
         ELSEIF ((ddr_domain_data->tgt_node_flag=3))
          SET ddr_domain_data->tgt_node_flag = 2
         ENDIF
        ENDIF
       ELSEIF (dstnf_accept="Q")
        SET dstnf_ok = 0
        SET message = nowindow
        SET dm_err->emsg = "User elected to quit from Target Node Type Confirmation"
        SET dm_err->err_ind = 1
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ELSE
        SET dstnf_ok = 0
       ENDIF
     ENDWHILE
    ENDIF
    CALL clear(1,1)
    SET message = nowindow
   ENDIF
   IF ((ddr_domain_data->tgt_node_flag IN (1, 2)))
    IF ((ddr_domain_data->tgt_was_arch_ind=0))
     IF ((ddr_domain_data->tgt_sec_server_master_id=0))
      SET dm_err->eproc = "Validating Security Master Server on Target Node"
      SET dm_err->emsg = "Security Master Server does not exist on current target node"
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((ddr_domain_data->tgt_tdb_server_master_id=0))
     SET dm_err->eproc = "Validating Transaction Database Master Server on Target Node"
     SET dm_err->emsg = "Transaction Database Master Server does not exist on current target node"
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_srv_status(dgss_id,dgss_desc,dgss_srv_status)
   DECLARE dgss_file_name = vc WITH protect, noconstant("")
   DECLARE dgss_cmd = vc WITH protect, noconstant("")
   DECLARE dgss_inst_fnd = i2 WITH protect, noconstant(0)
   DECLARE dgss_id_str = vc WITH protect, noconstant("")
   DECLARE dgss_desc_str = vc WITH protect, noconstant("")
   SET dgss_id_str = trim(cnvtstring(dgss_id))
   SET dgss_desc_str = trim(cnvtlower(dgss_desc))
   SET dm_err->eproc = concat("Get server status for server: ",dgss_desc_str,"(id = ",dgss_id_str,")"
    )
   CALL disp_msg("",dm_err->logfile,0)
   SET dgss_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"server_status",evaluate(
     dm2_sys_misc->cur_os,"AXP",".com",".ksh"))
   IF (dm2_findfile(dgss_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgss_cmd = concat("del ",dgss_file_name,";*")
    ELSE
     SET dgss_cmd = concat("rm ",dgss_file_name)
    ENDIF
    IF (dm2_push_dcl(dgss_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to get server instance :",dgss_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgss_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!server_status.com"), row + 1,
      CALL print("$srv_fnd=0"),
      row + 1,
      CALL print("$srv_inst=0"), row + 1,
      CALL print("$stat_pos=0"), row + 1,
      CALL print("$id_pos=0"),
      row + 1,
      CALL print("$desc_pos=0"), row + 1,
      CALL print('$tgt_node = f$getsyi("nodename") '), row + 1, dgss_cmd = concat('$   if f$search("',
       ddr_domain_data->tgt_tmp_full_dir,'server_status.dat") .nes. "" then delete ',ddr_domain_data
       ->tgt_tmp_full_dir,"server_status.dat;*"),
      CALL print(dgss_cmd), row + 1,
      CALL print(concat("$   define/user_mode sys$output ",ddr_domain_data->tgt_tmp_full_dir,
       "server_status.dat")),
      row + 1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
      CALL print("$DECK"), row + 1,
      CALL print(ddr_domain_data->tgt_mng),
      row + 1,
      CALL print(ddr_domain_data->tgt_domain_name), row + 1,
      CALL print(ddr_domain_data->tgt_mng_pwd), row + 1,
      CALL print("find -inst -gt 0"),
      row + 1,
      CALL print("exit"), row + 1,
      CALL print("$EOD"), row + 1,
      CALL print(concat("$   open/read SERVER_LIST ",ddr_domain_data->tgt_tmp_full_dir,
       "server_status.dat")),
      row + 1,
      CALL print("$   READ_SERVER_LIST:"), row + 1,
      CALL print("$      read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record"), row + 1,
      CALL print('$      record = f$edit(record, "lowercase")'),
      row + 1,
      CALL print("$      length = f$length(record)"), row + 1,
      CALL print(concat('$      id_pos = f$locate("',dgss_id_str,'", record)')), row + 1,
      CALL print("$      if (id_pos .ne. length)"),
      row + 1,
      CALL print("$      then"), row + 1,
      CALL print(concat('$         desc_pos = f$locate("',dgss_desc_str,'", record)')), row + 1,
      CALL print("$         if (desc_pos .gt. 0) .and. (desc_pos .ne. length)"),
      row + 1,
      CALL print("$         then"), row + 1,
      CALL print("$            srv_inst = 1"), row + 1,
      CALL print("$         endif"),
      row + 1,
      CALL print("$      endif"), row + 1,
      CALL print("$!     write sys$output record "), row + 1,
      CALL print("$      if (srv_inst .eq. 0)"),
      row + 1,
      CALL print("$      then"), row + 1,
      CALL print("$         goto READ_SERVER_LIST "), row + 1,
      CALL print("$      endif"),
      row + 1,
      CALL print("$   END_READ_SERVER_LIST: "), row + 1,
      CALL print("$      close SERVER_LIST  "), row + 1,
      CALL print("$   if (srv_inst .eq. 0) "),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print('$      write sys$output "Server does not have an instance."'), row + 1,
      CALL print("$      exit 1"),
      row + 1,
      CALL print("$   else"), row + 1,
      CALL print('$      write sys$output "Server has an instance."'), row + 1,
      CALL print("$      exit 1"),
      row + 1,
      CALL print("$   endif"), row + 1
     ELSE
      CALL print("#!/usr/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("# server_status.ksh"), row + 1,
      CALL print("#"), row + 1,
      CALL print("srv_inst=0"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",ddr_domain_data->tgt_tmp_full_dir,
       "server_status.dat")),
      row + 1,
      CALL print(ddr_domain_data->tgt_mng), row + 1,
      CALL print(ddr_domain_data->tgt_domain_name), row + 1,
      CALL print("$tgt_mng_pwd"),
      row + 1,
      CALL print("find -inst -gt 0"), row + 1,
      CALL print("exit"), row + 1,
      CALL print("!"),
      row + 1, row + 1,
      CALL print(concat("   tr '[:upper:]' '[:lower:]' < ",ddr_domain_data->tgt_tmp_full_dir,
       'server_status.dat|grep "',dgss_id_str,'" |grep "',
       dgss_desc_str,'"')),
      row + 1, row + 1,
      CALL print("   if [[ $? -eq 0 ]]"),
      row + 1,
      CALL print("   then"), row + 1,
      CALL print("      srv_inst=1"), row + 1,
      CALL print("   fi"),
      row + 1, row + 1,
      CALL print("if [[ $srv_inst -eq 0 ]]"),
      row + 1,
      CALL print("then"), row + 1,
      CALL print('   echo "Server does not have an instance."'), row + 1,
      CALL print("fi"),
      row + 1, row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ",dgss_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgss_cmd = concat("@",dgss_file_name)
   ELSE
    SET dgss_cmd = concat("chmod 777 ",dgss_file_name)
    IF (dm2_push_dcl(dgss_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgss_cmd = concat(". ",dgss_file_name)
   ENDIF
   IF (dm2_push_dcl(dgss_cmd)=0)
    RETURN(0)
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (findstring("Server does not have an instance",dm_err->errtext,1,1) > 0)
     SET dgss_inst_fnd = 0
    ELSE
     SET dgss_inst_fnd = 1
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (dgss_inst_fnd=1)
    SET dgss_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"server_status",evaluate(
      dm2_sys_misc->cur_os,"AXP",".com",".ksh"))
    IF (dm2_findfile(dgss_file_name) > 0)
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgss_cmd = concat("del ",dgss_file_name,";*")
     ELSE
      SET dgss_cmd = concat("rm ",dgss_file_name)
     ENDIF
     IF (dm2_push_dcl(dgss_cmd)=0)
      RETURN(0)
     ENDIF
    ELSE
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Create file to get server status :",dgss_file_name)
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO value(dgss_file_name)
     FROM (dummyt t  WITH seq = 1)
     DETAIL
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print("$!server_status.com"), row + 1,
       CALL print("$srv_fnd=0"),
       row + 1,
       CALL print("$srv_pos=0"), row + 1,
       CALL print('$tgt_node = f$getsyi("nodename") '), row + 1, dgss_cmd = concat(
        '$   if f$search("',ddr_domain_data->tgt_tmp_full_dir,
        'server_status.dat") .nes. "" then delete ',ddr_domain_data->tgt_tmp_full_dir,
        "server_status.dat;*"),
       CALL print(dgss_cmd), row + 1,
       CALL print(concat("$   define/user_mode sys$output ",ddr_domain_data->tgt_tmp_full_dir,
        "server_status.dat")),
       row + 1,
       CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
       CALL print("$DECK"), row + 1,
       CALL print(ddr_domain_data->tgt_mng),
       row + 1,
       CALL print(ddr_domain_data->tgt_domain_name), row + 1,
       CALL print(ddr_domain_data->tgt_mng_pwd), row + 1,
       CALL print("server -state running"),
       row + 1,
       CALL print("exit"), row + 1,
       CALL print("$EOD"), row + 1,
       CALL print(concat("$   open/read SERVER_LIST ",ddr_domain_data->tgt_tmp_full_dir,
        "server_status.dat")),
       row + 1,
       CALL print("$   READ_SERVER_LIST:"), row + 1,
       CALL print("$      read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record"), row + 1,
       CALL print('$      record = f$edit(record, "lowercase")'),
       row + 1,
       CALL print("$      length = f$length(record)"), row + 1,
       CALL print(concat('$      srv_pos = f$locate("',dgss_desc_str,'", record)')), row + 1,
       CALL print("$      if (srv_pos .gt. 0) .and. (srv_pos .ne. length)"),
       row + 1,
       CALL print("$      then"), row + 1,
       CALL print("$            srv_fnd = 1"), row + 1,
       CALL print("$      endif"),
       row + 1,
       CALL print("$!     write sys$output record "), row + 1,
       CALL print("$      if (srv_fnd .eq. 0)"), row + 1,
       CALL print("$      then"),
       row + 1,
       CALL print("$         goto READ_SERVER_LIST "), row + 1,
       CALL print("$      endif"), row + 1,
       CALL print("$   END_READ_SERVER_LIST: "),
       row + 1,
       CALL print("$      close SERVER_LIST  "), row + 1,
       CALL print("$   if (srv_fnd .eq. 0)"), row + 1,
       CALL print("$   then"),
       row + 1,
       CALL print('$      write sys$output "Server failed to run."'), row + 1,
       CALL print("$      exit 1"), row + 1,
       CALL print("$   else"),
       row + 1,
       CALL print('$      write sys$output "Server is running."'), row + 1,
       CALL print("$      exit 1"), row + 1,
       CALL print("$   endif"),
       row + 1
      ELSE
       CALL print("#!/usr/bin/ksh"), row + 1,
       CALL print("#"),
       row + 1,
       CALL print("# server_status.ksh"), row + 1,
       CALL print("#"), row + 1,
       CALL print("srv_fnd=0"),
       row + 1,
       CALL print("tgt_node=`hostname`"), row + 1,
       CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1,
       CALL print(concat("$cer_exe/scpview $tgt_node <<!>",ddr_domain_data->tgt_tmp_full_dir,
        "server_status.dat")),
       row + 1,
       CALL print(ddr_domain_data->tgt_mng), row + 1,
       CALL print(ddr_domain_data->tgt_domain_name), row + 1,
       CALL print("$tgt_mng_pwd"),
       row + 1,
       CALL print("server -state running"), row + 1,
       CALL print("exit"), row + 1,
       CALL print("!"),
       row + 1, row + 1,
       CALL print(concat("   tr '[:upper:]' '[:lower:]' < ",ddr_domain_data->tgt_tmp_full_dir,
        'server_status.dat|grep "',dgss_desc_str,'"')),
       row + 1, row + 1,
       CALL print("   if [[ $? -eq 0 ]]"),
       row + 1,
       CALL print("   then"), row + 1,
       CALL print("      srv_fnd=1"), row + 1,
       CALL print("   fi"),
       row + 1, row + 1,
       CALL print("if [[ $srv_fnd -eq 0 ]]"),
       row + 1,
       CALL print("then"), row + 1,
       CALL print('   echo "Server failed to run."'), row + 1,
       CALL print("fi"),
       row + 1, row + 1
      ENDIF
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Execute ",dgss_file_name)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgss_cmd = concat("@",dgss_file_name)
    ELSE
     SET dgss_cmd = concat("chmod 777 ",dgss_file_name)
     IF (dm2_push_dcl(dgss_cmd)=0)
      RETURN(0)
     ENDIF
     SET dgss_cmd = concat(". ",dgss_file_name)
    ENDIF
    IF (dm2_push_dcl(dgss_cmd)=0)
     RETURN(0)
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF (findstring("Server failed to run",dm_err->errtext,1,1) > 0)
      SET dgss_srv_status = 0
     ELSE
      SET dgss_srv_status = 1
     ENDIF
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ELSE
    SET dgss_srv_status = 0
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_servers(null)
   DECLARE dbs_cmd_file = vc WITH protect, noconstant("")
   DECLARE dbs_cmd = vc WITH protect, noconstant("")
   DECLARE dbs_env = vc WITH protect, noconstant(ddr_domain_data->tgt_env)
   DECLARE dbs_node = vc WITH protect, noconstant(trim(cnvtlower(curnode)))
   DECLARE dbs_dir_name = vc WITH protect, noconstant("")
   DECLARE dbs_file_name = vc WITH protect, noconstant("")
   DECLARE dbs_key_not_found = i2 WITH protect, noconstant(0)
   DECLARE dbs_slash = vc WITH protect, noconstant("\\")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dbs_slash = "\"
   ENDIF
   SET dbs_cmd = concat("\",dbs_slash,"system",dbs_slash,"node",
    dbs_slash,trim(curnode),dbs_slash,"domain",dbs_slash,
    ddr_domain_data->tgt_domain_name,dbs_slash,"servers")
   SET dm_err->eproc = concat("Delete any files in cer_reg with name secondary*.reg")
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dbs_file_name = evaluate(dm2_sys_misc->cur_os,"AXP","cer_reg:secondary*.reg;*",
    "$cer_reg/secondary*.reg")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dbs_file_name) > 0)
     IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dbs_file_name))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dbs_file_name) > 0)
     IF (dm2_push_dcl(concat("rm ",dbs_file_name))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = "Backup servers 31, 32, 34, 35 on secondary target node"
   CALL disp_msg("",dm_err->logfile,0)
   IF (get_unique_file("backup_servers",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dbs_cmd_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to backup servers :",dbs_cmd_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dbs_cmd_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$mcr cer_exe:lregview"), row + 1
     ELSE
      CALL print("$cer_exe/lregview <<!"), row + 1
     ENDIF
     CALL print(concat("cd ",dbs_cmd)), row + 1,
     CALL print(concat("copy 31 \",dbs_slash,"secondary_31_backup -sub")),
     row + 1,
     CALL print(concat("copy 32 \",dbs_slash,"secondary_32_backup -sub")), row + 1,
     CALL print(concat("copy 34 \",dbs_slash,"secondary_34_backup -sub")), row + 1,
     CALL print(concat("copy 35 \",dbs_slash,"secondary_35_backup -sub")),
     row + 1,
     CALL print("exit")
     IF ((dm2_sys_misc->cur_os != "AXP"))
      row + 1,
      CALL print("!"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",dbs_cmd_file)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dbs_cmd = concat("@",dbs_cmd_file)
   ELSE
    SET dbs_cmd = concat(". $CCLUSERDIR/",dbs_cmd_file)
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(dbs_cmd)=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dm_err->eproc = concat("Copy server backups to ",ddr_domain_data->tgt_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dbs_file_name = evaluate(dm2_sys_misc->cur_os,"AXP","cer_reg:secondary*.reg",
    "$cer_reg/secondary*.reg")
   SET dbs_dir_name = ddr_domain_data->tgt_tmp_full_dir
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dbs_file_name) > 0)
     IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","backup/log","cp -p")," ",
       dbs_file_name," ",dbs_dir_name))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dbs_file_name) > 0)
     IF (dm2_push_dcl(concat("cp -p ",dbs_file_name," ",dbs_dir_name))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_srv_def(dgsd_src_ind,dgsd_tgt_ind)
   DECLARE dgsd_ret = vc WITH protect, noconstant("")
   DECLARE dgsd_cmd = vc WITH protect, noconstant("")
   DECLARE dgsd_36_exists = i2 WITH protect, noconstant(0)
   DECLARE dgsd_err_file = vc WITH protect, noconstant("")
   DECLARE dgsd_stat = i2 WITH protect, noconstant(0)
   DECLARE dgsd_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgsd_str = vc WITH protect, noconstant("")
   DECLARE dgsd_scp_file = vc WITH protect, noconstant("")
   DECLARE dgsd_file = vc WITH protect, noconstant("")
   DECLARE dgsd_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgsd_changed = i2 WITH protect, noconstant(0)
   DECLARE dgsd_env = vc WITH protect, noconstant(evaluate(dgsd_src_ind,1,ddr_domain_data->
     src_domain_name,ddr_domain_data->tgt_domain_name))
   DECLARE dgsd_scp_dir = vc WITH protect, noconstant(evaluate(dgsd_src_ind,1,ddr_domain_data->
     src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir))
   DECLARE dgsd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgsd_node = vc WITH protect, noconstant(evaluate(dgsd_src_ind,1,ddr_domain_data->
     src_nodes[1].node_name,ddr_domain_data->tgt_nodes[1].node_name))
   DECLARE dgsd_cnt_file = vc WITH protect, noconstant(concat(ddr_domain_data->src_tmp_full_dir,
     ddr_domain_data->src_env,"_scp.txt"))
   DECLARE dgsd_server_count = i4 WITH protect, noconstant(0)
   IF (get_unique_file("ddr_get_reg",".err")=0)
    RETURN(0)
   ELSE
    SET dgsd_err_file = dm_err->unique_fname
   ENDIF
   IF (dgsd_src_ind=1)
    FOR (dgsd_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
      SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->src_nodes[dgsd_cnt].
       node_name,"_save.scp")
      SET dm_err->eproc = concat("Remove:",dgsd_scp_file)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      IF (dm2_findfile(dgsd_scp_file) > 0)
       IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(
          dm2_sys_misc->cur_os,"AXP",concat(dgsd_scp_file,dgsd_suffix),dgsd_scp_file)))=0)
        RETURN(0)
       ENDIF
      ENDIF
    ENDFOR
   ELSE
    FOR (dgsd_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
      SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->tgt_nodes[dgsd_cnt].
       node_name,"_save.scp")
      SET dm_err->eproc = concat("Remove:",dgsd_scp_file)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      IF (dm2_findfile(dgsd_scp_file) > 0)
       IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(
          dm2_sys_misc->cur_os,"AXP",concat(dgsd_scp_file,dgsd_suffix),dgsd_scp_file)))=0)
        RETURN(0)
       ENDIF
      ENDIF
    ENDFOR
   ENDIF
   SET dm_err->eproc = "Check if Server 36 exists."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsd_str = concat("\node\",dgsd_node,"\domain\",dgsd_env,"\servers\36 Protect")
   ELSE
    SET dgsd_str = concat("\\node\\",dgsd_node,"\\domain\\",dgsd_env,"\\servers\\36 Protect")
   ENDIF
   IF (ddr_lreg_oper("GET",dgsd_str,dgsd_ret)=0)
    RETURN(0)
   ENDIF
   IF (dgsd_ret="NOPARMRETURNED")
    SET dgsd_36_exists = 0
   ELSE
    SET dgsd_36_exists = 1
   ENDIF
   IF (dgsd_36_exists=1
    AND dgsd_ret != "N")
    SET dgsd_changed = 1
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsd_str = concat("\node\",dgsd_node,"\domain\",dgsd_env,'\servers\36 Protect "N"')
    ELSE
     SET dgsd_str = concat("\\node\\",dgsd_node,"\\domain\\",dgsd_env,'\\servers\\36 Protect "N"')
    ENDIF
    IF (ddr_lreg_oper("SET",dgsd_str,dgsd_ret)=0)
     RETURN(0)
    ENDIF
    IF (ddr_scp_apply("36",dgsd_src_ind,dgsd_tgt_ind)=0)
     RETURN(0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsd_str = concat("\node\",dgsd_node,"\domain\",dgsd_env,"\servers\36 Protect")
    ELSE
     SET dgsd_str = concat("\\node\\",dgsd_node,"\\domain\\",dgsd_env,"\\servers\\36 Protect")
    ENDIF
    IF (ddr_lreg_oper("GET",dgsd_str,dgsd_ret)=0)
     RETURN(0)
    ENDIF
    IF (dgsd_ret != "N")
     SET dm_err->emsg = "Error setting protect property for server 36."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (get_unique_file("get_src_srvdef",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
    ENDIF
    RETURN(0)
   ELSE
    SET dgsd_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to obtain SERVER DEFINITIONS:",dgsd_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dgsd_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print(concat("$mcr cer_exe:scpview ",dgsd_node)), row + 1,
      CALL print("$DECK"),
      row + 1
     ELSE
      IF (dgsd_src_ind=1)
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
      ELSE
       CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1
      ENDIF
      CALL print(concat("$cer_exe/scpview ",dgsd_node," <<!")), row + 1
     ENDIF
     IF (dgsd_src_ind=1)
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
     ELSE
      CALL print(ddr_domain_data->tgt_mng), row + 1,
      CALL print(ddr_domain_data->tgt_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->tgt_mng_pwd), row + 1
      ELSE
       CALL print("$tgt_mng_pwd"), row + 1
      ENDIF
     ENDIF
     IF (dgsd_src_ind=1)
      FOR (dgsd_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
        CALL print(concat("select ",ddr_domain_data->src_nodes[dgsd_cnt].node_name)), row + 1,
        dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->src_nodes[dgsd_cnt].
         node_name,"_save.scp"),
        CALL print(concat("export ",dgsd_scp_file)), row + 1
      ENDFOR
     ELSE
      FOR (dgsd_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
        CALL print(concat("select ",ddr_domain_data->tgt_nodes[dgsd_cnt].node_name)), row + 1,
        dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->tgt_nodes[dgsd_cnt].
         node_name,"_save.scp"),
        CALL print(concat("export ",dgsd_scp_file)), row + 1
      ENDFOR
     ENDIF
     CALL print("exit"), row + 1
     IF ((dm2_sys_misc->cur_os != "AXP"))
      CALL print("!"), row + 1
     ELSE
      CALL print("$EOD"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
    ENDIF
    RETURN(0)
   ENDIF
   IF (dgsd_src_ind=1)
    SET dm_err->eproc = "Obtain SOURCE SERVER DEFINITIONS."
   ELSE
    SET dm_err->eproc = "Obtain TARGET SERVER DEFINITIONS."
   ENDIF
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsd_cmd = concat("@",dgsd_file)
   ELSE
    SET dgsd_cmd = concat(". $CCLUSERDIR/",dgsd_file)
   ENDIF
   IF (dm2_push_dcl(dgsd_cmd)=0)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
    ENDIF
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
    ENDIF
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (((findstring("bad command",dm_err->errtext,1,1) > 0) OR (findstring(
    "node not offering services",dm_err->errtext,1,1) > 0)) )
    SET dm_err->emsg = concat("Error exporting server definitions:",dgsd_cmd)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
    ENDIF
    RETURN(0)
   ENDIF
   IF (dgsd_src_ind=1)
    FOR (dgsd_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
      SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->src_nodes[dgsd_cnt].
       node_name,"_save.scp")
      SET dm_err->eproc = concat("Check:",dgsd_scp_file)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      IF (dm2_findfile(dgsd_scp_file)=0)
       SET dm_err->emsg = concat(
        "Error exporting SOURCE server definitions. Server definitions export does not exist.")
       SET dm_err->err_ind = 1
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       IF (dgsd_changed=1)
        CALL ddr_reset_36(dgsd_node,dgsd_env)
       ENDIF
       RETURN(0)
      ENDIF
    ENDFOR
   ELSE
    FOR (dgsd_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
      SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->tgt_nodes[dgsd_cnt].
       node_name,"_save.scp")
      SET dm_err->eproc = concat("Check:",dgsd_scp_file)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      IF (dm2_findfile(dgsd_scp_file)=0)
       SET dm_err->emsg = concat(
        "Error exporting TARGET server definitions. Server definitions export does not exist.")
       SET dm_err->err_ind = 1
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       IF (dgsd_changed=1)
        CALL ddr_reset_36(dgsd_node,dgsd_env)
       ENDIF
       RETURN(0)
      ENDIF
    ENDFOR
   ENDIF
   IF (dgsd_src_ind=1)
    SET ddr_domain_data->src_srv_def_fnd = 1
    SET dgsd_file_date = 0.0
    SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->src_nodes[1].node_name,
     "_save.scp")
    IF (ddr_get_file_date(dgsd_scp_file,dgsd_file_date)=0)
     IF (dgsd_changed=1)
      CALL ddr_reset_36(dgsd_node,dgsd_env)
     ENDIF
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_srv_def_ts = dgsd_file_date
   ELSE
    SET dgsd_scp_file = concat(dgsd_scp_dir,dgsd_env,"_",ddr_domain_data->tgt_nodes[1].node_name,
     "_save.scp")
    SET ddr_domain_data->tgt_srv_def_fnd = 1
    SET dgsd_file_date = 0.0
    IF (ddr_get_file_date(dgsd_scp_file,dgsd_file_date)=0)
     IF (dgsd_changed=1)
      CALL ddr_reset_36(dgsd_node,dgsd_env)
     ENDIF
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_srv_def_ts = dgsd_file_date
   ENDIF
   IF (dgsd_src_ind=1)
    IF (dgsd_changed=1)
     CALL ddr_reset_36(dgsd_node,dgsd_env)
     IF ((dm_err->err_ind > 0))
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF (dgsd_src_ind=1)
    IF (get_unique_file("get_src_srv_cnt",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
     RETURN(0)
    ELSE
     SET dgsd_file = dm_err->unique_fname
    ENDIF
    SET dm_err->eproc = concat("Create file to obtain Source Server count:",dgsd_file)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SELECT INTO value(dgsd_file)
     DETAIL
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$define/user_mode sys$output ",dgsd_cnt_file)), row + 1,
       CALL print(concat("$mcr cer_exe:scpview ",dgsd_node)),
       row + 1,
       CALL print("$DECK"), row + 1
      ELSE
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1,
       CALL print(concat("$cer_exe/scpview ",dgsd_node,"  <<!>",dgsd_cnt_file)),
       row + 1
      ENDIF
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
      CALL print("dir"), row + 1,
      CALL print("exit"),
      row + 1
      IF ((dm2_sys_misc->cur_os != "AXP"))
       CALL print("!"), row + 1
      ELSE
       CALL print("$EOD"), row + 1
      ENDIF
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Obtain Source Server count."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsd_cmd = concat("@",dgsd_file)
    ELSE
     SET dgsd_cmd = concat(". $CCLUSERDIR/",dgsd_file)
    ENDIF
    IF (dm2_push_dcl(dgsd_cmd)=0)
     RETURN(0)
    ENDIF
    IF (ddr_parse_count(dgsd_cnt_file,dgsd_server_count)=0)
     RETURN(0)
    ENDIF
    IF (dgsd_server_count < 10)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Source server count is less than 10."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_server_count = dgsd_server_count
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_tdb(dgt_src_ind,dgt_tgt_ind)
   DECLARE dgt_file = vc WITH protect, noconstant("")
   DECLARE dgt_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgt_cmd = vc WITH protect, noconstant("")
   DECLARE dgt_tdb_file = vc WITH protect, noconstant(concat(evaluate(dgt_src_ind,1,ddr_domain_data->
      src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir),evaluate(dgt_src_ind,1,ddr_domain_data->
      src_env,ddr_domain_data->tgt_env),"_tdb.msg"))
   DECLARE dgt_suffix = vc WITH protect, noconstant(";*")
   DECLARE dgt_tdb_count = i4 WITH protect, noconstant(0)
   DECLARE dgt_cnt_file = vc WITH protect, noconstant(concat(ddr_domain_data->src_tmp_full_dir,
     ddr_domain_data->src_env,"_tdb.txt"))
   SET dm_err->eproc = concat("Remove:",dgt_tdb_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dgt_tdb_file) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc
       ->cur_os,"AXP",concat(dgt_tdb_file,dgt_suffix),dgt_tdb_file)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (get_unique_file("get_tdb",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dgt_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to obtain TDB info:",dgt_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dgt_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("mcr cer_exe:tdbview system"), row + 1,
      CALL print("$DECK"),
      row + 1
     ELSE
      IF (dgt_src_ind=1)
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
      ELSE
       CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1
      ENDIF
      CALL print("$cer_exe/tdbview system <<!"), row + 1
     ENDIF
     IF (dgt_src_ind=1)
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
      CALL print(concat("export * ",ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,
       "_tdb.msg")), row + 1
     ELSE
      CALL print(ddr_domain_data->tgt_mng), row + 1,
      CALL print(ddr_domain_data->tgt_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->tgt_mng_pwd), row + 1
      ELSE
       CALL print("$tgt_mng_pwd"), row + 1
      ENDIF
      CALL print(concat("export * ",ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_tdb.msg")), row + 1
     ENDIF
     CALL print("exit"), row + 1
     IF ((dm2_sys_misc->cur_os != "AXP"))
      CALL print("!"), row + 1
     ELSE
      CALL print("$EOD"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Obtain TDB export."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgt_cmd = concat("@",dgt_file)
   ELSE
    SET dgt_cmd = concat(". $CCLUSERDIR/",dgt_file)
   ENDIF
   IF (dm2_push_dcl(dgt_cmd)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dm_err->errtext = replace(dm_err->errtext,"Transaction Database (TDB) Viewer","",0)
   IF (size(dm_err->errtext) > 0)
    SET dm_err->emsg = concat("Error exporting TDB:",dm_err->errtext)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dgt_tdb_file)=0)
    SET dm_err->emsg = concat("Error exporting TDB. TDB export does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (ddr_get_file_date(dgt_tdb_file,dgt_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dgt_src_ind=1)
    SET ddr_domain_data->src_tdb_ts = dgt_file_date
    SET ddr_domain_data->src_tdb_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_tdb_ts = dgt_file_date
    SET ddr_domain_data->tgt_tdb_fnd = 1
   ENDIF
   IF (dgt_src_ind=1)
    IF (get_unique_file("get_src_tdb_cnt",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
     RETURN(0)
    ELSE
     SET dgt_file = dm_err->unique_fname
    ENDIF
    SET dm_err->eproc = concat("Create file to obtain Source TDB count:",dgt_file)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SELECT INTO value(dgt_file)
     DETAIL
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$define/user_mode sys$output ",dgt_cnt_file)), row + 1,
       CALL print("$mcr cer_exe:tdbview system"),
       row + 1,
       CALL print("$DECK"), row + 1
      ELSE
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1,
       CALL print(concat("$cer_exe/tdbview system <<!>",dgt_cnt_file)),
       row + 1
      ENDIF
      CALL print(ddr_domain_data->src_mng), row + 1,
      CALL print(ddr_domain_data->src_domain_name),
      row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ELSE
       CALL print("$src_mng_pwd"), row + 1
      ENDIF
      CALL print("dir"), row + 1,
      CALL print("exit"),
      row + 1
      IF ((dm2_sys_misc->cur_os != "AXP"))
       CALL print("!"), row + 1
      ELSE
       CALL print("$EOD"), row + 1
      ENDIF
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Obtain Source TDB count."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgt_cmd = concat("@",dgt_file)
    ELSE
     SET dgt_cmd = concat(". $CCLUSERDIR/",dgt_file)
    ENDIF
    IF (dm2_push_dcl(dgt_cmd)=0)
     RETURN(0)
    ENDIF
    IF (ddr_parse_count(dgt_cnt_file,dgt_tdb_count)=0)
     RETURN(0)
    ENDIF
    IF (dgt_tdb_count < 10)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Source TDB count is less than 10."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_tdb_count = dgt_tdb_count
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_parse_count(dpc_file_name,dpc_count)
   SET dm_err->eproc = concat("Parse out count from file ",dpc_file_name)
   CALL disp_msg("",dm_err->logfile,0)
   SET dpc_count = 0
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dpc_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     first_char = ""
    DETAIL
     first_char = ""
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     first_char = substring(1,1,r.line)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("first_char=",first_char))
     ENDIF
     IF (((cnvtint(first_char) > 0) OR (first_char="0")) )
      dpc_count = (dpc_count+ 1)
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_dicdat(dgd_src_ind,dgd_tgt_ind)
   DECLARE dgd_file_str = vc WITH protect, noconstant("")
   DECLARE dgd_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dgd_cerinstall = vc WITH protect, noconstant(trim(logical("cer_install")))
   DECLARE dgd_str = vc WITH protect, noconstant("")
   SET dgd_file_str = concat(dgd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dm_dict.dat;*",
     "/dm_dict.dat"))
   SET dm_err->eproc = concat("Remove:",dgd_file_str)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dgd_file_str) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgd_file_str))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    SET dgd_file_str = concat(dgd_cerinstall,"/","dm_dict.idx")
    SET dm_err->eproc = concat("Remove:",dgd_file_str)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF (dm2_findfile(dgd_file_str) > 0)
     IF (dm2_push_dcl(concat("rm ",dgd_file_str))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dgd_file_str = concat(evaluate(dgd_src_ind,1,ddr_domain_data->src_tmp_full_dir,ddr_domain_data
     ->tgt_tmp_full_dir),evaluate(dm2_sys_misc->cur_os,"AXP","dic.dat;*","dic.dat"))
   SET dm_err->eproc = concat("Remove:",dgd_file_str)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dm2_findfile(dgd_file_str) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",dgd_file_str))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    SET dgd_file_str = concat(evaluate(dgd_src_ind,1,ddr_domain_data->src_tmp_full_dir,
      ddr_domain_data->tgt_tmp_full_dir),"dic.idx")
    SET dm_err->eproc = concat("Remove:",dgd_file_str)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF (dm2_findfile(dgd_file_str) > 0)
     IF (dm2_push_dcl(concat("rm ",dgd_file_str))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = "Create copy of dictionary using DM_CREATE_A_DICTIONARY"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   EXECUTE dm_create_a_dictionary
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgd_file_str = concat(dgd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dm_dict.dat",
     "/dm_dict.dat"))
   IF (dm2_findfile(dgd_file_str)=0)
    SET dm_err->emsg = concat(
     "Error creating copy of SOURCE dictionary. Dictionary copy does not exist.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgd_file_str = concat(dgd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dm_dict.dat",
     "/dm_dict.dat"))
   SET dgd_str = concat(evaluate(dm2_sys_misc->cur_os,"AXP","rename","mv")," ",dgd_file_str," ",
    dgd_cerinstall,
    evaluate(dm2_sys_misc->cur_os,"AXP","dic.dat","/dic.dat"))
   IF (dm2_push_dcl(dgd_str)=0)
    RETURN(0)
   ENDIF
   SET dgd_file_str = concat(dgd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dm_dict.idx",
     "/dm_dict.idx"))
   IF ((dm2_sys_misc->cur_os != "AXP"))
    SET dgd_str = concat("mv ",dgd_file_str," ",dgd_cerinstall,"/dic.idx")
    IF (dm2_push_dcl(dgd_str)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dgd_file_str = concat(dgd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dic.dat","/dic.dat")
    )
   IF (ddr_get_file_date(dgd_file_str,dgd_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dgd_src_ind=1)
    SET ddr_domain_data->src_dict_ts = dgd_file_date
    SET ddr_domain_data->src_dict_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_dict_ts = dgd_file_date
    SET ddr_domain_data->tgt_dict_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_prompt_node_names(dpnn_src_ind,dpnn_tgt_ind)
   DECLARE dpnn_rows_max = i4 WITH protect, constant(23)
   DECLARE dpnn_col_max = i4 WITH protect, constant(80)
   DECLARE dpnn_node_list = vc WITH protect, noconstant("")
   DECLARE dpnn_cnt = i4 WITH protect, noconstant(0)
   DECLARE dpnn_row_cnt = i4 WITH protect, noconstant(0)
   DECLARE dpnn_col_num = i4 WITH protect, noconstant(2)
   DECLARE dpnn_length = i4 WITH protect, noconstant(0)
   DECLARE dpnn_exit = i2 WITH protect, noconstant(0)
   DECLARE dpnn_ndx = i2 WITH protect, noconstant(0)
   DECLARE dpnn_accept = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Node name confirmation"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   FREE RECORD dpnn_work
   RECORD dpnn_work(
     1 nodes_cnt = i4
     1 nodes[*]
       2 keep = i2
       2 node_name = vc
   )
   IF (dpnn_src_ind=1)
    SET dpnn_work->nodes_cnt = ddr_domain_data->src_nodes_cnt
   ELSE
    SET dpnn_work->nodes_cnt = ddr_domain_data->tgt_nodes_cnt
   ENDIF
   SET stat = alterlist(dpnn_work->nodes,dpnn_work->nodes_cnt)
   FOR (dpnn_ndx = 1 TO dpnn_work->nodes_cnt)
    IF (dpnn_src_ind=1)
     SET dpnn_work->nodes[dpnn_ndx].node_name = ddr_domain_data->src_nodes[dpnn_ndx].node_name
    ELSE
     SET dpnn_work->nodes[dpnn_ndx].node_name = ddr_domain_data->tgt_nodes[dpnn_ndx].node_name
    ENDIF
    SET dpnn_work->nodes[dpnn_ndx].keep = 1
   ENDFOR
   IF ((dm_err->debug_flag != 722))
    SET message = window
   ENDIF
   SET width = 132
   CALL clear(1,1)
   CALL clear(1,1)
   CALL box(1,1,22,131)
   CALL text(1,dpnn_col_num,"APPLICATION NODE CONFIRMATION SCREEN ")
   CALL text(3,dpnn_col_num,concat("Are the following nodes correct for environment: ",evaluate(
      dpnn_src_ind,1,ddr_domain_data->src_env,ddr_domain_data->tgt_env),"?"))
   CALL text(7,dpnn_col_num,concat(evaluate(dpnn_src_ind,1,"SOURCE","TARGET"),
     " Application Nodes Obtained from SCP: "))
   SET dpnn_node_list = ""
   FOR (dpnn_cnt = 1 TO dpnn_work->nodes_cnt)
     IF ((dpnn_work->nodes_cnt > 1)
      AND dpnn_cnt != 1)
      SET dpnn_node_list = concat(dpnn_node_list,", ",dpnn_work->nodes[dpnn_cnt].node_name)
     ELSE
      SET dpnn_node_list = dpnn_work->nodes[dpnn_cnt].node_name
     ENDIF
   ENDFOR
   SET dpnn_cnt = 0
   SET dpnn_row_cnt = 9
   WHILE (dpnn_cnt < size(dpnn_node_list)
    AND dpnn_row_cnt < dpnn_rows_max)
     CALL clear(dpnn_row_cnt,dpnn_col_num,129)
     IF (size(dpnn_node_list) < dpnn_col_max)
      CALL text(dpnn_row_cnt,(dpnn_col_num+ 2),trim(substring((dpnn_cnt+ 1),dpnn_col_max,
         dpnn_node_list)))
      SET dpnn_length = dpnn_col_max
     ELSE
      SET dpnn_length = findstring(",",substring((dpnn_cnt+ 1),dpnn_col_max,dpnn_node_list),(dpnn_cnt
       + 1),1)
      IF (dpnn_length=0)
       SET dpnn_length = dpnn_col_max
      ENDIF
      CALL text(dpnn_row_cnt,(dpnn_col_num+ 2),trim(substring((dpnn_cnt+ 1),dpnn_length,
         dpnn_node_list)))
     ENDIF
     SET dpnn_cnt = (dpnn_cnt+ dpnn_length)
     SET dpnn_row_cnt = (dpnn_row_cnt+ 1)
   ENDWHILE
   CALL text(5,dpnn_col_num,"(Y)es,(N)o,(Q)uit?")
   CALL accept(5,(21+ dpnn_col_num),"A;cu"," "
    WHERE curaccept IN ("Y", "N", "Q"))
   SET dpnn_accept = curaccept
   CALL clear(1,1)
   SET message = nowindow
   IF (dpnn_accept="Q")
    SET dm_err->emsg = "User elected to quit from Application Node entry"
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dpnn_accept="N")
    SET dm_err->emsg = concat("User entered that nodes obtained from SCP were not correct for ",
     evaluate(dpnn_src_ind,1,ddr_domain_data->src_env,ddr_domain_data->tgt_env))
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_new_source_data(null)
   DECLARE dgnsd_grants_file = vc WITH protect, noconstant(concat(ddr_domain_data->src_tmp_full_dir,
     ddr_domain_data->src_env,"_ccl_grants.txt"))
   DECLARE dgnsd_interrogator_ind = i2 WITH protect, noconstant(0)
   DECLARE dgnsd_interrogator_node = vc WITH protect, noconstant("")
   DECLARE dgnsd_utc_mock_db_name = vc WITH protect, noconstant("")
   DECLARE dgnsd_tgt_db_name = vc WITH protect, noconstant("")
   DECLARE dgnsd_idx = i4 WITH protect, noconstant(0)
   DECLARE dgnsd_invalid_cm_ind = i2 WITH protect, noconstant(0)
   DECLARE dgnsd_invalid_cust_user_ind = i2 WITH protect, noconstant(0)
   DECLARE dgnsd_invalid_dt_data_ind = i2 WITH protect, noconstant(0)
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dm2_install_schema->src_v500_p_word = drrr_rf_data->src_db_user_pwd
    SET dm2_install_schema->src_v500_connect_str = drrr_rf_data->src_db_cnct_str
    SET ddr_domain_data->src_env = trim(cnvtlower(drrr_rf_data->src_env_name))
    SET ddr_domain_data->src_mng = drrr_rf_data->src_high_priv_user
    SET ddr_domain_data->src_mng_pwd = drrr_rf_data->src_high_priv_user_pwd
   ENDIF
   IF ((dm2_install_schema->src_v500_p_word="NONE"))
    SET dm2_install_schema->dbase_name = "SOURCE"
    SET dm2_install_schema->u_name = "V500"
    EXECUTE dm2_connect_to_dbase "PC"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->src_v500_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->src_v500_connect_str = dm2_install_schema->connect_str
   ENDIF
   SET dm2_install_schema->dbase_name = currdbname
   SELECT INTO "nl:"
    FROM dm_environment de,
     dm_info d
    WHERE d.info_domain="DATA MANAGEMENT"
     AND d.info_name="DM_ENV_ID"
     AND de.environment_id=d.info_number
    DETAIL
     ddr_domain_data->src_db_env_name = trim(cnvtlower(de.environment_name))
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->emsg = "Could not obtain environment name"
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (ddr_val_client_mnemonic(1,0,0,dgnsd_invalid_cm_ind)=0)
     RETURN(0)
    ENDIF
    IF (drr_verify_custom_users(0,dgnsd_invalid_cust_user_ind)=0)
     RETURN(0)
    ENDIF
    IF (drr_verify_admin_content(0,dgnsd_invalid_dt_data_ind)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_misc_data(1,0)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_nodes(1,0)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Check if UTC migration is in progress"
   IF (validate(dm2_mig_utc_status,"-1")="-1")
    DECLARE dm2_mig_utc_status = vc WITH protect, noconstant("")
   ENDIF
   EXECUTE dm2_mig_status_check
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF (cnvtupper(dm2_mig_utc_status)="ERROR")
    SET dm_err->eproc = "Check UTC migration status."
    SET dm_err->emsg = "Unexpected error occurred in DM2_MIG_STATUS_CHECK"
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(dm2_mig_utc_status)="ON")
    SET dm_err->eproc = "Checking for Mock database name."
    SELECT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain="DM2_MIG_UTC_MOCK_DB_NAME"
     DETAIL
      dgnsd_utc_mock_db_name = cnvtupper(trim(d.info_name))
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Checking if UTC Migration in process."
    SELECT INTO "nl:"
     FROM dm_info d
     WHERE d.info_domain="DM2_RR_UTC_MIG_INFLIGHT_CHK"
      AND d.info_name="BYPASS_CHECK"
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
    IF (curqual > 0)
     SET dm_err->eproc =
     "Bypassing UTC Migration-in-process check due to replicate/refresh bypass override."
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     IF (validate(drrr_responsefile_in_use,0)=1)
      SET dgnsd_tgt_db_name = cnvtupper(trim(drrr_rf_data->tgt_db_name))
     ELSE
      SET message = window
      SET width = 132
      CALL clear(1,1)
      CALL box(1,1,5,131)
      CALL text(3,8,"Please enter the TARGET database name: ")
      CALL accept(3,48,"P(10);CU"," "
       WHERE curaccept > " ")
      SET dgnsd_tgt_db_name = cnvtupper(trim(curaccept))
      SET message = nowindow
      CALL clear(1,1)
     ENDIF
     IF (dgnsd_tgt_db_name != dgnsd_utc_mock_db_name)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("UTC migration is in progress. This process cannot continue.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET dm_err->eproc = concat("Bypassing UTC Migration-in-process because ",dgnsd_utc_mock_db_name,
       " is a mock db.")
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
    ENDIF
   ENDIF
   IF ((ddr_domain_data->src_interrogator_ind=1))
    IF (ddr_interrogator_usage(dgnsd_interrogator_ind,dgnsd_interrogator_node)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_domain_data->src_interrogator_ind != dgnsd_interrogator_ind))
     SET dm_err->err_ind = 1
     SET dm_err->eproc =
     "Determine Interrogator Server #520 is running on source application node(s)"
     IF ((dgnsd_interrogator_ind > ddr_domain_data->src_interrogator_ind))
      SET dm_err->emsg = concat(
       "Interrogator Solution(server 520) is running on More than one Source APP nodes ")
     ELSE
      SET dm_err->emsg = concat("Interrogator Solution not enabled (server 520 not running on any ",
       "application node) but response file chose to copy Interrogator Solution")
     ENDIF
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_interrogator_node = dgnsd_interrogator_node
   ENDIF
   IF (validate(dm2_bypass_space_needs_calc,0)=0
    AND (validate(dm2_bypass_space_needs_calc,- (1))=- (1)))
    IF (ddr_data_collection_space_needs(1,0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_invalid_tbls(1,0,1)=0)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dm_err->eproc = "Using response file - bypassing source node list validation."
    CALL disp_msg(" ",dm_err->logfile,0)
   ELSE
    IF (ddr_prompt_node_names(1,0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_cleanup_opsexec_mapping(null)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_opsexec_servers(1,0,1)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_dicdat(1,0)=0)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->get_warehouse = 1
   IF ((ddr_domain_data->get_warehouse=1))
    IF (ddr_get_wh(1,0,0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_ocdtools(null)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_ccldir(null)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_config(null)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_tdb(1,0)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_srv_def(1,0)=0)
    RETURN(0)
   ENDIF
   IF ((ddr_domain_data->src_was_arch_ind=0))
    IF (ddr_get_sec_user(1,0,0)=0)
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->eproc = "Using WAS Architecture - bypassing copy of source sec user."
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF (ddr_get_env_reg(1,0,"DEFINITION",0)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_env_reg(1,0,"SYSTEM_DEFINITIONS",0)=0)
    RETURN(0)
   ENDIF
   IF ((ddr_domain_data->get_invalid_tables=1))
    IF (ddr_get_invalid_tbls(1,0,0)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "LNX")))
    IF (ddr_get_link_data(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_adm_env(null)=0)
    RETURN(0)
   ENDIF
   SET decg_export_fname = dgnsd_grants_file
   EXECUTE dm2_export_ccl_grants
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dgnsd_grants_file) > 0)
    SET ddr_domain_data->src_ccl_grants_ind = 1
   ENDIF
   IF ((ddr_domain_data->src_interrogator_ind=1))
    IF (ddr_interrogator_backup("BACKUP")=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_backup_file_content_load(1,0)=0)
    RETURN(0)
   ENDIF
   IF ((ddr_backup_file_content->src_backup_list_cnt > 0))
    FOR (dgnsd_idx = 1 TO ddr_backup_file_content->src_backup_list_cnt)
      IF (ddr_backup_file_content(ddr_backup_file_content->src_backup_list[dgnsd_idx].mode,
       ddr_backup_file_content->src_backup_list[dgnsd_idx].fdir,ddr_backup_file_content->
       src_backup_list[dgnsd_idx].fvalue,ddr_backup_file_content->src_backup_list[dgnsd_idx].dest_dir,
       ddr_backup_file_content->src_backup_list[dgnsd_idx].dest_fname,
       ddr_backup_file_content->src_backup_list[dgnsd_idx].options,ddr_backup_file_content->
       src_backup_list[dgnsd_idx].req_ind)=0)
       RETURN(0)
      ENDIF
    ENDFOR
   ENDIF
   IF (ddr_write_misc_data(1,0)=0)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (drr_add_default_scd_row(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_summary(1,0)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_new_target_data(null)
   DECLARE dgntd_src_was_arch_ind = i2 WITH protect, noconstant(0)
   DECLARE dgntd_src_ora_ver = i2 WITH protect, noconstant(0)
   DECLARE dgntd_src_characterset = vc WITH protect, noconstant("")
   DECLARE dgntd_tgt_characterset = vc WITH protect, noconstant("")
   DECLARE dgntd_grants_file = vc WITH protect, noconstant(concat(ddr_domain_data->tgt_tmp_full_dir,
     ddr_domain_data->tgt_env,"_ccl_grants.txt"))
   DECLARE dgntd_utc_ind = i2 WITH protect, noconstant(0)
   DECLARE dgntd_date_mode = vc WITH protect, noconstant("")
   DECLARE dgntd_part_enabled_ind = i2 WITH protect, noconstant(0)
   DECLARE dgntd_part_usage_ind = i2 WITH protect, noconstant(0)
   DECLARE dgntd_idx = i4 WITH protect, noconstant(0)
   DECLARE dgntd_invalid_cm_ind = i2 WITH protect, noconstant(0)
   DECLARE dgntd_invalid_dt_data_ind = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Get [new] target data."
   CALL disp_msg("",dm_err->logfile,0)
   IF ((ddr_domain_data->process="REPLICATE"))
    IF (ddr_get_misc_data(0,1)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_tgt_node_flag(null)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_env_reg(0,1,"DEFINITION",0)=0)
     RETURN(0)
    ENDIF
    IF (ddr_write_misc_data(0,1)=0)
     RETURN(0)
    ENDIF
   ELSEIF ((ddr_domain_data->process="REFRESH"))
    IF (validate(drrr_responsefile_in_use,0)=1)
     IF (ddr_val_client_mnemonic(0,1,0,dgntd_invalid_cm_ind)=0)
      RETURN(0)
     ENDIF
     IF (drr_verify_admin_content(0,dgntd_invalid_dt_data_ind)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm2_install_schema->src_v500_p_word = drrr_rf_data->src_db_user_pwd
     SET dm2_install_schema->src_v500_connect_str = drrr_rf_data->src_db_cnct_str
     SET ddr_domain_data->src_domain_name = drrr_rf_data->src_domain_name
    ENDIF
    SET dm2_install_schema->dbase_name = '"SOURCE"'
    SET dm2_install_schema->u_name = "V500"
    IF ((dm2_install_schema->src_v500_p_word != "NONE")
     AND (dm2_install_schema->src_v500_connect_str != "NONE"))
     SET dm2_install_schema->p_word = dm2_install_schema->src_v500_p_word
     SET dm2_install_schema->connect_str = dm2_install_schema->src_v500_connect_str
     EXECUTE dm2_connect_to_dbase "CO"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     SET dm2_force_connect_string = 1
     EXECUTE dm2_connect_to_dbase "PC"
     SET dm2_force_connect_string = 0
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     SET dm2_install_schema->src_v500_p_word = dm2_install_schema->p_word
     SET dm2_install_schema->src_v500_connect_str = dm2_install_schema->connect_str
    ENDIF
    IF ((((ddr_domain_data->src_domain_name="")) OR ((ddr_domain_data->src_domain_name="DM2NOTSET")
    )) )
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,5,131)
     CALL text(3,8,"Please enter the SOURCE domain: ")
     CALL accept(3,40,"P(30);CU"," "
      WHERE curaccept > " ")
     SET ddr_domain_data->src_domain_name = cnvtlower(curaccept)
     SET message = nowindow
     CALL clear(1,1)
    ENDIF
    IF ((validate(dm2_bypass_was_check,- (1))=- (1)))
     IF (drr_identify_was_usage(ddr_domain_data->src_domain_name,dgntd_src_was_arch_ind)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->src_was_arch_ind = dgntd_src_was_arch_ind
    ENDIF
    IF (dm2_get_rdbms_version(null)=0)
     RETURN(0)
    ENDIF
    SET dgntd_src_ora_ver = dm2_rdbms_version->level1
    SET dm_err->eproc = "Determining SOURCE character set from v$nls_parameters."
    SELECT INTO "nl:"
     FROM v$nls_parameters vnp
     WHERE vnp.parameter="NLS_CHARACTERSET"
     DETAIL
      dgntd_src_characterset = vnp.value
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Check if source has gone through UTC conversion."
    SELECT INTO "nl:"
     FROM dm2_ddl_ops
     WHERE process_option IN ("UTC CONVERSION UPTIME", "UTC CONVERSION DOWNTIME")
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
    IF (curqual > 0)
     SET dgntd_utc_ind = 1
    ENDIF
    IF (dgntd_utc_ind=0)
     SET dm_err->eproc = "Check if UTC migration is in progress"
     IF (validate(dm2_mig_utc_status,"-1")="-1")
      DECLARE dm2_mig_utc_status = vc WITH protect, noconstant("")
     ENDIF
     EXECUTE dm2_mig_status_check
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     IF (cnvtupper(dm2_mig_utc_status)="ERROR")
      SET dm_err->eproc = "Check UTC migration status."
      SET dm_err->emsg = "Unexpected error occurred in DM2_MIG_STATUS_CHECK"
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (cnvtupper(dm2_mig_utc_status)="ON")
      SET dgntd_utc_ind = 1
     ENDIF
    ENDIF
    SET dm_err->eproc =
    "Check if source has partitioning option enabled and has partitioned objects."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dpr_identify_partition_usage(1,dgntd_part_enabled_ind,dgntd_part_usage_ind)=0)
     RETURN(0)
    ENDIF
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dm2_install_schema->v500_p_word = drrr_rf_data->tgt_db_user_pwd
     SET dm2_install_schema->v500_connect_str = drrr_rf_data->tgt_db_cnct_str
     SET ddr_domain_data->tgt_env = trim(cnvtlower(drrr_rf_data->tgt_env_name))
     SET ddr_domain_data->tgt_mng = drrr_rf_data->tgt_high_priv_user
     SET ddr_domain_data->tgt_mng_pwd = drrr_rf_data->tgt_high_priv_user_pwd
    ENDIF
    IF ((((dm2_install_schema->v500_p_word="NONE")) OR ((dm2_install_schema->v500_connect_str="NONE")
    )) )
     SET dm2_install_schema->dbase_name = "TARGET"
     SET dm2_install_schema->u_name = "V500"
     EXECUTE dm2_connect_to_dbase "PC"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     SET dm2_install_schema->v500_p_word = dm2_install_schema->p_word
     SET dm2_install_schema->v500_connect_str = dm2_install_schema->connect_str
    ELSE
     SET dm2_install_schema->p_word = dm2_install_schema->v500_p_word
     SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
     EXECUTE dm2_connect_to_dbase "CO"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
    SET dm2_install_schema->dbase_name = currdbname
    SET dm2_install_schema->target_dbase_name = currdbname
    IF (dm2_get_rdbms_version(null)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Determining TARGET character set from v$nls_parameters."
    SELECT INTO "nl:"
     FROM v$nls_parameters vnp
     WHERE vnp.parameter="NLS_CHARACTERSET"
     DETAIL
      dgntd_tgt_characterset = vnp.value
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (validate(dm2_bypass_oraver_check,- (1)) != 1)
     IF (validate(drrr_rf_data->tgt_db_copy_type,"DM2NOTSET")="ALTERNATE"
      AND validate(drrr_rf_data->target_refresh,"DM2NOTSET")="YES"
      AND (((dgntd_src_ora_ver < dm2_rdbms_version->level1)) OR ((dgntd_src_ora_ver >
     dm2_rdbms_version->level1)
      AND ((dgntd_src_ora_ver != 19) OR ((dm2_rdbms_version->level1 != 11))) )) )
      SET dm_err->err_ind = 1
      SET dm_err->eproc = "Cross Oracle refresh versions (high-level) compare."
      SET dm_err->emsg = concat("Target Oracle version (",trim(cnvtstring(dm2_rdbms_version->level1)),
       ") and Source Oracle version (",trim(cnvtstring(dgntd_src_ora_ver)),
       ") are not valid for Cross Oracle Refresh.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSEIF (((validate(drrr_rf_data->tgt_db_copy_type,"DM2NOTSET") != "ALTERNATE") OR (validate(
      drrr_rf_data->target_refresh,"DM2NOTSET") != "YES"))
      AND (dm2_rdbms_version->level1 != dgntd_src_ora_ver))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = "Verify Target and Source Oracle versions (high-level) match."
      SET dm_err->emsg = concat("Target Oracle version (",trim(cnvtstring(dm2_rdbms_version->level1)),
       ") does not match Source Oracle version (",trim(cnvtstring(dgntd_src_ora_ver)),").")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF (dgntd_tgt_characterset != dgntd_src_characterset
     AND validate(dm2_bypass_charset_check,- (1)) != 1)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Verify Target and Source Characterset match."
     SET dm_err->emsg = concat("Target Characterset (",trim(dgntd_tgt_characterset),
      ") does not match Source Characterset (",trim(dgntd_src_characterset),").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgntd_utc_ind=1)
     SET dgntd_date_mode = trim(logical("DATE_MODE"))
     IF (cnvtupper(dgntd_date_mode) != "UTC")
      SET dm_err->eproc = "Checking if UTC Migration in process."
      SELECT INTO "nl:"
       FROM dm_info d
       WHERE d.info_domain="DM2_RR_UTC_MATCH_CHK"
        AND d.info_name="BYPASS_CHECK"
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
       RETURN(0)
      ENDIF
      IF (curqual > 0)
       SET dm_err->eproc = "Bypassing UTC conversion check due to replicate/refresh bypass override."
       CALL disp_msg("",dm_err->logfile,0)
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat(
        "Source is going through or has completed a UTC Conversion while Target remains a local domain. ",
        "This process cannot continue.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
    IF (dgntd_part_usage_ind=1)
     SET dm_err->eproc = "Check if target partitioning option is enabled."
     CALL disp_msg(" ",dm_err->logfile,0)
     IF (dpr_identify_partition_usage(0,dgntd_part_enabled_ind,dgntd_part_usage_ind)=0)
      RETURN(0)
     ENDIF
     IF (dgntd_part_enabled_ind=0)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat(
       "Target partitioning option (v$option) is disabled and Source has partitioned objects. ",
       "Partitioning must be enabled in Target to proceed.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_misc_data(0,1)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_domain_data->tgt_was_arch_ind != ddr_domain_data->src_was_arch_ind))
     SET dm_err->eproc = concat("WAS Security Architecture different between Source and Target.",
      "The refresh process will use Source Security Architecture when setting up Target.")
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF (validate(dm2_bypass_space_needs_calc,0)=0
     AND (validate(dm2_bypass_space_needs_calc,- (1))=- (1)))
     IF (ddr_data_collection_space_needs(0,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_prompt_tgt_backups(null)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_nodes(0,1)=0)
     RETURN(0)
    ENDIF
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dm_err->eproc = "Using response file - bypassing source node list validation."
     CALL disp_msg(" ",dm_err->logfile,0)
    ELSE
     IF (ddr_prompt_node_names(0,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_set_tgt_node_flag(null)=0)
     RETURN(0)
    ENDIF
    IF (ddr_cleanup_opsexec_mapping(null)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_opsexec_servers(0,1,1)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_domain_data->tgt_node_flag=3))
     IF (ddr_backup_servers(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dm_err->eproc = "Using response file - bypassing ccluserdir backup prompt."
     CALL disp_msg(" ",dm_err->logfile,0)
     SET ddr_domain_data->get_ccluserdir = evaluate(drrr_rf_data->tgt_backup_ccluserdir,"YES",1,0)
    ELSE
     IF (ddr_get_ccluserdir(1)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dm_err->eproc = "Using response file - bypassing warehouse backup prompt."
     CALL disp_msg(" ",dm_err->logfile,0)
     SET ddr_domain_data->get_warehouse = evaluate(drrr_rf_data->tgt_backup_warehouse,"YES",1,0)
    ELSE
     IF (ddr_get_wh(0,1,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((ddr_domain_data->get_warehouse=1))
     IF (ddr_get_wh(0,1,0)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((ddr_domain_data->get_ccluserdir=1))
     IF (ddr_get_ccluserdir(0)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_tdb(0,1)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_srv_def(0,1)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_domain_data->tgt_was_arch_ind=0))
     IF (ddr_get_sec_user(0,1,0)=0)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->eproc = "Using WAS Architecture - bypassing copy of target sec user."
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF (ddr_get_env_reg(0,1,"DEFINITION",0)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_env_reg(0,1,"SYSTEM_DEFINITIONS",0)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_env_reg(0,1,"SYSTEM",0)=0)
     RETURN(0)
    ENDIF
    IF ((dm2_sys_misc->cur_os != "AXP"))
     IF (ddr_get_cerforms(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_ccldbas(null)=0)
     RETURN(0)
    ENDIF
    IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX")))
     IF (ddr_get_users(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_dicdat(0,1)=0)
     RETURN(0)
    ENDIF
    IF ((((ddr_domain_data->preserve_ind=1)) OR ((ddr_domain_data->preserve_user_ind=1))) )
     IF (ddr_get_preserved_data(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    EXECUTE dm2_repl_preserve_pwds
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (ddr_validate_preserve_pwds(null)=0)
     RETURN(0)
    ENDIF
    SET decg_export_fname = dgntd_grants_file
    EXECUTE dm2_export_ccl_grants
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
    IF (dm2_findfile(dgntd_grants_file) > 0)
     SET ddr_domain_data->tgt_ccl_grants_ind = 1
    ENDIF
    IF (ddr_backup_file_content_load(0,1)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_backup_file_content->tgt_backup_list_cnt > 0))
     FOR (dgntd_idx = 1 TO ddr_backup_file_content->tgt_backup_list_cnt)
       IF (ddr_backup_file_content(ddr_backup_file_content->tgt_backup_list[dgntd_idx].mode,
        ddr_backup_file_content->tgt_backup_list[dgntd_idx].fdir,ddr_backup_file_content->
        tgt_backup_list[dgntd_idx].fvalue,ddr_backup_file_content->tgt_backup_list[dgntd_idx].
        dest_dir,ddr_backup_file_content->tgt_backup_list[dgntd_idx].dest_fname,
        ddr_backup_file_content->tgt_backup_list[dgntd_idx].options,ddr_backup_file_content->
        tgt_backup_list[dgntd_idx].req_ind)=0)
        RETURN(0)
       ENDIF
     ENDFOR
    ENDIF
    IF (ddr_backup_reg_content_load(null)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_backup_reg_content->tgt_backup_list_cnt > 0))
     FOR (dgntd_idx = 1 TO ddr_backup_reg_content->tgt_backup_list_cnt)
       IF (ddr_backup_reg_content(ddr_backup_reg_content->tgt_backup_list[dgntd_idx].mode,
        ddr_backup_reg_content->tgt_backup_list[dgntd_idx].key,ddr_backup_reg_content->
        tgt_backup_list[dgntd_idx].prop,ddr_backup_reg_content->tgt_backup_list[dgntd_idx].dest_dir,
        ddr_backup_reg_content->tgt_backup_list[dgntd_idx].dest_fname,
        ddr_backup_reg_content->tgt_backup_list[dgntd_idx].req_ind,ddr_backup_reg_content->
        tgt_backup_list[dgntd_idx].cre_key_ind)=0)
        RETURN(0)
       ENDIF
     ENDFOR
    ENDIF
    IF (ddr_backup_srvreg_content_load(null)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_backup_srvreg_content->tgt_backup_list_cnt > 0))
     FOR (dgntd_idx = 1 TO ddr_backup_srvreg_content->tgt_backup_list_cnt)
       IF (ddr_backup_srvreg_content(ddr_backup_srvreg_content->tgt_backup_list[dgntd_idx].mode,
        ddr_backup_srvreg_content->tgt_backup_list[dgntd_idx].entry,ddr_backup_srvreg_content->
        tgt_backup_list[dgntd_idx].dest_dir,ddr_backup_srvreg_content->tgt_backup_list[dgntd_idx].
        dest_fname,ddr_backup_srvreg_content->tgt_backup_list[dgntd_idx].options,
        ddr_backup_srvreg_content->tgt_backup_list[dgntd_idx].req_ind)=0)
        RETURN(0)
       ENDIF
     ENDFOR
    ENDIF
    IF (ddr_write_misc_data(0,1)=0)
     RETURN(0)
    ENDIF
    IF (ddr_summary(0,1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_file_date(dgfd_file_name,dgfd_file_date)
   DECLARE dgfd_cmd = vc WITH protect, noconstant("")
   DECLARE dgfd_dir_ret_file = vc WITH protect, noconstant("")
   DECLARE dgfd_date_str = vc WITH protect, noconstant("")
   DECLARE dgfd_name_cut = vc WITH protect, noconstant("")
   DECLARE dgfd_delim = vc WITH protect, noconstant(evaluate(dm2_sys_misc->cur_os,"AXP","]","/"))
   IF (findstring(dgfd_delim,dgfd_file_name,1,1) > 0)
    SET dgfd_name_cut = substring((findstring(dgfd_delim,dgfd_file_name,1,1)+ 1),(size(dgfd_file_name
      ) - findstring(dgfd_delim,dgfd_file_name,1,1)),dgfd_file_name)
   ELSEIF ((dm2_sys_misc->cur_os="AXP")
    AND findstring(":",dgfd_file_name,1,1) > 0)
    SET dgfd_name_cut = substring((findstring(":",dgfd_file_name,1,1)+ 1),(size(dgfd_file_name) -
     findstring(":",dgfd_file_name,1,1)),dgfd_file_name)
   ELSE
    SET dgfd_name_cut = dgfd_file_name
   ENDIF
   SET dm_err->eproc = concat("Check if ",dgfd_file_name," exists.")
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dgfd_file_name)=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "File does not exist. Unable to obtain date."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dgfd_file_name)=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "File does not exist. Unable to obtain date."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (get_unique_file("chkdate",".dat")=0)
    RETURN(0)
   ELSE
    SET dgfd_dir_ret_file = dm_err->unique_fname
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dm_err->eproc = concat("Pipe dir into ",dgfd_dir_ret_file," to later get date of file.")
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET dgfd_cmd = concat("pipe dir/date ",dgfd_file_name," > ",dgfd_dir_ret_file)
    CALL dcl(dgfd_cmd,size(dgfd_cmd),dm_err->ecode)
    IF ((dm_err->ecode=0))
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("ERROR Executing ",dgfd_cmd)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Pipe list into ",dgfd_dir_ret_file," to later get date of file.")
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET dgfd_cmd = concat("ls -lt ",dgfd_file_name," | awk '{print $6,$7,$8}' > ",dgfd_dir_ret_file)
    CALL dcl(dgfd_cmd,size(dgfd_cmd),dm_err->ecode)
    IF ((dm_err->ecode=0))
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("ERROR Executing ",dgfd_cmd)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgfd_name_cut = replace(dgfd_name_cut,"*.*;*","",0)
   ELSE
    SET dgfd_name_cut = replace(dgfd_name_cut,"*.dmp","",0)
   ENDIF
   SET dm_err->eproc = concat("Open ",dgfd_dir_ret_file," to parse date.")
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET logical dgfd_data_file dgfd_dir_ret_file
   FREE DEFINE rtl
   DEFINE rtl "dgfd_data_file"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    HEAD REPORT
     dgfd_date_str = "x"
    DETAIL
     IF ((dm_err->debug_flag > 2))
      CALL echo(t.line)
     ENDIF
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF (dgfd_date_str="")
       IF (findstring("-",t.line,1,0) > 0)
        dgfd_date_str = substring((findstring("-",t.line,1,0) - 2),(findstring(".",t.line,1,1)+ 2),t
         .line)
       ENDIF
      ELSE
       IF (findstring(cnvtupper(dgfd_name_cut),cnvtupper(t.line),1,1) > 0)
        IF (findstring("-",t.line,1,0) > 0)
         dgfd_date_str = substring((findstring("-",t.line,1,0) - 2),(findstring(".",t.line,1,1)+ 2),t
          .line)
        ELSE
         dgfd_date_str = ""
        ENDIF
       ENDIF
      ENDIF
     ELSE
      IF (dgfd_date_str="x")
       CASE (cnvtupper(substring(1,3,t.line)))
        OF "JAN":
         xmonth = 1
        OF "FEB":
         xmonth = 2
        OF "MAR":
         xmonth = 3
        OF "APR":
         xmonth = 4
        OF "MAY":
         xmonth = 5
        OF "JUN":
         xmonth = 6
        OF "JUL":
         xmonth = 7
        OF "AUG":
         xmonth = 8
        OF "SEP":
         xmonth = 9
        OF "OCT":
         xmonth = 10
        OF "NOV":
         xmonth = 11
        OF "DEC":
         xmonth = 12
       ENDCASE
       IF (findstring(":",substring(7,6,t.line),1,0) > 0)
        IF (xmonth > month(cnvtdatetime(curdate,curtime3)))
         xyear = (year(curdate) - 1)
        ELSE
         xyear = year(curdate)
        ENDIF
        xtime = substring((findstring(":",t.line,1,0) - 2),5,t.line)
       ELSE
        xyear = cnvtint(substring(7,6,t.line)), xtime = "00:00"
       ENDIF
       xday = cnvtint(substring(5,2,t.line)), xdatestr = build(xday,"-",cnvtupper(substring(1,3,t
          .line)),"-",xyear,
        concat(" ",xtime)), xdateint = cnvtdatetime(xdatestr)
       IF ((dm_err->debug_flag > 0))
        CALL echo(xday),
        CALL echo(xyear),
        CALL echo(xmonth),
        CALL echo(xdatestr),
        CALL echo(xtime)
       ENDIF
       dgfd_date_str = trim(xdatestr)
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("DATE FOUND:",dgfd_date_str))
   ENDIF
   SET dgfd_file_date = cnvtdatetime(evaluate(dgfd_date_str,"x","0.0",dgfd_date_str))
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_write_misc_data(dwmd_src_ind,dwmd_tgt_ind)
   DECLARE dwmd_file = vc WITH protect, noconstant(concat(evaluate(dwmd_src_ind,1,ddr_domain_data->
      src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir),ddr_domain_data->data_file_name))
   DECLARE dwmd_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dwmd_str = vc WITH protect, noconstant("")
   DECLARE dwmd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dwmd_suffix = vc WITH protect, noconstant(";*")
   IF (dm2_findfile(dwmd_file) > 0)
    IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","del","rm")," ",evaluate(dm2_sys_misc
       ->cur_os,"AXP",concat(dwmd_file,dwmd_suffix),dwmd_file)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Writing source data to ",dwmd_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET logical dwmd_config_file dwmd_file
   SELECT INTO "dwmd_config_file"
    DETAIL
     IF (dwmd_src_ind=1)
      dwmd_str = concat('src_cer_data_dev,"',ddr_domain_data->src_cer_data_dev,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_wh,"',ddr_domain_data->src_wh,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_wh_device,"',ddr_domain_data->src_wh_device,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_cer_install_dir,"',ddr_domain_data->src_cer_install_dir,'"'), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('src_revision_level,"',ddr_domain_data->src_revision_level,'"'), col
       0,
      dwmd_str, row + 1, dwmd_str = concat('src_system,"',ddr_domain_data->src_system,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_system_pwd,"',ddr_domain_data->src_system_pwd,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat("offline_dict_ind,",build(ddr_domain_data->offline_dict_ind)), col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_domain_name,"',ddr_domain_data->src_domain_name,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_priv,"',ddr_domain_data->src_priv,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_priv_pwd,"',ddr_domain_data->src_priv_pwd,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_mng,"',ddr_domain_data->src_mng,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_mng_pwd,"',ddr_domain_data->src_mng_pwd,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_sec_user_name,"',ddr_domain_data->src_sec_user_name,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_local_user_name,"',ddr_domain_data->
       src_local_user_name,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("src_auth_server_id,",build(ddr_domain_data->src_auth_server_id)), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('src_auth_server_desc,"',ddr_domain_data->src_auth_server_desc,'"'),
      col 0,
      dwmd_str, row + 1, dwmd_str = concat("src_scp_server_id,",build(ddr_domain_data->
        src_scp_server_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_scp_server_desc,"',ddr_domain_data->src_scp_server_desc,'"'), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat("src_tdb_server_master_id,",build(ddr_domain_data->
        src_tdb_server_master_id)), col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_tdb_server_master_desc,"',ddr_domain_data->
       src_tdb_server_master_desc,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("src_tdb_server_slave_id,",build(ddr_domain_data->src_tdb_server_slave_id)),
      col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_tdb_server_slave_desc,"',ddr_domain_data->
       src_tdb_server_slave_desc,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("src_sec_server_master_id,",build(ddr_domain_data->
        src_sec_server_master_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_sec_server_master_desc,"',ddr_domain_data->src_sec_server_master_desc,
       '"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_sec_server_master_lrl,"',ddr_domain_data->
       src_sec_server_master_lrl,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("src_sec_server_slave_id,",build(ddr_domain_data->
        src_sec_server_slave_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('src_sec_server_slave_desc,"',ddr_domain_data->src_sec_server_slave_desc,'"'),
      col 0, dwmd_str,
      row + 1, dwmd_str = concat('src_sec_server_slave_lrl,"',ddr_domain_data->
       src_sec_server_slave_lrl,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("src_tdb_count,",build(ddr_domain_data->src_tdb_count)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("src_server_count,",build(ddr_domain_data->src_server_count)), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('src_db_env_name,"',ddr_domain_data->src_db_env_name,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("src_was_arch_ind,",build(ddr_domain_data->
        src_was_arch_ind)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("src_ccl_grants_ind,",build(ddr_domain_data->src_ccl_grants_ind)), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat("src_ops_ver,",build(ddr_domain_data->src_ops_ver)), col 0,
      dwmd_str, row + 1
      IF ((dm2_sys_misc->cur_os="AXP"))
       dwmd_str = concat('src_ccldir,"',ddr_domain_data->src_ccldir,'"'), col 0, dwmd_str,
       row + 1, dwmd_str = concat('src_ccluserdir_dir,"',ddr_domain_data->src_ccluserdir_dir,'"'),
       col 0,
       dwmd_str, row + 1, dwmd_str = concat('src_ocdtools_dir,"',ddr_domain_data->src_ocdtools_dir,
        '"'),
       col 0, dwmd_str, row + 1,
       dwmd_str = concat('src_warehouse_dir,"',ddr_domain_data->src_warehouse_dir,'"'), col 0,
       dwmd_str,
       row + 1, dwmd_str = concat('src_cer_config_dir,"',ddr_domain_data->src_cer_config_dir,'"'),
       col 0,
       dwmd_str, row + 1
      ENDIF
      FOR (dwmd_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
        dwmd_str = concat("node_name,",ddr_domain_data->src_nodes[dwmd_cnt].node_name), col 0,
        dwmd_str,
        row + 1
      ENDFOR
      dwmd_str = concat('src_tdb_curpages,"',build(ddr_domain_data->src_tdb_curpages),'"'), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('src_tdb_maxpages,"',build(ddr_domain_data->src_tdb_maxpages),'"'),
      col 0,
      dwmd_str, row + 1, dwmd_str = concat('src_tdb_init_size,"',build(ddr_domain_data->
        src_tdb_init_size),'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("src_ldap_ind,",build(ddr_domain_data->src_ldap_ind)), col 0, dwmd_str,
      row + 1
     ELSE
      dwmd_str = concat('tgt_cer_data_dev,"',ddr_domain_data->tgt_cer_data_dev,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_wh,"',ddr_domain_data->tgt_wh,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_wh_device,"',ddr_domain_data->tgt_wh_device,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_cer_install_dir,"',ddr_domain_data->tgt_cer_install_dir,'"'), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('tgt_revision_level,"',ddr_domain_data->tgt_revision_level,'"'), col
       0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_system,"',ddr_domain_data->tgt_system,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_system_pwd,"',ddr_domain_data->tgt_system_pwd,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat("offline_dict_ind,",build(ddr_domain_data->offline_dict_ind)), col 0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_domain_name,"',ddr_domain_data->tgt_domain_name,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_priv,"',ddr_domain_data->tgt_priv,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_priv_pwd,"',ddr_domain_data->tgt_priv_pwd,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_mng,"',ddr_domain_data->tgt_mng,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_mng_pwd,"',ddr_domain_data->tgt_mng_pwd,'"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_sec_user_name,"',ddr_domain_data->tgt_sec_user_name,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_local_user_name,"',ddr_domain_data->
       tgt_local_user_name,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("tgt_auth_server_id,",build(ddr_domain_data->tgt_auth_server_id)), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat('tgt_auth_server_desc,"',ddr_domain_data->tgt_auth_server_desc,'"'),
      col 0,
      dwmd_str, row + 1, dwmd_str = concat("tgt_scp_server_id,",build(ddr_domain_data->
        tgt_scp_server_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_scp_server_desc,"',ddr_domain_data->tgt_scp_server_desc,'"'), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat("tgt_tdb_server_master_id,",build(ddr_domain_data->
        tgt_tdb_server_master_id)), col 0,
      dwmd_str, row + 1, dwmd_str = concat('tgt_tdb_server_master_desc,"',ddr_domain_data->
       tgt_tdb_server_master_desc,'"'),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("tgt_tdb_server_slave_id,",build(ddr_domain_data->tgt_tdb_server_slave_id)),
      col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_tdb_server_slave_desc,"',ddr_domain_data->
       tgt_tdb_server_slave_desc,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("tgt_sec_server_master_id,",build(ddr_domain_data->
        tgt_sec_server_master_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_sec_server_master_desc,"',ddr_domain_data->tgt_sec_server_master_desc,
       '"'), col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_sec_server_master_lrl,"',ddr_domain_data->
       tgt_sec_server_master_lrl,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("tgt_sec_server_slave_id,",build(ddr_domain_data->
        tgt_sec_server_slave_id)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat('tgt_sec_server_slave_desc,"',ddr_domain_data->tgt_sec_server_slave_desc,'"'),
      col 0, dwmd_str,
      row + 1, dwmd_str = concat('tgt_sec_server_slave_lrl,"',ddr_domain_data->
       tgt_sec_server_slave_lrl,'"'), col 0,
      dwmd_str, row + 1, dwmd_str = concat("tgt_node_flag,",build(ddr_domain_data->tgt_node_flag)),
      col 0, dwmd_str, row + 1,
      dwmd_str = concat("tgt_was_arch_ind,",build(ddr_domain_data->tgt_was_arch_ind)), col 0,
      dwmd_str,
      row + 1, dwmd_str = concat("tgt_ccl_grants_ind,",build(ddr_domain_data->tgt_ccl_grants_ind)),
      col 0,
      dwmd_str, row + 1
      FOR (dwmd_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
        dwmd_str = concat("node_name,",ddr_domain_data->tgt_nodes[dwmd_cnt].node_name), col 0,
        dwmd_str,
        row + 1
      ENDFOR
      dwmd_str = concat("tgt_ldap_ind,",build(ddr_domain_data->tgt_ldap_ind)), col 0, dwmd_str,
      row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dwmd_src_ind=1)
    SET ddr_domain_data->src_data_fnd = 1
   ELSE
    SET ddr_domain_data->tgt_data_fnd = 1
   ENDIF
   IF (ddr_get_file_date(dwmd_file,dwmd_file_date)=0)
    RETURN(0)
   ENDIF
   IF (dwmd_src_ind=1)
    SET ddr_domain_data->src_data_ts = dwmd_file_date
   ELSE
    SET ddr_domain_data->tgt_data_ts = dwmd_file_date
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_misc_data(dgmd_src_ind,dgmd_tgt_ind)
   DECLARE dgmd_env = vc WITH protect, noconstant("")
   DECLARE dgmd_str = vc WITH protect, noconstant("")
   DECLARE dgmd_ret_val = vc WITH protect, noconstant("")
   DECLARE dgmd_domain = vc WITH protect, noconstant("")
   DECLARE dgmd_wh = vc WITH protect, noconstant("")
   DECLARE dgmd_server_id = vc WITH protect, noconstant("")
   DECLARE dgmd_server_desc = vc WITH protect, noconstant("")
   DECLARE dgmd_from_dir = vc WITH protect, noconstant("")
   DECLARE dgmd_replicate_tgt_skip = i2 WITH protect, noconstant(0)
   DECLARE dgmd_user = vc WITH protect, noconstant("")
   DECLARE dgmd_pass = vc WITH protect, noconstant("")
   DECLARE dgmd_has_privs = i2 WITH protect, noconstant(1)
   DECLARE dgmd_was_ind = i2 WITH protect, noconstant(0)
   DECLARE dgmd_tdb_file = vc WITH protect, noconstant("")
   DECLARE dgmd_ldap_ind = i2 WITH protect, noconstant(0)
   IF (dgmd_tgt_ind=1
    AND (ddr_domain_data->process="REPLICATE"))
    SET dgmd_replicate_tgt_skip = 1
   ENDIF
   SET dgmd_env = evaluate(dgmd_src_ind,1,ddr_domain_data->src_env,ddr_domain_data->tgt_env)
   IF (dgmd_src_ind=1)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET ddr_domain_data->src_cer_data_dev = substring(1,(findstring(":",trim(logical("cer_data")),1,
       1) - 1),trim(logical("cer_data")))
    ELSE
     SET ddr_domain_data->src_cer_data_dev = trim(logical("cer_data"))
    ENDIF
   ELSE
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET ddr_domain_data->tgt_cer_data_dev = substring(1,(findstring(":",trim(logical("cer_data")),1,
       1) - 1),trim(logical("cer_data")))
    ELSE
     SET ddr_domain_data->tgt_cer_data_dev = trim(logical("cer_data"))
    ENDIF
   ENDIF
   SET dm_err->eproc = "Get domain name."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dgmd_str = concat("\\environment\\",dgmd_env," Domain")
   IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
    RETURN(0)
   ENDIF
   SET dgmd_domain = dgmd_ret_val
   IF (dgmd_src_ind=1)
    SET ddr_domain_data->src_domain_name = dgmd_ret_val
   ELSE
    SET ddr_domain_data->tgt_domain_name = dgmd_ret_val
   ENDIF
   IF (dgmd_ret_val="NOPARMRETURNED")
    SET dm_err->emsg = concat("Unable to retrieve domain name property for ",dgmd_env)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((validate(dm2_bypass_was_check,- (1))=- (1)))
    IF (drr_identify_was_usage(dgmd_domain,dgmd_was_ind)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_was_arch_ind = dgmd_was_ind
    ELSE
     SET ddr_domain_data->tgt_was_arch_ind = dgmd_was_ind
    ENDIF
   ENDIF
   SET dm_err->eproc = "Get warehouse."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgmd_str = concat("\environment\",dgmd_env,' "warehouse1"')
   ELSE
    SET dgmd_str = concat("\\environment\\",dgmd_env,' "warehouse1"')
   ENDIF
   IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
    RETURN(0)
   ENDIF
   IF (dgmd_ret_val="NOPARMRETURNED")
    SET dm_err->emsg = concat("Unable to retrieve warehouse name for ",dgmd_env)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgmd_wh = cnvtlower(dgmd_ret_val)
   IF (dgmd_src_ind=1)
    SET ddr_domain_data->src_wh = cnvtlower(dgmd_ret_val)
   ELSE
    SET ddr_domain_data->tgt_wh = cnvtlower(dgmd_ret_val)
   ENDIF
   IF (dgmd_src_ind=1)
    SET ddr_domain_data->src_wh_device = evaluate(dm2_sys_misc->cur_os,"AXP",substring(1,(findstring(
       ":",trim(logical("cer_wh1")),1,1) - 1),trim(logical("cer_wh1"))),trim(logical("cer_wh")))
   ELSE
    SET ddr_domain_data->tgt_wh_device = evaluate(dm2_sys_misc->cur_os,"AXP",substring(1,(findstring(
       ":",trim(logical("cer_wh1")),1,1) - 1),trim(logical("cer_wh1"))),trim(logical("cer_wh")))
   ENDIF
   IF (dgmd_src_ind=1)
    SET ddr_domain_data->src_cer_install_dir = trim(logical("cer_install"))
   ELSE
    SET ddr_domain_data->tgt_cer_install_dir = trim(logical("cer_install"))
   ENDIF
   SET dm_err->eproc = "Get revision level."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgmd_str = concat("\warehouse\",dgmd_wh,' "revision level"')
   ELSE
    SET dgmd_str = concat("\\warehouse\\",dgmd_wh,' "revision level"')
   ENDIF
   IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
    RETURN(0)
   ENDIF
   IF (dgmd_ret_val="NOPARMRETURNED")
    SET dm_err->emsg = concat("Unable to retrieve revision level property for ",dgmd_wh)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgmd_src_ind=1)
    SET ddr_domain_data->src_revision_level = cnvtlower(dgmd_ret_val)
   ELSE
    SET ddr_domain_data->tgt_revision_level = cnvtlower(dgmd_ret_val)
   ENDIF
   SET dgmd_str = "$cer_exe/server_ctrl"
   IF (dm2_findfile(dgmd_str) > 0)
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_revision_level = "2015.01"
    ELSE
     SET ddr_domain_data->tgt_revision_level = "2015.01"
    ENDIF
   ENDIF
   IF (dgmd_replicate_tgt_skip=0)
    SET dm_err->eproc = "Get priv user."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\51 logonuser")
    ELSE
     SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,
      "\\servers\\51 logonuser")
    ENDIF
    IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve priv user for ",dgmd_domain)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_priv = dgmd_ret_val
    ELSE
     SET ddr_domain_data->tgt_priv = dgmd_ret_val
    ENDIF
    SET dm_err->eproc = "Get system password."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\51 logonpassword")
    ELSE
     SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,
      "\\servers\\51 logonpassword")
    ENDIF
    IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve priv user password for ",dgmd_domain)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_priv_pwd = dgmd_ret_val
    ELSE
     SET ddr_domain_data->tgt_priv_pwd = dgmd_ret_val
    ENDIF
    SET dm_err->eproc = "Get source system."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\57 logonuser")
    ELSE
     SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,
      "\\servers\\57 logonuser")
    ENDIF
    IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve system user for ",dgmd_domain)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_system = dgmd_ret_val
    ELSE
     SET ddr_domain_data->tgt_system = dgmd_ret_val
    ENDIF
    SET dm_err->eproc = "Get system password."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\57 logonpassword")
    ELSE
     SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,
      "\\servers\\57 logonpassword")
    ENDIF
    IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve system user password for ",dgmd_domain)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_system_pwd = dgmd_ret_val
    ELSE
     SET ddr_domain_data->tgt_system_pwd = dgmd_ret_val
    ENDIF
    IF (((trim(logical("ccldiraccess"),3)="") OR (((trim(logical("ccldir1"),3)="") OR (trim(logical(
      "ccldir2"),3)="")) )) )
     SET ddr_domain_data->offline_dict_ind = 0
    ELSE
     SET ddr_domain_data->offline_dict_ind = 1
    ENDIF
    IF (validate(drrr_responsefile_in_use,0)=0)
     IF (ddr_get_mng_userpass(dgmd_src_ind,dgmd_tgt_ind)=0)
      RETURN(0)
     ENDIF
    ELSE
     IF (dgmd_src_ind=1)
      SET dgmd_user = ddr_domain_data->src_mng
      SET dgmd_pass = ddr_domain_data->src_mng_pwd
     ELSE
      SET dgmd_user = ddr_domain_data->tgt_mng
      SET dgmd_pass = ddr_domain_data->tgt_mng_pwd
     ENDIF
     IF (ddr_check_mng_accnt_privs(dgmd_src_ind,dgmd_tgt_ind,dgmd_user,dgmd_pass,dgmd_has_privs)=0)
      RETURN(0)
     ENDIF
     IF (dgmd_has_privs=1)
      SET dm_err->eproc = "Managed account provided has the required privileges."
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg(" ",dm_err->logfile,0)
      ENDIF
     ELSEIF (dgmd_has_privs=2)
      SET dm_err->eproc = "Verify the managed account provided has sufficient privileges"
      SET dm_err->emsg = "The managed account provided could not be validated."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSEIF (dgmd_has_privs=0)
      SET dm_err->eproc = "Verify the managed account provided has sufficient privileges"
      SET dm_err->emsg =
      "The account provided does not have required privileges. Please choose another account."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((validate(dm2_bypass_ldap_check,- (1))=- (1)))
     IF (dgmd_src_ind=1)
      IF (ddr_identify_ldap_usage(dgmd_env,dgmd_domain,ddr_domain_data->src_mng,ddr_domain_data->
       src_mng_pwd,ddr_domain_data->src_system,
       ddr_domain_data->src_priv,dgmd_was_ind,dgmd_ldap_ind)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->src_ldap_ind = dgmd_ldap_ind
     ELSE
      IF (ddr_identify_ldap_usage(dgmd_env,dgmd_domain,ddr_domain_data->tgt_mng,ddr_domain_data->
       tgt_mng_pwd,ddr_domain_data->tgt_system,
       ddr_domain_data->tgt_priv,dgmd_was_ind,dgmd_ldap_ind)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_ldap_ind = dgmd_ldap_ind
     ENDIF
    ENDIF
   ELSE
    SET ddr_domain_data->tgt_priv = "system"
    SET ddr_domain_data->tgt_priv_pwd = "system"
    SET ddr_domain_data->tgt_system = "systemoe"
    SET ddr_domain_data->tgt_system_pwd = "systemoe"
    SET ddr_domain_data->tgt_mng = "cerner"
    SET ddr_domain_data->tgt_mng_pwd = "v5system"
   ENDIF
   IF (ddr_get_sec_user_name(dgmd_src_ind,dgmd_tgt_ind)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_local_user_name(dgmd_src_ind,dgmd_tgt_ind)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (ddr_get_local_group_name(dgmd_src_ind,dgmd_tgt_ind)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dgmd_replicate_tgt_skip=0)
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"authorize",dgmd_server_id,
     dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_auth_server_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_auth_server_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_auth_server_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_auth_server_desc = dgmd_server_desc
    ENDIF
    IF (dgmd_src_ind=1)
     IF ( NOT ((ddr_domain_data->src_auth_server_id > 0)))
      SET dm_err->eproc = "Finding Authorize server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find Authorize Server for SRC Domain: ",dgmd_domain)
      RETURN(0)
     ENDIF
    ELSE
     IF ( NOT ((ddr_domain_data->tgt_auth_server_id > 0)))
      SET dm_err->eproc = "Finding Authorize server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find Authorize Server for TGT Domain: ",dgmd_domain)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"transaction database master",
     dgmd_server_id,dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_tdb_server_master_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_tdb_server_master_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_tdb_server_master_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_tdb_server_master_desc = dgmd_server_desc
    ENDIF
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"transaction database slave",
     dgmd_server_id,dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_tdb_server_slave_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_tdb_server_slave_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_tdb_server_slave_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_tdb_server_slave_desc = dgmd_server_desc
    ENDIF
    IF (dgmd_src_ind=1)
     IF ( NOT ((ddr_domain_data->src_tdb_server_master_id > 0)))
      SET dm_err->eproc = "Finding TDB server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find Transaction Database Master Server for SRC domain: ",
       dgmd_domain)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ( NOT ((((ddr_domain_data->tgt_tdb_server_master_id > 0)) OR ((ddr_domain_data->
     tgt_tdb_server_slave_id > 0))) ))
      SET dm_err->eproc = "Finding TDB server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find both, Master AND Slave TDB Servers for TGT Domain: ",
       dgmd_domain)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"server control panel",dgmd_server_id,
     dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_scp_server_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_scp_server_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_scp_server_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_scp_server_desc = dgmd_server_desc
    ENDIF
    IF (dgmd_src_ind=1)
     IF ( NOT ((ddr_domain_data->src_scp_server_id > 0)))
      SET dm_err->eproc = "Finding Server Control Panel server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find server control panel Server for SRC Domain: ",
       dgmd_domain)
      RETURN(0)
     ENDIF
    ELSE
     IF ( NOT ((ddr_domain_data->tgt_scp_server_id > 0)))
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find server control panel Server for TGT Domain: ",
       dgmd_domain)
      RETURN(0)
     ENDIF
    ENDIF
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"security master",dgmd_server_id,
     dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_sec_server_master_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_sec_server_master_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_sec_server_master_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_sec_server_master_desc = dgmd_server_desc
    ENDIF
    IF (cnvtint(dgmd_server_id) > 0)
     SET dm_err->eproc = "Get Security Master's property Lock Request Limit."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg(" ",dm_err->logfile,0)
     ENDIF
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\",
       trim(dgmd_server_id),'\prop "Lock Request Limit"')
     ELSE
      SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,"\\servers\\",
       trim(dgmd_server_id),'\\prop "Lock Request Limit"')
     ENDIF
     IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
      RETURN(0)
     ENDIF
     IF (dgmd_src_ind=1)
      SET ddr_domain_data->src_sec_server_master_lrl = dgmd_ret_val
     ELSE
      SET ddr_domain_data->tgt_sec_server_master_lrl = dgmd_ret_val
     ENDIF
    ENDIF
    IF (ddr_get_srv_info(evaluate(dgmd_src_ind,1,"src","tgt"),"security slave",dgmd_server_id,
     dgmd_server_desc)=0)
     RETURN(0)
    ENDIF
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_sec_server_slave_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->src_sec_server_slave_desc = dgmd_server_desc
    ELSE
     SET ddr_domain_data->tgt_sec_server_slave_id = cnvtint(dgmd_server_id)
     SET ddr_domain_data->tgt_sec_server_slave_desc = dgmd_server_desc
    ENDIF
    IF (cnvtint(dgmd_server_id) > 0)
     SET dm_err->eproc = "Get Security Slave's property Lock Request Limit."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg(" ",dm_err->logfile,0)
     ENDIF
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\",
       trim(dgmd_server_id),'\prop "Lock Request Limit"')
     ELSE
      SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,"\\servers\\",
       trim(dgmd_server_id),'\\prop "Lock Request Limit"')
     ENDIF
     IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
      RETURN(0)
     ENDIF
     IF (dgmd_src_ind=1)
      SET ddr_domain_data->src_sec_server_slave_lrl = dgmd_ret_val
     ELSE
      SET ddr_domain_data->tgt_sec_server_slave_lrl = dgmd_ret_val
     ENDIF
    ENDIF
    IF (dgmd_src_ind=1)
     IF ( NOT ((((ddr_domain_data->src_sec_server_master_id > 0)) OR ((ddr_domain_data->
     src_sec_server_slave_id > 0))) )
      AND dgmd_was_ind=0)
      SET dm_err->eproc = "Finding Security server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat(
       "Failed to find both, Master AND Slave Security Servers for SRC Domain: ",dgmd_domain)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ( NOT ((((ddr_domain_data->tgt_sec_server_master_id > 0)) OR ((ddr_domain_data->
     tgt_sec_server_slave_id > 0))) )
      AND dgmd_was_ind=0)
      SET dm_err->eproc = "Finding Security server id and description"
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat(
       "Failed to find both, Master AND Slave Security Servers for TGT Domain: ",dgmd_domain)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF ((ddr_domain_data->process="REFRESH")
      AND (ddr_domain_data->tgt_sec_server_master_id > 0))
      SET dm_err->eproc = "Check if Security Master is Protected."
      CALL disp_msg("",dm_err->logfile,0)
      IF ((dm2_sys_misc->cur_os="AXP"))
       SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\",
        trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id))," Protect")
      ELSE
       SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,"\\servers\\",
        trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id))," Protect")
      ENDIF
      IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
       RETURN(0)
      ENDIF
      IF (cnvtupper(dgmd_ret_val) != "Y"
       AND dgmd_was_ind=0)
       SET dm_err->eproc = "Set Security Master to Protected."
       CALL disp_msg("",dm_err->logfile,0)
       IF ((dm2_sys_misc->cur_os="AXP"))
        SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\",
         trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id)),' Protect "Y"')
       ELSE
        SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,"\\servers\\",
         trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id)),' Protect "Y"')
       ENDIF
       IF (ddr_lreg_oper("SET",dgmd_str,dgmd_ret_val)=0)
        RETURN(0)
       ENDIF
       IF (ddr_scp_apply(cnvtstring(ddr_domain_data->tgt_sec_server_master_id),dgmd_src_ind,
        dgmd_tgt_ind)=0)
        RETURN(0)
       ENDIF
       IF ((dm2_sys_misc->cur_os="AXP"))
        SET dgmd_str = concat("\node\",trim(curnode),"\domain\",dgmd_domain,"\servers\",
         trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id))," Protect")
       ELSE
        SET dgmd_str = concat("\\node\\",trim(curnode),"\\domain\\",dgmd_domain,"\\servers\\",
         trim(cnvtstring(ddr_domain_data->tgt_sec_server_master_id))," Protect")
       ENDIF
       IF (ddr_lreg_oper("GET",dgmd_str,dgmd_ret_val)=0)
        RETURN(0)
       ENDIF
       IF (cnvtupper(dgmd_ret_val) != "Y")
        SET dm_err->emsg = "Error setting protect property for Security Master."
        SET dm_err->err_ind = 1
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   IF (dgmd_src_ind=1)
    IF (ddr_get_tdb_file(1,0,ddr_domain_data->src_tdb_server_master_id,dgmd_tdb_file)=0)
     RETURN(0)
    ENDIF
    IF (ddr_get_tdb_data(dgmd_tdb_file)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dgmd_src_ind=1
    AND (dm2_sys_misc->cur_os="AXP"))
    IF (ddr_get_from_dir(1,"ccluserdir",dgmd_from_dir)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (dgmd_src_ind=1)
     SET ddr_domain_data->src_warehouse_dir = ""
     SET ddr_domain_data->src_cer_config_dir = ""
     SET ddr_domain_data->src_ccluserdir_dir = ""
     SET ddr_domain_data->src_ocdtools_dir = ""
     SET ddr_domain_data->src_ccldir = ""
    ENDIF
   ENDIF
   IF (dgmd_src_ind=0)
    SET ddr_domain_data->tgt_warehouse_dir = ""
    SET ddr_domain_data->tgt_cer_config_dir = ""
    SET ddr_domain_data->tgt_ccluserdir_dir = ""
    SET ddr_domain_data->tgt_ocdtools_dir = ""
    SET ddr_domain_data->tgt_ccldir = ""
   ENDIF
   IF (dgmd_src_ind=1)
    IF (ddr_get_ops_version("")=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_ops_ver = ddr_ops_info->version
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_read_misc_data(drmd_src_ind,drmd_tgt_ind)
   DECLARE drmd_cnt = i4 WITH protect, noconstant(0)
   DECLARE drmd_file = vc WITH protect, noconstant(concat(evaluate(drmd_src_ind,1,ddr_domain_data->
      src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir),ddr_domain_data->data_file_name))
   DECLARE drmd_file_date = f8 WITH protect, noconstant(0.0)
   FREE RECORD drmd_cmd
   RECORD drmd_cmd(
     1 qual[*]
       2 rs_item = vc
       2 rs_item_value = vc
   )
   SET dm_err->eproc = concat("Read ",drmd_file)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET logical drmd_config_file drmd_file
   FREE DEFINE rtl
   DEFINE rtl "drmd_config_file"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     drmd_cnt = (drmd_cnt+ 1), stat = alterlist(drmd_cmd->qual,drmd_cnt), drmd_cmd->qual[drmd_cnt].
     rs_item = substring(1,(findstring(",",t.line,1,0) - 1),t.line),
     drmd_cmd->qual[drmd_cnt].rs_item_value = substring((findstring(",",t.line,1,0)+ 1),(size(t.line)
       - findstring(",",t.line,1,0)),t.line)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drmd_cmd)
   ENDIF
   IF (drmd_src_ind=0)
    SET stat = alterlist(ddr_domain_data->tgt_nodes,0)
    SET ddr_domain_data->tgt_nodes_cnt = 0
   ELSE
    SET stat = alterlist(ddr_domain_data->src_nodes,0)
    SET ddr_domain_data->src_nodes_cnt = 0
   ENDIF
   SET drmd_cnt = 0
   FOR (drmd_cnt = 1 TO size(drmd_cmd->qual,5))
     IF ((drmd_cmd->qual[drmd_cnt].rs_item="node_name"))
      IF (drmd_src_ind=1)
       SET ddr_domain_data->src_nodes_cnt = (ddr_domain_data->src_nodes_cnt+ 1)
       SET stat = alterlist(ddr_domain_data->src_nodes,ddr_domain_data->src_nodes_cnt)
       SET ddr_domain_data->src_nodes[ddr_domain_data->src_nodes_cnt].node_name = drmd_cmd->qual[
       drmd_cnt].rs_item_value
      ELSE
       SET ddr_domain_data->tgt_nodes_cnt = (ddr_domain_data->tgt_nodes_cnt+ 1)
       SET stat = alterlist(ddr_domain_data->tgt_nodes,ddr_domain_data->tgt_nodes_cnt)
       SET ddr_domain_data->tgt_nodes[ddr_domain_data->tgt_nodes_cnt].node_name = drmd_cmd->qual[
       drmd_cnt].rs_item_value
      ENDIF
     ELSE
      CALL parser(concat("set ddr_domain_data->",drmd_cmd->qual[drmd_cnt].rs_item," = ",drmd_cmd->
        qual[drmd_cnt].rs_item_value," go"),1)
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drmd_cmd)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_source_data(null)
   DECLARE dvsd_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dvsd_str = vc WITH protect, noconstant("")
   DECLARE dvsd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvsd_scp_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvsd_cerinstall = vc WITH protect, noconstant(trim(logical("cer_install")))
   DECLARE dvsd_reg_src_env = vc WITH protect, noconstaint
   IF (size(ddr_domain_data->src_env,1) > max_reg_env_len)
    SET dvsd_reg_src_env = substring(1,max_reg_env_len,ddr_domain_data->src_env)
   ELSE
    SET dvsd_reg_src_env = ddr_domain_data->src_env
   ENDIF
   SET ddr_domain_data->src_restart_ind = 0
   SET ddr_domain_data->src_data_fnd = 0
   SET ddr_domain_data->src_data_ts = 0
   SET ddr_domain_data->src_ind_data_fnd = 0
   SET ddr_domain_data->src_dict_fnd = 0
   SET ddr_domain_data->src_dict_ts = 0
   SET ddr_domain_data->src_tdb_fnd = 0
   SET ddr_domain_data->src_tdb_ts = 0
   SET ddr_domain_data->src_srv_def_fnd = 0
   SET ddr_domain_data->src_srv_def_ts = 0
   SET ddr_domain_data->src_sec_user_fnd = 0
   SET ddr_domain_data->src_sec_user_ts = 0
   SET ddr_domain_data->src_env_reg_fnd = 0
   SET ddr_domain_data->src_sysdef_reg_ts = 0
   SET ddr_domain_data->src_sysdef_reg_fnd = 0
   SET ddr_domain_data->src_env_reg_ts = 0
   SET ddr_domain_data->src_invalid_tbls_fnd = 0
   SET ddr_domain_data->src_invalid_tbls_ts = 0
   SET ddr_domain_data->src_ocd_tools_fnd = 0
   SET ddr_domain_data->src_ocd_tools_ts = 0
   SET ddr_domain_data->src_wh_fnd = 0
   SET ddr_domain_data->src_wh_ts = 0
   SET ddr_domain_data->src_ccldir_fnd = 0
   SET ddr_domain_data->src_ccldir_ts = 0
   SET ddr_domain_data->src_config_fnd = 0
   SET ddr_domain_data->src_config_ts = 0
   SET ddr_domain_data->src_tdb_count = 0
   SET ddr_domain_data->src_server_count = 0
   SET ddr_domain_data->src_adm_env_csv_fnd = 0
   SET ddr_domain_data->src_adm_env_csv_ts = 0
   SET dm_err->eproc = concat("Check SOURCE DATA",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->data_file_name)) > 0)
    SET ddr_domain_data->src_data_fnd = 1
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->data_file_name),
     dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_data_ts = dvsd_file_date
    IF (ddr_read_misc_data(1,0)=0)
     RETURN(0)
    ELSE
     IF ((dm2_sys_misc->cur_os != "AXP"))
      SET ddr_domain_data->src_warehouse_dir = ""
      SET ddr_domain_data->src_cer_config_dir = ""
      SET ddr_domain_data->src_ccluserdir_dir = ""
      SET ddr_domain_data->src_ocdtools_dir = ""
      SET ddr_domain_data->src_ccldir = ""
     ENDIF
     IF ((((ddr_domain_data->src_cer_data_dev="DM2NOTSET")) OR ((((ddr_domain_data->src_wh=
     "DM2NOTSET")) OR ((((ddr_domain_data->src_wh_device="DM2NOTSET")) OR ((((ddr_domain_data->
     src_revision_level="DM2NOTSET")) OR ((((ddr_domain_data->src_system="DM2NOTSET")) OR ((((
     ddr_domain_data->src_system_pwd="DM2NOTSET")) OR ((((ddr_domain_data->src_priv="DM2NOTSET")) OR
     ((((ddr_domain_data->src_priv_pwd="DM2NOTSET")) OR ((((ddr_domain_data->src_mng="DM2NOTSET"))
      OR ((((ddr_domain_data->src_mng_pwd="DM2NOTSET")) OR ((((ddr_domain_data->
     src_tdb_server_master_id=0)) OR ((((ddr_domain_data->src_scp_server_id=0)) OR ((((
     ddr_domain_data->src_auth_server_id=0)) OR ((((ddr_domain_data->src_local_user_name="DM2NOTSET")
     ) OR ((((ddr_domain_data->src_ccldir="DM2NOTSET")) OR ((((ddr_domain_data->src_warehouse_dir=
     "DM2NOTSET")) OR ((((ddr_domain_data->src_cer_config_dir="DM2NOTSET")) OR ((((ddr_domain_data->
     src_ccluserdir_dir="DM2NOTSET")) OR ((((ddr_domain_data->src_ocdtools_dir="DM2NOTSET")) OR ((((
     ddr_domain_data->offline_dict_ind=- (1))) OR ((((ddr_domain_data->src_nodes_cnt=0)) OR ((((
     ddr_domain_data->src_tdb_count=0)) OR ((((ddr_domain_data->src_db_env_name="DM2NOTSET")) OR ((((
     ddr_domain_data->src_tdb_curpages="DM2NOTSET")) OR ((((ddr_domain_data->src_tdb_maxpages=
     "DM2NOTSET")) OR ((ddr_domain_data->src_tdb_init_size="DM2NOTSET"))) )) )) )) )) )) )) )) )) ))
     )) )) )) )) )) )) )) )) )) )) )) )) )) )) )) )
      SET ddr_domain_data->src_ind_data_fnd = 0
     ELSE
      IF ((ddr_domain_data->src_was_arch_ind=1))
       SET ddr_domain_data->src_ind_data_fnd = 1
      ELSE
       IF ((((ddr_domain_data->src_sec_user_name="DM2NOTSET")) OR ((ddr_domain_data->
       src_sec_server_master_id=0)
        AND (ddr_domain_data->src_sec_server_slave_id=0))) )
        SET ddr_domain_data->src_ind_data_fnd = 0
       ELSE
        SET ddr_domain_data->src_ind_data_fnd = 1
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ELSE
    SET ddr_domain_data->src_data_fnd = 0
   ENDIF
   IF ((ddr_domain_data->src_ind_data_fnd=0))
    SET dvsd_str = "Source data missing from misc_data.dat file include:  "
    IF ((ddr_domain_data->src_cer_data_dev="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"cer_data_dev, ")
    ENDIF
    IF ((ddr_domain_data->src_wh="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"wh, ")
    ENDIF
    IF ((ddr_domain_data->src_wh_device="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"wh_device, ")
    ENDIF
    IF ((ddr_domain_data->src_revision_level="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"revision_level, ")
    ENDIF
    IF ((ddr_domain_data->src_system="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"system, ")
    ENDIF
    IF ((ddr_domain_data->src_system_pwd="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"system_pwd, ")
    ENDIF
    IF ((ddr_domain_data->src_priv="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"priv, ")
    ENDIF
    IF ((ddr_domain_data->src_priv_pwd="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"priv_pwd, ")
    ENDIF
    IF ((ddr_domain_data->src_mng="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"mng, ")
    ENDIF
    IF ((ddr_domain_data->src_mng_pwd="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"mng_pwd, ")
    ENDIF
    IF ((ddr_domain_data->src_tdb_server_master_id=0))
     SET dvsd_str = concat(dvsd_str,"tdb_server_master_id, ")
    ENDIF
    IF ((ddr_domain_data->src_scp_server_id=0))
     SET dvsd_str = concat(dvsd_str,"scp_server_id, ")
    ENDIF
    IF ((ddr_domain_data->src_auth_server_id=0))
     SET dvsd_str = concat(dvsd_str,"auth_server_id, ")
    ENDIF
    IF ((ddr_domain_data->src_local_user_name="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"local_user_name, ")
    ENDIF
    IF ((ddr_domain_data->src_ccldir="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"ccldir, ")
    ENDIF
    IF ((ddr_domain_data->src_warehouse_dir="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"warehouse_dir, ")
    ENDIF
    IF ((ddr_domain_data->src_cer_config_dir="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"cer_config_dir, ")
    ENDIF
    IF ((ddr_domain_data->src_ccluserdir_dir="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"ccluserdir_dir, ")
    ENDIF
    IF ((ddr_domain_data->src_ocdtools_dir="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"ocdtools_dir, ")
    ENDIF
    IF ((ddr_domain_data->offline_dict_ind=- (1)))
     SET dvsd_str = concat(dvsd_str,"offline_dict_ind, ")
    ENDIF
    IF ((ddr_domain_data->src_nodes_cnt=0))
     SET dvsd_str = concat(dvsd_str,"src_nodes, ")
    ENDIF
    IF ((ddr_domain_data->src_tdb_count=0))
     SET dvsd_str = concat(dvsd_str,"tdb_count, ")
    ENDIF
    IF ((ddr_domain_data->src_db_env_name="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"db_env_name, ")
    ENDIF
    IF ((ddr_domain_data->src_tdb_curpages="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"tdb_curpages, ")
    ENDIF
    IF ((ddr_domain_data->src_tdb_maxpages="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"tdb_maxpages, ")
    ENDIF
    IF ((ddr_domain_data->src_tdb_init_size="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"tdb_init_size, ")
    ENDIF
    IF ((ddr_domain_data->src_was_arch_ind=0)
     AND (ddr_domain_data->src_sec_user_name="DM2NOTSET"))
     SET dvsd_str = concat(dvsd_str,"sec_user_name, ")
    ENDIF
    IF ((ddr_domain_data->src_was_arch_ind=0)
     AND (ddr_domain_data->src_sec_server_master_id=0)
     AND (ddr_domain_data->src_sec_server_slave_id=0))
     SET dvsd_str = concat(dvsd_str,"sec_server_master/slave_id(s), ")
    ENDIF
    SET dvsd_str = replace(dvsd_str,",","",2)
    SET dm_err->eproc = dvsd_str
    CALL disp_msg(" ",dm_err->logfile,0)
    SET ddr_domain_data->src_restart_ind = 0
    RETURN(1)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE ",dvsd_cerinstall,"DIC.DAT")
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((((dm2_sys_misc->cur_os="AXP")
    AND dm2_findfile(concat(dvsd_cerinstall,"dic.dat")) > 0) OR ((dm2_sys_misc->cur_os != "AXP")
    AND dm2_findfile(concat(dvsd_cerinstall,"/dic.dat")) > 0
    AND dm2_findfile(concat(dvsd_cerinstall,"/dic.idx")) > 0)) )
    SET ddr_domain_data->src_dict_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(dvsd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dic.dat",
       "/dic.dat")),dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_dict_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_dict_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE ",dvsd_cerinstall,
     "DIC.DAT.  Dictionary not found in cer_install.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE OCD_TOOLS in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dvsd_str = concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_ocds.sav")
   IF (dm2_findfile(dvsd_str) > 0)
    SET ddr_domain_data->src_ocd_tools_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(dvsd_str,dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_ocd_tools_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_ocd_tools_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE OCD_TOOLS in ",build(ddr_domain_data->src_tmp_full_dir),
     ".  OCD_TOOLS file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE CCLDIR in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dvsd_str = concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_ccldir.sav")
   IF (dm2_findfile(dvsd_str) > 0)
    SET ddr_domain_data->src_ccldir_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(dvsd_str,dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_ccldir_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_ccldir_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE CCLDIR in ",build(ddr_domain_data->src_tmp_full_dir),
     ".  CCLDIR file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE CER_CONFIG in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dvsd_str = concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_config.sav")
   IF (dm2_findfile(dvsd_str) > 0)
    SET ddr_domain_data->src_config_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(dvsd_str,dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_config_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_config_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE CER_CONFIG in ",build(ddr_domain_data->src_tmp_full_dir),
     ".  CER_CONFIG file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE TDB in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_tdb.msg")) >
   0)
    SET ddr_domain_data->src_tdb_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,
      "_tdb.msg"),dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_tdb_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_tdb_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE TDB in ",build(ddr_domain_data->src_tmp_full_dir),
     ".  TDB file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE SERVER DEFINITIONS in ",ddr_domain_data->src_tmp_full_dir
    )
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dvsd_scp_cnt = 0
   FOR (dvsd_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
     SET dvsd_str = ""
     SET dvsd_str = concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_domain_name,"_",
      ddr_domain_data->src_nodes[dvsd_cnt].node_name,"_save.scp")
     IF (dm2_findfile(dvsd_str) > 0)
      SET dvsd_scp_cnt = (dvsd_scp_cnt+ 1)
     ENDIF
   ENDFOR
   IF ((dvsd_scp_cnt=ddr_domain_data->src_nodes_cnt))
    SET ddr_domain_data->src_srv_def_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_domain_name,
      "_",ddr_domain_data->src_nodes[1].node_name,"_save.scp"),dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_srv_def_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_srv_def_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE SERVER DEFINITIONS in ",build(ddr_domain_data->
      src_tmp_full_dir),".  SCP file(s) not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF ((ddr_domain_data->src_was_arch_ind=0))
    SET dm_err->eproc = concat("Check SOURCE SEC_USER in ",ddr_domain_data->src_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,
      "_sec_user.dat")) > 0)
     SET ddr_domain_data->src_sec_user_fnd = 1
     SET dvsd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,
       "_sec_user.dat"),dvsd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->src_sec_user_ts = dvsd_file_date
    ELSE
     SET ddr_domain_data->src_sec_user_fnd = 0
     SET dm_err->eproc = concat("Check SOURCE SEC_USER in ",build(ddr_domain_data->src_tmp_full_dir),
      ".  SEC_USER file not found.")
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE ENV REGISTRY SETTINGS in ",ddr_domain_data->
    src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,dvsd_reg_src_env,"_env.reg")) > 0)
    SET ddr_domain_data->src_env_reg_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,dvsd_reg_src_env,"_env.reg"),
     dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_env_reg_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_env_reg_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE ENV REGISTRY SETTINGS in ",build(ddr_domain_data->
      src_tmp_full_dir),".  ENVIRONMENT Registry file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE SYSTEM DEFINITION REGISTRY SETTINGS in ",ddr_domain_data
    ->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,dvsd_reg_src_env,"_sysdef.reg")) > 0)
    SET ddr_domain_data->src_sysdef_reg_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,dvsd_reg_src_env,"_sysdef.reg"),
     dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_sysdef_reg_ts = dvsd_file_date
   ELSE
    SET ddr_domain_data->src_sysdef_reg_fnd = 0
    SET dm_err->eproc = concat("Check SOURCE SYSTEM DEFINITION REGISTRY SETTINGS in ",build(
      ddr_domain_data->src_tmp_full_dir),".  SYSTEM_DEFINITIONS Registry file not found.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE NON-STANDARD tables in ",ddr_domain_data->
    src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dvsd_file = concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->exp_parfile_prefix,
    "*.dmp")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF (dm2_findfile(dvsd_file) > 0)
     SET ddr_domain_data->src_invalid_tbls_fnd = 1
     SET dvsd_file_date = 0.0
     IF (ddr_get_file_date(dvsd_file,dvsd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->src_invalid_tbls_ts = dvsd_file_date
    ELSE
     SET ddr_domain_data->src_invalid_tbls_fnd = 0
    ENDIF
   ELSE
    IF (ddr_lnx_findfile(dvsd_file) > 0)
     SET ddr_domain_data->src_invalid_tbls_fnd = 1
     SET dvsd_file_date = 0.0
     IF (ddr_get_file_date(dvsd_file,dvsd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->src_invalid_tbls_ts = dvsd_file_date
    ELSE
     SET ddr_domain_data->src_invalid_tbls_fnd = 0
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE Warehouse backup in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2_findfile(evaluate(dm2_sys_misc->cur_os,"AXP",concat(ddr_domain_data->src_tmp_full_dir,
      ddr_domain_data->src_env,"_",ddr_domain_data->src_wh,".sav"),concat(ddr_domain_data->
      src_tmp_full_dir,ddr_domain_data->src_env,"_wh.sav"))) > 0)
    SET ddr_domain_data->src_wh_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(evaluate(dm2_sys_misc->cur_os,"AXP",concat(ddr_domain_data->
       src_tmp_full_dir,ddr_domain_data->src_env,"_",ddr_domain_data->src_wh,".sav"),concat(
       ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_wh.sav")),dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_wh_ts = dvsd_file_date
   ELSE
    IF ((ddr_domain_data->process="REFRESH"))
     SET ddr_domain_data->src_wh_fnd = 0
     SET dm_err->eproc = concat("Check SOURCE Warehouse backup in ",build(ddr_domain_data->
       src_tmp_full_dir),".  Warehouse backup file not found.")
     CALL disp_msg(" ",dm_err->logfile,0)
    ELSE
     SET ddr_domain_data->src_wh_fnd = 1
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE Admin env history csv files ",ddr_domain_data->
    src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (drr_validate_adm_env_csv(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_db_env_name)=0
   )
    SET ddr_domain_data->src_adm_env_csv_fnd = 0
    SET dm_err->eproc =
    "Check SOURCE Admin env history csv files.  Admin env history csv files not found."
    CALL disp_msg(" ",dm_err->logfile,0)
   ELSE
    SET ddr_domain_data->src_adm_env_csv_fnd = 1
    SET dvsd_file_date = 0.0
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,"dm2_",ddr_domain_data->
      src_db_env_name,"_env_hist_summary.txt"),dvsd_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_adm_env_csv_ts = dvsd_file_date
   ENDIF
   SET dm_err->eproc = concat("Check Source DAFSOLR backup in ",ddr_domain_data->src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((ddr_domain_data->src_interrogator_ind=1))
    IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,"_dafsolr.sav"
      )) > 0)
     SET dvsd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_env,
       "_dafsolr.sav"),dvsd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->src_interrogator_ts = dvsd_file_date
     SET ddr_domain_data->src_interrogator_fnd = 1
    ELSE
     SET ddr_domain_data->src_interrogator_fnd = 0
     SET dm_err->eproc = concat("Could not find Interrogator backup file in ",ddr_domain_data->
      src_tmp_full_dir)
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
   ENDIF
   IF ((ddr_domain_data->src_data_fnd=1)
    AND (ddr_domain_data->src_dict_fnd=1)
    AND (ddr_domain_data->src_tdb_fnd=1)
    AND (ddr_domain_data->src_srv_def_fnd=1)
    AND (ddr_domain_data->src_sysdef_reg_fnd=1)
    AND (ddr_domain_data->src_env_reg_fnd=1)
    AND (ddr_domain_data->src_ind_data_fnd=1)
    AND (ddr_domain_data->src_wh_fnd=1)
    AND (ddr_domain_data->src_ccldir_fnd=1)
    AND (ddr_domain_data->src_config_fnd=1)
    AND (ddr_domain_data->src_ocd_tools_fnd=1)
    AND (ddr_domain_data->src_adm_env_csv_fnd=1))
    IF ((ddr_domain_data->src_was_arch_ind=1))
     SET ddr_domain_data->src_restart_ind = 1
    ELSE
     IF ((ddr_domain_data->src_sec_user_fnd=1))
      SET ddr_domain_data->src_restart_ind = 1
     ELSE
      SET ddr_domain_data->src_restart_ind = 0
     ENDIF
    ENDIF
   ELSE
    SET ddr_domain_data->src_restart_ind = 0
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_collect_source_data(null)
   DECLARE dcsd_log_ret = vc WITH protect, noconstant("")
   DECLARE dcsd_node_ret = vc WITH protect, noconstant("")
   DECLARE dcsd_dev_ret = vc WITH protect, noconstant("")
   DECLARE dcsd_dir_ret = vc WITH protect, noconstant("")
   DECLARE dcsd_env_ok_ret = i2 WITH protect, noconstant(0)
   DECLARE dcsd_recollect = i2 WITH protect, noconstant(0)
   DECLARE dcsd_mode = i2 WITH protect, noconstant(0)
   DECLARE dcsd_ora_home = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Collect SOURCE data."
   CALL disp_msg("",dm_err->logfile,0)
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dm_err->eproc = "Response file detected and will be used to collect data."
    CALL disp_msg("",dm_err->logfile,0)
    IF (validate(drrr_rf_data->responsefile_version,"X")="X"
     AND validate(drrr_rf_data->responsefile_version,"Z")="Z")
     SET dm_err->eproc = "Verify response file structures accessible"
     SET dm_err->emsg = "Response file structure could not be accessed."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(drrr_rf_data)
     CALL echorecord(drrr_misc_data)
    ENDIF
    IF ((drrr_rf_data->tgt_copy_interrogator="YES"))
     SET ddr_domain_data->src_interrogator_ind = 1
    ENDIF
   ENDIF
   IF (ddr_get_env_logical(dcsd_log_ret)=0)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (cnvtlower(dcsd_log_ret) != cnvtlower(drrr_rf_data->src_env_name))
     SET dm_err->eproc = concat("Verify Source response file environment (",drrr_rf_data->
      src_env_name,") with current enviornment (",dcsd_log_ret,").")
     SET dm_err->emsg = "Environments specified do not match."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_env = cnvtlower(dcsd_log_ret)
   ELSE
    IF (ddr_env_confirm(1,0,dcsd_log_ret,dcsd_env_ok_ret)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND (ddr_domain_data->src_tmp_dev="DM2NOTSET"))
    IF (ddr_dev_prompt(1,0,dcsd_dev_ret)=0)
     RETURN(0)
    ELSE
     SET ddr_domain_data->src_tmp_dev = dcsd_dev_ret
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET ddr_domain_data->src_tmp_full_dir = build(drrr_rf_data->src_app_temp_dir,ddr_domain_data->
     src_env,"/")
   ELSEIF ((ddr_domain_data->src_tmp_full_dir="DM2NOTSET"))
    IF (ddr_dir_prompt(1,0,dcsd_dir_ret)=0)
     RETURN(0)
    ELSE
     SET ddr_domain_data->src_tmp_dir = dcsd_dir_ret
     SET ddr_domain_data->src_tmp_full_dir = evaluate(dm2_sys_misc->cur_os,"AXP",concat(
       ddr_domain_data->src_tmp_dev,":[",dcsd_dir_ret,".",ddr_domain_data->src_env,
       "]"),concat(dcsd_dir_ret,ddr_domain_data->src_env,"/"))
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os != "LNX"))
    IF ( NOT (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,"*.*"))))
     SET ddr_domain_data->src_tmp_dir_exists = 0
     SET ddr_domain_data->src_restart_ind = 0
    ELSE
     SET ddr_domain_data->src_tmp_dir_exists = 1
    ENDIF
   ELSE
    IF ( NOT (ddr_lnx_findfile(concat(ddr_domain_data->src_tmp_full_dir,"*.*"))))
     SET ddr_domain_data->src_tmp_dir_exists = 0
     SET ddr_domain_data->src_restart_ind = 0
    ELSE
     SET ddr_domain_data->src_tmp_dir_exists = 1
    ENDIF
   ENDIF
   IF ((ddr_domain_data->src_tmp_dir_exists=1))
    IF (ddr_validate_source_data(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((ddr_domain_data->src_restart_ind=1))
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dcsd_recollect = 1
    ELSE
     IF (ddr_summary(1,0)=0)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Previous Start Prompt"
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,7,131)
     CALL text(1,2,"PREVIOUS START ATTEMPTED")
     CALL text(3,4,"Would you like to recollect ALL data again or proceed with collected data?")
     CALL text(4,4,
      'Enter "P" to proceed with currently collected data specified in previous summary screen.')
     CALL text(5,4,'Enter "R" to recollect data.')
     CALL text(6,4,'Enter "Q" to Quit.')
     CALL accept(3,80,"A;cu"," "
      WHERE curaccept IN ("R", "P", "Q"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="Q")
      SET dm_err->emsg = "User elected to not continue."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (curaccept="R")
      SET dcsd_recollect = 1
     ENDIF
    ENDIF
   ELSEIF ((ddr_domain_data->src_tmp_dir_exists=1))
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm_err->eproc = "Not all data present, data will be recollected."
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,6,131)
     CALL text(3,4,concat("The ",ddr_domain_data->src_tmp_full_dir,
       " directory exists and will be cleared."))
     CALL text(5,4,'Enter "Y" to proceed. Enter "N" to abort process.')
     CALL accept(5,67,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="N")
      SET dm_err->emsg = concat("User elected to not continue with the removal of ",ddr_domain_data->
       src_tmp_full_dir)
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_domain_data)
   ENDIF
   IF ((((ddr_domain_data->src_restart_ind=0)) OR ((ddr_domain_data->src_restart_ind=1)
    AND dcsd_recollect=1)) )
    IF (der_determine_expimp_mode(dcsd_mode)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->standalone_expimp_mode = dcsd_mode
    IF (ddr_create_dir(ddr_domain_data->src_tmp_full_dir)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_tmp_dir_exists = 1
    IF ( NOT ((dm2_sys_misc->cur_os="AXP")))
     SET dcsd_ora_home = trim(logical("oracle_home"))
     IF (ddr_check_sqlnet(1,0,dcsd_ora_home)=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET stat = alterlist(ddr_domain_data->src_nodes,0)
    SET ddr_domain_data->src_nodes_cnt = 0
    SET ddr_domain_data->get_ccluserdir = 0
    SET ddr_domain_data->get_warehouse = 0
    SET ddr_domain_data->get_invalid_tables = 0
    SET ddr_domain_data->src_restart_ind = 0
    IF (ddr_get_new_source_data(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_target_data(null)
   DECLARE dvtd_log_ret = vc WITH protect, noconstant("")
   DECLARE dvtd_node_ret = vc WITH protect, noconstant("")
   DECLARE dvtd_dev_ret = vc WITH protect, noconstant("")
   DECLARE dvtd_dir_ret = vc WITH protect, noconstant("")
   DECLARE dvtd_env_ok_ret = i2 WITH protect, noconstant(0)
   DECLARE dvtd_recollect = i2 WITH protect, noconstant(0)
   DECLARE dvtd_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dvtd_pd_present = i2 WITH protect, noconstant(0)
   DECLARE dvtd_file = vc WITH protect, noconstant("")
   DECLARE dvtd_find_str = vc WITH protect, noconstant("")
   DECLARE dvtd_found = i2 WITH protect, noconstant(0)
   DECLARE dvtd_scp_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_str = vc WITH protect, noconstant("")
   DECLARE dvtd_cerinstall = vc WITH protect, noconstant(trim(logical("cer_install")))
   DECLARE dvtd_reg_tgt_env = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Validate TARGET data."
   CALL disp_msg("",dm_err->logfile,0)
   IF (ddr_get_env_logical(dvtd_log_ret)=0)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    IF (cnvtlower(dvtd_log_ret) != cnvtlower(drrr_rf_data->tgt_env_name))
     SET dm_err->eproc = concat("Verify response file Target environment (",drrr_rf_data->
      tgt_env_name,") with current enviornment (",dvtd_log_ret,").")
     SET dm_err->emsg = "Environments specified do not match."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_env = cnvtlower(dvtd_log_ret)
   ELSE
    IF (ddr_env_confirm(0,1,dvtd_log_ret,dvtd_env_ok_ret)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP")
    AND (ddr_domain_data->tgt_tmp_full_dir="DM2NOTSET"))
    IF (ddr_dev_prompt(0,1,dvtd_dev_ret)=0)
     RETURN(0)
    ELSE
     SET ddr_domain_data->tgt_tmp_dev = dvtd_dev_ret
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    SET ddr_domain_data->tgt_tmp_full_dir = build(drrr_rf_data->tgt_app_temp_dir,ddr_domain_data->
     tgt_env,"/")
    SET ddr_domain_data->tgt_tmp_dir = drrr_rf_data->tgt_app_temp_dir
    SET dvtd_dir_ret = drrr_rf_data->tgt_app_temp_dir
   ELSEIF ((ddr_domain_data->tgt_tmp_full_dir="DM2NOTSET"))
    IF (ddr_dir_prompt(0,1,dvtd_dir_ret)=0)
     RETURN(0)
    ELSE
     SET ddr_domain_data->tgt_tmp_dir = dvtd_dir_ret
     SET ddr_domain_data->tgt_tmp_full_dir = evaluate(dm2_sys_misc->cur_os,"AXP",concat(
       ddr_domain_data->tgt_tmp_dev,":[",dvtd_dir_ret,".",ddr_domain_data->tgt_env,
       "]"),concat(dvtd_dir_ret,ddr_domain_data->tgt_env,"/"))
    ENDIF
   ENDIF
   IF ((ddr_domain_data->process="REPLICATE"))
    IF ( NOT (dm2_find_dir(ddr_domain_data->tgt_tmp_full_dir)))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validate Target temporary directory during Replicate."
     SET dm_err->emsg = concat("Fail to find Target temp dir ",ddr_domain_data->tgt_tmp_full_dir)
     CALL disp_msg(dm_err->emsg,dm_err->eproc,1)
     RETURN(0)
    ELSE
     SET ddr_domain_data->tgt_tmp_dir_exists = 1
    ENDIF
   ELSEIF ((ddr_domain_data->process="REFRESH"))
    IF ((dm2_sys_misc->cur_os != "LNX"))
     IF ( NOT (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,"*.*"))))
      SET ddr_domain_data->tgt_tmp_dir_exists = 0
      SET ddr_domain_data->tgt_restart_ind = 0
     ELSE
      SET ddr_domain_data->tgt_tmp_dir_exists = 1
     ENDIF
    ELSE
     IF ( NOT (ddr_lnx_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,"*.*"))))
      SET ddr_domain_data->tgt_tmp_dir_exists = 0
      SET ddr_domain_data->tgt_restart_ind = 0
     ELSE
      SET ddr_domain_data->tgt_tmp_dir_exists = 1
     ENDIF
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    SET ddr_domain_data->src_env = cnvtlower(drrr_rf_data->src_env_name)
   ELSEIF ((ddr_domain_data->src_env="DM2NOTSET"))
    SET message = window
    SET width = 132
    CALL clear(1,1)
    CALL box(1,1,5,131)
    IF ((ddr_domain_data->process="REFRESH"))
     CALL text(3,4,"What is the SOURCE environment name from which TARGET is being refreshed from?")
    ELSEIF ((ddr_domain_data->process="REPLICATE"))
     CALL text(3,4,"What is the SOURCE environment name from which TARGET is being replicated from?")
    ENDIF
    CALL accept(3,83,"P(30);CUF"," "
     WHERE curaccept > " ")
    SET ddr_domain_data->src_env = cnvtlower(curaccept)
    SET message = nowindow
    CALL clear(1,1)
   ENDIF
   SET ddr_domain_data->src_tmp_full_dir = evaluate(dm2_sys_misc->cur_os,"AXP",concat(ddr_domain_data
     ->tgt_tmp_dev,":[",dvtd_dir_ret,".",ddr_domain_data->src_env,
     "]"),concat(dvtd_dir_ret,ddr_domain_data->src_env,"/"))
   IF ( NOT (dm2_find_dir(ddr_domain_data->src_tmp_full_dir)))
    SET ddr_domain_data->tgt_tmp_src_dir_exists = 0
    IF ((ddr_domain_data->process="REPLICATE"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validate Source temporary directory during Replicate."
     SET dm_err->emsg = concat("Fail to find Source temp dir ",ddr_domain_data->src_tmp_full_dir)
     CALL disp_msg(dm_err->emsg,dm_err->eproc,1)
     RETURN(0)
    ENDIF
   ELSE
    SET ddr_domain_data->tgt_tmp_src_dir_exists = 1
   ENDIF
   IF ((ddr_domain_data->process="REPLICATE"))
    SET ddr_domain_data->tgt_restart_ind = 0
    RETURN(1)
   ENDIF
   IF (size(ddr_domain_data->tgt_env,1) > max_reg_env_len)
    SET dvtd_reg_tgt_env = substring(1,max_reg_env_len,ddr_domain_data->tgt_env)
   ELSE
    SET dvtd_reg_tgt_env = ddr_domain_data->tgt_env
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echo(concat("dvtd_reg_tgt_env = ",dvtd_reg_tgt_env))
   ENDIF
   IF ((ddr_domain_data->tgt_tmp_dir_exists=1))
    SET ddr_domain_data->tgt_restart_ind = 0
    SET ddr_domain_data->tgt_data_fnd = 0
    SET ddr_domain_data->tgt_data_ts = 0
    SET ddr_domain_data->tgt_ind_data_fnd = 0
    SET ddr_domain_data->tgt_dict_fnd = 0
    SET ddr_domain_data->tgt_dict_ts = 0
    SET ddr_domain_data->tgt_tdb_fnd = 0
    SET ddr_domain_data->tgt_tdb_ts = 0
    SET ddr_domain_data->tgt_srv_def_fnd = 0
    SET ddr_domain_data->tgt_srv_def_ts = 0
    SET ddr_domain_data->tgt_sec_user_fnd = 0
    SET ddr_domain_data->tgt_sec_user_ts = 0
    SET ddr_domain_data->tgt_env_reg_fnd = 0
    SET ddr_domain_data->tgt_env_reg_ts = 0
    SET ddr_domain_data->tgt_invalid_tbls_fnd = 0
    SET ddr_domain_data->tgt_invalid_tbls_ts = 0
    SET ddr_domain_data->tgt_preserve_fnd = 0
    SET ddr_domain_data->tgt_forms_fnd = 0
    SET ddr_domain_data->tgt_forms_ts = 0
    SET ddr_domain_data->tgt_dbas_fnd = 0
    SET ddr_domain_data->tgt_dbas_ts = 0
    SET ddr_domain_data->tgt_users_fnd = 0
    SET ddr_domain_data->tgt_users_ts = 0
    SET ddr_domain_data->tgt_sys_reg_fnd = 0
    SET ddr_domain_data->tgt_sys_reg_ts = 0
    SET ddr_domain_data->tgt_sysdef_reg_fnd = 0
    SET ddr_domain_data->tgt_sysdef_reg_ts = 0
    SET ddr_domain_data->tgt_wh_fnd = 0
    SET ddr_domain_data->tgt_wh_ts = 0
    SET ddr_domain_data->tgt_ccluserdir_fnd = 0
    SET ddr_domain_data->tgt_ccluserdir_ts = 0
    SET dm_err->eproc = concat("Check TARGET DATA",ddr_domain_data->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->data_file_name)) > 0)
     SET ddr_domain_data->tgt_data_fnd = 1
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->data_file_name),
      dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_data_ts = dvtd_file_date
     IF (ddr_read_misc_data(0,1)=0)
      RETURN(0)
     ELSE
      SET ddr_domain_data->tgt_warehouse_dir = ""
      SET ddr_domain_data->tgt_cer_config_dir = ""
      SET ddr_domain_data->tgt_ccluserdir_dir = ""
      SET ddr_domain_data->tgt_ocdtools_dir = ""
      SET ddr_domain_data->tgt_ccldir = ""
      IF ((((ddr_domain_data->tgt_cer_data_dev="DM2NOTSET")) OR ((((ddr_domain_data->tgt_wh=
      "DM2NOTSET")) OR ((((ddr_domain_data->tgt_wh_device="DM2NOTSET")) OR ((((ddr_domain_data->
      tgt_revision_level="DM2NOTSET")) OR ((((ddr_domain_data->tgt_system="DM2NOTSET")) OR ((((
      ddr_domain_data->tgt_system_pwd="DM2NOTSET")) OR ((((ddr_domain_data->tgt_priv="DM2NOTSET"))
       OR ((((ddr_domain_data->tgt_priv_pwd="DM2NOTSET")) OR ((((ddr_domain_data->tgt_mng="DM2NOTSET"
      )) OR ((((ddr_domain_data->tgt_mng_pwd="DM2NOTSET")) OR ((((ddr_domain_data->
      tgt_tdb_server_master_id=0)
       AND (ddr_domain_data->tgt_tdb_server_slave_id=0)) OR ((((ddr_domain_data->tgt_scp_server_id=0)
      ) OR ((((ddr_domain_data->tgt_auth_server_id=0)) OR ((((ddr_domain_data->tgt_local_user_name=
      "DM2NOTSET")) OR ((((ddr_domain_data->tgt_ccldir="DM2NOTSET")) OR ((((ddr_domain_data->
      tgt_warehouse_dir="DM2NOTSET")) OR ((((ddr_domain_data->tgt_cer_config_dir="DM2NOTSET")) OR (((
      (ddr_domain_data->tgt_ccluserdir_dir="DM2NOTSET")) OR ((((ddr_domain_data->tgt_ocdtools_dir=
      "DM2NOTSET")) OR ((((ddr_domain_data->offline_dict_ind=- (1))) OR ((((ddr_domain_data->
      tgt_nodes_cnt=0)) OR ((ddr_domain_data->tgt_node_flag=0))) )) )) )) )) )) )) )) )) )) )) )) ))
      )) )) )) )) )) )) )) )) )
       SET ddr_domain_data->tgt_ind_data_fnd = 0
      ELSE
       IF ((ddr_domain_data->tgt_was_arch_ind=1))
        SET ddr_domain_data->tgt_ind_data_fnd = 1
       ELSE
        IF ((((ddr_domain_data->tgt_sec_user_name="DM2NOTSET")) OR ((ddr_domain_data->
        tgt_sec_server_master_id=0)
         AND (ddr_domain_data->tgt_sec_server_slave_id=0))) )
         SET ddr_domain_data->tgt_ind_data_fnd = 0
        ELSE
         SET ddr_domain_data->tgt_ind_data_fnd = 1
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Check for TARGET preserved passwords")
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (ddr_validate_preserve_pwds(null)=0)
     RETURN(0)
    ENDIF
    IF ((ddr_domain_data->tgt_preserve_pwds_cnt=- (1)))
     SET ddr_domain_data->tgt_ind_data_fnd = 0
    ENDIF
    IF ((ddr_domain_data->tgt_ind_data_fnd=0))
     SET ddr_domain_data->tgt_restart_ind = 0
     RETURN(1)
    ENDIF
    SET dm_err->eproc = concat("Check TARGET ENV REGISTRY SETTINGS in ",ddr_domain_data->
     tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_env.reg")) > 0)
     SET ddr_domain_data->tgt_env_reg_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_env.reg"),
      dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_env_reg_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_env_reg_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check TARGET ",dvtd_cerinstall,"/dic.dat")
    CALL disp_msg(" ",dm_err->logfile,0)
    IF ((((dm2_sys_misc->cur_os="AXP")
     AND dm2_findfile(concat(dvtd_cerinstall,"dic.dat")) > 0) OR ((dm2_sys_misc->cur_os != "AXP")
     AND dm2_findfile(concat(dvtd_cerinstall,"/dic.dat")) > 0
     AND dm2_findfile(concat(dvtd_cerinstall,"/dic.idx")) > 0)) )
     SET ddr_domain_data->tgt_dict_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(dvtd_cerinstall,evaluate(dm2_sys_misc->cur_os,"AXP","dic.dat",
        "/dic.dat")),dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_dict_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_dict_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check TARGET TDB in ",ddr_domain_data->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,"_tdb.msg"))
     > 0)
     SET ddr_domain_data->tgt_tdb_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_tdb.msg"),dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_tdb_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_tdb_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check TARGET SERVER DEFINITIONS in ",ddr_domain_data->
     tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dvtd_scp_cnt = 0
    FOR (dvtd_cnt = 1 TO ddr_domain_data->tgt_nodes_cnt)
      SET dvtd_str = ""
      SET dvtd_str = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_domain_name,"_",
       ddr_domain_data->tgt_nodes[dvtd_cnt].node_name,"_save.scp")
      IF (dm2_findfile(dvtd_str) > 0)
       SET dvtd_scp_cnt = (dvtd_scp_cnt+ 1)
      ENDIF
    ENDFOR
    IF ((dvtd_scp_cnt=ddr_domain_data->tgt_nodes_cnt))
     SET ddr_domain_data->tgt_srv_def_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_domain_name,
       "_",ddr_domain_data->tgt_nodes[1].node_name,"_save.scp"),dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_srv_def_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_srv_def_fnd = 0
    ENDIF
    IF ((ddr_domain_data->tgt_was_arch_ind=0))
     SET dm_err->eproc = concat("Check TARGET SEC_USER in ",ddr_domain_data->tgt_tmp_full_dir)
     CALL disp_msg(" ",dm_err->logfile,0)
     IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_sec_user.dat")) > 0)
      SET ddr_domain_data->tgt_sec_user_fnd = 1
      SET dvtd_file_date = 0.0
      IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
        "_sec_user.dat"),dvtd_file_date)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_sec_user_ts = dvtd_file_date
     ELSE
      SET ddr_domain_data->tgt_sec_user_fnd = 0
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Check TARGET SYSTEM DEFINITION REGISTRY SETTINGS in ",ddr_domain_data
     ->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_sysdef.reg")) > 0)
     SET ddr_domain_data->tgt_sysdef_reg_fnd = 1
     SET dvsd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_sysdef.reg"),
      dvsd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_sysdef_reg_ts = dvsd_file_date
    ELSE
     SET ddr_domain_data->tgt_sysdef_reg_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check TARGET NON-STANDARD tables in ",ddr_domain_data->
     tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dvtd_file = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->exp_parfile_prefix,
     "*.dmp")
    IF ((dm2_sys_misc->cur_os != "LNX"))
     IF (dm2_findfile(dvtd_file) > 0)
      SET ddr_domain_data->tgt_invalid_tbls_fnd = 1
      SET dvtd_file_date = 0.0
      IF (ddr_get_file_date(dvtd_file,dvtd_file_date)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_invalid_tbls_ts = dvtd_file_date
     ELSE
      SET ddr_domain_data->tgt_invalid_tbls_fnd = 0
     ENDIF
    ELSE
     IF (ddr_lnx_findfile(dvtd_file) > 0)
      SET ddr_domain_data->tgt_invalid_tbls_fnd = 1
      SET dvtd_file_date = 0.0
      IF (ddr_get_file_date(dvtd_file,dvtd_file_date)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_invalid_tbls_ts = dvtd_file_date
     ELSE
      SET ddr_domain_data->tgt_invalid_tbls_fnd = 0
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Check TARGET Warehouse backup in ",ddr_domain_data->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dvtd_file = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,"_",
      ddr_domain_data->tgt_wh,".sav")
    ELSE
     SET dvtd_file = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,"_wh.sav")
    ENDIF
    IF (dm2_findfile(dvtd_file) > 0)
     SET ddr_domain_data->tgt_wh_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(dvtd_file,dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_wh_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_wh_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check for preserved data in ",ddr_domain_data->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET drr_clin_copy_data->temp_location = ddr_domain_data->tgt_tmp_full_dir
    SET dm2_install_schema->schema_prefix = "dm2s"
    IF (drr_chk_for_preserved_data(dvtd_pd_present)=0)
     RETURN(0)
    ENDIF
    IF (dvtd_pd_present=1)
     SET ddr_domain_data->tgt_preserve_fnd = 1
     SET dvtd_file = concat(ddr_domain_data->tgt_tmp_full_dir,drr_clin_copy_data->preserve_tbl_pre,
      evaluate(dm2_sys_misc->cur_os,"AXP","*.*;*","*.*"))
     IF (ddr_get_file_date(dvtd_file,dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_preserve_ts = dvtd_file_date
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET ddr_domain_data->tgt_forms_fnd = 1
     SET ddr_domain_data->tgt_forms_ts = cnvtdatetime("22-JUL-1978")
    ELSE
     SET dm_err->eproc = "Check TARGET for cer_forms data"
     CALL disp_msg(" ",dm_err->logfile,0)
     SET dvtd_find_str = concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
      "_frmque.sav")
     SET dvtd_found = dm2_findfile(dvtd_find_str)
     IF (dvtd_found > 0)
      IF (ddr_get_file_date(dvtd_find_str,dvtd_file_date)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_forms_fnd = 1
      SET ddr_domain_data->tgt_forms_ts = dvtd_file_date
     ELSE
      SET dvtd_find_str = concat(trim(logical("cer_forms")),"/","form*")
      IF ((dm2_sys_misc->cur_os != "LNX"))
       SET dvtd_found = dm2_findfile(dvtd_find_str)
       IF (dvtd_found=0)
        SET dvtd_find_str = concat(ddr_domain_data->tgt_tmp_full_dir,"queue*")
        SET dvtd_found = dm2_findfile(dvtd_find_str)
       ENDIF
      ELSE
       SET dvtd_found = ddr_lnx_findfile(dvtd_find_str)
       IF (dvtd_found=0)
        SET dvtd_find_str = concat(ddr_domain_data->tgt_tmp_full_dir,"queue*")
        SET dvtd_found = ddr_lnx_findfile(dvtd_find_str)
       ENDIF
      ENDIF
      IF (dvtd_found > 0)
       SET ddr_domain_data->tgt_forms_fnd = 0
      ELSE
       SET ddr_domain_data->tgt_forms_fnd = 1
       SET ddr_domain_data->tgt_forms_ts = cnvtdatetime("22-JUL-1978")
      ENDIF
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Check CCL DBA backup in ",ddr_domain_data->tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,"_dbas.dat"))
     > 0)
     SET ddr_domain_data->tgt_dbas_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_dbas.dat"),dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_dbas_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_dbas_fnd = 0
    ENDIF
    IF ((dm2_sys_misc->cur_os IN ("AXP", "LNX")))
     SET ddr_domain_data->tgt_users_fnd = 1
    ELSE
     SET dm_err->eproc = concat("Check for TARGET USERS BACKUP in ",ddr_domain_data->tgt_tmp_full_dir
      )
     CALL disp_msg(" ",dm_err->logfile,0)
     IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_grp_users.dat")) > 0)
      SET ddr_domain_data->tgt_users_fnd = 1
      SET dvtd_file_date = 0.0
      IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
        "_grp_users.dat"),dvtd_file_date)=0)
       RETURN(0)
      ENDIF
      SET ddr_domain_data->tgt_users_ts = dvtd_file_date
     ELSE
      SET ddr_domain_data->tgt_users_fnd = 0
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Check for SYS REGISTRY SETTINGS in ",ddr_domain_data->
     tgt_tmp_full_dir)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_sys.reg")) > 0)
     SET ddr_domain_data->tgt_sys_reg_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,dvtd_reg_tgt_env,"_sys.reg"),
      dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_sys_reg_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_sys_reg_fnd = 0
    ENDIF
    SET dm_err->eproc = concat("Check TARGET CCLUSERDIR backup in ",ddr_domain_data->tgt_tmp_full_dir
     )
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dm2_findfile(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
      "_ccluserdir.sav")) > 0)
     SET ddr_domain_data->tgt_ccluserdir_fnd = 1
     SET dvtd_file_date = 0.0
     IF (ddr_get_file_date(concat(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_env,
       "_ccluserdir.sav"),dvtd_file_date)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_ccluserdir_ts = dvtd_file_date
    ELSE
     SET ddr_domain_data->tgt_ccluserdir_fnd = 0
    ENDIF
    IF ((ddr_domain_data->tgt_data_fnd=1)
     AND (ddr_domain_data->tgt_tdb_fnd=1)
     AND (ddr_domain_data->tgt_srv_def_fnd=1)
     AND (ddr_domain_data->tgt_sysdef_reg_fnd=1)
     AND (ddr_domain_data->tgt_env_reg_fnd=1)
     AND (ddr_domain_data->tgt_ind_data_fnd=1)
     AND (ddr_domain_data->tgt_dbas_fnd=1)
     AND (ddr_domain_data->tgt_users_fnd=1)
     AND (ddr_domain_data->tgt_sys_reg_fnd=1)
     AND (ddr_domain_data->tgt_forms_fnd=1))
     IF ((ddr_domain_data->tgt_was_arch_ind=1))
      SET ddr_domain_data->tgt_restart_ind = 1
     ELSE
      IF ((ddr_domain_data->tgt_sec_user_fnd=1))
       SET ddr_domain_data->tgt_restart_ind = 1
      ELSE
       SET ddr_domain_data->tgt_restart_ind = 0
      ENDIF
     ENDIF
    ELSE
     SET ddr_domain_data->tgt_restart_ind = 0
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_collect_target_data(null)
   DECLARE dctd_recollect = i2 WITH protect, noconstant(0)
   DECLARE dctd_str = vc WITH protect, noconstant("")
   DECLARE dctd_mode = i2 WITH protect, noconstant(0)
   DECLARE dvtd_preserve_ret = i2 WITH protect, noconstant(0)
   DECLARE dvtd_run_id = i4 WITH protect, noconstant(0)
   DECLARE dvtd_total_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_complete_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_left_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_running_cnt = i4 WITH protect, noconstant(0)
   DECLARE dvtd_failed_cnt = i4 WITH protect, noconstant(0)
   DECLARE dctd_ora_home = vc WITH protect, noconstant("")
   DECLARE dctd_prim_node = vc WITH protect, noconstant("")
   DECLARE dctd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dctd_cmd = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Collect TARGET data."
   CALL disp_msg("",dm_err->logfile,0)
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    SET dm_err->eproc = "Response file detected and will be used to collect data."
    CALL disp_msg("",dm_err->logfile,0)
    IF (validate(drrr_rf_data->responsefile_version,"X")="X"
     AND validate(drrr_rf_data->responsefile_version,"Z")="Z")
     SET dm_err->eproc = "Verify response file structures accessible"
     SET dm_err->emsg = "Response file structure could not be accessed."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(drrr_rf_data)
     CALL echorecord(drrr_misc_data)
    ENDIF
    SET dm2_install_schema->v500_p_word = drrr_rf_data->tgt_db_user_pwd
    SET dm2_install_schema->v500_connect_str = drrr_rf_data->tgt_db_cnct_str
    SET dm2_install_schema->target_dbase_name = drrr_rf_data->tgt_db_name
    SET ddr_domain_data->tgt_env = trim(cnvtlower(drrr_rf_data->tgt_env_name))
    SET ddr_domain_data->tgt_mng = drrr_rf_data->tgt_high_priv_user
    SET ddr_domain_data->tgt_mng_pwd = drrr_rf_data->tgt_high_priv_user_pwd
    SET dctd_prim_node = drrr_rf_data->tgt_primary_app_node
    IF ((drrr_misc_data->tgt_retain_db_user_cnt > 0))
     SET drr_retain_db_users->cnt = drrr_misc_data->tgt_retain_db_user_cnt
     SET stat = alterlist(drr_retain_db_users->user,drr_retain_db_users->cnt)
     FOR (dctd_cnt = 1 TO drr_retain_db_users->cnt)
       SET drr_retain_db_users->user[dctd_cnt].user_name = drrr_misc_data->tgt_retain_db_users[
       dctd_cnt].user_name
     ENDFOR
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm2_install_schema)
     CALL echorecord(ddr_domain_data)
     CALL echorecord(drr_retain_db_users)
    ENDIF
   ENDIF
   IF (ddr_validate_target_data(null)=0)
    RETURN(0)
   ENDIF
   IF ((ddr_domain_data->process="REFRESH")
    AND (ddr_domain_data->tgt_tmp_src_dir_exists=0))
    SET dctd_str = evaluate(dm2_sys_misc->cur_os,"AXP",concat(ddr_domain_data->tgt_tmp_dev,":[",
      ddr_domain_data->tgt_tmp_dir,".",ddr_domain_data->src_env,
      "]"),concat(ddr_domain_data->tgt_tmp_dir,ddr_domain_data->src_env,"/"))
    IF (ddr_create_dir(dctd_str)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_tmp_src_dir_exists = 1
   ENDIF
   IF ((ddr_domain_data->tgt_restart_ind=1)
    AND (ddr_domain_data->process="REFRESH"))
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dctd_recollect = 1
     SET dm_err->eproc =
     "Target data previously collected.  Forcing recollection as part of response file path."
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     IF (ddr_summary(0,1)=0)
      RETURN(0)
     ENDIF
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,7,131)
     CALL text(1,2,"PREVIOUS START ATTEMPTED")
     CALL text(3,4,"Would you like to recollect ALL data again or proceed with collected data?")
     CALL text(4,4,
      'Enter "P" to proceed with currently collected data specified in previous summary screen.')
     CALL text(5,4,'Enter "R" to recollect data.')
     CALL text(6,4,'Enter "Q" to Quit.')
     CALL accept(3,80,"A;cu"," "
      WHERE curaccept IN ("R", "P", "Q"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="Q")
      SET dm_err->emsg = "User elected to not continue."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (curaccept="R")
      SET dctd_recollect = 1
     ENDIF
    ENDIF
   ELSEIF ((ddr_domain_data->tgt_tmp_dir_exists=1)
    AND (ddr_domain_data->process="REFRESH"))
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET dm_err->eproc = "Not all data present, data will be recollected."
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,6,131)
     CALL text(3,4,concat("The ",ddr_domain_data->tgt_tmp_full_dir,
       " directory exists and will be cleared."))
     CALL text(5,4,'Enter "Y" to proceed. Enter "N" to abort process.')
     CALL accept(5,67,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="N")
      SET dm_err->emsg = concat("User elected to not continue with the removal of ",ddr_domain_data->
       tgt_tmp_full_dir)
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_domain_data)
   ENDIF
   IF ((((ddr_domain_data->tgt_restart_ind=0)) OR ((ddr_domain_data->tgt_restart_ind=1)
    AND dctd_recollect=1)) )
    IF ((ddr_domain_data->process="REFRESH"))
     IF ((dm2_sys_misc->cur_os IN ("AIX", "LNX", "HPX")))
      SET dctd_cmd = concat("chmod 777 $CCLUSERDIR/")
      IF (dm2_push_dcl(dctd_cmd)=0)
       RETURN(0)
      ENDIF
     ENDIF
     IF (ddr_create_dir(ddr_domain_data->tgt_tmp_full_dir)=0)
      RETURN(0)
     ENDIF
    ELSEIF ((ddr_domain_data->process="REPLICATE")
     AND validate(drrr_responsefile_in_use,- (1))=1)
     IF (ddr_create_dir(ddr_domain_data->tgt_tmp_full_dir)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((ddr_domain_data->process="REFRESH"))
     IF (der_determine_expimp_mode(dctd_mode)=0)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->standalone_expimp_mode = dctd_mode
     SET ddr_domain_data->preserve_user_ind = 0
     IF ((ddr_domain_data->standalone_expimp_mode=1))
      IF (validate(drrr_responsefile_in_use,- (1))=1)
       IF (dctd_prim_node=cnvtlower(trim(curnode)))
        SET ddr_domain_data->preserve_ind = evaluate(drrr_rf_data->tgt_preserve_data,"YES",1,0)
        SET ddr_domain_data->preserve_user_ind = evaluate(drr_retain_db_users->cnt,0,0,1)
       ELSE
        IF ((dm_err->debug_flag > 0))
         CALL echo("Not on primary application node - skipping preserve logic")
        ENDIF
        SET ddr_domain_data->preserve_ind = 0
       ENDIF
      ELSE
       IF (ddr_preserve_prompt(dvtd_preserve_ret)=0)
        RETURN(0)
       ENDIF
       SET ddr_domain_data->preserve_ind = dvtd_preserve_ret
      ENDIF
      IF ((((ddr_domain_data->preserve_ind=1)) OR ((ddr_domain_data->preserve_user_ind=1))) )
       IF ((((dm2_install_schema->target_dbase_name="NONE")) OR ((((dm2_install_schema->v500_p_word=
       "NONE")) OR ((dm2_install_schema->v500_connect_str="NONE"))) )) )
        SET dm2_install_schema->dbase_name = '"TARGET"'
        SET dm2_install_schema->u_name = "V500"
        SET dm2_force_connect_string = 1
        EXECUTE dm2_connect_to_dbase "PC"
        SET dm2_force_connect_string = 0
        IF ((dm_err->err_ind=1))
         RETURN(0)
        ENDIF
        SET dm2_install_schema->target_dbase_name = currdbname
        SET dm2_install_schema->v500_p_word = dm2_install_schema->p_word
        SET dm2_install_schema->v500_connect_str = dm2_install_schema->connect_str
       ENDIF
       IF (der_manage_admin_data(dm2_install_schema->target_dbase_name,"DM2_ADMIN_DM_INFO","S","ALL",
        "")=0)
        RETURN(0)
       ENDIF
       IF ((der_expimp_data->setup_complete_ind=0))
        SET message = nowindow
        SET dm_err->err_ind = 1
        SET dm_err->eproc = "Validating standalone export setup work has been completed."
        SET dm_err->emsg = "Setup work not completed for standalone export process."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       SET der_expimp_data->preserve_from_begin = 1
       SET dm_err->eproc = "Get Clin Copy-Preserve DDL from Target."
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg("",dm_err->logfile,0)
       ENDIF
       SELECT INTO "nl:"
        FROM dm2_ddl_ops_log ddol
        WHERE (ddol.run_id=
        (SELECT
         ddo.run_id
         FROM dm2_ddl_ops ddo
         WHERE ddo.process_option="CLIN COPY-PRESERVE"))
         AND ddol.status="COMPLETE"
        WITH nocounter
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ELSEIF (curqual > 0)
        IF (validate(drrr_responsefile_in_use,- (1))=1)
         SET der_expimp_data->preserve_from_begin = 1
        ELSE
         SET dvtd_preserve_ret = 0
         IF (ddr_preserve_check_prompt(dvtd_preserve_ret)=0)
          RETURN(0)
         ENDIF
         IF (dvtd_preserve_ret=1)
          SET der_expimp_data->preserve_from_begin = 0
         ELSE
          SET der_expimp_data->preserve_from_begin = 1
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ELSE
      SET ddr_domain_data->preserve_ind = 1
     ENDIF
    ENDIF
    SET ddr_domain_data->tgt_tmp_dir_exists = 1
    IF ( NOT ((dm2_sys_misc->cur_os="AXP")))
     SET dctd_ora_home = trim(logical("oracle_home"))
     IF (ddr_check_sqlnet(0,1,dctd_ora_home)=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET stat = alterlist(ddr_domain_data->tgt_nodes,0)
    SET ddr_domain_data->tgt_nodes_cnt = 0
    SET ddr_domain_data->tgt_restart_ind = 0
    SET ddr_domain_data->get_ccluserdir = 0
    SET ddr_domain_data->get_warehouse = 0
    SET ddr_domain_data->get_invalid_tables = 0
    IF (ddr_get_new_target_data(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_create_dir(dcd_dir_name)
   DECLARE dcd_cmd_txt = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Create directory:",dcd_dir_name)
   CALL disp_msg("",dm_err->logfile,0)
   IF (dm2_find_dir(dcd_dir_name))
    SET dm_err->eproc = concat("Clear the following directory:",dcd_dir_name)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF (ddr_clear_dir(dcd_dir_name)=0)
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Create the following directory:",dcd_dir_name)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dcd_cmd_txt = concat("create/dir/vers=1/prot=(s:rwed,o:rwed,g:rwed,w:rwed) ",dcd_dir_name)
    ELSE
     SET dcd_cmd_txt = concat("mkdir -pm 755 ",dcd_dir_name)
    ENDIF
    IF (dm2_push_dcl(dcd_cmd_txt)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_clear_dir(ddd_dir_name)
   DECLARE ddd_cmd_txt = vc WITH protect, noconstant("")
   DECLARE ddd_dir_txt = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Clear the following directory:",ddd_dir_name)
   CALL disp_msg("",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET ddd_cmd_txt = concat("delete ",ddd_dir_name,"*.*;*")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(ddd_cmd_txt)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(dm_err)
     ENDIF
    ENDIF
    IF (findstring("file not found",dm_err->errtext,1,0)=0
     AND (dm_err->errtext != ""))
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET ddd_cmd_txt = concat("rm -f ",ddd_dir_name,"*.*")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(ddd_cmd_txt)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(dm_err)
     ENDIF
    ENDIF
    IF (findstring("does not exist",dm_err->errtext,1,0)=0
     AND findstring("not found",dm_err->errtext,1,0)=0
     AND (dm_err->errtext != ""))
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddd_cmd_txt = concat("for i in `ls -ld ",ddd_dir_name,
     "* | awk {'print $9'}`;do rm -rf $i ;done")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(ddd_cmd_txt)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(dm_err)
     ENDIF
    ENDIF
    IF (findstring("does not exist",dm_err->errtext,1,0)=0
     AND findstring("not found",dm_err->errtext,1,0)=0
     AND findstring("No such file or directory",dm_err->errtext,1,0)=0
     AND (dm_err->errtext != ""))
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_env_confirm(dec_src_env,dec_tgt_env,dec_env_to_chk,dec_env_ok_ret)
   DECLARE dec_prompt_str = vc WITH protect, noconstant("")
   SET dec_prompt_str = concat("Is ",dec_env_to_chk," the correct Environment Name for ",evaluate(
     dec_src_env,1,"SOURCE","TARGET")," environment (Y,N)?")
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,5,131)
   CALL text(3,4,dec_prompt_str)
   CALL accept(3,(size(dec_prompt_str)+ 5),"A;cu"," "
    WHERE curaccept IN ("Y", "N"))
   SET dec_env_ok_ret = evaluate(curaccept,"Y",1,0)
   CALL clear(1,1)
   SET message = nowindow
   IF (dec_env_ok_ret=1)
    IF (dec_src_env=1)
     SET ddr_domain_data->src_env = cnvtlower(dec_env_to_chk)
    ELSE
     SET ddr_domain_data->tgt_env = cnvtlower(dec_env_to_chk)
    ENDIF
   ELSE
    SET dm_err->emsg = concat('Environment obtained from "environment" logical, ',dec_env_to_chk,
     " ,is not correct.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_env_logical(dgel_log_ret)
   SET dm_err->eproc = "Get environment name via environment logical"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dgel_log_ret = ""
   SET dgel_log_ret = cnvtlower(trim(logical("environment")))
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("ENVIRONMENT LOGICAL:",dgel_log_ret))
   ENDIF
   IF (trim(dgel_log_ret) > " ")
    RETURN(1)
   ELSE
    SET dm_err->emsg = "Environment logical is not valued."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE ddr_node_prompt(dnp_src_node,dnp_tgt_node,dnp_node_ret)
   SET dm_err->eproc = "Prompt user for node name."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,5,131)
   CALL text(3,4,concat("Is this process being run from the ",evaluate(dnp_src_node,0,"TARGET",
      "SOURCE")," primary application node?"))
   CALL accept(3,64,"A;cu"," "
    WHERE curaccept IN ("Y", "N"))
   IF (curaccept="Y")
    SET dnp_node_ret = cnvtlower(trim(curnode))
   ELSE
    SET message = nowindow
    SET dm_err->emsg = concat("Process must be run from ",evaluate(dnp_src_node,0,"TARGET","SOURCE"),
     " application node.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET message = nowindow
   CALL clear(1,1)
   IF (dnp_src_node=1)
    SET ddr_domain_data->src_nodes_cnt = (ddr_domain_data->src_nodes_cnt+ 1)
    SET stat = alterlist(ddr_domain_data->src_nodes,ddr_domain_data->src_nodes_cnt)
    SET ddr_domain_data->src_nodes[ddr_domain_data->src_nodes_cnt].node_name = dnp_node_ret
   ELSE
    SET ddr_domain_data->tgt_nodes_cnt = (ddr_domain_data->tgt_nodes_cnt+ 1)
    SET stat = alterlist(ddr_domain_data->tgt_nodes,ddr_domain_data->tgt_nodes_cnt)
    SET ddr_domain_data->tgt_nodes[ddr_domain_data->tgt_nodes_cnt].node_name = dnp_node_ret
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_dev_prompt(ddp_src_dev,ddp_tgt_dev,ddp_dev_ret)
   DECLARE ddp_str = vc WITH protect, noconstant("")
   SET ddp_str = concat("Enter ",evaluate(ddp_src_dev,1,"SOURCE","TARGET"),
    " device name for storage of temporary files:")
   SET dm_err->eproc = "Prompt user for device name."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,5,131)
   CALL text(3,4,ddp_str)
   CALL accept(3,(size(ddp_str)+ 5),"P(30);CF"," "
    WHERE curaccept != " ")
   IF (findstring(":",trim(curaccept),1,1)=size(trim(curaccept)))
    SET ddp_dev_ret = cnvtlower(substring(1,(size(trim(curaccept)) - 1),curaccept))
   ELSE
    SET ddp_dev_ret = cnvtlower(curaccept)
   ENDIF
   SET message = nowindow
   CALL clear(1,1)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_dir_prompt(ddp_src_dir,ddp_tgt_dir,ddp_dir_ret)
   DECLARE ddp_file_delim = vc WITH protect, noconstant("")
   DECLARE ddp_example_txt = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Prompt user for temporary directory."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,6,131)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET ddp_example_txt = concat("replicate_backup.",trim(cnvtlower(curnode)))
    SET ddp_file_delim = "]"
   ELSE
    SET ddp_example_txt = concat("/cerner/replicate_backup/",trim(cnvtlower(curnode)),"/")
    SET ddp_file_delim = "/"
   ENDIF
   CALL text(3,4,concat("Enter Temporary Directory for ",evaluate(ddp_src_dir,1,"SOURCE","TARGET"),
     " (i.e. ",ddp_example_txt,"):"))
   CALL accept(5,8,"P(90);C",""
    WHERE  NOT (curaccept=""))
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET ddp_dir_ret = curaccept
   ELSE
    IF (substring(1,1,curaccept) != ddp_file_delim)
     SET ddp_dir_ret = concat(ddp_file_delim,curaccept)
    ELSE
     SET ddp_dir_ret = curaccept
    ENDIF
    IF (findstring(ddp_file_delim,trim(ddp_dir_ret),1,1) != size(trim(ddp_dir_ret)))
     SET ddp_dir_ret = concat(trim(ddp_dir_ret),ddp_file_delim)
    ENDIF
   ENDIF
   SET message = nowindow
   CALL clear(1,1)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_user(dvu_env_name)
   DECLARE dvu_str = vc WITH protect, noconstant("")
   DECLARE dvu_reg_ret = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Validating User"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os != "AXP")
    AND cnvtupper(curuser) != "ROOT")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Current user is not the ROOT user."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF ((dm2_sys_misc->cur_os="AXP"))
    SET dvu_str = concat("\environment\",dvu_env_name," LocalUserName")
    IF (ddr_lreg_oper("GET",dvu_str,dvu_reg_ret)=0)
     RETURN(0)
    ENDIF
    IF (cnvtupper(curuser) != cnvtupper(dvu_reg_ret))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Making sure current user is the domain user."
     SET dm_err->emsg = "Current user is not the domain user."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_source_env(dvse_chk_dir)
   DECLARE dvse_str = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Prompt for SOURCE environment name"
   CALL disp_msg("",dm_err->logfile,0)
   IF ((ddr_domain_data->src_env="DM2NOTSET"))
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET ddr_domain_data->src_env = cnvtlower(drrr_rf_data->src_env_name)
    ELSE
     SET message = window
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,5,131)
     CALL text(3,4,"Please enter SOURCE environment name:")
     CALL accept(3,44,"P(30);C"," "
      WHERE curaccept > " ")
     SET ddr_domain_data->src_env = curaccept
     CALL clear(1,1)
     SET message = nowindow
    ENDIF
   ENDIF
   IF (dvse_chk_dir=1)
    SET dvse_str = evaluate(dm2_sys_misc->cur_os,"AXP",concat(ddr_domain_data->tgt_tmp_dev,":[",
      ddr_domain_data->tgt_tmp_dir,".",ddr_domain_data->src_env,
      "]"),concat(ddr_domain_data->tgt_tmp_dir,ddr_domain_data->src_env,"/"))
    SET dm_err->eproc = concat("Verify that ",dvse_str," directory exists")
    IF ( NOT (dm2_find_dir(dvse_str)))
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Directory for SOURCE environment does not exist."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_pop_reg_struct(dprs_type,dprs_file,dprs_reset)
   DECLARE dprs_str = vc WITH protect, noconstant("")
   DECLARE dprs_new = i2 WITH protect, noconstant(0)
   DECLARE dprs_new_key = i2 WITH protect, noconstant(0)
   DECLARE dprs_new_prop = i2 WITH protect, noconstant(0)
   DECLARE dprs_ckcnt = i4 WITH protect, noconstant(0)
   DECLARE dprs_skcnt = i4 WITH protect, noconstant(0)
   DECLARE dprs_tkcnt = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Open ",dprs_file," and load registry data")
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (dprs_reset=1)
    CASE (dprs_type)
     OF 1:
      FOR (dprs_skcnt = 1 TO ddr_reg->skcnt)
       SET ddr_reg->skey[dprs_skcnt].spcnt = 0
       SET stat = alterlist(ddr_reg->skey[dprs_skcnt].sprop,0)
      ENDFOR
      SET ddr_reg->skcnt = 0
      SET stat = alterlist(ddr_reg->skey,ddr_reg->skcnt)
     OF 2:
      FOR (dprs_tkcnt = 1 TO ddr_reg->tkcnt)
       SET ddr_reg->tkey[dprs_tkcnt].tpcnt = 0
       SET stat = alterlist(ddr_reg->tkey[dprs_tkcnt].tprop,0)
      ENDFOR
      SET ddr_reg->tkcnt = 0
      SET stat = alterlist(ddr_reg->tkey,ddr_reg->tkcnt)
     OF 3:
      FOR (dprs_ckcnt = 1 TO ddr_reg->ckcnt)
       SET ddr_reg->ckey[dprs_ckcnt].cpcnt = 0
       SET stat = alterlist(ddr_reg->ckey[dprs_ckcnt].cprop,0)
      ENDFOR
      SET ddr_reg->ckcnt = 0
      SET stat = alterlist(ddr_reg->ckey,ddr_reg->ckcnt)
    ENDCASE
   ENDIF
   FREE SET dprs_data_file
   SET logical dprs_data_file dprs_file
   FREE DEFINE rtl3
   DEFINE rtl3 "dprs_data_file"
   SELECT INTO "nl:"
    t.line
    FROM rtl3t t
    WHERE t.line > " "
    HEAD REPORT
     dprs_new = 1
    DETAIL
     dprs_str = trim(t.line,3)
     CASE (dprs_type)
      OF 1:
       IF (substring(1,2,dprs_str)="[\")
        ddr_reg->skcnt = (ddr_reg->skcnt+ 1), stat = alterlist(ddr_reg->skey,ddr_reg->skcnt), ddr_reg
        ->skey[ddr_reg->skcnt].skeyname = cnvtlower(substring(2,(size(dprs_str) - 2),dprs_str))
       ELSE
        IF (substring(1,1,dprs_str) != "\"
         AND (ddr_reg->skcnt > 0))
         ddr_reg->skey[ddr_reg->skcnt].spcnt = (ddr_reg->skey[ddr_reg->skcnt].spcnt+ 1), stat =
         alterlist(ddr_reg->skey[ddr_reg->skcnt].sprop,ddr_reg->skey[ddr_reg->skcnt].spcnt), ddr_reg
         ->skey[ddr_reg->skcnt].sprop[ddr_reg->skey[ddr_reg->skcnt].spcnt].spropname_orig = substring
         (1,(findstring("=",dprs_str,1,0) - 1),dprs_str),
         ddr_reg->skey[ddr_reg->skcnt].sprop[ddr_reg->skey[ddr_reg->skcnt].spcnt].spropname =
         cnvtlower(substring(1,(findstring("=",dprs_str,1,0) - 1),dprs_str)), ddr_reg->skey[ddr_reg->
         skcnt].sprop[ddr_reg->skey[ddr_reg->skcnt].spcnt].spropval = substring((findstring("=",
           dprs_str,1,0)+ 1),(size(dprs_str) - findstring("=",dprs_str,1,0)),dprs_str)
        ENDIF
       ENDIF
      OF 2:
       IF (substring(1,2,dprs_str)="[\")
        ddr_reg->tkcnt = (ddr_reg->tkcnt+ 1), stat = alterlist(ddr_reg->tkey,ddr_reg->tkcnt), ddr_reg
        ->tkey[ddr_reg->tkcnt].tkeyname = cnvtlower(substring(2,(size(dprs_str) - 2),dprs_str))
       ELSE
        IF (substring(1,1,dprs_str) != "\"
         AND (ddr_reg->tkcnt > 0))
         ddr_reg->tkey[ddr_reg->tkcnt].tpcnt = (ddr_reg->tkey[ddr_reg->tkcnt].tpcnt+ 1), stat =
         alterlist(ddr_reg->tkey[ddr_reg->tkcnt].tprop,ddr_reg->tkey[ddr_reg->tkcnt].tpcnt), ddr_reg
         ->tkey[ddr_reg->tkcnt].tprop[ddr_reg->tkey[ddr_reg->tkcnt].tpcnt].tpropname_orig = substring
         (1,(findstring("=",dprs_str,1,0) - 1),dprs_str),
         ddr_reg->tkey[ddr_reg->tkcnt].tprop[ddr_reg->tkey[ddr_reg->tkcnt].tpcnt].tpropname =
         cnvtlower(substring(1,(findstring("=",dprs_str,1,0) - 1),dprs_str)), ddr_reg->tkey[ddr_reg->
         tkcnt].tprop[ddr_reg->tkey[ddr_reg->tkcnt].tpcnt].tpropval = substring((findstring("=",
           dprs_str,1,0)+ 1),(size(dprs_str) - findstring("=",dprs_str,1,0)),dprs_str)
        ENDIF
       ENDIF
      OF 3:
       IF (substring(1,2,dprs_str)="[\")
        ddr_reg->ckcnt = (ddr_reg->ckcnt+ 1), stat = alterlist(ddr_reg->ckey,ddr_reg->ckcnt), ddr_reg
        ->ckey[ddr_reg->ckcnt].ckeyname = cnvtlower(substring(2,(size(dprs_str) - 2),dprs_str))
       ELSE
        IF (substring(1,1,dprs_str) != "\"
         AND (ddr_reg->ckcnt > 0))
         ddr_reg->ckey[ddr_reg->ckcnt].cpcnt = (ddr_reg->ckey[ddr_reg->ckcnt].cpcnt+ 1), stat =
         alterlist(ddr_reg->ckey[ddr_reg->ckcnt].cprop,ddr_reg->ckey[ddr_reg->ckcnt].cpcnt), ddr_reg
         ->ckey[ddr_reg->ckcnt].cprop[ddr_reg->ckey[ddr_reg->ckcnt].cpcnt].cpropname_orig = substring
         (1,(findstring("=",dprs_str,1,0) - 1),dprs_str),
         ddr_reg->ckey[ddr_reg->ckcnt].cprop[ddr_reg->ckey[ddr_reg->ckcnt].cpcnt].cpropname =
         cnvtlower(substring(1,(findstring("=",dprs_str,1,0) - 1),dprs_str)), ddr_reg->ckey[ddr_reg->
         ckcnt].cprop[ddr_reg->ckey[ddr_reg->ckcnt].cpcnt].cpropval = substring((findstring("=",
           dprs_str,1,0)+ 1),(size(dprs_str) - findstring("=",dprs_str,1,0)),dprs_str)
        ENDIF
       ENDIF
     ENDCASE
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_reg)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_srv_info(dgsi_type,dgsi_tag,dgsi_server_id,dgsi_server_desc)
   DECLARE dgsi_file_name = vc WITH protect, noconstant("")
   DECLARE dgsi_cmd = vc WITH protect, noconstant("")
   DECLARE dgsi_path = vc WITH protect, noconstant("")
   DECLARE dgsi_domain_name = vc WITH protect, noconstant("")
   DECLARE dgsi_user = vc WITH protect, noconstant("")
   DECLARE dgsi_pw = vc WITH protect, noconstant("")
   DECLARE dgsi_srv_path = vc WITH protect, noconstant("")
   DECLARE dgsi_srv_found_flag = i2 WITH protect, noconstant(0)
   DECLARE dgsi_tmp_err_ind = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Find server id and description for ",dgsi_tag)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dgsi_type="src")
    SET dgsi_domain_name = ddr_domain_data->src_domain_name
    SET dgsi_user = ddr_domain_data->src_mng
    SET dgsi_pw = ddr_domain_data->src_mng_pwd
    SET dgsi_path = ddr_domain_data->src_tmp_full_dir
   ELSEIF (dgsi_type="tgt")
    SET dgsi_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgsi_domain_name = ddr_domain_data->tgt_domain_name
    SET dgsi_user = ddr_domain_data->tgt_mng
    SET dgsi_pw = ddr_domain_data->tgt_mng_pwd
   ENDIF
   SET dgsi_server_id = "0"
   SET dgsi_server_desc = "NOT FOUND"
   CASE (dgsi_tag)
    OF "authorize":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:auth_server.exe"
     ELSE
      SET dgsi_srv_path = "cer_exe/auth_server"
     ENDIF
    OF "transaction database master":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:tdb_server.exe -param *master*"
     ELSE
      SET dgsi_srv_path = "cer_exe/tdb_server -param *master*"
     ENDIF
    OF "transaction database slave":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:tdb_server.exe -param *slave*"
     ELSE
      SET dgsi_srv_path = "cer_exe/tdb_server -param *slave*"
     ENDIF
    OF "server control panel":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:scp_server.exe"
     ELSE
      SET dgsi_srv_path = "cer_exe/scp_server"
     ENDIF
    OF "security master":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:sec_server.exe -param *master*"
     ELSE
      SET dgsi_srv_path = "cer_exe/sec_server -param *master*"
     ENDIF
    OF "security slave":
     IF ((dm2_sys_misc->cur_os="AXP"))
      SET dgsi_srv_path = "cer_exe:sec_server.exe -param -not *master*"
     ELSE
      SET dgsi_srv_path = "cer_exe/sec_server -param -not *master*"
     ENDIF
   ENDCASE
   SET dgsi_file_name = concat(dgsi_path,"server_id.dat")
   IF (dm2_findfile(dgsi_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsi_cmd = concat("del ",dgsi_file_name,";*")
    ELSE
     SET dgsi_cmd = concat("rm ",dgsi_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dgsi_file_name = concat(dgsi_path,"server_name",evaluate(dm2_sys_misc->cur_os,"AXP",".com",
     ".ksh"))
   IF (dm2_findfile(dgsi_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsi_cmd = concat("del ",dgsi_file_name,";*")
    ELSE
     SET dgsi_cmd = concat("rm ",dgsi_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to find server id for ",dgsi_tag,": ",dgsi_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgsi_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!server_name.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('$tgt_node=f$getsyi("nodename")'), row + 1,
      dgsi_cmd = concat('$if f$search("',dgsi_path,'find_server_id.dat") .nes. "" then delete ',
       dgsi_path,"find_server_id.dat;*"),
      CALL print(dgsi_cmd), row + 1,
      CALL print('$server_id = "NOT_FOUND"'), row + 1,
      CALL print('$server_desc = "NOT_FOUND"'),
      row + 1,
      CALL print('$srv_path = "NONE"'), row + 1,
      CALL print("$id_pos = 0"), row + 1,
      CALL print("$desc_pos = 0"),
      row + 1,
      CALL print("$row_num = 0"), row + 1,
      CALL print("$srv_row_num = 0"), row + 1,
      CALL print("$tries = 0"),
      row + 1,
      CALL print(concat("$define/user_mode sys$output ",dgsi_path,"find_server_id.dat")), row + 1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
      CALL print("$DECK"),
      row + 1,
      CALL print(dgsi_user), row + 1,
      CALL print(dgsi_domain_name), row + 1,
      CALL print(dgsi_pw),
      row + 1,
      CALL print(concat("find -path ",dgsi_srv_path)), row + 1,
      CALL print("exit"), row + 1,
      CALL print("$EOD"),
      row + 1,
      CALL print(concat("$open/read SERVER_LIST ",dgsi_path,"find_server_id.dat")), row + 1,
      CALL print("$tries = tries + 1"), row + 1,
      CALL print("$READ_SERVER_LIST:"),
      row + 1,
      CALL print("$   read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record"), row + 1,
      CALL print("$   row_num = row_num + 1"), row + 1,
      CALL print("$   length = f$length(record)"),
      row + 1,
      CALL print('$   if(f$locate("No matching entries found" ,record) .ne. length)'), row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      goto END_READ_SERVER_LIST "),
      row + 1,
      CALL print("$   endif"), row + 1,
      CALL print("$   if (row_num .eq. srv_row_num)"), row + 1,
      CALL print("$   then"),
      row + 1,
      CALL print('$      server_id = f$element(0, " ", record)'), row + 1,
      CALL print("$      server_desc = f$extract(desc_pos, length, record)"), row + 1,
      CALL print("$   else"),
      row + 1,
      CALL print('$      id_pos = f$locate("id" ,record)'), row + 1,
      CALL print("$      if (id_pos .ne. length)"), row + 1,
      CALL print("$      then"),
      row + 1,
      CALL print('$         desc_pos = f$locate("description" ,record)'), row + 1,
      CALL print("$         if (desc_pos .gt. 0) .and. (desc_pos .ne. length)"), row + 1,
      CALL print("$         then"),
      row + 1,
      CALL print("$            srv_row_num = row_num + 2"), row + 1,
      CALL print("$         endif"), row + 1,
      CALL print("$      endif"),
      row + 1,
      CALL print("$   endif"), row + 1,
      CALL print("$!  write sys$output record "), row + 1,
      CALL print("$   goto READ_SERVER_LIST "),
      row + 1,
      CALL print("$END_READ_SERVER_LIST: "), row + 1,
      CALL print("$   close SERVER_LIST  "), row + 1, dgsi_cmd = concat('$if f$search("',dgsi_path,
       'server_id.dat") .nes. "" then delete ',dgsi_path,"server_id.dat;*"),
      CALL print(dgsi_cmd), row + 1,
      CALL print(concat("$define sys$output ",dgsi_path,"server_id.dat")),
      row + 1,
      CALL print('$if (server_id .eqs. "NOT_FOUND") .or. (server_desc .eqs. "NOT_FOUND")'), row + 1,
      CALL print("$then"), row + 1,
      CALL print(concat('$   write sys$output "Error : Server ',dgsi_tag,' is not found."')),
      row + 1,
      CALL print("$   deassign sys$output"), row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$else"),
      row + 1,
      CALL print(concat(^$   write sys$output "server_id=''server_id'"^)), row + 1,
      CALL print(concat(^$   write sys$output "server_desc=''server_desc'"^)), row + 1,
      CALL print("$   deassign sys$output"),
      row + 1,
      CALL print("$exit 1"), row + 1,
      CALL print("$   endif"), row + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("system_pwd='",dgsi_pw,"'")), row + 1,
      CALL print(concat("srv_path='",dgsi_srv_path,"'")),
      row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",dgsi_path,"server_name.dat")), row + 1,
      CALL print(dgsi_user), row + 1,
      CALL print(dgsi_domain_name),
      row + 1,
      CALL print("$system_pwd"), row + 1,
      CALL print("find -path $srv_path"), row + 1,
      CALL print("exit"),
      row + 1,
      CALL print("!"), row + 1,
      row + 1, dgsi_cmd = concat("server_id=$(grep '^[0-9]' ",dgsi_path,"server_name.dat|"), dgsi_cmd
       = concat(dgsi_cmd,^awk -F" " '{print $1}')^),
      CALL print(dgsi_cmd), row + 1, dgsi_cmd = concat("server_desc=$(grep '^[0-9]' ",dgsi_path,
       "server_name.dat|"),
      dgsi_cmd = concat(dgsi_cmd,^awk 'BEGIN { FS = "[0-9]+[ \t]+" } ; { print $2 }')^),
      CALL print(dgsi_cmd), row + 1,
      CALL print("if [[ -z $server_id || -z $server_desc ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print(concat('   echo "Error : Server ',dgsi_tag,' is not found."')), row + 1,
      dgsi_cmd = concat('   echo "Error : Server ',dgsi_tag,' is not found." >>',dgsi_path,
       "server_id.dat"),
      CALL print(dgsi_cmd), row + 1,
      CALL print("else"), row + 1, dgsi_cmd = concat('   echo "server_id=$server_id" >>',dgsi_path,
       "server_id.dat"),
      CALL print(dgsi_cmd), row + 1, dgsi_cmd = concat('   echo "server_desc=$server_desc" >>',
       dgsi_path,"server_id.dat"),
      CALL print(dgsi_cmd), row + 1,
      CALL print("fi"),
      row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",dgsi_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsi_cmd = concat("@",dgsi_file_name)
   ELSE
    SET dgsi_cmd = concat("chmod 777 ",dgsi_file_name)
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgsi_cmd = concat(". ",dgsi_file_name)
   ENDIF
   SET dgsi_tmp_err_ind = dm_err->err_ind
   IF (dm2_push_dcl(dgsi_cmd)=0)
    RETURN(0)
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (findstring("Error : Server",dm_err->errtext,1,1) > 0)
     SET dgsi_srv_found_flag = 0
     SET dgsi_server_id = "0"
     SET dgsi_server_desc = "NOT FOUND"
     SET dm_err->err_ind = dgsi_tmp_err_ind
    ELSE
     SET dgsi_srv_found_flag = 1
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (dgsi_srv_found_flag=1)
    SET dgsi_file_name = concat(dgsi_path,"server_id.dat")
    IF (dm2_findfile(dgsi_file_name)=0)
     IF ((dm_err->err_ind=0))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Find file ",dgsi_file_name)
      SET dm_err->emsg = concat("Failed to find ",dgsi_file_name)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Parse out server id and description for ",dgsi_tag)
    CALL disp_msg("",dm_err->logfile,0)
    FREE DEFINE rtl2
    FREE SET file_loc
    SET logical file_loc value(dgsi_file_name)
    DEFINE rtl2 "file_loc"
    SELECT INTO "nl:"
     r.line
     FROM rtl2t r
     HEAD REPORT
      beg_pos = 0, end_pos = 0
     DETAIL
      beg_pos = 0, end_pos = 0
      IF ((dm_err->debug_flag > 1))
       CALL echo(concat("LINE = ",r.line))
      ENDIF
      beg_pos = findstring("=",r.line,1,0)
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("BEG_POS=",beg_pos))
      ENDIF
      end_pos = size(trim(r.line))
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("END_POS=",end_pos))
      ENDIF
      IF (beg_pos > 0
       AND end_pos > 0)
       IF (findstring("Error : Server",trim(r.line),1,0) > 0)
        dgsi_server_id = "0", dgsi_server_desc = "NOT FOUND"
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgsi_server_id=",dgsi_server_id)),
         CALL echo(build("dgsi_server_desc=",dgsi_server_desc))
        ENDIF
       ELSEIF (findstring("server_id",trim(r.line),1,0) > 0)
        dgsi_server_id = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgsi_server_id=",dgsi_server_id))
        ENDIF
       ELSEIF (findstring("server_desc",trim(r.line),1,0) > 0)
        dgsi_server_desc = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgsi_server_desc=",dgsi_server_desc))
        ENDIF
       ELSE
        dgsi_server_id = "0", dgsi_server_desc = "NOT FOUND"
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgsi_server_id=",dgsi_server_id)),
         CALL echo(build("dgsi_server_desc=",dgsi_server_desc))
        ENDIF
       ENDIF
      ENDIF
     WITH nocounter, maxcol = 255
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSEIF (((dgsi_server_id="") OR (dgsi_server_desc="")) )
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Failed to extract server id and/or description for ",dgsi_tag)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_srv_details(dgsd_type,dgsd_id,dgsd_desc,dgsd_srv_found)
   DECLARE dgsd_file_name = vc WITH protect, noconstant("")
   DECLARE dgsd_cmd = vc WITH protect, noconstant("")
   DECLARE dgsd_path = vc WITH protect, noconstant("")
   DECLARE dgsd_domain_name = vc WITH protect, noconstant("")
   DECLARE dgsd_user = vc WITH protect, noconstant("")
   DECLARE dgsd_pw = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Getting server details for ",dgsd_id," from SCP")
   CALL disp_msg("",dm_err->logfile,0)
   IF (dgsd_type="src")
    SET dgsd_domain_name = ddr_domain_data->src_domain_name
    SET dgsd_user = ddr_domain_data->src_mng
    SET dgsd_pw = ddr_domain_data->src_mng_pwd
    SET dgsd_path = ddr_domain_data->src_tmp_full_dir
   ELSEIF (dgsd_type="tgt")
    SET dgsd_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgsd_domain_name = ddr_domain_data->tgt_domain_name
    SET dgsd_user = ddr_domain_data->tgt_mng
    SET dgsd_pw = ddr_domain_data->tgt_mng_pwd
   ENDIF
   SET dgsd_srv_found = 0
   SET dgsd_desc = "NOT FOUND"
   SET dgsd_file_name = concat(dgsd_path,"server_details.dat")
   IF (dm2_findfile(dgsd_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsd_cmd = concat("del ",dgsd_file_name,";*")
    ELSE
     SET dgsd_cmd = concat("rm ",dgsd_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsd_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dgsd_file_name = concat(dgsd_path,"server_details",evaluate(dm2_sys_misc->cur_os,"AXP",".com",
     ".ksh"))
   IF (dm2_findfile(dgsd_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsd_cmd = concat("del ",dgsd_file_name,";*")
    ELSE
     SET dgsd_cmd = concat("rm ",dgsd_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsd_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to find server details:",dgsd_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgsd_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!server_details.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('tgt_node=f$getsyi("nodename")'), row + 1,
      dgsd_cmd = concat('$if f$search("',dgsd_path,'find_server_details.dat") .nes. "" then delete ',
       dgsd_path,"find_server_details.dat;*"),
      CALL print(dgsd_cmd), row + 1,
      CALL print('$server_desc = "NOT_FOUND"'), row + 1,
      CALL print("$desc_pos = 0"),
      row + 1,
      CALL print(concat("$define/user_mode sys$output ",dgsd_path,"find_server_details.dat")), row +
      1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
      CALL print("$DECK"),
      row + 1,
      CALL print(dgsd_user), row + 1,
      CALL print(dgsd_domain_name), row + 1,
      CALL print(dgsd_pw),
      row + 1,
      CALL print(concat("show ",dgsd_id)), row + 1,
      CALL print("exit"), row + 1,
      CALL print("$EOD"),
      row + 1,
      CALL print(concat("$open/read SERVER_LIST ",dgsd_path,"find_server_details.dat")), row + 1,
      CALL print("$READ_SERVER_LIST:"), row + 1,
      CALL print("$   read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record"),
      row + 1,
      CALL print('$   record = f$edit(record, "lowercase")'), row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print('$   if(f$locate("entry not found" ,record) .ne. length)'),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      goto END_READ_SERVER_LIST "), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print(concat('$   desc_pos = f$locate("description: " ,record)')), row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print("$   if (desc_pos .gt. 0) .and. (desc_pos .ne. length)"),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      server_desc = f$extract(desc_pos, length, record)"), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print("$!  write sys$output record "), row + 1,
      CALL print("$   goto READ_SERVER_LIST "), row + 1,
      CALL print("$END_READ_SERVER_LIST: "),
      row + 1,
      CALL print("$   close SERVER_LIST  "), row + 1,
      dgsd_cmd = concat('$if f$search("',dgsd_path,'server_details.dat") .nes. "" then delete ',
       dgsd_path,"server_details.dat;*"),
      CALL print(dgsd_cmd), row + 1,
      CALL print(concat("$define sys$output ",dgsd_path,"server_details.dat")), row + 1,
      CALL print('$if server_desc .eqs. "NOT_FOUND"'),
      row + 1,
      CALL print("$then"), row + 1,
      CALL print(concat('$   write sys$output "Error : Server ',dgsd_id,' is not found."')), row + 1,
      CALL print("$   deassign sys$output"),
      row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$else"), row + 1,
      CALL print(concat(^$   write sys$output "server_desc=''server_desc'"^)),
      row + 1,
      CALL print("$   deassign sys$output"), row + 1,
      CALL print("$exit 1"), row + 1,
      CALL print("$   endif"),
      row + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("system_pwd='",dgsd_pw,"'")), row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",dgsd_path,"find_server_details.dat")),
      row + 1,
      CALL print(dgsd_user), row + 1,
      CALL print(dgsd_domain_name), row + 1,
      CALL print("$system_pwd"),
      row + 1,
      CALL print(concat("show ",dgsd_id)), row + 1,
      CALL print("exit"), row + 1,
      CALL print("!"),
      row + 1, row + 1, dgsd_cmd = concat("server_desc=$(tr '[:upper:]' '[:lower:]' < ",dgsd_path,
       ^find_server_details.dat|grep "description:" |awk -F"description: " '{print $2}')^),
      CALL print(dgsd_cmd), row + 1,
      CALL print("if [[ $server_desc = '' ]]"),
      row + 1,
      CALL print("then"), row + 1,
      CALL print(concat('   echo "Error : Server ',dgsd_id,' is not found." > ',dgsd_path,
       "server_details.dat")), row + 1,
      CALL print("else"),
      row + 1, dgsd_cmd = concat('   echo "server_desc=$server_desc" >',dgsd_path,
       "server_details.dat"),
      CALL print(dgsd_cmd),
      row + 1,
      CALL print("   fi"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Find server desc for server: ",dgsd_id)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsd_cmd = concat("@",dgsd_file_name)
   ELSE
    SET dgsd_cmd = concat("chmod 777 ",dgsd_file_name)
    IF (dm2_push_dcl(dgsd_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgsd_cmd = concat(". ",dgsd_file_name)
   ENDIF
   IF (dm2_push_dcl(dgsd_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dgsd_file_name = concat(dgsd_path,"server_details.dat")
   IF (dm2_findfile(dgsd_file_name)=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find file ",dgsd_file_name)
     SET dm_err->emsg = concat("Failed to find ",dgsd_file_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Parse out server desc for ",dgsd_id)
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dgsd_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     beg_pos = 0, end_pos = 0
    DETAIL
     beg_pos = 0, end_pos = 0
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     beg_pos = findstring("=",r.line,1,0)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("BEG_POS=",beg_pos))
     ENDIF
     end_pos = size(trim(r.line))
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("END_POS=",end_pos))
     ENDIF
     IF (beg_pos > 0
      AND end_pos > 0)
      IF (findstring("Error :",trim(r.line),1,0) > 0)
       dgsd_srv_found = 0, dgsd_desc = "NOT FOUND"
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dgsd_desc=",dgsd_desc))
       ENDIF
      ELSEIF (findstring("server_desc",trim(r.line),1,0) > 0)
       dgsd_srv_found = 1, dgsd_desc = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dgsd_desc=",dgsd_desc))
       ENDIF
      ELSE
       dgsd_srv_found = 0, dgsd_desc = "NOT FOUND"
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dgsd_desc=",dgsd_desc))
       ENDIF
      ENDIF
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (dgsd_desc="")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Failed to find server desc for ",dgsd_id)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    SET dgsd_srv_found = 0
    RETURN(0)
   ELSEIF (dgsd_desc="NOT FOUND")
    SET dgsd_srv_found = 0
   ELSE
    SET dgsd_srv_found = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_srv_id(dgsi_type,dgsi_desc,dgsi_server_id)
   DECLARE dgsi_file_name = vc WITH protect, noconstant("")
   DECLARE dgsi_cmd = vc WITH protect, noconstant("")
   DECLARE dgsi_path = vc WITH protect, noconstant("")
   DECLARE dgsi_domain_name = vc WITH protect, noconstant("")
   DECLARE dgsi_user = vc WITH protect, noconstant("")
   DECLARE dgsi_pw = vc WITH protect, noconstant("")
   IF (dgsi_type="src")
    SET dgsi_domain_name = ddr_domain_data->src_domain_name
    SET dgsi_user = ddr_domain_data->src_mng
    SET dgsi_pw = ddr_domain_data->src_mng_pwd
    SET dgsi_path = ddr_domain_data->src_tmp_full_dir
   ELSEIF (dgsi_type="tgt")
    SET dgsi_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgsi_domain_name = ddr_domain_data->tgt_domain_name
    SET dgsi_user = ddr_domain_data->tgt_mng
    SET dgsi_pw = ddr_domain_data->tgt_mng_pwd
   ENDIF
   SET dgsi_file_name = concat(dgsi_path,"server_id.dat")
   IF (dm2_findfile(dgsi_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsi_cmd = concat("del ",dgsi_file_name,";*")
    ELSE
     SET dgsi_cmd = concat("rm ",dgsi_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dgsi_file_name = concat(dgsi_path,"server_name",evaluate(dm2_sys_misc->cur_os,"AXP",".com",
     ".ksh"))
   IF (dm2_findfile(dgsi_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgsi_cmd = concat("del ",dgsi_file_name,";*")
    ELSE
     SET dgsi_cmd = concat("rm ",dgsi_file_name)
    ENDIF
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to find server id:",dgsi_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgsi_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!server_name.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('tgt_node=f$getsyi("nodename")'), row + 1,
      dgsi_cmd = concat('$if f$search("',dgsi_path,'find_server_id.dat") .nes. "" then delete ',
       dgsi_path,"find_server_id.dat;*"),
      CALL print(dgsi_cmd), row + 1,
      CALL print('$server_id = "NOT_FOUND"'), row + 1,
      CALL print("$desc_pos = 0"),
      row + 1,
      CALL print(concat("$define/user_mode sys$output ",dgsi_path,"find_server_id.dat")), row + 1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
      CALL print("$DECK"),
      row + 1,
      CALL print(dgsi_user), row + 1,
      CALL print(dgsi_domain_name), row + 1,
      CALL print(dgsi_pw),
      row + 1,
      CALL print(concat('find -descrip "',dgsi_desc,'"')), row + 1,
      CALL print("exit"), row + 1,
      CALL print("$EOD"),
      row + 1,
      CALL print(concat("$open/read SERVER_LIST ",dgsi_path,"find_server_id.dat")), row + 1,
      CALL print("$READ_SERVER_LIST:"), row + 1,
      CALL print("$   read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record"),
      row + 1,
      CALL print('$   record = f$edit(record, "lowercase")'), row + 1,
      dgsi_desc = replace(dgsi_desc,"*","",2),
      CALL print(concat('$   desc_pos = f$locate("',trim(dgsi_desc),'" ,record)')), row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print("$   if (desc_pos .gt. 0) .and. (desc_pos .ne. length)"),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print('$      server_id = f$element(0, " ", record)'), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print("$!  write sys$output record "), row + 1,
      CALL print("$   goto READ_SERVER_LIST "), row + 1,
      CALL print("$END_READ_SERVER_LIST: "),
      row + 1,
      CALL print("$   close SERVER_LIST  "), row + 1,
      dgsi_cmd = concat('$if f$search("',dgsi_path,'server_id.dat") .nes. "" then delete ',dgsi_path,
       "server_id.dat;*"),
      CALL print(dgsi_cmd), row + 1,
      CALL print(concat("$define sys$output ",dgsi_path,"server_id.dat")), row + 1,
      CALL print('$if server_id .eqs. "NOT_FOUND"'),
      row + 1,
      CALL print("$then"), row + 1,
      CALL print(concat('$   write sys$output "Error : Server ',dgsi_desc,' is not found."')), row +
      1,
      CALL print("$   deassign sys$output"),
      row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$else"), row + 1,
      CALL print(concat(^$   write sys$output "server_id=''server_id'"^)),
      row + 1,
      CALL print("$   deassign sys$output"), row + 1,
      CALL print("$exit 1"), row + 1,
      CALL print("$   endif"),
      row + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("system_pwd='",dgsi_pw,"'")), row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",dgsi_path,"server_name.dat")),
      row + 1,
      CALL print(dgsi_user), row + 1,
      CALL print(dgsi_domain_name), row + 1,
      CALL print("$system_pwd"),
      row + 1,
      CALL print(concat('find -descrip "',dgsi_desc,'"')), row + 1,
      CALL print("exit"), row + 1,
      CALL print("!"),
      row + 1, row + 1, dgsi_desc = replace(dgsi_desc,"*","",2),
      dgsi_cmd = concat("server_id=$(tr '[:upper:]' '[:lower:]' < ",dgsi_path,
       'server_name.dat|tail -n 5|grep "',trim(dgsi_desc),^" |awk -F" " '{print $1}')^),
      CALL print(dgsi_cmd), row + 1,
      CALL print("if [[ -z $server_id ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print(concat('   echo "Error : Server ',dgsi_desc,' is not found."')), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, dgsi_cmd = concat('   echo "server_id=$server_id" >',dgsi_path,"server_id.dat"),
      CALL print(dgsi_cmd),
      row + 1,
      CALL print("   fi"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Find server id for ",dgsi_desc)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgsi_cmd = concat("@",dgsi_file_name)
   ELSE
    SET dgsi_cmd = concat("chmod 777 ",dgsi_file_name)
    IF (dm2_push_dcl(dgsi_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgsi_cmd = concat(". ",dgsi_file_name)
   ENDIF
   IF (dm2_push_dcl(dgsi_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dgsi_file_name = concat(dgsi_path,"server_id.dat")
   IF (dm2_findfile(dgsi_file_name)=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find file ",dgsi_file_name)
     SET dm_err->emsg = concat("Failed to find ",dgsi_file_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Parse out server id for ",dgsi_desc)
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dgsi_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     beg_pos = 0, end_pos = 0
    DETAIL
     beg_pos = 0, end_pos = 0
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     beg_pos = findstring("=",r.line,1,0)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("BEG_POS=",beg_pos))
     ENDIF
     end_pos = size(trim(r.line))
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("END_POS=",end_pos))
     ENDIF
     IF (beg_pos > 0
      AND end_pos > 0)
      IF (findstring("server_id",trim(r.line),1,0) > 0)
       dgsi_server_id = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dgsi_server_id=",dgsi_server_id))
       ENDIF
      ENDIF
     ENDIF
     IF (findstring("Error :",trim(r.line),1,0) > 0)
      dm_err->err_ind = 1, dm_err->emsg = concat("Failed to find server id for ",dgsi_desc)
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (dgsi_server_id="")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Failed to find server id for ",dgsi_desc)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_from_dir(dgfd_src_ind,dgfd_logical,dgfd_from_dir)
   SET dm_err->eproc = concat("Find directory path for logical ",dgfd_logical)
   CALL disp_msg("",dm_err->logfile,0)
   DECLARE dgfd_loop = i2 WITH protect, noconstant(1)
   DECLARE dgfd_path = vc WITH protect, noconstant("")
   DECLARE dgfd_subpath = vc WITH protect, noconstant("")
   DECLARE dgfd_beg_pos = i4 WITH protect, noconstant(0)
   DECLARE dgfd_end_pos = i4 WITH protect, noconstant(0)
   DECLARE dgfd_logical_name = vc WITH protect, noconstant("")
   SET dgfd_logical_name = dgfd_logical
   WHILE (dgfd_loop)
    SET dgfd_path = parser(concat("trim(logical('",dgfd_logical_name,"'))"))
    IF (dgfd_path="")
     IF (dgfd_logical_name="cer_ocdtools")
      IF ((dm2_sys_misc->cur_os="AXP"))
       SET dgfd_path = replace(trim(logical("cer_ocd")),"]","tools]",2)
      ELSE
       SET dgfd_path = concat(trim(logical("cer_ocd")),"/tools")
      ENDIF
      SET dgfd_loop = 0
     ELSE
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Logical ",dgfd_logical_name," is not defined.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF (findstring("[",dgfd_path,1,0) > 0)
       SET dgfd_loop = 0
      ELSE
       SET dgfd_logical_name = dgfd_path
      ENDIF
     ELSE
      IF (findstring("/",dgfd_path,1,0) > 0)
       SET dgfd_loop = 0
      ELSE
       SET dgfd_logical_name = dgfd_path
      ENDIF
     ENDIF
    ENDIF
   ENDWHILE
   IF ((dm2_sys_misc->cur_os="AXP"))
    IF (findstring(".]",dgfd_path,1,0) > 0)
     IF (((dgfd_logical_name="ccldir") OR (dgfd_logical_name="cer_config"))
      AND dgfd_src_ind=1)
      SET dgfd_from_dir = replace(dgfd_path,".]","]",2)
     ELSE
      SET dgfd_from_dir = replace(dgfd_path,"]","..]*.*;*",2)
     ENDIF
    ELSE
     IF ( NOT (((dgfd_logical_name="ccldir") OR (dgfd_logical_name="cer_config")) )
      AND dgfd_src_ind=1)
      SET dgfd_from_dir = replace(dgfd_path,"]","...]*.*;*",2)
     ELSE
      SET dgfd_from_dir = dgfd_path
     ENDIF
    ENDIF
   ELSE
    SET dgfd_from_dir = concat(dgfd_path,"/")
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("from_dir = ",dgfd_from_dir))
   ENDIF
   IF (dgfd_src_ind=1
    AND (dm2_sys_misc->cur_os="AXP"))
    SET dgfd_beg_pos = findstring("[",dgfd_path,0)
    IF (findstring(".]",dgfd_path,1,0) > 0)
     SET dgfd_end_pos = findstring(".]",dgfd_path,0)
    ELSE
     SET dgfd_end_pos = findstring("]",dgfd_path,0)
    ENDIF
    SET dgfd_subpath = substring((dgfd_beg_pos+ 1),((dgfd_end_pos - dgfd_beg_pos) - 1),dgfd_path)
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("subpath = ",dgfd_subpath))
    ENDIF
    CASE (dgfd_logical)
     OF "cer_config":
      SET ddr_domain_data->src_cer_config_dir = dgfd_subpath
     OF "ccldir":
      SET ddr_domain_data->src_ccldir = dgfd_subpath
     OF "cer_ocdtools":
      SET ddr_domain_data->src_ocdtools_dir = dgfd_subpath
     OF "cer_wh":
      SET ddr_domain_data->src_warehouse_dir = dgfd_subpath
     OF "ccluserdir":
      SET ddr_domain_data->src_ccluserdir_dir = dgfd_subpath
    ENDCASE
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_continue_prompt(null)
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,20,131)
   CALL text(2,2,concat("Most Recent eproc: ",dm_err->eproc))
   CALL text(3,2,concat("Most Recent emsg (if any): ",dm_err->emsg))
   CALL text(4,2,concat("Do you want to continue?"))
   CALL text(5,2,"[Y]es or [N]o:")
   CALL accept(5,16,"A;cu"," "
    WHERE curaccept IN ("Y", "N"))
   IF (curaccept="N")
    CALL clear(1,1)
    SET message = nowindow
    SET dm_err->emsg = concat("I elect not to continue because ",dm_err->emsg)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET message = nowindow
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_tgt_node_flag(null)
   DECLARE dgtnf_file = vc WITH protect, noconstant(concat(ddr_domain_data->src_tmp_full_dir,
     "target_misc_data.dat"))
   IF (dm2_findfile(dgtnf_file)=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find file ",dgtnf_file)
     SET dm_err->emsg = concat("Failed to find ",dgtnf_file)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Read ",dgtnf_file," to set tgt_node_flag.")
   CALL disp_msg(" ",dm_err->logfile,0)
   FREE DEFINE rtl
   FREE SET file_loc
   SET logical file_loc dgtnf_file
   DEFINE rtl "file_loc"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    HEAD REPORT
     beg_pos = 0, length = 0
    DETAIL
     IF (findstring("tgt_node_flag=",t.line,1,0) > 0)
      length = size(trim(t.line)), beg_pos = findstring("=",t.line,1,0), ddr_domain_data->
      tgt_node_flag = cnvtint(substring((beg_pos+ 1),(length - beg_pos),t.line))
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("tgt_node_flag = ",ddr_domain_data->tgt_node_flag))
   ENDIF
   IF ( NOT ((ddr_domain_data->tgt_node_flag IN (1, 2, 3))))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = build("Invalid tgt_node_flag ",ddr_domain_data->tgt_node_flag)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_preserve_prompt(dpp_preserve)
   DECLARE dpp_curaccept = vc WITH protect, noconstant("")
   SET dpp_preserve = 0
   SET dm_err->eproc = "Prompt user whether to preserve Target data."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,6,131)
   CALL text(4,8,"Preserve data from TARGET database (Y/N) : ")
   CALL accept(4,52,"A;cu"," "
    WHERE curaccept IN ("Y", "N"))
   SET message = nowindow
   CALL clear(1,1)
   SET dpp_curaccept = curaccept
   IF (dpp_curaccept="Y")
    SET dpp_preserve = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_preserve_check_prompt(dpcp_preserve)
   DECLARE dpcp_curaccept = vc WITH protect, noconstant("")
   SET dpcp_preserve = 0
   SET dm_err->eproc = "Prompt user whether to preserve Target data should continue or restart."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET message = window
   SET width = 132
   CALL clear(1,1)
   CALL box(1,1,6,131)
   CALL text(4,8,
    "Preserve data from TARGET database in process.  Enter 'C' to continue or 'R' to restart (C/R) : "
    )
   CALL accept(4,104,"A;cu"," "
    WHERE curaccept IN ("C", "R"))
   SET message = nowindow
   CALL clear(1,1)
   SET dpcp_curaccept = curaccept
   IF (dpcp_curaccept="C")
    SET dpcp_preserve = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_link_data(null)
   DECLARE dgld_cfnd = i4 WITH protect, noconstant(0)
   DECLARE dgld_pfnd = i4 WITH protect, noconstant(0)
   DECLARE dgld_jfnd = i4 WITH protect, noconstant(0)
   DECLARE dgld_file = vc WITH protect, noconstant(build(ddr_domain_data->src_tmp_full_dir,
     "link_data.dat"))
   DECLARE dgld_str = vc WITH protect, noconstant("")
   DECLARE dgld_cnt = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = "Determining if CPLINK, PURGE and JVM symbolic link rows exist in dm_info."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "DM2_REPLICATE_LINK"=di.info_domain
     AND (("PURGE"=di.info_name) OR ((("CPLINK"=di.info_name) OR ("JVM"=di.info_name)) ))
    DETAIL
     IF (di.info_name="PURGE")
      dgld_pfnd = 1
     ELSEIF (di.info_name="CPLINK")
      dgld_cfnd = 1
     ELSEIF (di.info_name="JVM")
      dgld_jfnd = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgld_pfnd=0)
    SET dm_err->eproc = "Inserting PURGE symbolic link data into dm_info."
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_LINK", di.info_name = "PURGE", di.info_number = 1,
      di.info_char = "<$cer_exe/purge><$cer_proc/purge>"
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ENDIF
    COMMIT
   ENDIF
   IF (dgld_cfnd=0)
    SET dm_err->eproc = "Inserting CPLINK symbolic link data into dm_info."
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_LINK", di.info_name = "CPLINK", di.info_number = 1,
      di.info_char = "<$cer_exe/cplink><$cer_proc/cplink>"
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ENDIF
    COMMIT
   ENDIF
   IF (dgld_jfnd=0)
    SET dm_err->eproc = "Inserting JVM symbolic link data into dm_info."
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_LINK", di.info_name = "JVM", di.info_number = 1,
      di.info_char = "<$cer_wh/jvm>"
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ENDIF
    COMMIT
   ENDIF
   RECORD dgld_link_list(
     1 cnt = i4
     1 qual[*]
       2 sym_link_name = vc
       2 full_file_name = vc
       2 full_link_name = vc
       2 link_fnd = i2
   )
   SET dm_err->eproc = "Selecting list of symbolic link data from dm_info."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "DM2_REPLICATE_LINK"=di.info_domain
     AND 1=di.info_number
    HEAD REPORT
     tmp1 = 0, dgld_link_list->cnt = 0, stat = alterlist(dgld_link_list->qual,0)
    DETAIL
     IF (substring(1,1,di.info_char)="<"
      AND findstring(">",di.info_char,0) > 0)
      dgld_link_list->cnt = (dgld_link_list->cnt+ 1), stat = alterlist(dgld_link_list->qual,
       dgld_link_list->cnt), dgld_link_list->qual[dgld_link_list->cnt].sym_link_name = di.info_name,
      tmp1 = findstring(">",di.info_char,0), dgld_link_list->qual[dgld_link_list->cnt].full_link_name
       = substring(2,(tmp1 - 2),di.info_char)
      IF (tmp1 != size(trim(di.info_char)))
       dgld_link_list->qual[dgld_link_list->cnt].full_file_name = substring((tmp1+ 2),((size(trim(di
          .info_char)) - tmp1) - 2),di.info_char)
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dgld_link_list->cnt > 0))
    FOR (dgld_cnt = 1 TO dgld_link_list->cnt)
      SET dgld_str = concat("test -h ",dgld_link_list->qual[dgld_cnt].full_link_name,";echo $?")
      CALL dm2_push_dcl(dgld_str)
      SET dm_err->err_ind = 0
      IF (parse_errfile(dm_err->errfile)=0)
       RETURN(0)
      ENDIF
      IF (cnvtint(dm_err->errtext)=0)
       IF ((dm_err->debug_flag > 1))
        SET dm_err->eproc = concat("Symbolic Link ",dgld_link_list->qual[dgld_cnt].full_link_name,
         " found.")
        CALL disp_msg("",dm_err->logfile,0)
       ENDIF
       SET dgld_link_list->qual[dgld_cnt].link_fnd = 1
      ELSE
       IF ((dm_err->debug_flag > 1))
        SET dm_err->eproc = concat("Symbolic Link ",dgld_link_list->qual[dgld_cnt].full_link_name,
         " not found.")
        CALL disp_msg("",dm_err->logfile,0)
       ENDIF
       SET dgld_link_list->qual[dgld_cnt].link_fnd = 0
      ENDIF
    ENDFOR
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dgld_link_list)
    ENDIF
    IF (dm2_findfile(dgld_file) > 0)
     IF (dm2_push_dcl(concat("rm ",dgld_file))=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dm_err->eproc = "Writing source data to link_data.dat"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET logical dgld_config_file dgld_file
    SELECT INTO "dgld_config_file"
     DETAIL
      FOR (dgld_cnt = 1 TO dgld_link_list->cnt)
        IF ((dgld_link_list->qual[dgld_cnt].link_fnd=1))
         dgld_str = concat(dgld_link_list->qual[dgld_cnt].sym_link_name," ",dgld_link_list->qual[
          dgld_cnt].full_link_name," ",dgld_link_list->qual[dgld_cnt].full_file_name), col 0,
         dgld_str,
         row + 1
        ENDIF
      ENDFOR
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_rpt_reg_issues(null)
   DECLARE drri_log_ret = vc WITH protect, noconstant("")
   DECLARE drri_env_ok_ret = i2 WITH protect, noconstant(0)
   DECLARE drri_ckcnt = i4 WITH protect, noconstant(0)
   DECLARE drri_ckpcnt = i4 WITH protect, noconstant(0)
   DECLARE drri_fname = vc WITH protect, noconstant("")
   DECLARE drri_full_fname = vc WITH protect, noconstant("")
   DECLARE drri_str = vc WITH protect, noconstant("")
   DECLARE drri_ret_val = vc WITH protect, noconstant("")
   DECLARE drri_tm_key = vc WITH protect, noconstant("")
   DECLARE drri_max_pcnt = i4 WITH protect, noconstant(0)
   DECLARE drri_reg_tgt_env = vc WITH protect, noconstant("")
   IF ((ddr_domain_data->tgt_env="DM2NOTSET"))
    IF (ddr_get_env_logical(drri_log_ret)=0)
     RETURN(0)
    ENDIF
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     IF (cnvtlower(drri_log_ret) != cnvtlower(drrr_rf_data->tgt_env_name))
      SET dm_err->eproc = concat("Verify Target response file environment (",drrr_rf_data->
       tgt_env_name,") with current enviornment (",drri_log_ret,").")
      SET dm_err->emsg = "Environments specified do not match."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET ddr_domain_data->tgt_env = cnvtlower(dcsd_log_ret)
    ELSE
     IF (ddr_env_confirm(0,1,drri_log_ret,drri_env_ok_ret)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF (size(ddr_domain_data->tgt_env,1) > max_reg_env_len)
    SET drri_reg_tgt_env = substring(1,max_reg_env_len,ddr_domain_data->tgt_env)
   ELSE
    SET drri_reg_tgt_env = ddr_domain_data->tgt_env
   ENDIF
   IF ((ddr_domain_data->tgt_domain_name="DM2NOTSET"))
    SET dm_err->eproc = "Get domain name."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET drri_str = concat("\\environment\\",ddr_domain_data->tgt_env," Domain")
    IF (ddr_lreg_oper("GET",drri_str,drri_ret_val)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->tgt_domain_name = drri_ret_val
    IF (drri_ret_val="NOPARMRETURNED")
     SET dm_err->emsg = concat("Unable to retrieve domain name property for ",ddr_domain_data->
      tgt_env)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_validate_source_env(0)=0)
    RETURN(0)
   ENDIF
   SET message = nowindow
   IF (ddr_get_env_reg(0,0,"DEFINITION",1)=0)
    RETURN(0)
   ENDIF
   SET ddr_reg->cur_reg_file = build(dm2_install_schema->ccluserdir,drri_reg_tgt_env,"_c_env.reg")
   IF (ddr_pop_reg_struct(3,ddr_reg->cur_reg_file,1)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_env_reg(0,0,"NODE_DOMAIN",1)=0)
    RETURN(0)
   ENDIF
   SET ddr_reg->cur_reg_file = build(dm2_install_schema->ccluserdir,drri_reg_tgt_env,
    "_c_node_dom.reg")
   IF (ddr_pop_reg_struct(3,ddr_reg->cur_reg_file,0)=0)
    RETURN(0)
   ENDIF
   FOR (drri_ckcnt = 1 TO ddr_reg->ckcnt)
     IF (drri_ckcnt=1)
      SET drri_tm_key = build("\environment\",trim(ddr_domain_data->tgt_env),"\definitions")
      SET ddr_reg->ckey[drri_ckcnt].ckeyname = drri_tm_key
     ELSEIF ((ddr_reg->ckey[drri_ckcnt].ckeyname="\"))
      SET drri_tm_key = build("\node\",trim(curnode),"\domain\",trim(ddr_domain_data->tgt_domain_name
        ))
      SET ddr_reg->ckey[drri_ckcnt].ckeyname = drri_tm_key
     ELSE
      SET ddr_reg->ckey[drri_ckcnt].ckeyname = build(drri_tm_key,ddr_reg->ckey[drri_ckcnt].ckeyname)
     ENDIF
     IF ((ddr_reg->ckey[drri_ckcnt].cpcnt > drri_max_pcnt))
      SET drri_max_pcnt = ddr_reg->ckey[drri_ckcnt].cpcnt
     ENDIF
     FOR (drri_ckpcnt = 1 TO ddr_reg->ckey[drri_ckcnt].cpcnt)
       IF (findstring(cnvtupper(ddr_domain_data->src_env),cnvtupper(ddr_reg->ckey[drri_ckcnt].cprop[
         drri_ckpcnt].cpropval),1,0) > 0)
        SET ddr_reg->ckey[drri_ckcnt].cprop[drri_ckpcnt].cstr_fnd = 1
        SET ddr_reg->ckey[drri_ckcnt].cstr_fnd = 1
        SET ddr_reg->cstr_fnd = 1
       ENDIF
     ENDFOR
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_reg)
   ENDIF
   IF ((ddr_reg->cstr_fnd=1))
    IF (get_unique_file("dm2_reg_warn",".rpt")=0)
     RETURN(0)
    ENDIF
    SET drri_fname = cnvtlower(dm_err->unique_fname)
    SET drri_full_fname = build(dm2_install_schema->ccluserdir,cnvtlower(dm_err->unique_fname))
    IF (validate(drrr_responsefile_in_use,- (1))=1)
     SET drri_fname = build(drrr_misc_data->active_dir,cnvtlower(dm_err->unique_fname))
     SET drri_full_fname = build(drrr_misc_data->active_dir,cnvtlower(dm_err->unique_fname))
    ENDIF
    SET dm_err->eproc = concat("Creating TARGET Registry Warning Report ",drri_full_fname)
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO value(drri_fname)
     keyname = substring(1,100,ddr_reg->ckey[d.seq].ckeyname)
     FROM (dummyt d  WITH seq = value(ddr_reg->ckcnt)),
      (dummyt d2  WITH seq = value(drri_max_pcnt))
     PLAN (d
      WHERE (ddr_reg->ckey[d.seq].cstr_fnd=1))
      JOIN (d2
      WHERE (d2.seq <= ddr_reg->ckey[d.seq].cpcnt)
       AND (ddr_reg->ckey[d.seq].cprop[d2.seq].cstr_fnd=1))
     ORDER BY ddr_reg->ckey[d.seq].ckeyname
     HEAD REPORT
      "Target Registry Warning Report", row + 1,
      "-----------------------------------------------------------------------------",
      row + 1, "Report Location:  ", drri_full_fname,
      row + 1, row + 1,
      "The following Target registry property values contain the Source environment ",
      ddr_domain_data->src_env, ".", row + 2,
      "Review the Target properties to ensure they reflect the correct values.", row + 1
     HEAD PAGE
      row + 1, col 7, "Property Name",
      col 50, "Property Value", row + 1,
      col 7, "-------------", col 50,
      "--------------", row + 1
     HEAD keyname
      "Key:  ", ddr_reg->ckey[d.seq].ckeyname, row + 1
     DETAIL
      col 7, ddr_reg->ckey[d.seq].cprop[d2.seq].cpropname, col 50,
      ddr_reg->ckey[d.seq].cprop[d2.seq].cpropval, row + 1
     WITH nocounter, format = variable, formfeed = none,
      maxcol = 512
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ( NOT (validate(drrr_responsefile_in_use,- (1))=1))
     SET dm_err->eproc = concat("Displaying TARGET Registry Warning Report ",drri_full_fname)
     FREE DEFINE rtl2
     DEFINE rtl2 value(drri_fname)
     SELECT INTO mine
      t.line
      FROM rtl2t t
      DETAIL
       col 0, t.line, row + 1
      FOOT REPORT
       row + 0
      WITH nocounter, maxcol = 5000
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ((drer_email_list->email_cnt > 0))
      SET drer_email_det->msgtype = "ACTIONREQ"
      SET drer_email_det->status = "REPORT"
      SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
      SET drer_email_det->step = "TARGET Registry Warning Report"
      SET drer_email_det->email_level = 1
      SET drer_email_det->logfile = dm_err->logfile
      SET drer_email_det->err_ind = dm_err->err_ind
      SET drer_email_det->eproc = dm_err->eproc
      SET drer_email_det->emsg = dm_err->emsg
      SET drer_email_det->user_action = dm_err->user_action
      SET drer_email_det->attachment = drri_full_fname
      CALL drer_add_body_text(concat("TARGET Registry Warning Report was generated at ",format(
         drer_email_det->status_dt_tm,";;q")),1)
      CALL drer_add_body_text(concat("User Action : Please review the report to ensure ",
        "Target properties reflect the correct values."),0)
      CALL drer_add_body_text(concat("Report file name : ",drri_full_fname),0)
      IF (drer_compose_email(null)=1)
       CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
        email_level)
      ENDIF
      CALL drer_reset_pre_err(null)
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Target Registry Warnings Detected:  Report can be found in : ",
     drri_full_fname)
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_check_sqlnet(dcs_src_ind,dcs_tgt_ind,dcs_oracle_home)
   DECLARE dcs_sqlnet_file = vc WITH protect, noconstant("")
   DECLARE dcs_sqlnet_dir = vc WITH protect, noconstant("")
   DECLARE dcs_sqlnet_path = vc WITH protect, noconstant("")
   DECLARE dcs_file_name = vc WITH protect, noconstant("")
   DECLARE dcs_dir = vc WITH protect, noconstant("")
   DECLARE dcs_cmd = vc WITH protect, noconstant("")
   DECLARE dcs_val = vc WITH protect, noconstant("DM2NOTSET")
   SET dm_err->eproc = "Verify that sqlnet.ora file has the bequeath_detach parameter"
   CALL disp_msg("",dm_err->logfile,0)
   SET dcs_sqlnet_file = "sqlnet.ora"
   SET dcs_sqlnet_dir = concat(dcs_oracle_home,"/network/admin/")
   SET dcs_sqlnet_path = concat(dcs_sqlnet_dir,dcs_sqlnet_file)
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("ORACLE_HOME: ",dcs_oracle_home))
    CALL echo(concat("DIRECTORY: ",dcs_sqlnet_dir))
    CALL echo(concat("FILE: ",dcs_sqlnet_file))
    CALL echo(concat("FULL PATH: ",dcs_sqlnet_path))
   ENDIF
   IF (trim(dcs_oracle_home)="")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Oracle Home value passed in is invalid"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (findstring("10.",dcs_oracle_home,1,1)=0)
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Parse through sqlnet.ora"
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dcs_sqlnet_path)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     beg_pos = 0, end_pos = 0
    DETAIL
     beg_pos = 0, end_pos = 0
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     beg_pos = findstring("=",r.line,1,0)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("BEG_POS=",beg_pos))
     ENDIF
     end_pos = size(trim(r.line))
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("END_POS=",end_pos))
     ENDIF
     IF (beg_pos > 0
      AND end_pos > 0)
      IF (findstring("bequeath_detach",cnvtlower(trim(r.line)),1,0) > 0)
       dcs_val = replace(substring((beg_pos+ 1),(end_pos - beg_pos),r.line)," ","",0)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dcs_val=",dcs_val))
       ENDIF
      ENDIF
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtlower(dcs_val) != "yes")
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat(
     "bequeath_detach property either does NOT exist or is NOT set correctly ",
     "in $ORACLE_HOME/network/admin/sqlnet.ora")
    SET dm_err->user_action =
    "Modify the sqlnet.ora file to have the following line (without quotes): 'bequeath_detach=yes'"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_data_collection_space_needs(ddcsn_src_ind,ddcsn_tgt_ind)
   DECLARE ddcsn_file_name = vc WITH protect, noconstant("")
   DECLARE ddcsn_cmd = vc WITH protect, noconstant("")
   DECLARE ddcsn_path = vc WITH protect, noconstant("")
   DECLARE ddcsn_domain_name = vc WITH protect, noconstant("")
   DECLARE ddcsn_user = vc WITH protect, noconstant("")
   DECLARE ddcsn_tmp_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_srv_path = vc WITH protect, noconstant("")
   DECLARE ddcsn_srv_found_flag = i2 WITH protect, noconstant(0)
   DECLARE ddcsn_tmp_err_ind = i2 WITH protect, noconstant(0)
   DECLARE ddcsn_ccldir = vc WITH protect, noconstant("")
   DECLARE ddcsn_ccluserdir_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_warehouse_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_cer_config_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_ocdtools_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_cer_forms_dir = vc WITH protect, noconstant("")
   DECLARE ddcsn_tdb_id = i4 WITH protect, noconstant(0)
   DECLARE ddcsn_tdb_file = vc WITH protect, noconstant("")
   DECLARE ddcsn_temp_size = vc WITH protect, noconstant("")
   DECLARE ddcsn_size_nbr = f8 WITH protect, noconstant(0.0)
   DECLARE ddcsn_cnt = i4 WITH protect, noconstant(0)
   DECLARE ddcsn_str = vc WITH protect, noconstant("")
   DECLARE ddcsn_report_destination = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Calculate space needs for various ",evaluate(ddcsn_tgt_ind,1,"TGT",
     "SRC")," components ")
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (ddr_get_from_dir(ddcsn_src_ind,"cer_config",ddcsn_cer_config_dir)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_from_dir(ddcsn_src_ind,"ccldir",ddcsn_ccldir)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_from_dir(ddcsn_src_ind,"cer_ocdtools",ddcsn_ocdtools_dir)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_from_dir(ddcsn_src_ind,"cer_wh",ddcsn_warehouse_dir)=0)
    RETURN(0)
   ENDIF
   IF (ddr_get_from_dir(ddcsn_src_ind,"ccluserdir",ddcsn_ccluserdir_dir)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (ddr_get_from_dir(ddcsn_src_ind,"cer_forms",ddcsn_cer_forms_dir)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddcsn_src_ind=1)
    SET ddcsn_domain_name = ddr_domain_data->src_domain_name
    SET ddcsn_path = ddr_domain_data->src_tmp_full_dir
    IF ((ddr_domain_data->src_tdb_server_master_id > 0))
     SET ddcsn_tdb_id = ddr_domain_data->src_tdb_server_master_id
    ENDIF
   ELSEIF (ddcsn_tgt_ind=1)
    SET ddcsn_domain_name = ddr_domain_data->tgt_domain_name
    SET ddcsn_path = ddr_domain_data->tgt_tmp_full_dir
    IF ((ddr_domain_data->tgt_tdb_server_master_id > 0))
     SET ddcsn_tdb_id = ddr_domain_data->tgt_tdb_server_master_id
    ELSEIF ((ddr_domain_data->tgt_tdb_server_slave_id > 0))
     SET ddcsn_tdb_id = ddr_domain_data->tgt_tdb_server_slave_id
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(ddcsn_domain_name)
    CALL echo(ddcsn_ccldir)
    CALL echo(ddcsn_ccluserdir_dir)
    CALL echo(ddcsn_warehouse_dir)
    CALL echo(ddcsn_cer_config_dir)
    CALL echo(ddcsn_ocdtools_dir)
   ENDIF
   SET ddcsn_file_name = concat(ddcsn_path,"space_needs.dat")
   IF (dm2_findfile(ddcsn_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET ddcsn_cmd = concat("del ",ddcsn_file_name,";*")
    ELSE
     SET ddcsn_cmd = concat("rm ",ddcsn_file_name)
    ENDIF
    IF (dm2_push_dcl(ddcsn_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET ddcsn_file_name = concat(ddcsn_path,"calc_space_needs",evaluate(dm2_sys_misc->cur_os,"AXP",
     ".com",".ksh"))
   IF (dm2_findfile(ddcsn_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET ddcsn_cmd = concat("del ",ddcsn_file_name,";*")
    ELSE
     SET ddcsn_cmd = concat("rm ",ddcsn_file_name)
    ENDIF
    IF (dm2_push_dcl(ddcsn_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   IF (ddr_get_tdb_file(ddcsn_src_ind,ddcsn_tgt_ind,ddcsn_tdb_id,ddcsn_tdb_file)=0)
    RETURN(0)
   ENDIF
   CALL echo(ddcsn_tdb_file)
   SET dm_err->eproc = concat("Create file to calculate space needs: ",ddcsn_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(ddcsn_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!calc_space_needs.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('$tgt_node=f$getsyi("nodename")'), row + 1,
      ddcsn_cmd = concat('$if f$search("',ddcsn_path,'sn_temp.dat") .nes. "" then delete ',ddcsn_path,
       "sn_temp.dat;*"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(concat("$define/user_mode sys$output ",ddcsn_path,"sn_temp.dat")), row + 1,
      CALL print(concat("$open/write SPACE_NEEDS ",ddcsn_path,"space_needs.dat")),
      row + 1, ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_ccldir,
       "dic.dat"," /out=",
       ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print(
      '$call get_size "dicdat"                                                            '), row + 1,
      ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_warehouse_dir,
       " /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(
      '$call get_size "warehouse"                                                            '), row
       + 1, ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",
       ddcsn_ocdtools_dir," /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(
      '$call get_size "ocd_tools"                                                            '),
      row + 1, ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_ccldir,
       " /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print(
      '$call get_size "ccldir"                                                            '), row + 1,
      ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_cer_config_dir,
       " /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(
      '$call get_size "cer_config"                                                            '), row
       + 1, ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_tdb_file,
       " /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(
      '$call get_size "tdb_export"                                                            '),
      row + 1, ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",
       ddcsn_cer_config_dir,"sec_user.dat"," /out=",
       ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print(
      '$call get_size "sec_user_export"                                                            '),
      row + 1,
      ddcsn_cmd = concat("pipe dir /grand_total/size=all/size=units=bytes "," ",ddcsn_ccluserdir_dir,
       " /out=",ddcsn_path,
       "sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      CALL print(
      '$call get_size "ccluserdir"                                                            '), row
       + 1,
      CALL print("$deassign sys$output"),
      row + 1,
      CALL print("$close SPACE_NEEDS  "), row + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!subroutine definition                                                               "),
      row + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!------------------------------------                                                "), row
       + 1,
      CALL print(
      "$! subroutine:                                                                        "),
      row + 1,
      CALL print(
      "$!      get_size - get size from sn_temp.dat                                          "), row
       + 1,
      CALL print(
      "$!-----------------------------------                                                 "), row
       + 1,
      CALL print(
      "$GET_SIZE:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print('$size = " "'), row + 1,
      CALL print("$length = 0"),
      row + 1,
      CALL print("$size_pos = 0"), row + 1,
      CALL print(concat("$open/read SN_TEMP ",ddcsn_path,"sn_temp.dat")), row + 1,
      CALL print("$READ_SN_TEMP:"),
      row + 1,
      CALL print("$   read/end_of_file=END_SN_TEMP SN_TEMP record"), row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print('$   if(f$locate("no such file" ,record) .ne. length)'),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print("$      goto END_SN_TEMP"), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print('$   if(f$locate("Grand total" ,record) .ne. length)'), row + 1,
      CALL print("$   then"), row + 1,
      CALL print('$      if(f$locate("files," ,record) .ne. length)'),
      row + 1,
      CALL print("$      then"), row + 1,
      CALL print('$         size_pos = f$locate("files," ,record) + 6'), row + 1,
      CALL print("$         size = f$extract(size_pos,length - size_pos,record)"),
      row + 1,
      CALL print("$         goto END_SN_TEMP "), row + 1,
      CALL print("$      else"), row + 1,
      CALL print('$         if(f$locate("file," ,record) .ne. length)'),
      row + 1,
      CALL print("$         then"), row + 1,
      CALL print('$            size_pos = f$locate("file," ,record) + 5'), row + 1,
      CALL print("$            size = f$extract(size_pos,length - size_pos,record)"),
      row + 1,
      CALL print("$            goto END_SN_TEMP "), row + 1,
      CALL print("$         endif"), row + 1,
      CALL print("$      endif"),
      row + 1,
      CALL print("$   endif"), row + 1,
      CALL print("$   goto READ_SN_TEMP"), row + 1,
      CALL print("$END_SN_TEMP: "),
      row + 1,
      CALL print("$   close SN_TEMP  "), row + 1,
      CALL print('$   if (size .eqs. " ")'), row + 1,
      CALL print("$   then"),
      row + 1,
      CALL print("$      deassign sys$output"), row + 1,
      CALL print(^$      write sys$output "Error :Could not determine size for ''p1'"^), row + 1,
      CALL print("$      exit 1"),
      row + 1,
      CALL print("$   else"), row + 1,
      CALL print(^$      write SPACE_NEEDS "''p1'=''size'"^), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_ccldir,"dic.dat > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for dic.dat"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "dicdat="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_ccldir,"dic.idx > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for dic.idx"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "dicidx="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_warehouse_dir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for warehouse"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "warehouse="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_ocdtools_dir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for ocd_tools"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "ocd_tools="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_ccldir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for ccldir"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "ccldir="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_cer_config_dir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for cer_config"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "cer_config="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_cer_forms_dir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for cer_forms"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "cer_forms="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1,
      ddcsn_cmd = concat("du -sk ",ddcsn_tdb_file," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for tdb_export"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "tdb_export="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1
      IF ((((ddr_domain_data->src_was_arch_ind=0)
       AND ddcsn_src_ind=1) OR ((ddr_domain_data->tgt_was_arch_ind=0)
       AND ddcsn_tgt_ind=1)) )
       ddcsn_cmd = concat("du -sk ",ddcsn_cer_config_dir,"sec_user.dat > ",ddcsn_path,"sn_temp.dat"),
       CALL print(ddcsn_cmd), row + 1,
       ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
        'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
       CALL print(ddcsn_cmd), row + 1,
       CALL print("if [[ $? -eq 0 ]]"), row + 1,
       CALL print("then"),
       row + 1,
       CALL print('   echo "Error :Could not determine size for sec_user"'), row + 1,
       CALL print("   exit 1"), row + 1,
       CALL print("else"),
       row + 1, ddcsn_cmd = concat(^   awk '{print "sec_user="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
        ddcsn_path,"space_needs.dat"),
       CALL print(ddcsn_cmd),
       row + 1,
       CALL print("fi"), row + 1
      ENDIF
      ddcsn_cmd = concat("du -sk ",ddcsn_ccluserdir_dir," > ",ddcsn_path,"sn_temp.dat"),
      CALL print(ddcsn_cmd), row + 1,
      ddcsn_cmd = concat("tr '[:upper:]' '[:lower:]' < ",ddcsn_path,
       'sn_temp.dat |grep "a file or directory in the path name does not exist" '),
      CALL print(ddcsn_cmd), row + 1,
      CALL print("if [[ $? -eq 0 ]]"), row + 1,
      CALL print("then"),
      row + 1,
      CALL print('   echo "Error :Could not determine size for ccluserdir"'), row + 1,
      CALL print("   exit 1"), row + 1,
      CALL print("else"),
      row + 1, ddcsn_cmd = concat(^   awk '{print "ccluserdir="$1}' ^,ddcsn_path,"sn_temp.dat >> ",
       ddcsn_path,"space_needs.dat"),
      CALL print(ddcsn_cmd),
      row + 1,
      CALL print("fi"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",ddcsn_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET ddcsn_cmd = concat("@",ddcsn_file_name)
   ELSE
    SET ddcsn_cmd = concat("chmod 777 ",ddcsn_file_name)
    IF (dm2_push_dcl(ddcsn_cmd)=0)
     RETURN(0)
    ENDIF
    SET ddcsn_cmd = concat(". ",ddcsn_file_name)
   ENDIF
   SET ddcsn_tmp_err_ind = dm_err->err_ind
   IF (dm2_push_dcl(ddcsn_cmd)=0)
    RETURN(0)
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (findstring("Error : Could not determine",dm_err->errtext,1,1) > 0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Unable to determine space needs estimate"
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET ddcsn_file_name = concat(ddcsn_path,"space_needs.dat")
   IF (dm2_findfile(ddcsn_file_name)=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find file ",ddcsn_file_name)
     SET dm_err->emsg = concat("Failed to find ",ddcsn_file_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Parse out space needs from space_needs.dat"
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(ddcsn_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     beg_pos = 0, end_pos = 0
    DETAIL
     beg_pos = 0, end_pos = 0
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     beg_pos = findstring("=",r.line,1,0)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("BEG_POS=",beg_pos))
     ENDIF
     end_pos = size(trim(r.line))
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("END_POS=",end_pos))
     ENDIF
     IF (beg_pos > 0
      AND end_pos > 0)
      ddcsn_temp_size = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
      IF ((dm2_sys_misc->cur_os="AXP"))
       ddcsn_pos = findstring("KB",ddcsn_temp_size,0)
       IF (ddcsn_pos > 0)
        ddcsn_temp_size = substring(1,(textlen(ddcsn_temp_size) - ddcsn_pos),ddcsn_temp_size)
       ENDIF
       ddcsn_pos = findstring("MB",ddcsn_temp_size,0)
       IF (ddcsn_pos > 0)
        ddcsn_temp_size = substring(1,(ddcsn_pos - 1),ddcsn_temp_size), ddcsn_temp_size = cnvtstring(
         (cnvtreal(trim(ddcsn_temp_size)) * 1024))
       ENDIF
       ddcsn_pos = findstring("GB",ddcsn_temp_size,0)
       IF (ddcsn_pos > 0)
        ddcsn_temp_size = substring(1,(ddcsn_pos - 1),ddcsn_temp_size), ddcsn_temp_size = cnvtstring(
         ((cnvtreal(trim(ddcsn_temp_size)) * 1024) * 1024))
       ENDIF
      ENDIF
      IF (findstring("dicdat",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_dicdat_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_dicdat_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("dicidx",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_dicidx_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_dicidx_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("warehouse",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_wh_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_wh_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("ocd_tools",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_ocd_tools_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_ocd_tools_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("ccldir",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_ccldir_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_ccldir_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("cer_config",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_cer_config_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_cer_config_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("cer_forms",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_cer_forms_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_cer_forms_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("tdb_export",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_tdb_exp_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_tdb_exp_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("sec_user",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_sec_user_exp_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_sec_user_exp_size = ddcsn_temp_size
       ENDIF
      ELSEIF (findstring("ccluserdir",trim(r.line),1,0) > 0)
       IF (ddcsn_src_ind=1)
        ddr_space_needs->src_ccluserdir_size = ddcsn_temp_size
       ELSE
        ddr_space_needs->tgt_ccluserdir_size = ddcsn_temp_size
       ENDIF
      ENDIF
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drr_load_preserved_table_data("TABLE"," ")=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_preserved_tables_data)
   ENDIF
   IF ((drr_preserved_tables_data->cnt > 0))
    SET ddcsn_size_nbr = 0.0
    SET dm_err->eproc = "Retieve space needs for preserved tables from user_segments"
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM user_segments us
     WHERE us.segment_type="TABLE"
     DETAIL
      IF (locateval(ddcsn_cnt,1,drr_preserved_tables_data->cnt,us.segment_name,
       drr_preserved_tables_data->tbl[ddcsn_cnt].table_name) > 0)
       ddcsn_size_nbr = (ddcsn_size_nbr+ us.bytes)
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET ddcsn_size_nbr = cnvtreal((ddcsn_size_nbr/ 1024.0))
    SET ddr_space_needs->tgt_preserve_tbl_size = cnvtstring(ddcsn_size_nbr)
   ENDIF
   IF (ddcsn_src_ind=1)
    IF ((ddr_domain_data->src_interrogator_ind=1))
     IF (ddr_interrogator_backup("SIZE")=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF (ddcsn_src_ind=1)
    SET ddr_space_needs->src_srv_def_size = "50.0"
    SET ddr_space_needs->src_env_reg_size = "1.0"
    SET ddr_space_needs->src_sys_reg_size = "1.0"
    SET ddr_space_needs->src_link_data_size = "1.0"
    SET ddr_space_needs->src_misc_data_size = "1.0"
    SET ddcsn_size_nbr = (((((((((((cnvtreal(ddr_space_needs->src_wh_size)+ cnvtreal(ddr_space_needs
     ->src_ocd_tools_size))+ cnvtreal(ddr_space_needs->src_ccldir_size))+ cnvtreal(ddr_space_needs->
     src_cer_config_size))+ cnvtreal(ddr_space_needs->src_tdb_exp_size))+ cnvtreal(ddr_space_needs->
     src_srv_def_size))+ cnvtreal(ddr_space_needs->src_sec_user_exp_size))+ cnvtreal(ddr_space_needs
     ->src_env_reg_size))+ cnvtreal(ddr_space_needs->src_sys_reg_size))+ cnvtreal(ddr_space_needs->
     src_link_data_size))+ cnvtreal(ddr_space_needs->src_misc_data_size))+ cnvtreal(ddr_space_needs->
     src_interrogator_size))
    SET ddcsn_size_nbr = (ddcsn_size_nbr/ 1024)
    SET ddr_space_needs->tot_src_temp_dir_size = cnvtstring(ddcsn_size_nbr)
    SET ddcsn_size_nbr = (cnvtreal(ddr_space_needs->src_dicdat_size)+ cnvtreal(ddr_space_needs->
     src_dicidx_size))
    SET ddcsn_size_nbr = (ddcsn_size_nbr/ 1024)
    SET ddr_space_needs->tot_src_cer_install_size = cnvtstring(ddcsn_size_nbr)
   ELSE
    SET ddr_space_needs->tgt_srv_def_size = "50.0"
    SET ddr_space_needs->tgt_env_reg_size = "1.0"
    SET ddr_space_needs->tgt_sys_reg_size = "1.0"
    SET ddr_space_needs->tgt_link_data_size = "1.0"
    SET ddr_space_needs->tgt_misc_data_size = "1.0"
    SET ddr_space_needs->tgt_srv_bkup_size = "1.0"
    SET ddr_space_needs->tgt_sys_reg_cpy_size = "1.0"
    SET ddcsn_size_nbr = ((((((((((cnvtreal(ddr_space_needs->tgt_wh_size)+ cnvtreal(ddr_space_needs->
     tgt_ccluserdir_size))+ cnvtreal(ddr_space_needs->tgt_cer_forms_size))+ cnvtreal(ddr_space_needs
     ->tgt_tdb_exp_size))+ cnvtreal(ddr_space_needs->tgt_srv_def_size))+ cnvtreal(ddr_space_needs->
     tgt_srv_bkup_size))+ cnvtreal(ddr_space_needs->tgt_sec_user_exp_size))+ cnvtreal(ddr_space_needs
     ->tgt_env_reg_size))+ cnvtreal(ddr_space_needs->tgt_sys_reg_size))+ cnvtreal(ddr_space_needs->
     tgt_sys_reg_cpy_size))+ cnvtreal(ddr_space_needs->tgt_misc_data_size))
    SET ddcsn_size_nbr = cnvtreal((ddcsn_size_nbr/ 1024))
    SET ddr_space_needs->tot_tgt_temp_dir_size = cnvtstring(ddcsn_size_nbr)
    SET ddcsn_size_nbr = (cnvtreal(ddr_space_needs->tgt_dicdat_size)+ cnvtreal(ddr_space_needs->
     tgt_dicidx_size))
    SET ddcsn_size_nbr = cnvtreal((ddcsn_size_nbr/ 1024))
    SET ddr_space_needs->tot_tgt_cer_install_size = cnvtstring(ddcsn_size_nbr)
    SET ddcsn_size_nbr = ((((((((cnvtreal(ddr_space_needs->tgt_cer_forms_size)+ cnvtreal(
     ddr_space_needs->tgt_tdb_exp_size))+ cnvtreal(ddr_space_needs->tgt_srv_def_size))+ cnvtreal(
     ddr_space_needs->tgt_srv_bkup_size))+ cnvtreal(ddr_space_needs->tgt_sec_user_exp_size))+
    cnvtreal(ddr_space_needs->tgt_env_reg_size))+ cnvtreal(ddr_space_needs->tgt_sys_reg_size))+
    cnvtreal(ddr_space_needs->tgt_sys_reg_cpy_size))+ cnvtreal(ddr_space_needs->tgt_misc_data_size))
    SET ddcsn_size_nbr = cnvtreal((ddcsn_size_nbr/ 1024))
    SET ddr_space_needs->opt_tgt_temp_dir_size = cnvtstring(ddcsn_size_nbr)
    SET ddcsn_size_nbr = (cnvtreal(ddr_space_needs->tgt_dicdat_size)+ cnvtreal(ddr_space_needs->
     tgt_dicidx_size))
    SET ddcsn_size_nbr = cnvtreal((ddcsn_size_nbr/ 1024))
    SET ddr_space_needs->opt_tgt_cer_install_size = cnvtstring(ddcsn_size_nbr)
   ENDIF
   SET dm_err->eproc = "Display space needs estimates report"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (get_unique_file("dm2_dom_spc_needs",".rpt")=0)
     RETURN(0)
    ENDIF
    SET ddcsn_report_destination = dm_err->unique_fname
    SET drr_rpt_file = build(drrr_misc_data->active_dir,ddcsn_report_destination)
    SELECT INTO value(ddcsn_report_destination)
     FROM (dummyt d  WITH seq = 1)
     HEAD REPORT
      IF (ddcsn_src_ind=1)
       row + 0, col 0, "Source Data Collection requires the following space needs: "
      ELSE
       row + 0, col 0, "Target Data Collection requires the following space needs: "
      ENDIF
     DETAIL
      IF (ddcsn_src_ind=1)
       ddcsn_str = concat(ddcsn_path," :   ",build(ddr_space_needs->tot_src_temp_dir_size,"MB")), row
        + 2, col 0,
       ddcsn_str, ddcsn_str = concat("cer_install : ",build(ddr_space_needs->tot_src_cer_install_size,
         "MB")), row + 2,
       col 0, ddcsn_str
       IF ((ddr_domain_data->src_interrogator_node != trim(curnode))
        AND (ddr_domain_data->src_interrogator_ind=1))
        ddcsn_str = concat(drrr_rf_data->tgt_interrogator_tmp_dir," :   ",build(ddr_space_needs->
          src_interrogator_size,"MB")), row + 2, col 0,
        ddcsn_str
       ENDIF
      ELSE
       row + 2, col 0, "If ALL Target Data (including optional components) is Collected:",
       ddcsn_str = concat(ddcsn_path," :   ",build(ddr_space_needs->tot_tgt_temp_dir_size,"MB")), row
        + 2, col 0,
       ddcsn_str, ddcsn_str = concat("cer_install : ",build(ddr_space_needs->tot_tgt_cer_install_size,
         "MB")), row + 1,
       col 0, ddcsn_str
       IF ((der_expimp_data->tgt_temp_dir != ""))
        ddcsn_str = concat(der_expimp_data->tgt_temp_dir," : ",ddr_space_needs->tgt_preserve_tbl_size,
         "MB"), row + 1, col 0,
        ddcsn_str
       ENDIF
       row + 2, col 0, "If only REQUIRED Target Data (excluding optional components) is Collected:",
       ddcsn_str = concat(ddcsn_path," :   ",build(ddr_space_needs->opt_tgt_temp_dir_size,"MB")), row
        + 2, col 0,
       ddcsn_str, ddcsn_str = concat("cer_install : ",build(ddr_space_needs->opt_tgt_cer_install_size,
         "MB")), row + 1,
       col 0, ddcsn_str
      ENDIF
      row + 2, col 0, "Verify space needs are met before continuing"
     WITH nocounter, nullreport, maxcol = 132,
      format = variable, formfeed = none
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Skipping display of SPACE NEEDS ESTIMATES REPORT (",
     ddcsn_report_destination,")")
    CALL disp_msg("",dm_err->logfile,0)
    IF ((drer_email_list->email_cnt > 0))
     SET drer_email_det->msgtype = "ACTIONREQ"
     SET drer_email_det->status = "REPORT"
     SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
     SET drer_email_det->step = "SPACE NEEDS ESTIMATES REPORT"
     SET drer_email_det->email_level = 1
     SET drer_email_det->logfile = dm_err->logfile
     SET drer_email_det->err_ind = dm_err->err_ind
     SET drer_email_det->eproc = dm_err->eproc
     SET drer_email_det->emsg = dm_err->emsg
     SET drer_email_det->user_action = dm_err->user_action
     SET drer_email_det->attachment = ddcsn_report_destination
     CALL drer_add_body_text(concat("SPACE NEEDS ESTIMATES REPORT was generated at ",format(
        drer_email_det->status_dt_tm,";;q")),1)
     CALL drer_add_body_text(concat("User Action : Please review the report to ensure ",
       "required space is available."),0)
     CALL drer_add_body_text(concat("Report file name : ",trim(ddcsn_report_destination,3)),0)
     IF (drer_compose_email(null)=1)
      CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
       email_level)
     ENDIF
     CALL drer_reset_pre_err(null)
    ENDIF
   ELSE
    SET message = window
    SET width = 132
    CALL clear(1,1)
    CALL box(1,1,20,131)
    CALL text(2,2,concat(evaluate(ddcsn_src_ind,1,"Source","Target"),
      " Data Collection requires the following space needs: "))
    IF (ddcsn_src_ind=1)
     CALL text(5,2,concat(ddcsn_path," :   ",build(ddr_space_needs->tot_src_temp_dir_size,"MB")))
     CALL text(7,2,concat("cer_install : ",build(ddr_space_needs->tot_src_cer_install_size,"MB")))
    ELSE
     CALL text(4,2,"If ALL Target Data (including optional components) is Collected:")
     CALL text(5,2,concat(ddcsn_path," :   ",build(ddr_space_needs->tot_tgt_temp_dir_size,"MB")))
     CALL text(6,2,concat("cer_install : ",build(ddr_space_needs->tot_tgt_cer_install_size,"MB")))
     IF ((der_expimp_data->tgt_temp_dir != ""))
      CALL text(7,2,concat(der_expimp_data->tgt_temp_dir," : ",ddr_space_needs->tgt_preserve_tbl_size,
        "MB"))
     ENDIF
     CALL text(9,2,"If only REQUIRED Target Data (excluding optional components) is Collected:")
     CALL text(10,2,concat(ddcsn_path," :   ",build(ddr_space_needs->opt_tgt_temp_dir_size,"MB")))
     CALL text(11,2,concat("cer_install : ",build(ddr_space_needs->opt_tgt_cer_install_size,"MB")))
    ENDIF
    CALL text(14,2,"Verify space needs are met before continuing")
    CALL text(16,2,"Continue/Exit [C/E]:")
    CALL accept(16,23,"A;cu"," "
     WHERE curaccept IN ("C", "E"))
    IF (curaccept="E")
     CALL clear(1,1)
     SET message = nowindow
     SET dm_err->emsg = "User elected to quit from space needs estimate report"
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    CALL clear(1,1)
    SET message = nowindow
    SET dm_err->eproc = "Space needs have been verified by the user"
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_tdb_file(dgtf_src_ind,dgtf_tgt_ind,dgtf_server_id,dgtf_file_ret)
   DECLARE dgtf_file_name = vc WITH protect, noconstant("")
   DECLARE dgtf_cmd = vc WITH protect, noconstant("")
   DECLARE dgtf_path = vc WITH protect, noconstant("")
   DECLARE dgtf_domain_name = vc WITH protect, noconstant("")
   DECLARE dgtf_user = vc WITH protect, noconstant("")
   DECLARE dgtf_pw = vc WITH protect, noconstant("")
   DECLARE dgtf_srv_found_flag = i2 WITH protect, noconstant(0)
   DECLARE dgtf_tmp_err_ind = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Find TDB file name from SCP entry for TDB id: ",build(dgtf_server_id))
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dgtf_src_ind=1)
    SET dgtf_domain_name = ddr_domain_data->src_domain_name
    SET dgtf_path = ddr_domain_data->src_tmp_full_dir
    SET dgtf_user = ddr_domain_data->src_mng
    SET dgtf_pw = ddr_domain_data->src_mng_pwd
   ELSEIF (dgtf_tgt_ind=1)
    SET dgtf_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgtf_domain_name = ddr_domain_data->tgt_domain_name
    SET dgtf_user = ddr_domain_data->tgt_mng
    SET dgtf_pw = ddr_domain_data->tgt_mng_pwd
   ENDIF
   SET dgtf_file_ret = "NOT FOUND"
   SET dgtf_file_name = concat(dgtf_path,"server_entry.dat")
   IF (dm2_findfile(dgtf_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgtf_cmd = concat("del ",dgtf_file_name,";*")
    ELSE
     SET dgtf_cmd = concat("rm ",dgtf_file_name)
    ENDIF
    IF (dm2_push_dcl(dgtf_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dgtf_file_name = concat(dgtf_path,"server_file_name.dat")
   IF (dm2_findfile(dgtf_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgtf_cmd = concat("del ",dgtf_file_name,";*")
    ELSE
     SET dgtf_cmd = concat("rm ",dgtf_file_name)
    ENDIF
    IF (dm2_push_dcl(dgtf_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dgtf_file_name = concat(dgtf_path,"get_file_name",evaluate(dm2_sys_misc->cur_os,"AXP",".com",
     ".ksh"))
   IF (dm2_findfile(dgtf_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgtf_cmd = concat("del ",dgtf_file_name,";*")
    ELSE
     SET dgtf_cmd = concat("rm ",dgtf_file_name)
    ENDIF
    IF (dm2_push_dcl(dgtf_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to find server file name for ",build(dgtf_server_id),": ",
    dgtf_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgtf_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!get_file_name.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('$tgt_node=f$getsyi("nodename")'), row + 1,
      dgtf_cmd = concat('$if f$search("',dgtf_path,'server_entry.dat") .nes. "" then delete ',
       dgtf_path,"server_entry.dat;*"),
      CALL print(dgtf_cmd), row + 1,
      CALL print('$file_name = "NOT_FOUND"'), row + 1,
      CALL print("$param_pos = 0"),
      row + 1,
      CALL print('$param_str = "NOT FOUND"'), row + 1,
      CALL print("$tries = 0"), row + 1,
      CALL print(concat("$define/user_mode sys$output ",dgtf_path,"server_entry.dat")),
      row + 1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"), row + 1,
      CALL print("$DECK"), row + 1,
      CALL print(dgtf_user),
      row + 1,
      CALL print(dgtf_domain_name), row + 1,
      CALL print(dgtf_pw), row + 1,
      CALL print(concat("show ",build(dgtf_server_id))),
      row + 1,
      CALL print("exit"), row + 1,
      CALL print("$EOD"), row + 1,
      CALL print(concat("$open/read TDB_FILE ",dgtf_path,"server_entry.dat")),
      row + 1,
      CALL print("$tries = tries + 1"), row + 1,
      CALL print("$READ_TDB_FILE:"), row + 1,
      CALL print("$   read/end_of_file=END_READ_TDB_FILE TDB_FILE record"),
      row + 1,
      CALL print("$   length = f$length(record)"), row + 1,
      CALL print('$   if(f$locate("entry not found" ,record) .ne. length)'), row + 1,
      CALL print("$   then"),
      row + 1,
      CALL print("$      goto END_READ_TDB_FILE "), row + 1,
      CALL print("$   endif"), row + 1,
      CALL print('$   if(f$locate("parameters:" ,record) .ne. length)'),
      row + 1,
      CALL print("$   then"), row + 1,
      CALL print('$      param_pos = f$locate("-" ,record)'), row + 1,
      CALL print("$      param_str = f$extract(param_pos,length-param_pos,record)"),
      row + 1,
      CALL print('$      file_name = f$element(2," ",param_str)'), row + 1,
      CALL print("$      goto END_READ_TDB_FILE "), row + 1,
      CALL print("$   endif"),
      row + 1,
      CALL print("$!  write sys$output record "), row + 1,
      CALL print("$   goto READ_TDB_FILE "), row + 1,
      CALL print("$END_READ_TDB_FILE: "),
      row + 1,
      CALL print("$   close TDB_FILE  "), row + 1,
      CALL print("$deassign sys$output"), row + 1, dgtf_cmd = concat('$if f$search("',dgtf_path,
       'server_file_name.dat") .nes. "" then delete ',dgtf_path,"server_file_name.dat;*"),
      CALL print(dgtf_cmd), row + 1,
      CALL print(concat("$define sys$output ",dgtf_path,"server_file_name.dat")),
      row + 1,
      CALL print('$if (file_name .eqs. "NOT_FOUND") .or. (param_str .eqs. "NOT_FOUND")'), row + 1,
      CALL print("$then"), row + 1,
      CALL print(concat('$   write sys$output "error : server File is not found."')),
      row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$else"), row + 1,
      CALL print(concat(^$   write sys$output "server_file_name=''file_name'"^)),
      row + 1,
      CALL print("$   deassign sys$output"), row + 1,
      CALL print("$   exit 1"), row + 1,
      CALL print("$endif"),
      row + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("system_pwd='",dgtf_pw,"'")), row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",dgtf_path,"server_entry.dat")),
      row + 1,
      CALL print(dgtf_user), row + 1,
      CALL print(dgtf_domain_name), row + 1,
      CALL print("$system_pwd"),
      row + 1,
      CALL print(concat("show ",build(dgtf_server_id))), row + 1,
      CALL print("exit"), row + 1,
      CALL print("!"),
      row + 1, row + 1, dgtf_cmd = concat("file_name=$(grep 'parameters:' ",dgtf_path,
       "server_entry.dat|"),
      dgtf_cmd = concat(dgtf_cmd,^awk -F"-" '{print $2}' | ^), dgtf_cmd = concat(dgtf_cmd,
       ^awk -F" " '{print $3}')^),
      CALL print(dgtf_cmd),
      row + 1,
      CALL print("if [[ -z $file_name ]]"), row + 1,
      CALL print("then"), row + 1,
      CALL print(concat('   echo "error : server File is not found."')),
      row + 1, dgtf_cmd = concat('   echo "error : server File is not found." >> ',dgtf_path,
       "server_file_name.dat"),
      CALL print(dgtf_cmd),
      row + 1,
      CALL print("else"), row + 1,
      dgtf_cmd = concat('   echo "server_file_name=$file_name" >> ',dgtf_path,"server_file_name.dat"),
      CALL print(dgtf_cmd), row + 1,
      CALL print("fi"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",dgtf_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgtf_cmd = concat("@",dgtf_file_name)
   ELSE
    SET dgtf_cmd = concat("chmod 777 ",dgtf_file_name)
    IF (dm2_push_dcl(dgtf_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgtf_cmd = concat(". ",dgtf_file_name)
   ENDIF
   SET dgtf_tmp_err_ind = dm_err->err_ind
   IF (dm2_push_dcl(dgtf_cmd)=0)
    RETURN(0)
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (findstring("error : server File is not found",dm_err->errtext,1,1) > 0)
     SET dgtf_srv_found_flag = 0
     SET dgtf_file_ret = "NOT FOUND"
     SET dm_err->err_ind = dgtf_tmp_err_ind
    ELSE
     SET dgtf_srv_found_flag = 1
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (dgtf_srv_found_flag=1)
    SET dgtf_file_name = concat(dgtf_path,"server_file_name.dat")
    IF (dm2_findfile(dgtf_file_name)=0)
     IF ((dm_err->err_ind=0))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Find file ",dgtf_file_name)
      SET dm_err->emsg = concat("Failed to find ",dgtf_file_name)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Parse out server file name for server id ",build(dgtf_server_id))
    CALL disp_msg("",dm_err->logfile,0)
    FREE DEFINE rtl2
    FREE SET file_loc
    SET logical file_loc value(dgtf_file_name)
    DEFINE rtl2 "file_loc"
    SELECT INTO "nl:"
     r.line
     FROM rtl2t r
     HEAD REPORT
      beg_pos = 0, end_pos = 0
     DETAIL
      beg_pos = 0, end_pos = 0
      IF ((dm_err->debug_flag > 1))
       CALL echo(concat("LINE = ",r.line))
      ENDIF
      beg_pos = findstring("=",r.line,1,0)
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("BEG_POS=",beg_pos))
      ENDIF
      end_pos = size(trim(r.line))
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("END_POS=",end_pos))
      ENDIF
      IF (beg_pos > 0
       AND end_pos > 0)
       IF (findstring("error : server",trim(r.line),1,0) > 0)
        dgtf_file_ret = "NOT FOUND"
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgtf_file_ret=",dgtf_file_ret))
        ENDIF
       ELSEIF (findstring("server_file_name",trim(r.line),1,0) > 0)
        dgtf_file_ret = substring((beg_pos+ 1),(end_pos - beg_pos),r.line)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgtf_file_ret=",dgtf_file_ret))
        ENDIF
       ELSE
        dgtf_file_ret = "NOT FOUND"
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dgtf_file_ret=",dgtf_file_ret))
        ENDIF
       ENDIF
      ENDIF
     WITH nocounter, maxcol = 255
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSEIF (((dgtf_file_ret="NOT FOUND") OR (dgtf_file_ret="")) )
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Failed to extract server file name for ",build(dgtf_server_id))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dm2_findfile(dgtf_file_ret)=0)
     IF ( NOT ((dm2_sys_misc->cur_os="AXP")))
      IF (dm2_findfile(build("$",dgtf_file_ret))=0)
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat("Failed to find server file name for ",build(dgtf_server_id))
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ELSE
       SET dgtf_file_ret = build("$",dgtf_file_ret)
      ENDIF
     ELSE
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Failed to find server file name for ",build(dgtf_server_id))
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF ((dm_err->err_ind=1))
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_add_tar_error(date_src_ind,date_tgt_ind,date_type)
   DECLARE date_file = vc WITH protect, noconstant(concat(evaluate(date_src_ind,1,ddr_domain_data->
      src_tmp_full_dir,ddr_domain_data->tgt_tmp_full_dir),"tar_error_list.dat"))
   DECLARE date_cmd = vc WITH protect, noconstant("")
   IF (dm2_findfile(date_file)=0)
    SET date_cmd = concat("touch ",date_file)
    IF (dm2_push_dcl(date_cmd)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Writing tar error info to ",date_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "LNX"))
    SET date_cmd = concat('echo "',date_type,' | \c" >> ',date_file)
   ELSE
    SET date_cmd = concat('echo -e "',date_type,' | \c" >> ',date_file)
   ENDIF
   IF (dm2_push_dcl(date_cmd)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_tar_errors(dgte_src_ind,dgte_tgt_ind,dgte_tar_errors_ind,dgte_tar_errors_list)
   DECLARE dgte_file_name = vc WITH protect, noconstant("")
   DECLARE dgte_cmd = vc WITH protect, noconstant("")
   DECLARE dgte_path = vc WITH protect, noconstant("")
   DECLARE dgte_domain_name = vc WITH protect, noconstant("")
   DECLARE dgte_user = vc WITH protect, noconstant("")
   DECLARE dgte_pw = vc WITH protect, noconstant("")
   DECLARE dgte_srv_path = vc WITH protect, noconstant("")
   DECLARE dgte_err_found_flag = i2 WITH protect, noconstant(0)
   DECLARE dgte_tmp_err_ind = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Find TAR error list file: tar_error_list.dat"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dgte_src_ind=1)
    SET dgte_domain_name = ddr_domain_data->src_domain_name
    SET dgte_path = ddr_domain_data->src_tmp_full_dir
   ELSEIF (dgte_tgt_ind=1)
    SET dgte_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgte_domain_name = ddr_domain_data->tgt_domain_name
   ENDIF
   SET dgte_tar_errors_ind = 0
   SET dgte_err_found_flag = 0
   SET dgte_file_name = concat(dgte_path,"tar_error_list.dat")
   IF (dm2_findfile(dgte_file_name)=0)
    SET dgte_tar_errors_ind = 0
    SET dgte_tar_errors_list = "NONE"
    SET dm_err->eproc = "TAR error list file not found"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Parse out tar errors "
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dgte_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF (textlen(trim(r.line)) > 2)
      IF ((dm_err->debug_flag > 1))
       CALL echo(concat("LINE = ",r.line))
      ENDIF
      dgte_tar_errors_list = r.line, dgte_tar_errors_ind = 1
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("dgte_tar_errors_list=",dgte_tar_errors_list)),
       CALL echo(build("dgte_tar_errors_ind=",dgte_tar_errors_ind))
      ENDIF
     ENDIF
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (((dgte_tar_errors_list="NONE") OR (dgte_tar_errors_list="")) )
    SET dgte_tar_errors_ind = 0
   ELSE
    SET dgte_tar_errors_ind = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_adm_env(null)
   DECLARE dgae_file = vc WITH protect, noconstant("")
   DECLARE dgae_file_date = f8 WITH protect, noconstant(0.0)
   EXECUTE dm2_capture_env_history ddr_domain_data->src_tmp_full_dir, ddr_domain_data->
   src_db_env_name
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Check SOURCE Admin env history files ",ddr_domain_data->
    src_tmp_full_dir)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (drr_validate_adm_env_csv(ddr_domain_data->src_tmp_full_dir,ddr_domain_data->src_db_env_name)=0
   )
    RETURN(0)
   ELSE
    SET dgae_file = concat(ddr_domain_data->src_tmp_full_dir,drr_env_hist_misc->summary_file)
    IF (ddr_get_file_date(dgae_file,dgae_file_date)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET ddr_domain_data->src_adm_env_csv_ts = dgae_file_date
   SET ddr_domain_data->src_adm_env_csv_fnd = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_prompt_tgt_backups(null)
   DECLARE dptb_rpt_file = vc WITH protect, noconstant("")
   DECLARE dptb_str = vc WITH protect, noconstant("")
   DECLARE dptb_locndx = i4 WITH protect, noconstant(0)
   DECLARE dptd_user_exists = i4 WITH protect, noconstant(0)
   FREE RECORD dptb_db_users
   RECORD dptb_db_users(
     1 cnt = i4
     1 qual[*]
       2 db_user_name = vc
   )
   SET dptb_db_users->cnt = 0
   SET dm_err->eproc = "Getting all non oracle database users."
   SELECT INTO "nl:"
    FROM dba_users u
    WHERE "CDBA" != u.username
     AND  NOT (u.username IN (
    (SELECT
     di.info_name
     FROM dm_info di
     WHERE di.info_domain="DM2_ORACLE_USER"
      AND di.info_number=1)))
    ORDER BY u.username
    HEAD REPORT
     dptb_db_users->cnt = 0, stat = alterlist(dptb_db_users->qual,dptb_db_users->cnt)
    DETAIL
     dptb_db_users->cnt = (dptb_db_users->cnt+ 1), stat = alterlist(dptb_db_users->qual,dptb_db_users
      ->cnt), dptb_db_users->qual[dptb_db_users->cnt].db_user_name = u.username
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (get_unique_file("dm2_tgt_db_backup",".rpt")=0)
    RETURN(0)
   ELSE
    SET dptb_rpt_file = dm_err->unique_fname
   ENDIF
   SET dptb_rpt_file = concat(ddr_domain_data->tgt_tmp_dir,dptb_rpt_file)
   SET logical dptb_rpt_file_logical dptb_rpt_file
   SET dm_err->eproc = "Generating target database backup report."
   SELECT INTO dptb_rpt_file_logical
    HEAD REPORT
     col 30,
     CALL print("TARGET DATABASE BACKUP WARNING REPORT"), row + 1
    DETAIL
     col 0, "BACKUP EXISTING TARGET DATA BEFORE REFRESH", row + 1,
     dptb_str = concat("Environment Name: ",ddr_domain_data->tgt_env), row + 1, col 0,
     dptb_str, dptb_str = concat("Database Name: ",dm2_install_schema->target_dbase_name), col 40,
     dptb_str, row + 1, dptb_str = concat(
      "If using Cerner tools that only refreshes the V500 user, only tables owned by V500 will be ",
      "dropped on TARGET prior to"),
     row + 1, col 0, dptb_str,
     dptb_str = concat(
      "performing imports from SOURCE. If you wish to take an export of any of the V500 tables, ",
      "exports should be taken at this time."), row + 1, col 0,
     dptb_str, row + 1, dptb_str = concat(
      "If using the Alternate Database Restore method, all tables, regardless of owner, currently on ",
      "TARGET will be dropped prior to"),
     row + 1, col 0, dptb_str,
     dptb_str = concat(
      "restore from SOURCE. If you wish to take an export of any [database users/tables] in TARGET, ",
      "exports should be taken at this"), row + 1, col 0,
     dptb_str, row + 1, col 0,
     "time.", row + 1
     IF ((dptb_db_users->cnt > 0))
      IF (validate(drrr_responsefile_in_use,- (1))=1)
       row + 1, col 0, "DATABASE USERS [*denotes user marked to be retained]:",
       row + 1
      ELSE
       row + 1, col 0, "DATABASE USERS:",
       row + 1
      ENDIF
     ENDIF
     FOR (dptb_locndx = 1 TO dptb_db_users->cnt)
       IF (validate(drrr_responsefile_in_use,- (1))=1
        AND (drrr_misc_data->tgt_retain_db_user_cnt > 0))
        IF (locateval(dptd_user_exists,1,drrr_misc_data->tgt_retain_db_user_cnt,dptb_db_users->qual[
         dptb_locndx].db_user_name,drrr_misc_data->tgt_retain_db_users[dptd_user_exists].user_name)
         > 0)
         dptb_str = concat(dptb_db_users->qual[dptb_locndx].db_user_name,"*"), row + 1, col 0,
         dptb_str
        ELSE
         row + 1, col 0, dptb_db_users->qual[dptb_locndx].db_user_name
        ENDIF
       ELSE
        row + 1, col 0, dptb_db_users->qual[dptb_locndx].db_user_name
       ENDIF
     ENDFOR
    WITH nocounter, nullreport, maxcol = 132,
     format = variable, formfeed = none, maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    SET dm_err->eproc = concat("Skipping display of Backup Warning Prompt.")
    CALL disp_msg("",dm_err->logfile,0)
    IF ((drer_email_list->email_cnt > 0))
     SET drer_email_det->msgtype = "ACTIONREQ"
     SET drer_email_det->status = "REPORT"
     SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
     SET drer_email_det->step = "TARGET DATABASE BACKUP WARNING REPORT"
     SET drer_email_det->email_level = 1
     SET drer_email_det->logfile = dm_err->logfile
     SET drer_email_det->err_ind = dm_err->err_ind
     SET drer_email_det->eproc = dm_err->eproc
     SET drer_email_det->emsg = dm_err->emsg
     SET drer_email_det->user_action = dm_err->user_action
     SET drer_email_det->attachment = dptb_rpt_file
     CALL drer_add_body_text(concat("Target Database Backup Report was generated at ",format(
        drer_email_det->status_dt_tm,";;q")),1)
     CALL drer_add_body_text(concat(
       "User Action : Please review the Target Database Backup Report and ",
       "take any necessary exports at this time."),0)
     CALL drer_add_body_text(concat("Report file name : ",trim(dptb_rpt_file,3)),0)
     IF (drer_compose_email(null)=1)
      CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
       email_level)
     ENDIF
     CALL drer_reset_pre_err(null)
    ENDIF
   ELSE
    SET dm_err->eproc = "Prompt user to take backups of any Target tables that will be dropped."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    FREE DEFINE rtl2
    DEFINE rtl2 "dptb_rpt_file_logical"
    SELECT INTO mine
     t.line
     FROM rtl2t t
     DETAIL
      col 0, t.line, row + 1
     WITH nocounter, maxcol = 2001
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Prompt for target database backup report confirmation."
    CALL disp_msg(" ",dm_err->logfile,0)
    SET message = window
    SET width = 132
    CALL clear(1,1)
    CALL box(1,1,8,100)
    CALL text(3,2,"TARGET DATABASE BACKUP REPORT CONFIRMATION PROMPT")
    CALL text(5,2,"Press 'C' to continue data collection process or 'Q' to quit:")
    CALL accept(5,64,"A;cu"," "
     WHERE curaccept IN ("C", "Q"))
    SET message = nowindow
    CALL clear(1,1)
    IF (curaccept="Q")
     SET dm_err->emsg = "User choose to quit from target database backup report confirmation prompt."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_lnx_findfile(dlf_file_path)
   DECLARE dlf_cmd_txt = vc WITH protect, noconstant(" ")
   SET dlf_cmd_txt = concat("ls ",dlf_file_path,";echo $?")
   CALL dm2_push_dcl(dlf_cmd_txt)
   SET dm_err->err_ind = 0
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF (cnvtint(dm_err->errtext)=0)
    IF ((dm_err->debug_flag > 1))
     SET dm_err->eproc = concat("File ",dlf_file_path," found.")
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    RETURN(1)
   ELSE
    IF ((dm_err->debug_flag > 1))
     SET dm_err->eproc = concat("File ",dlf_file_path," not found.")
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_preserve_pwds(null)
   SET dm_err->eproc = "Retrieve count of preserved passwords from admin dm_info"
   CALL disp_msg(" ",dm_err->logfile,0)
   SET ddr_domain_data->tgt_preserve_pwds_cnt = 0
   SELECT INTO "nl:"
    FROM dm2_admin_dm_info d
    WHERE d.info_domain="DM2_REPLICATE_USER_PWDS_CNT"
     AND d.info_name=cnvtupper(trim(currdbname))
    DETAIL
     ddr_domain_data->tgt_preserve_pwds_cnt = d.info_number
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET ddr_domain_data->tgt_preserve_pwds_cnt = - (1)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_opsexec_servers(dgos_src_ind,dgos_tgt_ind,dgos_set_protect_ind)
   SET dm_err->eproc = "Retrieve OpsExec server list"
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dgos_file_name = vc WITH protect, noconstant("")
   DECLARE dgos_cmd = vc WITH protect, noconstant("")
   DECLARE dgos_path = vc WITH protect, noconstant("")
   DECLARE dgos_domain_name = vc WITH protect, noconstant("")
   DECLARE dgos_user = vc WITH protect, noconstant("")
   DECLARE dgos_pw = vc WITH protect, noconstant("")
   DECLARE dgos_str = vc WITH protect, noconstant("")
   DECLARE dgos_ret = vc WITH protect, noconstant("")
   DECLARE dgos_idx = i4 WITH protect, noconstant(0)
   DECLARE dgos_srv_nbr = vc WITH protect, noconstant("")
   DECLARE dgos_srv_desc = vc WITH protect, noconstant("")
   IF (dgos_src_ind=1)
    SET dgos_domain_name = ddr_domain_data->src_domain_name
    SET dgos_user = ddr_domain_data->src_mng
    SET dgos_pw = ddr_domain_data->src_mng_pwd
    SET dgos_path = ddr_domain_data->src_tmp_full_dir
   ELSE
    SET dgos_path = ddr_domain_data->tgt_tmp_full_dir
    SET dgos_domain_name = ddr_domain_data->tgt_domain_name
    SET dgos_user = ddr_domain_data->tgt_mng
    SET dgos_pw = ddr_domain_data->tgt_mng_pwd
   ENDIF
   SET dgos_file_name = concat(dgos_path,"get_opsexec_servers",evaluate(dm2_sys_misc->cur_os,"AXP",
     ".com",".ksh"))
   IF (dm2_findfile(dgos_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgos_cmd = concat("del ",dgos_file_name,";*")
    ELSE
     SET dgos_cmd = concat("rm ",dgos_file_name)
    ENDIF
    IF (dm2_push_dcl(dgos_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to find OpsExec servers: ",dgos_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dgos_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!get_opsexec_servers.com"), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print('$tgt_node=f$getsyi("nodename")'), row + 1,
      dgos_cmd = concat('$if f$search("',dgos_path,'opsexec_servers.dat") .nes. "" then delete ',
       dgos_path,"opsexec_servers.dat;*"),
      CALL print(dgos_cmd), row + 1,
      CALL print(concat("$define/user_mode sys$output ",dgos_path,"opsexec_servers.dat")), row + 1,
      CALL print("$mcr cer_exe:scpview 'tgt_node'"),
      row + 1,
      CALL print("$DECK"), row + 1,
      CALL print(dgos_user), row + 1,
      CALL print(dgos_domain_name),
      row + 1,
      CALL print(dgos_pw), row + 1,
      CALL print(concat("find -descrip OpsExec*")), row + 1,
      CALL print("exit"),
      row + 1,
      CALL print("$EOD"), row + 1,
      CALL print("$exit 1"), row + 1
     ELSE
      CALL print("#!/bin/ksh"), row + 1,
      CALL print("#"),
      row + 1,
      CALL print("tgt_node=`hostname`"), row + 1,
      CALL print(concat("system_pwd='",dgos_pw,"'")), row + 1,
      CALL print(concat("$cer_exe/scpview $tgt_node <<!>",dgos_path,"opsexec_servers.dat")),
      row + 1,
      CALL print(dgos_user), row + 1,
      CALL print(dgos_domain_name), row + 1,
      CALL print("$system_pwd"),
      row + 1,
      CALL print("find -descrip OpsExec*"), row + 1,
      CALL print("exit"), row + 1,
      CALL print("!"),
      row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",dgos_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgos_cmd = concat("@",dgos_file_name)
   ELSE
    SET dgos_cmd = concat("chmod 777 ",dgos_file_name)
    IF (dm2_push_dcl(dgos_cmd)=0)
     RETURN(0)
    ENDIF
    SET dgos_cmd = concat(". ",dgos_file_name)
   ENDIF
   IF (dm2_push_dcl(dgos_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dgos_file_name = concat(dgos_path,"opsexec_servers.dat")
   IF (dm2_findfile(dgos_file_name)=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find file ",dgos_file_name)
     SET dm_err->emsg = concat("Failed to find ",dgos_file_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Parse out server id and description for Ops Exec Servers"
   CALL disp_msg("",dm_err->logfile,0)
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dgos_file_name)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     id_pos = 0, desc_pos = 0, ddr_opsexec_servers->cnt = 0,
     stat = alterlist(ddr_opsexec_servers->servers,ddr_opsexec_servers->cnt)
    DETAIL
     pos = 0, dgos_srv_nbr = "DM2NOTSET", dgos_srv_desc = "DM2NOTSET"
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     IF (findstring("No matching entries found",r.line,1,0)=0)
      IF (substring(1,2,r.line)="id")
       id_pos = 1, desc_pos = findstring("description",r.line,1,0)
      ELSE
       IF (id_pos > 0
        AND desc_pos > 0)
        pos = findstring(" ",r.line,1,0),
        CALL echo(build("POS = ",pos))
        IF (pos > 0
         AND  NOT (pos >= textlen(trim(r.line))))
         dgos_srv_nbr = substring(1,(pos - 1),r.line), dgos_srv_desc = substring(desc_pos,((textlen(r
           .line) - desc_pos)+ 1),r.line)
         IF ((dm_err->debug_flag > 0))
          CALL echo(build("SRV_NBR=",dgos_srv_nbr)),
          CALL echo(build("SRV_DESC=",dgos_srv_desc))
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
     IF (dgos_srv_nbr != "DM2NOTSET"
      AND dgos_srv_desc != "DM2NOTSET")
      ddr_opsexec_servers->cnt = (ddr_opsexec_servers->cnt+ 1)
      IF (mod(ddr_opsexec_servers->cnt,50)=1)
       stat = alterlist(ddr_opsexec_servers->servers,(ddr_opsexec_servers->cnt+ 49))
      ENDIF
      ddr_opsexec_servers->servers[ddr_opsexec_servers->cnt].server_name = dgos_srv_desc,
      ddr_opsexec_servers->servers[ddr_opsexec_servers->cnt].server_nbr = cnvtint(dgos_srv_nbr)
     ENDIF
    FOOT REPORT
     stat = alterlist(ddr_opsexec_servers->servers,ddr_opsexec_servers->cnt)
    WITH nocounter, maxcol = 255
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_opsexec_servers)
   ENDIF
   IF ((ddr_opsexec_servers->cnt=0))
    SET dm_err->eproc = "No OpsExec servers were found in SCP"
    CALL disp_msg(" ",dm_err->logfile,0)
   ELSE
    FOR (dgos_idx = 1 TO ddr_opsexec_servers->cnt)
      IF ((dm2_sys_misc->cur_os="AXP"))
       SET dgos_str = concat("\node\",build(curnode),"\domain\",dgos_domain_name,"\servers\",
        build(ddr_opsexec_servers->servers[dgos_idx].server_nbr)," Protect")
      ELSE
       SET dgos_str = concat("\\node\\",build(curnode),"\\domain\\",dgos_domain_name,"\\servers\\",
        build(ddr_opsexec_servers->servers[dgos_idx].server_nbr)," Protect")
      ENDIF
      IF (ddr_lreg_oper("GET",dgos_str,dgos_ret)=0)
       RETURN(0)
      ENDIF
      IF (dgos_ret != "N")
       SET dm_err->emsg = build("The following OpsExec server is protected:",ddr_opsexec_servers->
        servers[dgos_idx].server_name,"(",ddr_opsexec_servers->servers[dgos_idx].server_nbr,")")
       SET dm_err->err_ind = 1
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
    ENDFOR
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_opsexec_hosts(null)
   DECLARE dvoh_idx = i4 WITH protect, noconstant(0)
   DECLARE dvoh_idx2 = i4 WITH protect, noconstant(0)
   DECLARE dvoh_idx3 = i4 WITH protect, noconstant(0)
   DECLARE dvoh_str1 = vc WITH protect, noconstant("")
   DECLARE dvoh_str2 = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Retrieve current OpsExec host list"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT DISTINCT INTO "nl:"
    hn = parser(concat("o.",ddr_ops_info->col_host))
    FROM (value(ddr_ops_info->tbl_name) o)
    WHERE o.active_ind=1
    ORDER BY parser(concat("o.",ddr_ops_info->col_host))
    HEAD REPORT
     ddr_opsexec_nodes->src_node_cnt = 0, stat = alterlist(ddr_opsexec_nodes->src_nodes,
      ddr_opsexec_nodes->src_node_cnt)
    DETAIL
     IF (hn > " "
      AND hn != "SCOUT")
      ddr_opsexec_nodes->src_node_cnt = (ddr_opsexec_nodes->src_node_cnt+ 1), stat = alterlist(
       ddr_opsexec_nodes->src_nodes,ddr_opsexec_nodes->src_node_cnt), ddr_opsexec_nodes->src_nodes[
      ddr_opsexec_nodes->src_node_cnt].node_name = cnvtupper(hn),
      ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].tgt_map_node = "DM2NOTSET"
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((curqual=0) OR ((ddr_opsexec_nodes->src_node_cnt=0))) )
    SET dm_err->eproc = "No active hosts found in Operations control group table"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_opsexec_nodes)
   ENDIF
   FOR (dvoh_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
    SET dvoh_str1 = cnvtlower(ddr_opsexec_nodes->src_nodes[dvoh_idx].node_name)
    IF (locateval(dvoh_idx2,1,ddr_domain_data->tgt_nodes_cnt,dvoh_str1,ddr_domain_data->tgt_nodes[
     dvoh_idx2].node_name)=0)
     IF (locateval(dvoh_idx3,1,ddr_domain_data->src_nodes_cnt,dvoh_str1,ddr_domain_data->src_nodes[
      dvoh_idx3].node_name) > 0)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = "Verifying existence of OpsExec Hosts in Target Node list"
      SET dm_err->emsg = concat("Host ",ddr_opsexec_nodes->src_nodes[dvoh_idx].node_name,
       " does not exist in Target Node List from SCP")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_validate_mapping(dvm_mapping_applied,dvm_invalid_ind)
   DECLARE dvm_idx = i4 WITH protect, noconstant(0)
   DECLARE dvm_idx2 = i4 WITH protect, noconstant(0)
   DECLARE dvm_pos = i4 WITH protect, noconstant(0)
   DECLARE dvm_str = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Validating Ops Exec node mappings")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DM2_OPSEXEC_NODE_MAPPING"
     AND di.info_char=concat(cnvtupper(ddr_domain_data->src_domain_name),"::",cnvtupper(
      ddr_domain_data->tgt_domain_name))
    HEAD REPORT
     ddr_opsexec_nodes->src_node_cnt = 0, stat = alterlist(ddr_opsexec_nodes->src_nodes,
      ddr_opsexec_nodes->src_node_cnt)
    DETAIL
     ddr_opsexec_nodes->src_node_cnt = (ddr_opsexec_nodes->src_node_cnt+ 1), stat = alterlist(
      ddr_opsexec_nodes->src_nodes,ddr_opsexec_nodes->src_node_cnt), dvm_pos = findstring("::",di
      .info_name,0,1)
     IF (dvm_pos > 0)
      ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].node_name = substring(1,(dvm_pos
        - 1),di.info_name), ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].
      tgt_map_node = substring((dvm_pos+ 2),((textlen(di.info_name) - dvm_pos) - 1),di.info_name)
     ENDIF
     IF ((di.info_number=- (1)))
      ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].ignore_ind = 1
     ELSEIF (di.info_number=1)
      dvm_mapping_applied = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((ddr_opsexec_nodes->src_node_cnt=0))
    SET dm_err->eproc = "No OpsExec Mapping was found"
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dvm_invalid_ind = 1
    RETURN(1)
   ENDIF
   IF (dvm_mapping_applied=1)
    SET dm_err->eproc = "OpsExec Mapping has already been applied"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   SELECT DISTINCT INTO "nl:"
    hn = parser(concat("o.",ddr_ops_info->col_host))
    FROM (value(ddr_ops_info->tbl_name) o)
    ORDER BY parser(concat("o.",ddr_ops_info->col_host))
    DETAIL
     IF (hn > " "
      AND hn != "SCOUT")
      dvm_str = cnvtlower(trim(hn))
      IF (locateval(dvm_idx,1,ddr_domain_data->src_nodes_cnt,dvm_str,ddr_domain_data->src_nodes[
       dvm_idx].node_name) > 0)
       IF (locateval(dvm_idx2,1,ddr_opsexec_nodes->src_node_cnt,trim(hn),ddr_opsexec_nodes->
        src_nodes[dvm_idx2].node_name)=0)
        dvm_invalid_ind = 1
       ENDIF
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dvm_invalid_ind=1)
    SET dm_err->eproc = concat(
     "All OpsExec Hosts from ops_control_group are not accounted for in the existing mapping")
    CALL disp_msg("",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   FOR (dvm_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
     IF ((ddr_opsexec_nodes->src_nodes[dvm_idx].ignore_ind=0))
      SET dvm_str = cnvtlower(ddr_opsexec_nodes->src_nodes[dvm_idx].tgt_map_node)
      IF (locateval(dvm_idx2,1,ddr_domain_data->tgt_nodes_cnt,dvm_str,ddr_domain_data->tgt_nodes[
       dvm_idx2].node_name)=0)
       SET dm_err->eproc = concat("Host ",ddr_opsexec_nodes->src_nodes[dvm_idx].tgt_map_node,
        " does not exist in Target Node List from SCP")
       CALL disp_msg("",dm_err->logfile,0)
       SET dvm_invalid_ind = 1
       RETURN(1)
      ENDIF
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_opsexec_node_map(null)
   DECLARE dgonm_idx = i4 WITH protect, noconstant(0)
   DECLARE dgonm_idx2 = i4 WITH protect, noconstant(0)
   DECLARE dgonm_idx3 = i4 WITH protect, noconstant(0)
   DECLARE dgonm_loc = i4 WITH protect, noconstant(0)
   DECLARE dgonm_row = i4 WITH protect, noconstant(0)
   DECLARE dgonm_invalid = i2 WITH protect, noconstant(0)
   DECLARE dgonm_continue = i2 WITH protect, noconstant(1)
   DECLARE dgonm_get_mapping = i2 WITH protect, noconstant(0)
   DECLARE dgonm_mapping_applied = i2 WITH protect, noconstant(0)
   DECLARE dgonm_write_to_dm_info = i2 WITH protect, noconstant(0)
   DECLARE dgonm_str = vc WITH protect, noconstant("")
   IF (ddr_validate_mapping(dgonm_mapping_applied,dgonm_get_mapping)=0)
    RETURN(0)
   ENDIF
   IF (dgonm_mapping_applied=1)
    RETURN(1)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dgonm_get_mapping = 1
   ELSE
    IF (dgonm_get_mapping=0)
     IF ((dm_err->debug_flag != 722))
      SET message = window
     ENDIF
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,3,132)
     CALL box(1,1,24,132)
     CALL text(2,2,"OPS EXEC SERVERS MAINTAINENCE [SOURCE->TARGET NODE MAPPING]")
     CALL text(5,2,"A valid mapping was found between source and target nodes. ")
     CALL text(7,2,"Press C to Continue the process using the existing mapping OR ")
     CALL text(8,2,"Press M to Modify the mapping before proceeding.")
     CALL text(12,2,"Your Choice [C/M]:")
     CALL accept(12,23,"A;cu","C"
      WHERE curaccept IN ("C", "M"))
     IF (curaccept="M")
      SET dgonm_get_mapping = 1
     ELSE
      SET dgonm_get_mapping = 0
     ENDIF
     SET message = nowindow
    ENDIF
   ENDIF
   IF (dgonm_get_mapping=1)
    SET dm_err->eproc = "Retrieve current OpsExec host list"
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT DISTINCT INTO "nl:"
     hn = parser(concat("o.",ddr_ops_info->col_host))
     FROM (value(ddr_ops_info->tbl_name) o)
     ORDER BY parser(concat("o.",ddr_ops_info->col_host))
     HEAD REPORT
      ddr_opsexec_nodes->src_node_cnt = 0, stat = alterlist(ddr_opsexec_nodes->src_nodes,
       ddr_opsexec_nodes->src_node_cnt)
     DETAIL
      IF (hn > " "
       AND hn != "SCOUT")
       dgonm_str = cnvtupper(trim(hn))
       IF (locateval(dgonm_idx3,1,ddr_opsexec_nodes->src_node_cnt,cnvtupper(hn),ddr_opsexec_nodes->
        src_nodes[dgonm_idx3].node_name)=0)
        ddr_opsexec_nodes->src_node_cnt = (ddr_opsexec_nodes->src_node_cnt+ 1), stat = alterlist(
         ddr_opsexec_nodes->src_nodes,ddr_opsexec_nodes->src_node_cnt), ddr_opsexec_nodes->src_nodes[
        ddr_opsexec_nodes->src_node_cnt].node_name = dgonm_str,
        ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].tgt_map_node = "DM2NOTSET",
        dgonm_str = cnvtlower(trim(hn))
        IF (locateval(dgonm_idx,1,ddr_domain_data->src_nodes_cnt,dgonm_str,ddr_domain_data->
         src_nodes[dgonm_idx].node_name) > 0)
         ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].ignore_ind = 0
        ELSE
         ddr_opsexec_nodes->src_nodes[ddr_opsexec_nodes->src_node_cnt].ignore_ind = 1
        ENDIF
       ENDIF
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((curqual=0) OR ((ddr_opsexec_nodes->src_node_cnt=0))) )
     SET dm_err->eproc = "No active hosts found in Operations control group table"
     CALL disp_msg(" ",dm_err->logfile,0)
     RETURN(1)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(ddr_opsexec_nodes)
    ENDIF
    IF (validate(drrr_responsefile_in_use,0)=1)
     FOR (dgonm_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
       IF ((ddr_opsexec_nodes->src_nodes[dgonm_idx].ignore_ind=0))
        SET dgonm_loc = locateval(dgonm_idx2,1,drrr_misc_data->tgt_opsexec_map_cnt,ddr_opsexec_nodes
         ->src_nodes[dgonm_idx].node_name,drrr_misc_data->tgt_opsexec_map[dgonm_idx2].src_node)
        IF (dgonm_loc=0)
         SET dm_err->eproc = concat("Verifying all hosts are accounted for in ",
          "OpsExec Mapping specified in response file.")
         SET dm_err->emsg = concat("Source Host, ",ddr_opsexec_nodes->src_nodes[dgonm_idx].node_name,
          " does not have a corresponding target mapped node in resposne file")
         SET dm_err->err_ind = 1
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ELSE
         SET ddr_opsexec_nodes->src_nodes[dgonm_idx].tgt_map_node = cnvtupper(drrr_misc_data->
          tgt_opsexec_map[dgonm_loc].tgt_node)
        ENDIF
       ENDIF
     ENDFOR
     SET dgonm_write_to_dm_info = 1
    ELSE
     IF ((dm_err->debug_flag != 722))
      SET message = window
     ENDIF
     SET width = 132
     CALL clear(1,1)
     CALL box(1,1,3,132)
     CALL box(1,1,24,132)
     CALL text(2,2,"OPS EXEC SERVERS MAINTAINENCE [SOURCE->TARGET NODE MAPPING]")
     CALL text(5,2,concat("For each source node listed as an Ops Exec Host, ",
       "select a valid target app node to map the corresponding Ops Exec servers"))
     SET help = pos(10,80,10,35)
     SET help =
     SELECT INTO "nl:"
      target_node = substring(1,30,cnvtupper(ddr_domain_data->tgt_nodes[t.seq].node_name))
      FROM (dummyt t  WITH seq = value(ddr_domain_data->tgt_nodes_cnt))
      WITH nocounter
     ;end select
     CALL text(10,2,concat("SOURCE NODE",fillstring(30," "),"TARGET NODE TO MAP"))
     CALL text(11,2,fillstring(75,"-"))
     SET dgonm_row = 12
     FOR (dgonm_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
       IF ((ddr_opsexec_nodes->src_nodes[dgonm_idx].ignore_ind=0))
        CALL text(dgonm_row,2,ddr_opsexec_nodes->src_nodes[dgonm_idx].node_name)
        SET dgonm_continue = 1
        WHILE (dgonm_continue=1)
          CALL accept(dgonm_row,40,"P(30);CUF",ddr_opsexec_nodes->src_nodes[dgonm_idx].tgt_map_node
           WHERE curaccept > " ")
          SET ddr_opsexec_nodes->src_nodes[dgonm_idx].tgt_map_node = curaccept
          SET dgonm_str = cnvtlower(ddr_opsexec_nodes->src_nodes[dgonm_idx].tgt_map_node)
          IF (locateval(dgonm_idx2,1,ddr_domain_data->tgt_nodes_cnt,dgonm_str,ddr_domain_data->
           tgt_nodes[dgonm_idx2].node_name)=0)
           CALL text(8,2,
            "**The value entered is not a valid Target Node. Please choose a node from the help list"
            )
          ELSE
           CALL clear(8,2,100)
           SET dgonm_continue = 0
          ENDIF
        ENDWHILE
        SET dgonm_row = (dgonm_row+ 1)
       ENDIF
     ENDFOR
     SET help = off
     CALL text(22,2,"Continue/Exit [C/E]:")
     CALL accept(22,23,"A;cu","C"
      WHERE curaccept IN ("C", "E"))
     CALL clear(1,1)
     SET message = nowindow
     IF (curaccept="E")
      SET dm_err->emsg = "User elected to quit from Ops Exec servers node mapping menu."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET dgonm_write_to_dm_info = 1
     ENDIF
    ENDIF
    IF (dgonm_write_to_dm_info=1)
     SET dm_err->eproc = concat("Deleting Ops Exec node mappings from dm_info")
     CALL disp_msg("",dm_err->logfile,0)
     DELETE  FROM dm_info di
      WHERE di.info_domain="DM2_OPSEXEC_NODE_MAPPING"
       AND di.info_char=concat(cnvtupper(ddr_domain_data->src_domain_name),"::",cnvtupper(
        ddr_domain_data->tgt_domain_name))
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      ROLLBACK
      RETURN(0)
     ENDIF
     SET dm_err->eproc = concat("Inserting Ops Exec node mappings into dm_info")
     CALL disp_msg("",dm_err->logfile,0)
     INSERT  FROM dm_info di,
       (dummyt d  WITH seq = value(ddr_opsexec_nodes->src_node_cnt))
      SET di.info_domain = "DM2_OPSEXEC_NODE_MAPPING", di.info_char = concat(cnvtupper(
         ddr_domain_data->src_domain_name),"::",cnvtupper(ddr_domain_data->tgt_domain_name)), di
       .info_name = concat(ddr_opsexec_nodes->src_nodes[d.seq].node_name,"::",ddr_opsexec_nodes->
        src_nodes[d.seq].tgt_map_node),
       di.info_number = evaluate(ddr_opsexec_nodes->src_nodes[d.seq].ignore_ind,0,0,1,- (1)), di
       .info_date = cnvtdatetime(curdate,curtime3)
      PLAN (d
       WHERE d.seq > 0)
       JOIN (di)
      WITH nocounter
     ;end insert
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      ROLLBACK
      RETURN(0)
     ENDIF
     COMMIT
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_opsexec_nodes)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_update_opsexec_mapping(null)
   DECLARE duom_idx = i4 WITH protect, noconstant(0)
   DECLARE duom_active_cv = f8 WITH protect, noconstant(0.0)
   DECLARE duom_inactive_cv = f8 WITH protect, noconstant(0.0)
   DECLARE duom_cnt = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Get code value for active and inactive indicators")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM code_value c
    WHERE c.code_set=48
     AND c.cdf_meaning IN ("ACTIVE", "INACTIVE")
    DETAIL
     IF (c.cdf_meaning="ACTIVE")
      duom_active_cv = c.code_value
     ELSEIF (c.cdf_meaning="INACTIVE")
      duom_inactive_cv = c.code_value
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Retrieving OCG Ids for each valid host from ops_control_groups")
   CALL disp_msg("",dm_err->logfile,0)
   FOR (duom_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
     IF ((ddr_opsexec_nodes->src_nodes[duom_idx].ignore_ind=0))
      SET dm_err->eproc = "Getting list from Operations control group table for each host"
      SELECT INTO "nl:"
       FROM (value(ddr_ops_info->tbl_name) o)
       WHERE (cnvtupper(parser(concat("o.",ddr_ops_info->col_host)))=ddr_opsexec_nodes->src_nodes[
       duom_idx].node_name)
       HEAD REPORT
        ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt = 0, stat = alterlist(ddr_opsexec_nodes->
         src_nodes[duom_idx].ocg_list,ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt)
       DETAIL
        ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt = (ddr_opsexec_nodes->src_nodes[duom_idx].
        ocg_cnt+ 1), duom_cnt = ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt
        IF (mod(duom_cnt,10)=1)
         stat = alterlist(ddr_opsexec_nodes->src_nodes[duom_idx].ocg_list,(duom_cnt+ 9))
        ENDIF
        ddr_opsexec_nodes->src_nodes[duom_idx].ocg_list[duom_cnt].ocg_id = parser(concat("o.",
          ddr_ops_info->col_group_id))
       FOOT REPORT
        stat = alterlist(ddr_opsexec_nodes->src_nodes[duom_idx].ocg_list,ddr_opsexec_nodes->
         src_nodes[duom_idx].ocg_cnt)
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
   ENDFOR
   SET dm_err->eproc = concat("Updating Ops Exec node mappings into ops_control_groups")
   CALL disp_msg("",dm_err->logfile,0)
   FOR (duom_idx = 1 TO ddr_opsexec_nodes->src_node_cnt)
     IF ((ddr_opsexec_nodes->src_nodes[duom_idx].ignore_ind=0))
      IF ((ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt > 0))
       SET dm_err->eproc = concat("Updating ",ddr_ops_info->tbl_name," with target mapped nodes for ",
        ddr_opsexec_nodes->src_nodes[duom_idx].node_name)
       UPDATE  FROM (value(ddr_ops_info->tbl_name) o),
         (dummyt d  WITH seq = value(ddr_opsexec_nodes->src_nodes[duom_idx].ocg_cnt))
        SET parser(concat("o.",ddr_ops_info->col_host)) = ddr_opsexec_nodes->src_nodes[duom_idx].
         tgt_map_node, parser(concat("o.",ddr_ops_info->col_server_nbr)) = 0
        PLAN (d
         WHERE d.seq > 0)
         JOIN (o
         WHERE (parser(concat("o.",ddr_ops_info->col_group_id))=ddr_opsexec_nodes->src_nodes[duom_idx
         ].ocg_list[d.seq].ocg_id))
        WITH nocounter
       ;end update
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        ROLLBACK
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   UPDATE  FROM dm_info di
    SET di.info_number = 1
    WHERE di.info_domain="DM2_OPSEXEC_NODE_MAPPING"
     AND di.info_char=concat(cnvtupper(ddr_domain_data->src_domain_name),"::",cnvtupper(
      ddr_domain_data->tgt_domain_name))
     AND di.info_number=0
    WITH nocounter
   ;end update
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   COMMIT
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_cleanup_opsexec_mapping(null)
   DECLARE duom_idx = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Deleting Ops Exec node mappings from dm_info")
   CALL disp_msg("",dm_err->logfile,0)
   DELETE  FROM dm_info di
    WHERE di.info_domain="DM2_OPSEXEC_NODE_MAPPING"
    WITH nocounter
   ;end delete
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   COMMIT
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_assign_opsexec_servers(null)
   DECLARE daos_idx = i4 WITH protect, noconstant(0)
   DECLARE daos_idx2 = i4 WITH protect, noconstant(0)
   DECLARE daos_str = vc WITH protect, noconstant("")
   DECLARE daos_ret = vc WITH protect, noconstant("")
   DECLARE daos_cur_assigned_idx = i4 WITH protect, noconstant(0)
   DECLARE daos_file_name = vc WITH protect, noconstant("")
   DECLARE daos_cmd = vc WITH protect, noconstant("")
   DECLARE daos_path = vc WITH protect, noconstant("")
   DECLARE daos_srv_file = vc WITH protect, noconstant("")
   DECLARE daos_srv_param = vc WITH protect, noconstant("")
   DECLARE daos_dyn_where = vc WITH protect, noconstant("")
   SET dm_err->eproc =
   "Retrieve OpsExec servers from Operations control group table for current node"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((ddr_domain_data->src_ops_ver > 1.0))
    SET daos_dyn_where = concat(
     ' cnvtupper(parser(concat("o.", ddr_ops_info->col_host))) = cnvtupper(trim(curnode))',
     " and o.beg_effective_dt_tm <= cnvtdatetime (curdate, curtime3)",
     " and o.end_effective_dt_tm > cnvtdatetime (curdate, curtime3)")
   ELSE
    SET daos_dyn_where =
    ' cnvtupper(parser(concat("o.", ddr_ops_info->col_host))) = cnvtupper(trim(curnode))'
   ENDIF
   SELECT INTO "nl:"
    FROM (value(ddr_ops_info->tbl_name) o)
    WHERE o.active_ind=1
     AND parser(daos_dyn_where)
    HEAD REPORT
     ddr_opsexec_cgs->cnt = 0, stat = alterlist(ddr_opsexec_cgs->cgs,ddr_opsexec_cgs->cnt)
    DETAIL
     ddr_opsexec_cgs->cnt = (ddr_opsexec_cgs->cnt+ 1)
     IF (mod(ddr_opsexec_cgs->cnt,50)=1)
      stat = alterlist(ddr_opsexec_cgs->cgs,(ddr_opsexec_cgs->cnt+ 49))
     ENDIF
     ddr_opsexec_cgs->cgs[ddr_opsexec_cgs->cnt].ocg_id = parser(concat("o.",ddr_ops_info->
       col_group_id)), ddr_opsexec_cgs->cgs[ddr_opsexec_cgs->cnt].cg_name = parser(concat("o.",
       ddr_ops_info->col_group_name))
    FOOT REPORT
     stat = alterlist(ddr_opsexec_cgs->cgs,ddr_opsexec_cgs->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((curqual=0) OR ((ddr_opsexec_cgs->cnt=0))) )
    SET dm_err->eproc =
    "No OpsExec Control Groups were found in Operations control group table for current node"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF (ddr_get_lreg_servers(ddr_domain_data->tgt_tmp_full_dir,ddr_domain_data->tgt_domain_name)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Assigning OpsExec server numbers in the range 660-699"
   CALL disp_msg(" ",dm_err->logfile,0)
   SET daos_idx2 = 660
   WHILE (daos_idx2 < 700
    AND (daos_cur_assigned_idx < ddr_opsexec_cgs->cnt))
    IF (locateval(daos_idx,1,ddr_lreg_servers->cnt,daos_idx2,ddr_lreg_servers->qual[daos_idx].srv_nbr
     )=0)
     SET daos_cur_assigned_idx = (daos_cur_assigned_idx+ 1)
     SET ddr_opsexec_cgs->cgs[daos_cur_assigned_idx].server_nbr = daos_idx2
    ENDIF
    SET daos_idx2 = (daos_idx2+ 1)
   ENDWHILE
   SET dm_err->eproc = "Assigning OpsExec server numbers in the range 3285-3544"
   CALL disp_msg(" ",dm_err->logfile,0)
   SET daos_idx2 = 3285
   WHILE (daos_idx2 < 3545
    AND (daos_cur_assigned_idx < ddr_opsexec_cgs->cnt))
    IF (locateval(daos_idx,1,ddr_lreg_servers->cnt,daos_idx2,ddr_lreg_servers->qual[daos_idx].srv_nbr
     )=0)
     SET daos_cur_assigned_idx = (daos_cur_assigned_idx+ 1)
     SET ddr_opsexec_cgs->cgs[daos_cur_assigned_idx].server_nbr = daos_idx2
    ENDIF
    SET daos_idx2 = (daos_idx2+ 1)
   ENDWHILE
   IF ((daos_cur_assigned_idx < ddr_opsexec_cgs->cnt))
    IF ((validate(dm2_skip_unassigned_opsexec_servers,- (1))=- (1)))
     SET dm_err->eproc = "Assigning OpsExec server numbers"
     SET dm_err->err_ind = 1
     SET dm_err->emsg = "Unable to assign server numbers for all OpsExec cgs"
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_opsexec_cgs)
   ENDIF
   SET dm_err->eproc = concat("Updating OpsExec server numbers into Operations control group table")
   CALL disp_msg("",dm_err->logfile,0)
   UPDATE  FROM (value(ddr_ops_info->tbl_name) o),
     (dummyt d  WITH seq = value(ddr_opsexec_cgs->cnt))
    SET parser(concat("o.",ddr_ops_info->col_server_nbr)) = ddr_opsexec_cgs->cgs[d.seq].server_nbr
    PLAN (d
     WHERE d.seq > 0)
     JOIN (o
     WHERE (parser(concat("o.",ddr_ops_info->col_group_name))=ddr_opsexec_cgs->cgs[d.seq].cg_name)
      AND (parser(concat("o.",ddr_ops_info->col_group_id))=ddr_opsexec_cgs->cgs[d.seq].ocg_id))
    WITH nocounter
   ;end update
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   COMMIT
   SET daos_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"assign_opsexec_servers",evaluate(
     dm2_sys_misc->cur_os,"AXP",".com",".ksh"))
   IF (dm2_findfile(daos_file_name) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET daos_cmd = concat("del ",daos_file_name,";*")
    ELSE
     SET daos_cmd = concat("rm ",daos_file_name)
    ENDIF
    IF (dm2_push_dcl(daos_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to add OpsExec servers: ",daos_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((ddr_domain_data->src_ops_ver > 1.0))
    SET daos_srv_param = "ops_srvexecutor"
   ELSE
    SET daos_srv_param = "ops_srvexec"
   ENDIF
   SELECT INTO value(daos_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print(concat("$mcr cer_exe:scpview ",trim(curnode))), row + 1,
      CALL print("$DECK"),
      row + 1
     ELSE
      CALL print("tgt_node=`hostname`"), row + 1
      IF ((ddr_domain_data->process="REFRESH"))
       CALL print(concat("pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1
      ELSEIF ((ddr_domain_data->process="REPLICATE"))
       CALL print(concat("pwd='",ddr_domain_data->src_mng_pwd,"'")), row + 1
      ENDIF
      CALL print(concat("$cer_exe/scpview $tgt_node <<!")), row + 1
     ENDIF
     CALL print(ddr_domain_data->src_mng), row + 1,
     CALL print(ddr_domain_data->tgt_domain_name),
     row + 1
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF ((ddr_domain_data->process="REFRESH"))
       CALL print(ddr_domain_data->tgt_mng_pwd), row + 1
      ELSEIF ((ddr_domain_data->process="REPLICATE"))
       CALL print(ddr_domain_data->src_mng_pwd), row + 1
      ENDIF
     ELSE
      CALL print("$pwd"), row + 1
     ENDIF
     FOR (daos_idx = 1 TO ddr_opsexec_cgs->cnt)
       IF ((ddr_opsexec_cgs->cgs[daos_idx].server_nbr > 0))
        daos_cmd = concat("add ",build(ddr_opsexec_cgs->cgs[daos_idx].server_nbr),
         ' -descrip "OpsExec_',ddr_opsexec_cgs->cgs[daos_idx].cg_name,'"',
         " -path cer_exe/srv_drvr -param cer_exe/",daos_srv_param," -inst 0"," -user ",
         ddr_domain_data->src_priv,
         " -password ",ddr_domain_data->tgt_priv_pwd,' -restart y -prop cgname="',ddr_opsexec_cgs->
         cgs[daos_idx].cg_name,'"',
         ' -prop DependencyGroup=4 -prop "Rdbms User Name"=noccl'),
        CALL print(daos_cmd), row + 1
       ENDIF
     ENDFOR
     CALL print("exit"), row + 1
     IF ((dm2_sys_misc->cur_os != "AXP"))
      CALL print("!"), row + 1
     ELSE
      CALL print("$EOD"), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    CALL echo("Failed to create ksh/com file to add OpsExec servers.")
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute file: ",daos_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET daos_cmd = concat("@",daos_file_name)
   ELSE
    SET daos_cmd = concat("chmod 777 ",daos_file_name)
    IF (dm2_push_dcl(daos_cmd)=0)
     RETURN(0)
    ENDIF
    SET daos_cmd = concat(". ",daos_file_name)
   ENDIF
   IF (dm2_push_dcl(daos_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   SET dm_err->eproc = concat("Verify opsexec servers have been created")
   CALL disp_msg(" ",dm_err->logfile,0)
   FOR (daos_idx = 1 TO ddr_opsexec_cgs->cnt)
     IF ((ddr_opsexec_cgs->cgs[daos_idx].server_nbr > 0))
      IF ((dm2_sys_misc->cur_os="AXP"))
       SET daos_str = concat("\node\",trim(curnode),"\domain\",ddr_domain_data->tgt_domain_name,
        "\servers\",
        build(ddr_opsexec_cgs->cgs[daos_idx].server_nbr)," Servername")
      ELSE
       SET daos_str = concat("\\node\\",trim(curnode),"\\domain\\",ddr_domain_data->tgt_domain_name,
        "\\servers\\",
        build(ddr_opsexec_cgs->cgs[daos_idx].server_nbr)," Servername")
      ENDIF
      IF (ddr_lreg_oper("GET",daos_str,daos_ret)=0)
       RETURN(0)
      ENDIF
      IF (daos_ret != build("OpsExec_",ddr_opsexec_cgs->cgs[daos_idx].cg_name))
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat("Server for control group",ddr_opsexec_cgs->cgs[daos_idx].cg_name,
        "(",build(ddr_opsexec_cgs->cgs[daos_idx].server_nbr),") not created successfully")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ELSE
      SET dm_err->eproc = concat("Server was not created for the following control group: ",
       ddr_opsexec_cgs->cgs[daos_idx].cg_name)
      CALL disp_msg(" ",dm_err->logfile,0)
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_nodes_dns(null)
   DECLARE dgnd_file = vc WITH protect, noconstant("")
   DECLARE dgnd_cmd = vc WITH protect, noconstant("")
   DECLARE dgnd_found_start = i2 WITH protect, noconstant(0)
   DECLARE dgnd_found_node_name = i2 WITH protect, noconstant(0)
   DECLARE dgnd_errfile = vc WITH protect, noconstant("")
   DECLARE dgnd_found_curnode = i2 WITH protect, noconstant(0)
   DECLARE dgnd_cnt = i4 WITH protect, noconstant(0)
   DECLARE dgnd_pos = i4 WITH protect, noconstant(0)
   DECLARE dgnd_str = vc WITH protect, noconstant("")
   IF (get_unique_file("get_nodes",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dgnd_file = dm_err->unique_fname
   ENDIF
   SET dm_err->eproc = concat("Create file to obtain listing of nodes from DNS:",dgnd_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dgnd_file)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print(concat("$mcr cer_exe:testdns ",ddr_domain_data->tgt_domain_name)), row + 1
     ELSE
      CALL print(concat("$cer_exe/testdns ",ddr_domain_data->tgt_domain_name)), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Obtain node listing from DNS."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgnd_cmd = concat("@",dgnd_file)
   ELSE
    SET dgnd_cmd = concat(". $CCLUSERDIR/",dgnd_file)
   ENDIF
   IF (dm2_push_dcl(dgnd_cmd)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   IF (((findstring("bad command",dm_err->errtext,1,1) > 0) OR (findstring("Domain lookup failed",
    dm_err->errtext,1,1) > 0)) )
    SET dm_err->emsg = concat("Error getting target nodes from DNS:",dgnd_cmd)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgnd_errfile = dm_err->errfile
   SET dm_err->eproc = concat("Parse node listing from:",dgnd_errfile)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET logical dgnd_data_file dgnd_errfile
   FREE DEFINE rtl
   DEFINE rtl "dgnd_data_file"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     IF ((dm_err->debug_flag > 0))
      CALL echo(t.line)
     ENDIF
     dgnd_cnt = (dgnd_cnt+ 1)
     IF (dgnd_found_node_name=1)
      IF (findstring(".",t.line,dgnd_pos,0) > 0)
       dgnd_str = trim(cnvtupper(substring(1,(findstring(".",t.line,dgnd_pos,0) - dgnd_pos),t.line)))
      ELSE
       dgnd_str = substring(dgnd_pos,(findstring(" ",t.line,dgnd_pos,0) - dgnd_pos),t.line)
      ENDIF
      ddr_domain_data->tgt_nodes_cnt = (ddr_domain_data->tgt_nodes_cnt+ 1), stat = alterlist(
       ddr_domain_data->tgt_nodes,ddr_domain_data->tgt_nodes_cnt), ddr_domain_data->tgt_nodes[
      ddr_domain_data->tgt_nodes_cnt].node_name = cnvtlower(trim(dgnd_str,3))
      IF (trim(cnvtlower(dgnd_str))=trim(cnvtlower(curnode)))
       dgnd_found_curnode = 1
      ENDIF
     ENDIF
     IF (dgnd_found_start=1
      AND dgnd_found_node_name=0)
      dgnd_pos = findstring("Node Name",t.line,1,0)
      IF (dgnd_pos > 0)
       dgnd_found_node_name = 1
      ENDIF
     ENDIF
     IF (findstring("DNS SRV lookup for Cerner domain",t.line,1,1) > 0)
      dgnd_found_start = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(ddr_domain_data)
   ENDIF
   IF ((ddr_domain_data->tgt_nodes_cnt=0))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Unable to obtaing listing of nodes from DNS"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgnd_found_curnode=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Current node,",trim(curnode)," not found via testdns command.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_lreg_servers(dgls_path,dgls_domain)
   DECLARE dgls_idx = i4 WITH protect, noconstant(0)
   DECLARE dgls_file_name = vc WITH protect, noconstant("")
   DECLARE dgls_cmd = vc WITH protect, noconstant("")
   DECLARE dgls_str = vc WITH protect, noconstant("")
   DECLARE dgls_srv_file = vc WITH protect, noconstant("")
   SET dgls_srv_file = concat(dgls_path,"lreg_srv_list.txt")
   IF (dm2_findfile(dgls_srv_file) > 0)
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dgls_cmd = concat("del ",dgls_srv_file,";*")
    ELSE
     SET dgls_cmd = concat("rm ",dgls_srv_file)
    ENDIF
    IF (dm2_push_dcl(dgls_cmd)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create file to store list of servers defined in registry in ",
    dgls_srv_file)
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (get_unique_file("ddr_get_srv_list",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
    RETURN(0)
   ELSE
    SET dgls_file_name = dm_err->unique_fname
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgls_str = concat("\node\",trim(curnode),"\domain\",dgls_domain,"\servers")
   ELSE
    SET dgls_str = concat("\\node\\",trim(curnode),"\\domain\\",dgls_domain,"\\servers")
   ENDIF
   SELECT INTO value(dgls_file_name)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print(concat("$ mcr cer_exe:lreg -enumk ",dgls_str," ",dgls_srv_file)), row + 1
     ELSE
      CALL print(concat("$cer_exe/lreg -enumk ",dgls_str," ",dgls_srv_file)), row + 1
     ENDIF
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgls_cmd = concat("@",dgls_file_name)
   ELSE
    SET dgls_cmd = concat(". $CCLUSERDIR/",dgls_file_name)
   ENDIF
   IF (dm2_push_dcl(dgls_cmd)=0)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dgls_srv_file) > 0)
    SET dm_err->eproc = concat("Read ",dgls_srv_file)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET logical dgls_lreg_file dgls_srv_file
    FREE DEFINE rtl
    DEFINE rtl "dgls_lreg_file"
    SELECT INTO "nl:"
     t.line
     FROM rtlt t
     WHERE t.line > " "
     DETAIL
      IF (isnumeric(trim(t.line)))
       dgls_idx = cnvtint(trim(t.line)), ddr_lreg_servers->cnt = (ddr_lreg_servers->cnt+ 1), stat =
       alterlist(ddr_lreg_servers->qual,ddr_lreg_servers->cnt),
       ddr_lreg_servers->qual[ddr_lreg_servers->cnt].srv_nbr = dgls_idx
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ELSE
     SET dm_err->eproc = "Creating file with list of servers defined in lreg"
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Unable to create file :",dgls_srv_file)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 10))
    CALL echorecord(ddr_lreg_servers)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_tdb_data(dgtd_file_name)
   DECLARE dgtd_cmd = vc WITH protect, noconstant(" ")
   DECLARE dgtd_beg_pos = i4 WITH protect, noconstant(0)
   DECLARE dgtd_str = vc WITH protect, noconstant("")
   DECLARE dgtd_curpages = vc WITH protect, noconstant(" ")
   DECLARE dgtd_maxpages = vc WITH protect, noconstant(" ")
   DECLARE dgtd_init_size = vc WITH protect, noconstant(" ")
   DECLARE dgtd_file_temp = vc WITH protect, noconstant(" ")
   DECLARE dgtd_no_error = i2 WITH protect, noconstant(0)
   DECLARE dgtd_file_full = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Get sizing information for TDB file name: ",build(dgtd_file_name))
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (get_unique_file("dm2_tdb_tmp",".dat")=0)
    RETURN(0)
   ELSE
    SET dgtd_file_temp = dm_err->unique_fname
   ENDIF
   SET dgtd_file_full = build(dm2_install_schema->ccluserdir,dgtd_file_temp)
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(concat(evaluate(dm2_sys_misc->cur_os,"AXP","backup/ignore=interlock","cp -p")," ",
     dgtd_file_name," ",dgtd_file_full))=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   IF (dm2_findfile(dgtd_file_full)=0)
    SET dm_err->eproc = concat("Copy TDB file (",build(dgtd_file_name),") to CCLUSERDIR (",build(
      dgtd_file_full),").")
    SET dm_err->emsg = concat("Error copying tdb file. Copy does not exist in CCLUSERDIR.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgtd_cmd = concat("mcr cer_exe:pagemgr -dump ",dgtd_file_full)
   ELSE
    SET dgtd_cmd = concat("$cer_exe/pagemgr -dump ",dgtd_file_full)
   ENDIF
   IF (dm2_push_dcl(dgtd_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     dgtd_beg_pos = 0, dgtd_str = fillstring(132," ")
    DETAIL
     dgtd_beg_pos = 0, dgtd_str = "", dgtd_beg_pos = findstring("size:",r.line)
     IF (dgtd_beg_pos > 0)
      CALL echo("Found <curpages> line..."), dgtd_str = trim(substring((dgtd_beg_pos+ 5),textlen(trim
         (r.line)),r.line),3), dgtd_curpages = trim(substring(1,(findstring(" ",dgtd_str) - 1),
        dgtd_str))
      IF ((dm_err->debug_flag >= 1))
       CALL echo(concat("curpages = ",dgtd_curpages))
      ENDIF
     ELSE
      dgtd_beg_pos = findstring("extent:",r.line)
      IF (dgtd_beg_pos > 0)
       CALL echo("Found <maxpages> line..."), dgtd_str = trim(substring((dgtd_beg_pos+ 7),textlen(
          trim(r.line)),r.line),3), dgtd_maxpages = trim(substring(1,(findstring(" ",dgtd_str) - 1),
         dgtd_str))
       IF ((dm_err->debug_flag >= 1))
        CALL echo(concat("maxpages = ",dgtd_maxpages))
       ENDIF
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out curpages/maxpages sizes from tdb file.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgtd_cmd = concat("mcr cer_exe:tdbmgr -dump ",dgtd_file_full)
   ELSE
    SET dgtd_cmd = concat("$cer_exe/tdbmgr -dump ",dgtd_file_full)
   ENDIF
   IF (dm2_push_dcl(dgtd_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF ((dm_err->debug_flag > 1))
      CALL echo(concat("LINE = ",r.line))
     ENDIF
     dgtd_beg_pos = 0, dgtd_str = "", dgtd_beg_pos = findstring("size:",r.line)
     IF (dgtd_beg_pos > 0)
      CALL echo("Found <init_size> line..."), dgtd_str = trim(substring((dgtd_beg_pos+ 5),textlen(
         trim(r.line)),r.line),3), dgtd_init_size = trim(substring(1,(findstring(" ",dgtd_str) - 1),
        dgtd_str))
      IF ((dm_err->debug_flag >= 1))
       CALL echo(concat("init_size = ",dgtd_init_size))
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out init_size from tdb file.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET ddr_domain_data->src_tdb_curpages = dgtd_curpages
   SET ddr_domain_data->src_tdb_maxpages = dgtd_maxpages
   SET ddr_domain_data->src_tdb_init_size = dgtd_init_size
   IF (cnvtint(ddr_domain_data->src_tdb_curpages) > 0
    AND cnvtint(ddr_domain_data->src_tdb_maxpages) > 0
    AND cnvtint(ddr_domain_data->src_tdb_init_size) > 0)
    IF ((dm_err->debug_flag > 0))
     SET dm_err->eproc = concat("Curpage/maxpages/init_size information for TDB file (",build(
       dgtd_file_name),") retrieved and values greater than zero.")
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Verify curpage/maxpages/init_size information for TDB file (",build(
      dgtd_file_name),") is greater than zero.")
    SET dm_err->emsg = concat("TDB information not found or not valued (values retrieved:  ",build(
      ddr_domain_data->src_tdb_curpages,"/",ddr_domain_data->src_tdb_maxpages,"/",ddr_domain_data->
      src_tdb_init_size),").")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_identify_ldap_usage(dilu_env,dilu_domain,dilu_mng,dilu_mng_pwd,dilu_system,dilu_priv,
  dilu_was_ind,dilu_ldap_ind)
   DECLARE dilu_os_str = vc WITH protect, noconstant("aixrs6000")
   DECLARE dilu_echo = vc WITH protect, noconstant("echo")
   DECLARE dilu_prop = vc WITH protect, noconstant("")
   DECLARE dilu_str = vc WITH protect, noconstant("")
   DECLARE dilu_ret = vc WITH protect, noconstant("")
   DECLARE dilu_cmd = vc WITH protect, noconstant(" ")
   DECLARE dilu_begpos = i2 WITH protect, noconstant(0)
   DECLARE dilu_file_name = vc WITH protect, noconstant("")
   DECLARE dilu_defaults_fnd = i2 WITH protect, noconstant(0)
   DECLARE dilu_system_default = vc WITH protect, noconstant("")
   DECLARE dilu_ret_full = vc WITH protect, noconstant("")
   DECLARE dilu_ret_log = vc WITH protect, noconstant("")
   DECLARE dilu_output_mng = vc WITH protect, noconstant("")
   DECLARE dilu_output_system = vc WITH protect, noconstant("")
   DECLARE dilu_output_priv = vc WITH protect, noconstant("")
   DECLARE dilu_mng_value = vc WITH protect, noconstant("")
   DECLARE dilu_system_value = vc WITH protect, noconstant("")
   DECLARE dilu_priv_value = vc WITH protect, noconstant("")
   DECLARE dilu_config_value = vc WITH protect, noconstant("")
   SET dilu_ldap_ind = 0
   IF ((dm2_sys_misc->cur_os="HPX"))
    SET dilu_os_str = "hpuxia64"
   ELSEIF ((dm2_sys_misc->cur_os="LNX"))
    SET dilu_os_str = "linuxx86-64"
    SET dilu_echo = "echo -e"
   ENDIF
   SET dilu_prop = build(cnvtupper(dilu_domain),"_ExternalAuthenticationMethod")
   IF ( NOT ((dm2_sys_misc->cur_os IN ("AIX", "HPX", "LNX"))))
    SET dm_err->eproc = concat("Skipping LDAP usage check.  ",trim(dm2_sys_misc->cur_os),
     " is an unsupported operating system.")
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF (dilu_was_ind=1)
    SET dm_err->eproc = concat("Check if LDAP enabled in database (EA_CONFIG).")
    CALL disp_msg("",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM ea_config ec
     WHERE cnvtupper(ec.realm)=cnvtupper(dilu_domain)
      AND cnvtupper(ec.config_name)="LDAP/ENABLED"
     DETAIL
      dilu_config_value = ec.config_value
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dilu_config_value="1")
     SET dilu_ldap_ind = 1
     SET dm_err->eproc = "LDAP is enabled."
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Check for ",trim(dilu_prop)," registry property.")
    CALL disp_msg("",dm_err->logfile,0)
    SET dilu_str = concat("\\environment\\",trim(dilu_env),"\\definitions\\",dilu_os_str,
     "\\environment ",
     trim(dilu_prop))
    SET dilu_value = "LDAP_AUTH"
    IF (ddr_lreg_oper("GET",dilu_str,dilu_ret)=0)
     RETURN(0)
    ENDIF
    IF (cnvtupper(dilu_ret)=dilu_value)
     SET dilu_ldap_ind = 1
     SET dm_err->eproc = "LDAP is enabled."
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF (dilu_ret="NOPARMRETURNED")
     SET dm_err->eproc = concat("Check for ",trim(dilu_prop)," environment logical (via getlog).")
     CALL disp_msg("",dm_err->logfile,0)
     SET dilu_cmd = concat("$cer_exe/getlog ",dilu_prop)
     IF (dm2_push_dcl(dilu_cmd)=0)
      RETURN(0)
     ELSEIF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ELSE
      IF ((dm_err->debug_flag > 0))
       CALL echo(concat("Parsing dm_err->errtext for: ",dilu_prop))
      ENDIF
      SET dilu_ret_full = dm_err->errtext
      SET dilu_ret_log = ""
      IF (findstring("not defined",dm_err->errtext)=0)
       SET dilu_begpos = findstring("[global]",dm_err->errtext)
       IF (dilu_begpos > 0)
        SET dilu_ret_log = substring((findstring("-->",dm_err->errtext,dilu_begpos,1)+ 4),((textlen(
          dm_err->errtext)+ 1) - (findstring("-->",dm_err->errtext,dilu_begpos,1)+ 4)),dm_err->
         errtext)
       ENDIF
      ENDIF
      IF ((dm_err->debug_flag > 0))
       CALL echo(concat("dm_err->errtext:[",dm_err->errtext,"]"))
       CALL echo(concat("dilu_ret_log:[",dilu_ret_log,"]"))
      ENDIF
      IF (cnvtupper(dilu_ret_log)=dilu_value)
       SET dilu_ldap_ind = 1
       SET dm_err->eproc = "LDAP is enabled."
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = "Determine LDAP system default setting."
   CALL disp_msg("",dm_err->logfile,0)
   IF (get_unique_file("dm2_ldap_default_chk",".ksh")=0)
    RETURN(0)
   ELSE
    SET dilu_file_name = dm_err->unique_fname
   ENDIF
   SET dilu_output_name = replace(dilu_file_name,".ksh",".dat")
   SET dm_err->eproc = concat("Create file to determine LDAP system default setting : ",
    dilu_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dilu_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     CALL print("#!/usr/bin/ksh"), row + 1,
     CALL print(concat("pwd='",dilu_mng_pwd,"'")),
     row + 1, dilu_cmd = concat(dilu_echo,' "',dilu_mng,"\n",dilu_domain,
      '\n$pwd\n" | authview "show -defaults" '),
     CALL print(dilu_cmd),
     row + 1, row + 1
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ",dilu_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dilu_cmd = concat("chmod 777 ",dilu_file_name)
   IF (dm2_push_dcl(dilu_cmd)=0)
    RETURN(0)
   ENDIF
   SET dilu_cmd = concat(". ",dm2_install_schema->ccluserdir,dilu_file_name)
   IF (dm2_push_dcl(dilu_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF (findstring("default password lifetime",cnvtlower(r.line),1,0) > 0)
      dilu_defaults_fnd = 1
     ENDIF
     dilu_begpos = 0, dilu_begpos = findstring("directory indicator",cnvtlower(r.line))
     IF (dilu_begpos > 0)
      dilu_system_default = trim(substring((dilu_begpos+ 19),textlen(trim(r.line)),r.line),3)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out directory indicator from authview output.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag >= 1))
    CALL echo(concat("defaults found indicator = ",cnvtstring(dilu_defaults_fnd)))
    CALL echo(concat("directory indicator = ",dilu_system_default))
   ENDIF
   IF (dilu_defaults_fnd=0)
    SET dm_err->eproc = "Determine LDAP system default setting."
    SET dm_err->emsg = "Unable to retrieve default policy settings from authview (show -defaults)."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (get_unique_file("dm2_get_acct_data",".ksh")=0)
    RETURN(0)
   ELSE
    SET dilu_file_name = dm_err->unique_fname
   ENDIF
   SET dilu_output_mng = build(replace(dilu_file_name,".ksh","_1.dat"))
   SET dilu_output_system = build(replace(dilu_file_name,".ksh","_2.dat"))
   SET dilu_output_priv = build(replace(dilu_file_name,".ksh","_3.dat"))
   SET dm_err->eproc = concat("Create file to determine account setting : ",dilu_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dilu_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     CALL print("#!/usr/bin/ksh"), row + 1,
     CALL print(concat("pwd='",dilu_mng_pwd,"'")),
     row + 1, dilu_cmd = concat(dilu_echo,' "',dilu_mng,"\n",dilu_domain,
      '\n$pwd\n" | authview "show ',dilu_mng," -out ",dm2_install_schema->ccluserdir,dilu_output_mng,
      '"'),
     CALL print(dilu_cmd),
     row + 1, dilu_cmd = concat(dilu_echo,' "',dilu_mng,"\n",dilu_domain,
      '\n$pwd\n" | authview "show ',dilu_system," -out ",dm2_install_schema->ccluserdir,
      dilu_output_system,
      '"'),
     CALL print(dilu_cmd),
     row + 1, dilu_cmd = concat(dilu_echo,' "',dilu_mng,"\n",dilu_domain,
      '\n$pwd\n" | authview "show ',dilu_priv," -out ",dm2_install_schema->ccluserdir,
      dilu_output_priv,
      '"'),
     CALL print(dilu_cmd),
     row + 1, row + 1
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ",dilu_file_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dilu_cmd = concat("chmod 777 ",dilu_file_name)
   IF (dm2_push_dcl(dilu_cmd)=0)
    RETURN(0)
   ENDIF
   SET dilu_cmd = concat(". ",dm2_install_schema->ccluserdir,dilu_file_name)
   IF (dm2_push_dcl(dilu_cmd)=0)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dilu_output_mng)=0)
    SET dm_err->eproc = concat("Execute file to determine account setting : ",dilu_file_name)
    SET dm_err->emsg = concat('Authview "show ',dilu_mng,'" did not create output file ',build(
      dilu_output_mng)," in CCLUSERDIR.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dilu_output_system)=0)
    SET dm_err->eproc = concat("Execute file to determine account setting : ",dilu_file_name)
    SET dm_err->emsg = concat('Authview "show ',dilu_system,'" did not create output file ',build(
      dilu_output_system)," in CCLUSERDIR.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(dilu_output_priv)=0)
    SET dm_err->eproc = concat("Execute file to determine account setting : ",dilu_file_name)
    SET dm_err->emsg = concat('Authview "show ',dilu_priv,'" did not create output file ',build(
      dilu_output_priv)," in CCLUSERDIR.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dilu_defaults_fnd = 0
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dilu_output_mng)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF (findstring("password life:",cnvtlower(r.line),1,0) > 0)
      dilu_defaults_fnd = 1
     ENDIF
     dilu_begpos = 0, dilu_begpos = findstring("directory user:",cnvtlower(r.line))
     IF (dilu_begpos > 0)
      dilu_mng_value = trim(substring((dilu_begpos+ 15),textlen(trim(r.line)),r.line),3)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out ",trim(dilu_mng)," account directory user from authview output."
     )) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag >= 1))
    CALL echo(concat("user defaults found indicator = ",cnvtstring(dilu_defaults_fnd)))
    CALL echo(concat(trim(dilu_mng)," directory user value = ",dilu_mng_value))
   ENDIF
   IF (dilu_defaults_fnd=0)
    SET dm_err->eproc = concat("Determine ",dilu_mng," user default setting.")
    SET dm_err->emsg =
    "Unable to retrieve user default settings from authview (show <user>) command."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dilu_defaults_fnd = 0
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dilu_output_system)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF (findstring("password life:",cnvtlower(r.line),1,0) > 0)
      dilu_defaults_fnd = 1
     ENDIF
     dilu_begpos = 0, dilu_begpos = findstring("directory user:",cnvtlower(r.line))
     IF (dilu_begpos > 0)
      dilu_system_value = trim(substring((dilu_begpos+ 15),textlen(trim(r.line)),r.line),3)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out ",trim(dilu_system),
     " account directory user from authview output.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag >= 1))
    CALL echo(concat("user defaults found indicator = ",cnvtstring(dilu_defaults_fnd)))
    CALL echo(concat(trim(dilu_system)," directory user value = ",dilu_system_value))
   ENDIF
   IF (dilu_defaults_fnd=0)
    SET dm_err->eproc = concat("Determine ",dilu_system," user default setting.")
    SET dm_err->emsg =
    "Unable to retrieve user default settings from authview (show <user>) command."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dilu_defaults_fnd = 0
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dilu_output_priv)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF (findstring("password life:",cnvtlower(r.line),1,0) > 0)
      dilu_defaults_fnd = 1
     ENDIF
     dilu_begpos = 0, dilu_begpos = findstring("directory user:",cnvtlower(r.line))
     IF (dilu_begpos > 0)
      dilu_priv_value = trim(substring((dilu_begpos+ 15),textlen(trim(r.line)),r.line),3)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parse out ",trim(dilu_priv),
     " account directory user from authview output.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag >= 1))
    CALL echo(concat("user defaults found indicator = ",cnvtstring(dilu_defaults_fnd)))
    CALL echo(concat(trim(dilu_priv)," directory user value = ",dilu_priv_value))
   ENDIF
   IF (dilu_defaults_fnd=0)
    SET dm_err->eproc = concat("Determine ",dilu_priv," user default setting.")
    SET dm_err->emsg =
    "Unable to retrieve user default settings from authview (show <user>) command."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(dilu_mng_value)="Y") OR (((cnvtupper(dilu_system_value)="Y") OR (cnvtupper(
    dilu_priv_value)="Y")) )) )
    SET dm_err->eproc = concat("Verify accounts [",dilu_mng,",",dilu_system,",",
     dilu_priv,"] are not LDAP enabled.")
    SET dm_err->emsg =
    "One or more of these accounts are LDAP enabled which is an invalid configuration."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (cnvtupper(dilu_system_default)="Y"
    AND ((cnvtupper(dilu_mng_value) != "N") OR (((cnvtupper(dilu_system_value) != "N") OR (cnvtupper(
    dilu_priv_value) != "N")) )) )
    SET dm_err->eproc = concat("Verify accounts [",dilu_mng,",",dilu_system,",",
     dilu_priv,"] are not LDAP enabled.")
    SET dm_err->emsg =
    "One or more of these accounts are LDAP enabled, by system default, which is an invalid configuration."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_interrogator_usage(diu_interrogator_ind,diu_interrogator_node)
   DECLARE diu_file_name = vc WITH protect, noconstant("")
   DECLARE diu_src_node = vc WITH protect, noconstant("")
   DECLARE diu_node_cnt = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Get Interrogator server (520) status.")
   CALL disp_msg("",dm_err->logfile,0)
   SET diu_file_name = concat(ddr_domain_data->src_tmp_full_dir,"intrrgtr_srvr_stat.ksh")
   SET diu_interrogator_ind = 0
   SET diu_interrogator_node = ""
   FOR (diu_node_cnt = 1 TO ddr_domain_data->src_nodes_cnt)
     SET diu_src_node = ddr_domain_data->src_nodes[diu_node_cnt].node_name
     IF (dm2_findfile(diu_file_name) > 0)
      IF (dm2_push_dcl(concat("rm ",diu_file_name))=0)
       RETURN(0)
      ENDIF
     ELSE
      IF ((dm_err->err_ind=1))
       RETURN(0)
      ENDIF
     ENDIF
     SET dm_err->eproc = concat("Create file to get server status :",diu_file_name)
     CALL disp_msg("",dm_err->logfile,0)
     SELECT INTO value(diu_file_name)
      FROM (dummyt t  WITH seq = 1)
      DETAIL
       CALL print("#!/usr/bin/ksh"), row + 1,
       CALL print("#"),
       row + 1,
       CALL print("# intrrgtr_srvr_stat.ksh"), row + 1,
       CALL print("#"), row + 1,
       CALL print(concat("src_mng_pwd='",ddr_domain_data->src_mng_pwd,"'")),
       row + 1,
       CALL print(concat("$cer_exe/scpview ",diu_src_node," <<!>",ddr_domain_data->src_tmp_full_dir,
        "intrrgtr_srvr_stat.dat")), row + 1,
       CALL print(ddr_domain_data->src_mng), row + 1,
       CALL print(ddr_domain_data->src_domain_name),
       row + 1,
       CALL print("$src_mng_pwd"), row + 1,
       CALL print("server -entry 520"), row + 1,
       CALL print("exit"),
       row + 1,
       CALL print("!"), row + 1,
       row + 1,
       CALL print(concat("tr '[:upper:]' '[:lower:]' < ",ddr_domain_data->src_tmp_full_dir,
        "intrrgtr_srvr_stat.dat|grep -e '^[0-9]'|grep 'running'")), row + 1,
       row + 1,
       CALL print("if [[ $? -eq 0 ]]"), row + 1,
       CALL print("then"), row + 1,
       CALL print('   echo "Server is running"'),
       row + 1,
       CALL print("fi"), row + 1,
       row + 1
      WITH nocounter, maxcol = 500, format = variable,
       maxrow = 1
     ;end select
     IF (check_error(dm_err->eproc) != 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = concat("Execute ",diu_file_name)
     CALL disp_msg(" ",dm_err->logfile,0)
     IF (dm2_push_dcl(concat("chmod 777 ",diu_file_name))=0)
      RETURN(0)
     ENDIF
     IF (dm2_push_dcl(concat(". ",diu_file_name))=0)
      RETURN(0)
     ELSE
      IF (parse_errfile(dm_err->errfile)=0)
       RETURN(0)
      ENDIF
      IF (findstring("Server is running",dm_err->errtext) > 0)
       SET diu_interrogator_ind = (diu_interrogator_ind+ 1)
       SET diu_interrogator_node = diu_src_node
      ENDIF
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm_err)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_interrogator_backup(dib_mode)
   DECLARE dib_cmd_file_ret = vc WITH protect, noconstant("")
   DECLARE dib_log_str = vc WITH protect, noconstant("")
   DECLARE dib_str = vc WITH protect, noconstant("")
   DECLARE dib_tmp_remote_mode = i2 WITH protect, noconstant(0)
   DECLARE dib_src_intrrgtr_dir_loc = vc WITH protect, noconstant("")
   DECLARE dib_file_name = vc WITH protect, noconstant(concat(ddr_domain_data->src_env,"_dafsolr.sav"
     ))
   DECLARE dib_cmd = vc WITH protect, noconstant("")
   DECLARE dib_no_error = i2 WITH protect, noconstant(0)
   DECLARE dib_file_date = f8 WITH protect, noconstant(0.0)
   DECLARE dib_tmp_dir = vc WITH protect, noconstant("")
   DECLARE dib_kfile_name = vc WITH protect, noconstant("")
   DECLARE dib_cur_node = vc WITH protect, noconstant("")
   DECLARE dib_ccluserdir = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Backup of the Interrogator solution content.")
   CALL disp_msg("",dm_err->logfile,0)
   IF ((ddr_domain_data->src_interrogator_node=trim(curnode)))
    SET dib_tmp_remote_mode = 0
   ELSE
    SET dib_tmp_remote_mode = 1
   ENDIF
   SET dm_err->eproc = concat("Get the Interrogator Data location row from DM_INFO.")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    di.info_char
    FROM dm_info di
    WHERE di.info_domain="ICD9 Interrogator"
     AND di.info_name="SolR Data Location Row"
    DETAIL
     dib_src_intrrgtr_dir_loc = di.info_char
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc))
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Interrogator Data Location Row does not exist in DM_INFO."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dib_tmp_remote_mode=1)
    SET dib_cmd = concat("ssh -o batchmode=yes -o numberofpasswordprompts=0 root@",ddr_domain_data->
     src_interrogator_node,' echo "Source_APP_Node:\`hostname\`"')
    SET dm_err->eproc = concat("Executing: ",dib_cmd)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(dib_cmd)=0
     AND (dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("Output returned from ssh command = ",dm_err->errtext))
    ENDIF
    IF (findstring("SOURCE_APP_NODE:",cnvtupper(dm_err->errtext),1,0) > 0)
     IF (findstring(cnvtupper(ddr_domain_data->src_interrogator_node),cnvtupper(dm_err->errtext),
      findstring("SOURCE_APP_NODE:",cnvtupper(dm_err->errtext),1,0),0)=0)
      SET dm_err->err_ind = 1
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
    ENDIF
    IF ((dm_err->err_ind=1))
     SET dm_err->eproc = concat("Verify SSH setup between Primary Source APP node (",trim(cnvtupper(
        curnode)),") and Remote Source APP node (",cnvtupper(ddr_domain_data->src_interrogator_node),
      ") for the root user.")
     SET dm_err->emsg = concat(
      "SSH command did not return the Remote Source App node.  On the Primary Source App node as ",
      "the root user, verify that the following o/s command returns a 'SOURCE_APP_NODE' value of ",
      ddr_domain_data->src_interrogator_node,": ",dib_cmd)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   WHILE (findstring("{",dib_src_intrrgtr_dir_loc,1,0) > 0)
     SET dib_log_str = substring((findstring("{",dib_src_intrrgtr_dir_loc,1,0)+ 1),((findstring("}",
       dib_src_intrrgtr_dir_loc,1,0) - findstring("{",dib_src_intrrgtr_dir_loc,1,0)) - 1),
      dib_src_intrrgtr_dir_loc)
     SET dib_str = trim(logical(trim(dib_log_str)))
     SET dib_src_intrrgtr_dir_loc = replace(dib_src_intrrgtr_dir_loc,concat("{",trim(dib_log_str),"}"
       ),trim(dib_str),0)
   ENDWHILE
   SET dib_src_intrrgtr_dir_loc = substring(0,(findstring("dafsolr",dib_src_intrrgtr_dir_loc,1,0)+ 7),
    dib_src_intrrgtr_dir_loc)
   IF (dib_tmp_remote_mode=0)
    IF ( NOT (dm2_find_dir(dib_src_intrrgtr_dir_loc)))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("No directory exists with ",dib_src_intrrgtr_dir_loc)
     SET dm_err->emsg = concat("Failed to find ",dib_src_intrrgtr_dir_loc)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     CALL dor_init_flex_cmds(null)
     CALL dor_add_flex_cmd(1," "," "," ",concat("du -sk ",dib_src_intrrgtr_dir_loc,
       " | awk '{print $1}'"),
      " ","EC")
     IF (dor_exec_flex_cmd(null)=0)
      RETURN(0)
     ENDIF
     SET ddr_space_needs->src_interrogator_size = trim(dor_flex_cmd->cmd[1].flex_output)
    ENDIF
   ENDIF
   IF (dib_tmp_remote_mode=1)
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node," ",concat("test -d ",
      dib_src_intrrgtr_dir_loc," ;echo $?"),
     " ","EC")
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ENDIF
    IF ((dor_flex_cmd->cmd[1].flex_output="1"))
     IF ((dm2ftpr->exists_ind=0))
      SET dm_err->eproc = concat("Verify directory (",dib_src_intrrgtr_dir_loc,") exists on node (",
       ddr_domain_data->src_interrogator_node,").")
      SET dm_err->emsg = concat("Interrogator directory (",dib_src_intrrgtr_dir_loc,
       ") not found on remote source APP node (",ddr_domain_data->src_interrogator_node,").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node," ",concat("du -sk ",
      dib_src_intrrgtr_dir_loc),
     " ","EC")
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ENDIF
    SET ddr_space_needs->src_interrogator_size = substring(1,(findstring("/",trim(dor_flex_cmd->cmd[1
       ].flex_output),1,0) - 2),trim(dor_flex_cmd->cmd[1].flex_output))
   ENDIF
   IF (dib_mode="SIZE")
    RETURN(1)
   ENDIF
   IF (dib_tmp_remote_mode=0)
    SET dm_err->eproc = concat("Creating a command file to backup Interrogator directory.")
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (ddr_create_tar_routine(dib_src_intrrgtr_dir_loc,concat(ddr_domain_data->src_tmp_full_dir,
      dib_file_name),dib_cmd_file_ret,"DAFSOLR")=0)
     RETURN(0)
    ENDIF
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(1," "," "," ",concat(". $CCLUSERDIR/",dib_cmd_file_ret),
     " ","EC")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ELSE
     SET dib_no_error = 1
    ENDIF
    IF (findstring("tar: couldn't get",trim(dor_flex_cmd->cmd[1].flex_output),1,0) > 0)
     IF (ddr_add_tar_error(1,0,"DAFSOLR")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dib_str = replace(trim(dor_flex_cmd->cmd[1].flex_output),"tar: couldn't get gname for gid ",
     "",0)
    SET dib_str = cnvtalphanum(replace(dib_str,"tar: couldn't get uname for gid ","",0))
    IF (isnumeric(dib_str)=1)
     SET dib_no_error = 1
    ENDIF
    IF (dib_no_error=0)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,dib_file_name))=0)
     SET dm_err->emsg = concat("Error copying ",dib_file_name,": file does not exist.")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,dib_file_name),dib_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_interrogator_ts = dib_file_date
    SET ddr_domain_data->src_interrogator_fnd = 1
   ENDIF
   IF (dib_tmp_remote_mode=1)
    SET dib_tmp_dir = drrr_rf_data->tgt_interrogator_tmp_dir
    SET dm_err->eproc = concat("Verify directory (",dib_tmp_dir,") exists on node (",ddr_domain_data
     ->src_interrogator_node,").")
    CALL disp_msg("",dm_err->logfile,0)
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node," ",concat("test -d ",
      dib_tmp_dir," ;echo $?"),
     " ","EC")
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ENDIF
    IF ((dor_flex_cmd->cmd[1].flex_output="1"))
     SET dm_err->eproc = concat("Verify directory (",dib_tmp_dir,") exists on node (",ddr_domain_data
      ->src_interrogator_node,").")
     SET dm_err->emsg = concat("Interrogator temporary directory (",dib_tmp_dir,
      ") not found on remote source APP node (",ddr_domain_data->src_interrogator_node,").")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((validate(dm2_bypass_intrrgtr_space_check,- (1))=- (1)))
     CALL echo(concat("Free Space Check String: ",dib_str))
     CALL dor_init_flex_cmds(null)
     CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node," ",concat(
       '"LANG=C df -kP ',dib_tmp_dir,^"|grep -v Filesys|awk '{print \$4}'^),
      " ","EC")
     IF (dor_exec_flex_cmd(null)=0)
      RETURN(0)
     ENDIF
     SET dib_size_str = trim(dor_flex_cmd->cmd[1].flex_output)
     IF (cnvtreal(ddr_space_needs->src_interrogator_size) > cnvtreal(trim(dib_size_str)))
      SET dm_err->eproc = concat("Verify to check if there is enough space on directory ",dib_tmp_dir
       )
      SET dm_err->emsg = concat(dib_tmp_dir," doesnot have enouhgh space on ",ddr_domain_data->
       src_interrogator_node)
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->eproc =
     "User requested bypass of Interrogator temporary directory free space check."
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET dm_err->eproc = concat("Creating a command file to backup Interrogator directory.")
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (ddr_create_tar_routine(dib_src_intrrgtr_dir_loc,concat(dib_tmp_dir,dib_file_name),
     dib_cmd_file_ret,"DAFSOLR")=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Copy command file ",dib_cmd_file_ret," to remote source APP node.")
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dib_ccluserdir = trim(logical("CCLUSERDIR"))
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node,concat(dib_ccluserdir,"/",
      dib_cmd_file_ret)," ",
     concat(dib_tmp_dir,dib_cmd_file_ret),"RCP")
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Execute command file ",dib_cmd_file_ret," on remote source APP node."
     )
    CALL disp_msg(" ",dm_err->logfile,0)
    CALL dor_init_flex_cmds(null)
    CALL dor_add_flex_cmd(0,"root",ddr_domain_data->src_interrogator_node," ",concat(". ",dib_tmp_dir,
      "/",dib_cmd_file_ret),
     " ","EC")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dor_exec_flex_cmd(null)=0)
     RETURN(0)
    ELSE
     SET dib_no_error = 1
    ENDIF
    IF (findstring("tar: couldn't get",trim(dor_flex_cmd->cmd[1].flex_output),1,0) > 0)
     IF (ddr_add_tar_error(1,0,"DAFSOLR")=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dib_str = replace(trim(dor_flex_cmd->cmd[1].flex_output),"tar: couldn't get gname for gid ",
     "",0)
    SET dib_str = cnvtalphanum(replace(dib_str,"tar: couldn't get uname for gid ","",0))
    IF (isnumeric(dib_str)=1)
     SET dib_no_error = 1
    ENDIF
    IF (dib_no_error=0)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Copy ",dib_file_name," file from remote source APP node (",
     ddr_domain_data->src_interrogator_node,").")
    CALL disp_msg("",dm_err->logfile,0)
    SET dm2ftpr->user_name = "root"
    SET dm2ftpr->remote_host = ddr_domain_data->src_interrogator_node
    SET dm2ftpr->options = "-b"
    CALL dfr_add_getops_line(" "," "," "," "," ",
     1)
    CALL dfr_add_getops_line(" ",ddr_domain_data->src_tmp_full_dir,trim(dib_file_name),trim(
      dib_tmp_dir),trim(dib_file_name),
     0)
    IF (dfr_get_file(null)=0)
     RETURN(0)
    ENDIF
    CALL dfr_add_getops_line(" "," "," "," "," ",
     1)
    IF (dm2_findfile(concat(ddr_domain_data->src_tmp_full_dir,dib_file_name))=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Copy ",dib_file_name," file from remote source APP node (",
      ddr_domain_data->src_interrogator_node,").")
     SET dm_err->emsg = concat("Faild to copy ",dib_file_name," file from remote source APP node (",
      ddr_domain_data->src_interrogator_node,") to primary source APP node.")
     RETURN(0)
    ENDIF
    IF (ddr_get_file_date(concat(ddr_domain_data->src_tmp_full_dir,dib_file_name),dib_file_date)=0)
     RETURN(0)
    ENDIF
    SET ddr_domain_data->src_interrogator_ts = dib_file_date
    SET ddr_domain_data->src_interrogator_fnd = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_get_ops_version(dgov_db_link)
  IF ((validate(dm2_bypass_opsexec_maint,- (1))=- (1)))
   IF (ops_get_version(dgov_db_link,ddr_ops_info->version,ddr_ops_info->migration_in_progress,
    ddr_ops_info->error)=0)
    SET dm_err->eproc = "Get Operations version."
    SET dm_err->emsg = ddr_ops_info->error
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF ((ddr_ops_info->migration_in_progress=1))
    SET dm_err->eproc = "Get Operations version."
    SET dm_err->emsg = "Operations migration in progress.  Cannot proceed."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((ddr_ops_info->version > 1.0))
    SET ddr_ops_info->tbl_name = "OPS2_CTRL_GROUP"
    SET ddr_ops_info->col_host = "host_name"
    SET ddr_ops_info->col_group_id = "ops2_ctrl_group_id"
    SET ddr_ops_info->col_group_name = "ctrl_group_name"
    SET ddr_ops_info->col_server_nbr = "server_entry_nbr"
   ELSE
    SET ddr_ops_info->tbl_name = "OPS_CONTROL_GROUP"
    SET ddr_ops_info->col_host = "host"
    SET ddr_ops_info->col_group_id = "ops_control_grp_id"
    SET ddr_ops_info->col_group_name = "name"
    SET ddr_ops_info->col_server_nbr = "server_number"
   ENDIF
   SET dm_err->eproc = concat("Operations [Major] Version: ",cnvtstring(ddr_ops_info->version))
   CALL disp_msg(" ",dm_err->logfile,0)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_file_content_load(dbfcl_src_ind,dbfcl_tgt_ind)
   DECLARE dbfcl_token_prefix = vc WITH protect, noconstant("")
   DECLARE dbfcl_domain = vc WITH protect, noconstant("")
   DECLARE dbfcl_temp_dir = vc WITH protect, noconstant("")
   DECLARE dbfcl_env = vc WITH protect, noconstant("")
   DECLARE dbfcl_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_file_content.csv"))
   DECLARE dbfcl_cust_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_file_content_<env>.csv"))
   DECLARE dbfcl_work_file = vc WITH protect, noconstant("")
   DECLARE dbfcl_file_cnt = i2 WITH protect, noconstant(1)
   DECLARE dbfcl_cntr = i2 WITH protect, noconstant(0)
   DECLARE dbfcl_fatal_err_ind = i2 WITH protect, noconstant(0)
   DECLARE dbfcl_fatal_str = vc WITH protect, noconstant("")
   DECLARE dbfcl_str = vc WITH protect, noconstant("")
   DECLARE dbfcl_token = vc WITH protect, noconstant("")
   DECLARE dbfcl_mode = vc WITH protect, noconstant("")
   DECLARE dbfcl_fdir = vc WITH protect, noconstant("")
   DECLARE dbfcl_fvalue = vc WITH protect, noconstant("")
   DECLARE dbfcl_dest_dir = vc WITH protect, noconstant("")
   DECLARE dbfcl_dest_fname = vc WITH protect, noconstant("")
   DECLARE dbfcl_options = vc WITH protect, noconstant("")
   DECLARE dbfcl_req_ind = vc WITH protect, noconstant("")
   DECLARE dbfcl_active_ind = vc WITH protect, noconstant("")
   DECLARE dbfcl_idx = i4 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   IF (((dbfcl_src_ind=0
    AND dbfcl_tgt_ind=0) OR (dbfcl_src_ind=1
    AND dbfcl_tgt_ind=1)) )
    SET dm_err->eproc = "Validating input indicators."
    SET dm_err->emsg =
    "Invalid input combination.  Need to specifiy either source or target indicator and not both."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dbfcl_src_ind=1)
    SET dbfcl_token_prefix = "SRC"
    SET dbfcl_domain = ddr_domain_data->src_domain_name
    SET dbfcl_temp_dir = ddr_domain_data->src_tmp_full_dir
    SET dbfcl_env = ddr_domain_data->src_env
   ELSE
    SET dbfcl_token_prefix = "TGT"
    SET dbfcl_domain = ddr_domain_data->tgt_domain_name
    SET dbfcl_temp_dir = ddr_domain_data->tgt_tmp_full_dir
    SET dbfcl_env = ddr_domain_data->tgt_env
   ENDIF
   IF (substring(size(dbfcl_temp_dir),1,dbfcl_temp_dir)="/")
    SET dbfcl_temp_dir = trim(replace(dbfcl_temp_dir,"/","",2),3)
   ENDIF
   SET dbfcl_cust_file = replace(dbfcl_cust_file,"<env>",dbfcl_env,0)
   IF (dm2_findfile(dbfcl_cust_file) > 0)
    SET dbfcl_file_cnt = (dbfcl_file_cnt+ 1)
   ENDIF
   FOR (dbfcl_cntr = 1 TO dbfcl_file_cnt)
     IF (dbfcl_cntr=1)
      SET dbfcl_work_file = dbfcl_file
     ELSE
      SET dbfcl_work_file = dbfcl_cust_file
     ENDIF
     SET dm_err->eproc = concat("Open ",dbfcl_work_file," and load backend file content.")
     CALL disp_msg("",dm_err->logfile,0)
     FREE SET dbfcl_data_file
     SET logical dbfcl_data_file dbfcl_work_file
     FREE DEFINE rtl3
     DEFINE rtl3 "dbfcl_data_file"
     SELECT INTO "nl:"
      t.line
      FROM rtl3t t
      WHERE t.line > " "
      DETAIL
       IF (dbfcl_fatal_err_ind=0)
        dbfcl_str = trim(t.line,3)
        IF ((dm_err->debug_flag > 4))
         CALL echo(concat("line = ",dbfcl_str))
        ENDIF
        IF (substring(1,3,dbfcl_str)=dbfcl_token_prefix)
         dbfcl_str = replace(dbfcl_str,"<<domain>>",dbfcl_domain,0), dbfcl_str = replace(dbfcl_str,
          "<<temp_full_dir>>",dbfcl_temp_dir,0), dbfcl_str = replace(dbfcl_str,"<<node>>",trim(
           cnvtlower(curnode),3),0),
         dbfcl_str = replace(dbfcl_str,"<<env>>",dbfcl_env,0)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("line_w_tokens_replaced = ",dbfcl_str))
         ENDIF
         dbfcl_token = trim(piece(dbfcl_str,",",1,"Not Found"),3), dbfcl_mode = trim(piece(dbfcl_str,
           ",",2,"Not Found"),3), dbfcl_fdir = trim(piece(dbfcl_str,",",3,"Not Found"),3),
         dbfcl_fvalue = trim(piece(dbfcl_str,",",4,"Not Found"),3), dbfcl_dest_dir = trim(piece(
           dbfcl_str,",",5,"Not Found"),3), dbfcl_dest_fname = trim(piece(dbfcl_str,",",6,"Not Found"
           ),3),
         dbfcl_options = trim(piece(dbfcl_str,",",7,"Not Found"),3), dbfcl_req_ind = trim(piece(
           dbfcl_str,",",8,"Not Found"),3), dbfcl_active_ind = trim(piece(dbfcl_str,",",9,"Not Found"
           ),3)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("token = ",dbfcl_token)),
          CALL echo(concat("mode = ",dbfcl_mode)),
          CALL echo(concat("fdir = ",dbfcl_fdir)),
          CALL echo(concat("fvalue = ",dbfcl_fvalue)),
          CALL echo(concat("dest_dir = ",dbfcl_dest_dir)),
          CALL echo(concat("dest_fname = ",dbfcl_dest_fname)),
          CALL echo(concat("options = ",dbfcl_options)),
          CALL echo(concat("req_ind = ",dbfcl_req_ind)),
          CALL echo(concat("active_ind = ",dbfcl_active_ind))
         ENDIF
         dbfcl_idx = 0
         IF (dbfcl_mode IN ("COPY", "TAR", "FINDCOPY")
          AND dbfcl_fdir != "Not Found"
          AND textlen(dbfcl_fdir) > 0
          AND findstring(" ",dbfcl_fdir,1)=0
          AND dbfcl_fvalue != "Not Found"
          AND textlen(dbfcl_fvalue) > 0
          AND ((dbfcl_mode="COPY"
          AND findstring(" ",dbfcl_fvalue,1)=0) OR (((dbfcl_mode="FINDCOPY"
          AND substring(1,5,dbfcl_fvalue)="find "
          AND findstring(dbfcl_fdir,dbfcl_fvalue,1,0) > 0) OR (dbfcl_mode="TAR"
          AND size(dbfcl_fvalue)=findstring("/",dbfcl_fvalue,0,0)
          AND findstring(" ",dbfcl_fvalue,1)=0)) ))
          AND dbfcl_dest_dir != "Not Found"
          AND textlen(dbfcl_dest_dir) > 0
          AND findstring(" ",dbfcl_dest_dir,1)=0
          AND ((dbfcl_mode IN ("COPY", "TAR")
          AND substring(1,size(dbfcl_temp_dir),dbfcl_dest_dir)=dbfcl_temp_dir) OR (dbfcl_mode=
         "FINDCOPY"
          AND substring(1,(size(dbfcl_temp_dir)+ 1),dbfcl_dest_dir)=build(dbfcl_temp_dir,"/")
          AND (size(dbfcl_dest_dir) > (size(dbfcl_temp_dir)+ 2))))
          AND dbfcl_dest_fname != "Not Found"
          AND textlen(dbfcl_dest_fname) > 0
          AND ((dbfcl_mode IN ("COPY", "TAR")
          AND findstring(" ",dbfcl_dest_fname,1)=0) OR (dbfcl_mode="FINDCOPY"
          AND findstring("$f",dbfcl_dest_fname,1) > 0))
          AND ((substring(1,1,dbfcl_options)="-") OR (dbfcl_options="none"))
          AND findstring(" ",dbfcl_options,1)=0
          AND dbfcl_req_ind IN ("0", "1")
          AND dbfcl_active_ind IN ("0", "1")
          AND ((dbfcl_token_prefix="SRC"
          AND dbfcl_mode="FINDCOPY"
          AND (((ddr_backup_file_content->src_backup_list_cnt > 0)
          AND locateval(dbfcl_idx,1,ddr_backup_file_content->src_backup_list_cnt,dbfcl_dest_dir,
          ddr_backup_file_content->src_backup_list[dbfcl_idx].dest_dir)=0) OR ((
         ddr_backup_file_content->src_backup_list_cnt=0))) ) OR (((dbfcl_token_prefix="TGT"
          AND dbfcl_mode="FINDCOPY"
          AND (((ddr_backup_file_content->tgt_backup_list_cnt > 0)
          AND locateval(dbfcl_idx,1,ddr_backup_file_content->tgt_backup_list_cnt,dbfcl_dest_dir,
          ddr_backup_file_content->tgt_backup_list[dbfcl_idx].dest_dir)=0) OR ((
         ddr_backup_file_content->tgt_backup_list_cnt=0))) ) OR (((dbfcl_token_prefix="SRC"
          AND dbfcl_mode != "FINDCOPY"
          AND (((ddr_backup_file_content->src_backup_list_cnt > 0)
          AND locateval(dbfcl_idx,1,ddr_backup_file_content->src_backup_list_cnt,dbfcl_dest_fname,
          ddr_backup_file_content->src_backup_list[dbfcl_idx].dest_fname)=0) OR ((
         ddr_backup_file_content->src_backup_list_cnt=0))) ) OR (dbfcl_token_prefix="TGT"
          AND dbfcl_mode != "FINDCOPY"
          AND (((ddr_backup_file_content->tgt_backup_list_cnt > 0)
          AND locateval(dbfcl_idx,1,ddr_backup_file_content->tgt_backup_list_cnt,dbfcl_dest_fname,
          ddr_backup_file_content->tgt_backup_list[dbfcl_idx].dest_fname)=0) OR ((
         ddr_backup_file_content->tgt_backup_list_cnt=0))) )) )) )) )
          IF (dbfcl_token_prefix="SRC"
           AND dbfcl_active_ind="1")
           ddr_backup_file_content->src_backup_list_cnt = (ddr_backup_file_content->
           src_backup_list_cnt+ 1), stat = alterlist(ddr_backup_file_content->src_backup_list,
            ddr_backup_file_content->src_backup_list_cnt), ddr_backup_file_content->src_backup_list[
           ddr_backup_file_content->src_backup_list_cnt].token = dbfcl_token,
           ddr_backup_file_content->src_backup_list[ddr_backup_file_content->src_backup_list_cnt].
           mode = dbfcl_mode, ddr_backup_file_content->src_backup_list[ddr_backup_file_content->
           src_backup_list_cnt].fdir = dbfcl_fdir, ddr_backup_file_content->src_backup_list[
           ddr_backup_file_content->src_backup_list_cnt].fvalue = dbfcl_fvalue,
           ddr_backup_file_content->src_backup_list[ddr_backup_file_content->src_backup_list_cnt].
           dest_dir = dbfcl_dest_dir, ddr_backup_file_content->src_backup_list[
           ddr_backup_file_content->src_backup_list_cnt].dest_fname = dbfcl_dest_fname,
           ddr_backup_file_content->src_backup_list[ddr_backup_file_content->src_backup_list_cnt].
           options = dbfcl_options,
           ddr_backup_file_content->src_backup_list[ddr_backup_file_content->src_backup_list_cnt].
           req_ind = cnvtint(dbfcl_req_ind)
          ELSEIF (dbfcl_token_prefix="TGT"
           AND dbfcl_active_ind="1")
           ddr_backup_file_content->tgt_backup_list_cnt = (ddr_backup_file_content->
           tgt_backup_list_cnt+ 1), stat = alterlist(ddr_backup_file_content->tgt_backup_list,
            ddr_backup_file_content->tgt_backup_list_cnt), ddr_backup_file_content->tgt_backup_list[
           ddr_backup_file_content->tgt_backup_list_cnt].token = dbfcl_token,
           ddr_backup_file_content->tgt_backup_list[ddr_backup_file_content->tgt_backup_list_cnt].
           mode = dbfcl_mode, ddr_backup_file_content->tgt_backup_list[ddr_backup_file_content->
           tgt_backup_list_cnt].fdir = dbfcl_fdir, ddr_backup_file_content->tgt_backup_list[
           ddr_backup_file_content->tgt_backup_list_cnt].fvalue = dbfcl_fvalue,
           ddr_backup_file_content->tgt_backup_list[ddr_backup_file_content->tgt_backup_list_cnt].
           dest_dir = dbfcl_dest_dir, ddr_backup_file_content->tgt_backup_list[
           ddr_backup_file_content->tgt_backup_list_cnt].dest_fname = dbfcl_dest_fname,
           ddr_backup_file_content->tgt_backup_list[ddr_backup_file_content->tgt_backup_list_cnt].
           options = dbfcl_options,
           ddr_backup_file_content->tgt_backup_list[ddr_backup_file_content->tgt_backup_list_cnt].
           req_ind = cnvtint(dbfcl_req_ind)
          ENDIF
         ELSE
          dbfcl_fatal_str = trim(dbfcl_str), dbfcl_fatal_err_ind = 1
         ENDIF
        ENDIF
       ENDIF
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      RETURN(0)
     ENDIF
     IF (dbfcl_fatal_err_ind=1)
      SET dm_err->emsg = concat("One or more fields for record in csv is invalid (",trim(
        dbfcl_fatal_str),").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 4))
    CALL echorecord(ddr_backup_file_content)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_file_content(dbfc_mode,dbfc_fdir,dbfc_fvalue,dbfc_dest_dir,dbfc_dest_fname,
  dbfc_options,dbfc_req_ind)
   DECLARE dbfc_dir_found_ind = i2 WITH protect, noconstant(0)
   DECLARE dbfc_cmd = vc WITH protect, noconstant(" ")
   DECLARE dbfc_bckup_file = vc WITH protect, noconstant("dm2_bkup_file")
   DECLARE dbfc_str = vc WITH protect, noconstant("")
   DECLARE dbfc_no_error = i2 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   SET dm_err->eproc = concat("Backup file where mode is (",dbfc_mode,"), directory is (",dbfc_fdir,
    ") and filename is (",
    dbfc_fvalue,").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dm_err->eproc = concat("Validating existence of destination directory (",build(dbfc_dest_dir),
    ").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dbfc_dir_found_ind = 0
   SET dbfc_dir_found_ind = dm2_find_dir(dbfc_dest_dir)
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF (dbfc_dir_found_ind=0)
    SET dm_err->eproc = concat("Creating destination directory (",build(dbfc_dest_dir),
     ") and opening permissions.")
    CALL disp_msg("",dm_err->logfile,0)
    SET dbfc_cmd = concat("mkdir -p ",dbfc_dest_dir)
    IF (dm2_push_dcl(dbfc_cmd)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dbfc_cmd = concat("chmod 777 ",dbfc_dest_dir)
   IF (dm2_push_dcl(dbfc_cmd)=0)
    RETURN(0)
   ENDIF
   IF (dbfc_mode IN ("COPY", "TAR"))
    SET dm_err->eproc = concat("Verifying existence of destination file ",build(dbfc_dest_dir,"/",
      dbfc_dest_fname),".")
    CALL disp_msg("",dm_err->logfile,0)
    IF (dm2_findfile(build(dbfc_dest_dir,"/",dbfc_dest_fname)) > 0)
     IF (dm2_push_dcl(concat("rm ",build(dbfc_dest_dir,"/",dbfc_dest_fname)))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Verifying existence of destination file(s) in ",build(dbfc_dest_dir),
     ".")
    CALL disp_msg("",dm_err->logfile,0)
    SET dbfc_cmd = concat("find ",build(dbfc_dest_dir)," -type f -print|wc -l")
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(dbfc_cmd)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (trim(dm_err->errtext,3) != "0")
     IF (dm2_push_dcl(concat("find ",build(dbfc_dest_dir)," -type f -exec rm {} \;"))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Verify input backup directory (",dbfc_fdir,").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dbfc_dir_found_ind = 0
   SET dbfc_dir_found_ind = dm2_find_dir(dbfc_fdir)
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF (dbfc_dir_found_ind=0)
    IF (dbfc_req_ind=1)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating directory for backup : ",dbfc_fdir)
     SET dm_err->emsg = concat("Directory (",dbfc_fdir,") not found.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET dm_err->eproc = concat("Backup directory (",dbfc_fdir,
      ") not found and backup of content not required.")
     CALL disp_msg(" ",dm_err->logfile,0)
     RETURN(1)
    ENDIF
   ENDIF
   IF (dbfc_mode="TAR")
    SET dm_err->eproc = concat("Validating directory for ",dbfc_mode," backup : ",build(dbfc_fdir,"/",
      dbfc_fvalue))
    CALL disp_msg("",dm_err->logfile,0)
    SET dbfc_dir_found_ind = 0
    SET dbfc_dir_found_ind = dm2_find_dir(build(dbfc_fdir,"/",dbfc_fvalue))
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
    IF (dbfc_dir_found_ind=0)
     IF (dbfc_req_ind=1)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating directory/filename for ",dbfc_mode," backup : ",build(
        dbfc_fdir,"/",dbfc_fvalue))
      SET dm_err->emsg = concat("Directory/filename (",build(dbfc_fdir,"/",dbfc_fvalue),
       ") not found.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET dm_err->eproc = concat("Backup directory/filename for ",dbfc_mode," backup (",build(
        dbfc_fdir,"/",dbfc_fvalue),") not found and backup of content not required.")
      CALL disp_msg(" ",dm_err->logfile,0)
      RETURN(1)
     ENDIF
    ENDIF
   ENDIF
   IF (dbfc_mode="COPY")
    SET dm_err->eproc = concat("Validating file for ",dbfc_mode," backup (",build(dbfc_fdir,"/",
      dbfc_fvalue),").")
    CALL disp_msg("",dm_err->logfile,0)
    IF (dm2_findfile(build(dbfc_fdir,"/",dbfc_fvalue))=0)
     IF (dbfc_req_ind=1)
      SET dm_err->eproc = concat("Validating file for ",dbfc_mode," backup : ",build(dbfc_fdir,"/",
        dbfc_fvalue))
      SET dm_err->emsg = concat("File (",build(dbfc_fdir,"/",dbfc_fvalue),") not found.")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET dm_err->eproc = concat("Backup file for ",dbfc_mode," backup (",build(dbfc_fdir,"/",
        dbfc_fvalue),") not found and backup of content not required.")
      CALL disp_msg(" ",dm_err->logfile,0)
      RETURN(1)
     ENDIF
    ENDIF
   ELSE
    IF (dbfc_mode="FINDCOPY")
     SET dm_err->eproc = concat("Validating backup files for ",dbfc_mode,": ",build(dbfc_fvalue))
     SET dbfc_cmd = concat(dbfc_fvalue,"|wc -l")
    ELSE
     SET dm_err->eproc = concat("Validating backup files for ",dbfc_mode,": ",build(dbfc_fdir,"/",
       dbfc_fvalue))
     SET dbfc_cmd = concat("find ",build(dbfc_fdir,"/",replace(dbfc_fvalue,"/","")),
      " -type f -o -type d -print|wc -l")
    ENDIF
    CALL disp_msg("",dm_err->logfile,0)
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(dbfc_cmd)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (trim(dm_err->errtext,3)="0")
     IF (dbfc_req_ind=1)
      SET dm_err->eproc = concat("Validating backup files for ",dbfc_mode,": ",evaluate(dbfc_mode,
        "FINDCOPY",build(dbfc_fvalue),build(dbfc_fdir,"/",dbfc_fvalue)))
      SET dm_err->emsg = concat("Expected files to backup not found in ",evaluate(dbfc_mode,
        "FINDCOPY",build(dbfc_fvalue),build(dbfc_fdir,"/",dbfc_fvalue)),".")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET dm_err->eproc = concat("Expected files for ",dbfc_mode," to backup not found in ",evaluate(
        dbfc_mode,"FINDCOPY",build(dbfc_fvalue),build(dbfc_fdir,"/",dbfc_fvalue)),
       " and backup of content not required.")
      CALL disp_msg(" ",dm_err->logfile,0)
      RETURN(1)
     ENDIF
    ENDIF
   ENDIF
   IF (dbfc_mode="COPY")
    SET dm_err->eproc = concat("Complete backup of ",build(dbfc_fdir,"/",dbfc_fvalue)," to ",build(
      dbfc_dest_dir,"/",dbfc_dest_fname),".")
    CALL disp_msg("",dm_err->logfile,0)
    SET dbfc_cmd = concat("\cp -f ",trim(evaluate(dbfc_options,"none","",dbfc_options),3)," ",build(
      dbfc_fdir,"/",dbfc_fvalue)," ",
     build(dbfc_dest_dir,"/",dbfc_dest_fname))
    IF (dm2_push_dcl(dbfc_cmd)=0)
     RETURN(0)
    ENDIF
    IF (dm2_findfile(build(dbfc_dest_dir,"/",dbfc_dest_fname))=0)
     SET dm_err->eproc = concat("Validating backup file for COPY: ",build(dbfc_dest_dir,"/",
       dbfc_dest_fname))
     SET dm_err->emsg = concat("File (",build(dbfc_dest_dir,"/",dbfc_dest_fname),") not found.")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSEIF (dbfc_mode IN ("FINDCOPY", "TAR"))
    IF (get_unique_file(dbfc_bckup_file,".ksh")=0)
     RETURN(0)
    ENDIF
    SET dbfc_bckup_file = dm_err->unique_fname
    SET dm_err->eproc = concat("Create file for copy file operation: ",dbfc_bckup_file)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SELECT INTO value(dbfc_bckup_file)
     DETAIL
      IF (dbfc_mode="FINDCOPY")
       CALL print("#!/bin/ksh"), row + 1,
       CALL print("#"),
       row + 1,
       CALL print(concat("for f in `",dbfc_fvalue,"`")), row + 1,
       CALL print("do"), row + 1,
       CALL print(concat("  filename=`",dbfc_dest_fname,"`")),
       row + 1,
       CALL print(concat("\cp ",trim(evaluate(dbfc_options,"none","",dbfc_options),3)," $f ",build(
         dbfc_dest_dir,"/$filename"))), row + 1,
       CALL print("done"), row + 1
      ELSE
       CALL print(concat("cd ",dbfc_fdir)), row + 1,
       CALL print(concat("tar ",trim(evaluate(dbfc_options,"none","",dbfc_options),3)," ",build(
         dbfc_dest_dir,"/",dbfc_dest_fname)," ",
        dbfc_fvalue)),
       row + 1
      ENDIF
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dbfc_mode="FINDCOPY")
     SET dm_err->eproc = concat('Complete backup of files from "',build(dbfc_fvalue),'" in ',
      dbfc_fdir," directory to ",
      build(dbfc_dest_dir)," based on find command.")
     CALL disp_msg("",dm_err->logfile,0)
     SET dbfc_cmd = concat("chmod 777 ",build(dm2_install_schema->ccluserdir,dbfc_bckup_file))
     IF (dm2_push_dcl(dbfc_cmd)=0)
      RETURN(0)
     ENDIF
     SET dbfc_cmd = concat(". ",build(dm2_install_schema->ccluserdir,dbfc_bckup_file))
     IF (dm2_push_dcl(dbfc_cmd)=0)
      RETURN(0)
     ENDIF
     SET dbfc_cmd = concat("find ",build(dbfc_dest_dir)," -type f -print|wc -l")
     SET dm_err->disp_dcl_err_ind = 0
     IF (dm2_push_dcl(dbfc_cmd)=0)
      IF ((dm_err->err_ind=1))
       RETURN(0)
      ENDIF
     ENDIF
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF (trim(dm_err->errtext,3)="0")
      SET dm_err->eproc = concat("Validating backup file for FINDCOPY: ",build(dbfc_dest_dir))
      SET dm_err->emsg = concat("Expected files not copied to ",build(dbfc_dest_dir),".")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->eproc = concat("Complete tar backup of ",build(dbfc_fdir,"/",dbfc_fvalue)," to ",
      build(dbfc_dest_dir,"/",dbfc_dest_fname),".")
     CALL disp_msg("",dm_err->logfile,0)
     SET dbfc_cmd = concat(". ",build(dm2_install_schema->ccluserdir,dbfc_bckup_file))
     SET dm_err->disp_dcl_err_ind = 0
     SET dbfc_no_error = dm2_push_dcl(dbfc_cmd)
     IF (dbfc_no_error=0)
      IF ((dm_err->err_ind=1))
       RETURN(0)
      ENDIF
     ELSE
      IF (parse_errfile(dm_err->errfile)=0)
       RETURN(0)
      ENDIF
      IF ((dm_err->debug_flag > 0))
       CALL echorecord(dm_err)
      ENDIF
     ENDIF
     SET dbfc_str = replace(dm_err->errtext,"tar: couldn't get gname for gid ","",0)
     SET dbfc_str = cnvtalphanum(replace(dbfc_str,"tar: couldn't get uname for uid ","",0))
     IF (isnumeric(dbfc_str)=1)
      SET dbfc_no_error = 1
     ENDIF
     IF (dbfc_no_error=0)
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (dm2_findfile(build(dbfc_dest_dir,"/",dbfc_dest_fname))=0)
      SET dm_err->emsg = concat("Error copying ",dbfc_fvalue,".  Backup file ",build(dbfc_dest_dir,
        "/",dbfc_dest_fname)," does not exist.")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_reg_content_load(null)
   DECLARE dbrcl_token_prefix = vc WITH protect, noconstant("")
   DECLARE dbrcl_domain = vc WITH protect, noconstant("")
   DECLARE dbrcl_temp_dir = vc WITH protect, noconstant("")
   DECLARE dbrcl_env = vc WITH protect, noconstant("")
   DECLARE dbrcl_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_reg_content.csv"))
   DECLARE dbrcl_cust_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_reg_content_<env>.csv"))
   DECLARE dbrcl_work_file = vc WITH protect, noconstant("")
   DECLARE dbrcl_file_cnt = i2 WITH protect, noconstant(1)
   DECLARE dbrcl_cntr = i2 WITH protect, noconstant(0)
   DECLARE dbrcl_str = vc WITH protect, noconstant("")
   DECLARE dbrcl_orig_str = vc WITH protect, noconstant("")
   DECLARE dbrcl_token = vc WITH protect, noconstant("")
   DECLARE dbrcl_mode = vc WITH protect, noconstant("")
   DECLARE dbrcl_key = vc WITH protect, noconstant("")
   DECLARE dbrcl_orig_key = vc WITH protect, noconstant("")
   DECLARE dbrcl_prop = vc WITH protect, noconstant("")
   DECLARE dbrcl_orig_prop = vc WITH protect, noconstant("")
   DECLARE dbrcl_dest_dir = vc WITH protect, noconstant("")
   DECLARE dbrcl_dest_fname = vc WITH protect, noconstant("")
   DECLARE dbrcl_orig_dest_fname = vc WITH protect, noconstant("")
   DECLARE dbrcl_cre_key_ind = vc WITH protect, noconstant("")
   DECLARE dbrcl_req_ind = vc WITH protect, noconstant("")
   DECLARE dbrcl_active_ind = vc WITH protect, noconstant("")
   DECLARE dbrcl_fatal_err_ind = i2 WITH protect, noconstant(0)
   DECLARE dbrcl_fatal_str = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   SET dbrcl_token_prefix = "TGT"
   SET dbrcl_domain = ddr_domain_data->tgt_domain_name
   SET dbrcl_temp_dir = ddr_domain_data->tgt_tmp_full_dir
   SET dbrcl_env = ddr_domain_data->tgt_env
   IF (substring(size(dbrcl_temp_dir),1,dbrcl_temp_dir)="/")
    SET dbrcl_temp_dir = trim(replace(dbrcl_temp_dir,"/","",2),3)
   ENDIF
   SET dbrcl_cust_file = replace(dbrcl_cust_file,"<env>",dbrcl_env,0)
   IF (dm2_findfile(dbrcl_cust_file) > 0)
    SET dbrcl_file_cnt = (dbrcl_file_cnt+ 1)
   ENDIF
   FOR (dbrcl_cntr = 1 TO dbrcl_file_cnt)
     IF (dbrcl_cntr=1)
      SET dbrcl_work_file = dbrcl_file
     ELSE
      SET dbrcl_work_file = dbrcl_cust_file
     ENDIF
     SET dm_err->eproc = concat("Open ",dbrcl_work_file," and load backend file content.")
     CALL disp_msg("",dm_err->logfile,0)
     FREE SET dbrcl_data_file
     SET logical dbrcl_data_file dbrcl_work_file
     FREE DEFINE rtl3
     DEFINE rtl3 "dbrcl_data_file"
     SELECT INTO "nl:"
      t.line
      FROM rtl3t t
      WHERE t.line > " "
      DETAIL
       IF (dbrcl_fatal_err_ind=0)
        dbrcl_str = trim(t.line,3), dbrcl_orig_str = dbrcl_str
        IF ((dm_err->debug_flag > 4))
         CALL echo(concat("line = ",dbrcl_str))
        ENDIF
        IF (substring(1,3,dbrcl_str)=dbrcl_token_prefix)
         dbrcl_str = replace(dbrcl_str,"<<domain>>",dbrcl_domain,0), dbrcl_str = replace(dbrcl_str,
          "<<temp_full_dir>>",dbrcl_temp_dir,0), dbrcl_str = replace(dbrcl_str,"<<node>>",trim(
           cnvtlower(curnode),3),0),
         dbrcl_str = replace(dbrcl_str,"<<env>>",dbrcl_env,0)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("line_w_tokens_replaced = ",dbrcl_str))
         ENDIF
         dbrcl_token = trim(piece(dbrcl_str,",",1,"Not Found"),3), dbrcl_mode = trim(piece(dbrcl_str,
           ",",2,"Not Found"),3), dbrcl_key = trim(piece(dbrcl_str,",",3,"Not Found"),3),
         dbrcl_prop = trim(piece(dbrcl_str,",",4,"Not Found"),3), dbrcl_dest_dir = trim(piece(
           dbrcl_str,",",5,"Not Found"),3), dbrcl_orig_dest_fname = trim(piece(dbrcl_orig_str,",",6,
           "Not Found"),3),
         dbrcl_dest_fname = trim(piece(dbrcl_str,",",6,"Not Found"),3), dbrcl_req_ind = trim(piece(
           dbrcl_str,",",7,"Not Found"),3), dbrcl_cre_key_ind = trim(piece(dbrcl_str,",",8,
           "Not Found"),3),
         dbrcl_active_ind = trim(piece(dbrcl_str,",",9,"Not Found"),3)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("token = ",dbrcl_token)),
          CALL echo(concat("mode = ",dbrcl_mode)),
          CALL echo(concat("key = ",dbrcl_key)),
          CALL echo(concat("prop = ",dbrcl_prop)),
          CALL echo(concat("dest_dir = ",dbrcl_dest_dir)),
          CALL echo(concat("dest_fname = ",dbrcl_dest_fname)),
          CALL echo(concat("req_ind = ",dbrcl_req_ind)),
          CALL echo(concat("cre_key_ind = ",dbrcl_cre_key_ind)),
          CALL echo(concat("active_ind = ",dbrcl_active_ind))
         ENDIF
         IF (dbrcl_mode="GET"
          AND dbrcl_key != "Not Found"
          AND textlen(dbrcl_key) > 0
          AND dbrcl_prop != "Not Found"
          AND textlen(dbrcl_prop) > 0
          AND dbrcl_dest_dir != "Not Found"
          AND textlen(dbrcl_dest_dir) > 0
          AND findstring(" ",dbrcl_dest_dir,1)=0
          AND substring(1,size(dbrcl_temp_dir),dbrcl_dest_dir)=dbrcl_temp_dir
          AND dbrcl_dest_fname != "Not Found"
          AND textlen(dbrcl_dest_fname) > 0
          AND findstring(" ",dbrcl_dest_fname,1)=0
          AND dbrcl_orig_dest_fname != "Not Found"
          AND textlen(dbrcl_orig_dest_fname) > 0
          AND findstring(" ",dbrcl_orig_dest_fname,1)=0
          AND findstring("<<",dbrcl_orig_dest_fname,1)=0
          AND findstring(">>",dbrcl_orig_dest_fname,1)=0
          AND dbrcl_req_ind IN ("0", "1")
          AND dbrcl_cre_key_ind IN ("0", "1")
          AND dbrcl_active_ind IN ("0", "1"))
          IF (dbrcl_token_prefix="TGT"
           AND dbrcl_active_ind="1")
           ddr_backup_reg_content->tgt_backup_list_cnt = (ddr_backup_reg_content->tgt_backup_list_cnt
           + 1), stat = alterlist(ddr_backup_reg_content->tgt_backup_list,ddr_backup_reg_content->
            tgt_backup_list_cnt), ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content->
           tgt_backup_list_cnt].token = dbrcl_token,
           ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content->tgt_backup_list_cnt].mode
            = dbrcl_mode, ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content->
           tgt_backup_list_cnt].key = dbrcl_key, ddr_backup_reg_content->tgt_backup_list[
           ddr_backup_reg_content->tgt_backup_list_cnt].prop = dbrcl_prop,
           ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content->tgt_backup_list_cnt].
           dest_dir = dbrcl_dest_dir, ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content
           ->tgt_backup_list_cnt].dest_fname = dbrcl_dest_fname, ddr_backup_reg_content->
           tgt_backup_list[ddr_backup_reg_content->tgt_backup_list_cnt].cre_key_ind = cnvtint(
            dbrcl_cre_key_ind),
           ddr_backup_reg_content->tgt_backup_list[ddr_backup_reg_content->tgt_backup_list_cnt].
           req_ind = cnvtint(dbrcl_req_ind)
          ENDIF
         ELSE
          dbrcl_fatal_str = trim(dbrcl_str), dbrcl_fatal_err_ind = 1
         ENDIF
        ENDIF
       ENDIF
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      RETURN(0)
     ENDIF
     IF (dbrcl_fatal_err_ind=1)
      SET dm_err->emsg = concat("One or more fields for record in csv is invalid (",trim(
        dbrcl_fatal_str),").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 4))
    CALL echorecord(ddr_backup_reg_content)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_reg_content(dbrc_mode,dbrc_key,dbrc_prop,dbrc_dest_dir,dbrc_dest_fname,
  dbrc_req_ind,dbrc_cre_key_ind)
   DECLARE dbrc_dir_found_ind = i2 WITH protect, noconstant(0)
   DECLARE dbrc_cmd = vc WITH protect, noconstant(" ")
   DECLARE dbrc_ret = vc WITH protect, noconstant("")
   DECLARE dbrc_bckup_file = vc WITH protect, noconstant(" ")
   DECLARE dbrc_reg_file = vc WITH protect, noconstant("dm2_get_reg_prop")
   DECLARE dbrc_no_error = i2 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   SET dm_err->eproc = concat("Backup registry content where mode is (",dbrc_mode,"), key is (",
    dbrc_key,") and prop is (",
    dbrc_prop,").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dbrc_dir_found_ind = 0
   SET dbrc_dir_found_ind = dm2_find_dir(dbrc_dest_dir)
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF (dbrc_dir_found_ind=0)
    SET dm_err->eproc = concat("Creating destination directory (",build(dbrc_dest_dir),
     ") and opening permissions.")
    CALL disp_msg("",dm_err->logfile,0)
    SET dbrc_cmd = concat("mkdir -p ",dbrc_dest_dir)
    IF (dm2_push_dcl(dbrc_cmd)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dbrc_cmd = concat("chmod 777 ",dbrc_dest_dir)
   IF (dm2_push_dcl(dbrc_cmd)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Verifying existence of destination file ",build(dbrc_dest_dir,"/",
     dbrc_dest_fname),".")
   CALL disp_msg("",dm_err->logfile,0)
   IF (dm2_findfile(build(dbrc_dest_dir,"/",dbrc_dest_fname)) > 0)
    IF (dm2_push_dcl(concat("rm ",build(dbrc_dest_dir,"/",dbrc_dest_fname)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Check for ",trim(dbrc_key)," key and ",trim(dbrc_prop)," property.")
   CALL disp_msg("",dm_err->logfile,0)
   IF (get_unique_file(dbrc_reg_file,".ksh")=0)
    RETURN(0)
   ENDIF
   SET dbrc_reg_file = dm_err->unique_fname
   SET dm_err->eproc = concat("Create file get registry value: ",dbrc_reg_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dbrc_reg_file)
    DETAIL
     CALL print(concat("$cer_exe/lreg -getp ",trim(dbrc_key)," ",trim(dbrc_prop))), row + 1
    WITH nocounter, maxcol = 2000, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dgfd_cmd = concat(". $CCLUSERDIR/",dbrc_reg_file)
   SET dm_err->disp_dcl_err_ind = 0
   SET dbrc_no_error = dm2_push_dcl(dgfd_cmd)
   IF (dbrc_no_error=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dm_err)
    ENDIF
   ENDIF
   IF (((findstring("unable",dm_err->errtext,1,1)) OR (((findstring("key not found",dm_err->errtext,1,
    1)) OR (findstring("property not found",dm_err->errtext,1,1))) )) )
    IF ((dm_err->errtext=""))
     SET dbrc_no_error = 1
     SET dbrc_ret = ""
    ELSE
     SET dbrc_no_error = 1
     SET dbrc_ret = "NOPARMRETURNED"
    ENDIF
   ELSE
    SET dbrc_ret = dm_err->errtext
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("parm_value: <<",dbrc_ret,">>"))
   ENDIF
   IF (dbrc_no_error=0)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dbrc_ret="NOPARMRETURNED")
    IF (dbrc_req_ind=1)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Check for ",trim(dbrc_key)," key and ",trim(dbrc_prop)," property.")
     SET dm_err->emsg = "Property not found."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET dm_err->eproc = concat(trim(dbrc_key)," key and ",trim(dbrc_prop),
      " property not found and backup of content not required.")
     CALL disp_msg(" ",dm_err->logfile,0)
     RETURN(1)
    ENDIF
   ENDIF
   SET dbrc_ret = evaluate(findstring(" ",dbrc_ret,1),0,dbrc_ret,build('"',dbrc_ret,'"'))
   SET dm_err->eproc = concat("Validating existence of destination directory (",build(dbrc_dest_dir),
    ").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dbrc_bckup_file = build(dbrc_dest_dir,"/",dbrc_dest_fname)
   SET dm_err->eproc = concat("Create file for copy registry operations: ",dbrc_bckup_file)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(dbrc_bckup_file)
    DETAIL
     IF (dbrc_cre_key_ind=1)
      CALL print(concat("$cer_exe/lreg -crek ",dbrc_key)), row + 1
     ENDIF
     CALL print(concat("$cer_exe/lreg -setp ",dbrc_key," ",evaluate(findstring(" ",dbrc_prop,1),0,
       dbrc_prop,build('"',dbrc_prop,'"'))," ",
      dbrc_ret)), row + 1
    WITH nocounter, maxcol = 2000, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_restore_reg_content(null)
   DECLARE drrc_idx = i4 WITH protect, noconstant(0)
   DECLARE drrc_cmd = vc WITH protect, noconstant(" ")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   IF (ddr_backup_reg_content_load(null)=0)
    RETURN(0)
   ENDIF
   IF ((ddr_backup_reg_content->tgt_backup_list_cnt > 0))
    FOR (drrc_idx = 1 TO ddr_backup_reg_content->tgt_backup_list_cnt)
      SET dm_err->eproc = concat("Verifying existence of ",build(ddr_backup_reg_content->
        tgt_backup_list[drrc_idx].dest_dir,"/",ddr_backup_reg_content->tgt_backup_list[drrc_idx].
        dest_fname),".")
      CALL disp_msg("",dm_err->logfile,0)
      IF (dm2_findfile(build(ddr_backup_reg_content->tgt_backup_list[drrc_idx].dest_dir,"/",
        ddr_backup_reg_content->tgt_backup_list[drrc_idx].dest_fname)) > 0)
       SET dm_err->eproc = concat("Execute ksh ",build(ddr_backup_reg_content->tgt_backup_list[
         drrc_idx].dest_dir,"/",ddr_backup_reg_content->tgt_backup_list[drrc_idx].dest_fname),
        " to restore registry content.")
       CALL disp_msg(" ",dm_err->logfile,0)
       SET drrc_cmd = concat(". ",build(ddr_backup_reg_content->tgt_backup_list[drrc_idx].dest_dir,
         "/",ddr_backup_reg_content->tgt_backup_list[drrc_idx].dest_fname))
       IF (dm2_push_dcl(drrc_cmd)=0)
        RETURN(0)
       ENDIF
      ENDIF
    ENDFOR
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_srvreg_content_load(null)
   DECLARE dbscl_token_prefix = vc WITH protect, noconstant("")
   DECLARE dbscl_domain = vc WITH protect, noconstant("")
   DECLARE dbscl_temp_dir = vc WITH protect, noconstant("")
   DECLARE dbscl_env = vc WITH protect, noconstant("")
   DECLARE dbscl_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_srvreg_content.csv"))
   DECLARE dbscl_cust_file = vc WITH protect, noconstant(build(dm2_install_schema->cer_install,
     "dm2_rr_backup_srvreg_content_<env>.csv"))
   DECLARE dbscl_work_file = vc WITH protect, noconstant("")
   DECLARE dbscl_file_cnt = i2 WITH protect, noconstant(1)
   DECLARE dbscl_cntr = i2 WITH protect, noconstant(0)
   DECLARE dbscl_str = vc WITH protect, noconstant("")
   DECLARE dbscl_orig_str = vc WITH protect, noconstant("")
   DECLARE dbscl_token = vc WITH protect, noconstant("")
   DECLARE dbscl_mode = vc WITH protect, noconstant("")
   DECLARE dbscl_entry = vc WITH protect, noconstant("")
   DECLARE dbscl_dest_dir = vc WITH protect, noconstant("")
   DECLARE dbscl_dest_fname = vc WITH protect, noconstant("")
   DECLARE dbscl_orig_dest_fname = vc WITH protect, noconstant("")
   DECLARE dbscl_req_ind = vc WITH protect, noconstant("")
   DECLARE dbscl_options = vc WITH protect, noconstant("")
   DECLARE dbscl_active_ind = vc WITH protect, noconstant("")
   DECLARE dbscl_fatal_err_ind = i2 WITH protect, noconstant(0)
   DECLARE dbscl_fatal_str = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   SET dbscl_token_prefix = "TGT"
   SET dbscl_domain = ddr_domain_data->tgt_domain_name
   SET dbscl_temp_dir = ddr_domain_data->tgt_tmp_full_dir
   SET dbscl_env = ddr_domain_data->tgt_env
   IF (substring(size(dbscl_temp_dir),1,dbscl_temp_dir)="/")
    SET dbscl_temp_dir = trim(replace(dbscl_temp_dir,"/","",2),3)
   ENDIF
   SET dbscl_cust_file = replace(dbscl_cust_file,"<env>",dbscl_env,0)
   IF (dm2_findfile(dbscl_cust_file) > 0)
    SET dbscl_file_cnt = (dbscl_file_cnt+ 1)
   ENDIF
   FOR (dbscl_cntr = 1 TO dbscl_file_cnt)
     IF (dbscl_cntr=1)
      SET dbscl_work_file = dbscl_file
     ELSE
      SET dbscl_work_file = dbscl_cust_file
     ENDIF
     SET dm_err->eproc = concat("Open ",dbscl_work_file," and load backend file content.")
     CALL disp_msg("",dm_err->logfile,0)
     FREE SET dbscl_data_file
     SET logical dbscl_data_file dbscl_work_file
     FREE DEFINE rtl3
     DEFINE rtl3 "dbscl_data_file"
     SELECT INTO "nl:"
      t.line
      FROM rtl3t t
      WHERE t.line > " "
      DETAIL
       IF (dbscl_fatal_err_ind=0)
        dbscl_str = trim(t.line,3), dbscl_orig_str = dbscl_str
        IF ((dm_err->debug_flag > 4))
         CALL echo(concat("line = ",dbscl_str))
        ENDIF
        IF (substring(1,3,dbscl_str)=dbscl_token_prefix)
         dbscl_str = replace(dbscl_str,"<<domain>>",dbscl_domain,0), dbscl_str = replace(dbscl_str,
          "<<temp_full_dir>>",dbscl_temp_dir,0), dbscl_str = replace(dbscl_str,"<<node>>",trim(
           cnvtlower(curnode),3),0),
         dbscl_str = replace(dbscl_str,"<<env>>",dbscl_env,0)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("line_w_tokens_replaced = ",dbscl_str))
         ENDIF
         dbscl_token = trim(piece(dbscl_str,",",1,"Not Found"),3), dbscl_mode = trim(piece(dbscl_str,
           ",",2,"Not Found"),3), dbscl_entry = trim(piece(dbscl_str,",",3,"Not Found"),3),
         dbscl_dest_dir = trim(piece(dbscl_str,",",4,"Not Found"),3), dbscl_dest_fname = trim(piece(
           dbscl_str,",",5,"Not Found"),3), dbscl_options = trim(piece(dbscl_str,",",6,"Not Found"),3
          ),
         dbscl_req_ind = trim(piece(dbscl_str,",",7,"Not Found"),3), dbscl_active_ind = trim(piece(
           dbscl_str,",",8,"Not Found"),3)
         IF ((dm_err->debug_flag > 4))
          CALL echo(concat("token = ",dbscl_token)),
          CALL echo(concat("mode = ",dbscl_mode)),
          CALL echo(concat("entry = ",dbscl_entry)),
          CALL echo(concat("dest_dir = ",dbscl_dest_dir)),
          CALL echo(concat("dest_fname = ",dbscl_dest_fname)),
          CALL echo(concat("orig_dest_fname = ",dbscl_orig_dest_fname)),
          CALL echo(concat("options = ",dbscl_options)),
          CALL echo(concat("req_ind = ",dbscl_req_ind)),
          CALL echo(concat("active_ind = ",dbscl_active_ind))
         ENDIF
         IF (dbscl_mode="EXPORT"
          AND dbscl_entry != "Not Found"
          AND textlen(dbscl_entry) > 0
          AND dbscl_dest_dir != "Not Found"
          AND textlen(dbscl_dest_dir) > 0
          AND findstring(" ",dbscl_dest_dir,1)=0
          AND substring(1,size(dbscl_temp_dir),dbscl_dest_dir)=dbscl_temp_dir
          AND dbscl_dest_fname != "Not Found"
          AND textlen(dbscl_dest_fname) > 0
          AND findstring(" ",dbscl_dest_fname,1)=0
          AND dbscl_orig_dest_fname != "Not Found"
          AND textlen(dbscl_orig_dest_fname) > 0
          AND findstring(" ",dbscl_orig_dest_fname,1)=0
          AND findstring("<<",dbscl_orig_dest_fname,1)=0
          AND findstring(">>",dbscl_orig_dest_fname,1)=0
          AND ((substring(1,1,dbscl_options)="-") OR (dbscl_options="none"))
          AND dbscl_req_ind IN ("0", "1")
          AND dbscl_active_ind IN ("0", "1"))
          IF (dbscl_token_prefix="TGT"
           AND dbscl_active_ind="1")
           ddr_backup_srvreg_content->tgt_backup_list_cnt = (ddr_backup_srvreg_content->
           tgt_backup_list_cnt+ 1), stat = alterlist(ddr_backup_srvreg_content->tgt_backup_list,
            ddr_backup_srvreg_content->tgt_backup_list_cnt), ddr_backup_srvreg_content->
           tgt_backup_list[ddr_backup_srvreg_content->tgt_backup_list_cnt].token = dbscl_token,
           ddr_backup_srvreg_content->tgt_backup_list[ddr_backup_srvreg_content->tgt_backup_list_cnt]
           .mode = dbscl_mode, ddr_backup_srvreg_content->tgt_backup_list[ddr_backup_srvreg_content->
           tgt_backup_list_cnt].entry = dbscl_entry, ddr_backup_srvreg_content->tgt_backup_list[
           ddr_backup_srvreg_content->tgt_backup_list_cnt].dest_dir = dbscl_dest_dir,
           ddr_backup_srvreg_content->tgt_backup_list[ddr_backup_srvreg_content->tgt_backup_list_cnt]
           .dest_fname = dbscl_dest_fname, ddr_backup_srvreg_content->tgt_backup_list[
           ddr_backup_srvreg_content->tgt_backup_list_cnt].options = dbscl_options,
           ddr_backup_srvreg_content->tgt_backup_list[ddr_backup_srvreg_content->tgt_backup_list_cnt]
           .req_ind = cnvtint(dbscl_req_ind)
          ENDIF
         ELSE
          dbscl_fatal_str = trim(dbscl_str), dbscl_fatal_err_ind = 1
         ENDIF
        ENDIF
       ENDIF
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      RETURN(0)
     ENDIF
     IF (dbscl_fatal_err_ind=1)
      SET dm_err->emsg = concat("One or more fields for record in csv is invalid (",trim(
        dbscl_fatal_str),").")
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 4))
    CALL echorecord(ddr_backup_srvreg_content)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_backup_srvreg_content(dbsc_mode,dbsc_entry,dbsc_dest_dir,dbsc_dest_fname,dbsc_options,
  dbsc_req_ind)
   DECLARE dbsc_dir_found_ind = i2 WITH protect, noconstant(0)
   DECLARE dbsc_cmd = vc WITH protect, noconstant(" ")
   DECLARE dbsc_file = vc WITH protect, noconstant("dm2_bkup_regsrv")
   IF ((dm2_sys_misc->cur_os != "LNX"))
    RETURN(1)
   ENDIF
   SET dm_err->eproc = concat("Backup server registry content where mode is (",dbsc_mode,
    "), entry is (",dbsc_entry,").")
   CALL disp_msg("",dm_err->logfile,0)
   SET dbsc_dir_found_ind = 0
   SET dbsc_dir_found_ind = dm2_find_dir(dbsc_dest_dir)
   IF ((dm_err->err_ind > 0))
    RETURN(0)
   ENDIF
   IF (dbsc_dir_found_ind=0)
    SET dm_err->eproc = concat("Creating destination directory (",build(dbsc_dest_dir),
     ") and opening permissions.")
    CALL disp_msg("",dm_err->logfile,0)
    SET dbsc_cmd = concat("mkdir -p ",dbsc_dest_dir)
    IF (dm2_push_dcl(dbsc_cmd)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dbsc_cmd = concat("chmod 777 ",dbsc_dest_dir)
   IF (dm2_push_dcl(dbsc_cmd)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Verifying existence of destination file ",build(dbsc_dest_dir,"/",
     dbsc_dest_fname),".")
   CALL disp_msg("",dm_err->logfile,0)
   IF (dm2_findfile(build(dbsc_dest_dir,"/",dbsc_dest_fname)) > 0)
    IF (dm2_push_dcl(concat("rm ",build(dbsc_dest_dir,"/",dbsc_dest_fname)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (get_unique_file(dbsc_file,".ksh")=0)
    RETURN(0)
   ENDIF
   SET dbsc_file = dm_err->unique_fname
   SET dm_err->eproc = concat("Create file to backup specific server definitions: ",dbsc_file)
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dbsc_file)
    DETAIL
     CALL print(concat("tgt_mng_pwd='",ddr_domain_data->tgt_mng_pwd,"'")), row + 1,
     CALL print(concat("$cer_exe/scpview ",trim(cnvtlower(curnode))," <<!")),
     row + 1,
     CALL print(ddr_domain_data->tgt_mng), row + 1,
     CALL print(ddr_domain_data->tgt_domain_name), row + 1,
     CALL print("$tgt_mng_pwd"),
     row + 1,
     CALL print(concat(dbsc_mode," ",build(dbsc_dest_dir,"/",dbsc_dest_fname)," ",dbsc_entry,
      " ",trim(evaluate(dbsc_options,"none","",dbsc_options),3))), row + 1,
     CALL print("exit"), row + 1,
     CALL print("!"),
     row + 1
    WITH nocounter, maxcol = 500, format = variable,
     maxrow = 1
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Execute ksh (",dbsc_file,
    ") to backup server registry content where mode is (",dbsc_mode,"), entry is (",
    dbsc_entry,").")
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dbsc_cmd = concat(". $CCLUSERDIR/",dbsc_file)
   IF (dm2_push_dcl(dbsc_cmd)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(dm_err)
   ENDIF
   IF (((findstring("bad command",dm_err->errtext,1,1) > 0) OR (findstring(
    "node not offering services",dm_err->errtext,1,1) > 0)) )
    SET dm_err->emsg = concat("Error exporting server definitions: ",dbsc_cmd)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_findfile(build(dbsc_dest_dir,"/",dbsc_dest_fname))=0)
    IF (dbsc_req_ind=1)
     SET dm_err->eproc = concat("Validating registry server content for (",dbsc_mode,") of entry (",
      dbsc_entry,").")
     SET dm_err->emsg = concat("File (",build(dbsc_dest_dir,"/",dbsc_dest_fname),") not found.")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET dm_err->eproc = concat("Backup file for registry server content for (",dbsc_mode,
      ") of entry (",dbsc_entry,") not found and backup of content not required.")
     CALL disp_msg(" ",dm_err->logfile,0)
     RETURN(1)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddr_val_client_mnemonic(dvcm_src_ind,dvcm_tgt_ind,dvcm_inform_only_ind,
  dvcm_invalid_data_ind)
   DECLARE dvcm_rf_client_mnemonic = vc WITH protect, noconstant(drrr_rf_data->client_mnemonic)
   DECLARE dvcm_reg_path = vc WITH protect, noconstant("")
   DECLARE dvcm_reg_val = vc WITH protect, noconstant("")
   DECLARE dvcm_dm_info_val = vc WITH protect, noconstant("")
   DECLARE dvcm_logical_val = vc WITH protect, noconstant("")
   DECLARE dvcm_msg = vc WITH protect, noconstant("")
   DECLARE dvcm_invalid_reg_ind = i2 WITH protect, noconstant(0)
   DECLARE dvcm_invalid_dm_info_ind = i2 WITH protect, noconstant(0)
   DECLARE dvcm_invalid_logical_ind = i2 WITH protect, noconstant(0)
   SET dvcm_invalid_data_ind = 0
   IF (((dvcm_src_ind=0
    AND dvcm_tgt_ind=0) OR (dvcm_src_ind=1
    AND dvcm_tgt_ind=1)) )
    SET dm_err->eproc = "Validating input indicators."
    SET dm_err->emsg =
    "Invalid input combination.  Need to specifiy either source or target indicator and not both."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((dvcm_src_ind=1
    AND validate(dm2_bypass_src_val_client_mnemonic,- (1))=1) OR (dvcm_tgt_ind=1
    AND validate(dm2_bypass_tgt_val_client_mnemonic,- (1))=1)) )
    SET dm_err->eproc = concat("Bypassing validation of client mnemonic for ",evaluate(dvcm_src_ind,1,
      "SOURCE","TARGET"),".")
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET dvcm_reg_path = "\\definitions\\aixrs6000\\Environment\\ CLIENT_MNEMONIC"
   ELSEIF ((dm2_sys_misc->cur_os="LNX"))
    SET dvcm_reg_path = "\\definitions\\linuxx86-64\\Environment\\ CLIENT_MNEMONIC"
   ELSE
    RETURN(1)
   ENDIF
   SET dm_err->eproc =
   "Verifying if client mnemonic value in the response file matches the value in the registry."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (ddr_lreg_oper("GET",dvcm_reg_path,dvcm_reg_val)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("CLIENT_MNEMONIC in registry: ",dvcm_reg_val))
   ENDIF
   IF (cnvtupper(dvcm_rf_client_mnemonic) != cnvtupper(dvcm_reg_val))
    IF (dvcm_src_ind=1)
     SET dvcm_invalid_reg_ind = 1
    ELSE
     IF (ddr_lreg_oper("SET",concat(dvcm_reg_path," ",dvcm_rf_client_mnemonic),dvcm_reg_val)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc =
   "Verifying if client mnemonic value in the response file matches the value in DM_INFO."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DATA MANAGEMENT"
     AND di.info_name="CLIENT MNEMONIC"
    DETAIL
     dvcm_dm_info_val = di.info_char
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("CLIENT_MNEMONIC in DM_INFO: ",dvcm_dm_info_val))
   ENDIF
   IF (cnvtupper(dvcm_rf_client_mnemonic) != dvcm_dm_info_val)
    IF (dvcm_src_ind=1)
     SET dvcm_invalid_dm_info_ind = 1
    ELSE
     SET dm_err->eproc =
     "Inserting/Updating client mnemonic value in DM_INFO with the response file value."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     MERGE INTO dm_info di
     USING DUAL ON (di.info_domain="DATA MANAGEMENT"
      AND di.info_name="CLIENT MNEMONIC")
     WHEN MATCHED THEN
     (UPDATE
      SET di.info_char = cnvtupper(dvcm_rf_client_mnemonic), di.updt_dt_tm = cnvtdatetime(curdate,
        curtime3)
      WHERE 1=1
     ;end update
     )
     WHEN NOT MATCHED THEN
     (INSERT  FROM di
      (di.info_domain, di.info_name, di.info_char,
      di.updt_dt_tm)
      VALUES("DATA MANAGEMENT", "CLIENT MNEMONIC", cnvtupper(dvcm_rf_client_mnemonic),
      cnvtdatetime(curdate,curtime3))
      WITH nocounter
     ;end insert
     )
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      COMMIT
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc =
   "Verifying if client mnemonic value in the response file matches the logical value."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dvcm_logical_val = logical("client_mnemonic")
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("CLIENT_MNEMONIC in logical (local): ",dvcm_logical_val))
   ENDIF
   IF (cnvtupper(dvcm_rf_client_mnemonic) != cnvtupper(dvcm_logical_val)
    AND dvcm_src_ind=1)
    SET dvcm_invalid_logical_ind = 1
   ENDIF
   IF (((dvcm_invalid_reg_ind=1) OR (((dvcm_invalid_dm_info_ind=1) OR (dvcm_invalid_logical_ind=1))
   )) )
    SET dvcm_msg = concat(
     "Client mnemonic value is invalid at the following locations when compared ",
     "against the response file(",dvcm_rf_client_mnemonic,"):")
    IF (dvcm_invalid_reg_ind=1)
     SET dvcm_msg = concat(dvcm_msg," Registry(",dvcm_reg_val,"),")
    ENDIF
    IF (dvcm_invalid_dm_info_ind=1)
     SET dvcm_msg = concat(dvcm_msg," DM_INFO(",dvcm_dm_info_val,"),")
    ENDIF
    IF (dvcm_invalid_logical_ind=1)
     SET dvcm_msg = concat(dvcm_msg," Logical(",dvcm_logical_val,").")
    ENDIF
    IF (findstring(",",dvcm_msg,1,1)=textlen(dvcm_msg))
     SET dvcm_msg = replace(dvcm_msg,",",".",2)
    ENDIF
    IF (dvcm_inform_only_ind=1)
     SET dvcm_invalid_data_ind = 1
     SET dm_err->eproc = dvcm_msg
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc =
     "Validating client mnemonic value from the registry against the response file."
     SET dm_err->emsg = dvcm_msg
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE drr_val_write_privs(dvwp_full_dir=vc) = i4
 DECLARE drr_clin_copy_setup(dccs_whereto=vc(ref)) = i2
 DECLARE drr_clin_copy_restart_chk(null) = i2
 DECLARE drr_check_log_for_errors(dclfe_op_id=f8,dclfe_oper_logfile=vc,dclfe_force_load_ind=i2,
  dclfe_err_ind=i2(ref)) = i2
 DECLARE drr_load_mixed_table_data(dlmtd_force_load_ind=i2) = i2
 DECLARE drr_get_dmp_log_loc(dgdll_op_id=f8,dgdll_dmp_loc_out=vc(ref)) = i2
 DECLARE drr_load_ref_table_data(force_load_ind=i2) = i2
 DECLARE drr_get_exp_dmp_loc(dgedl_dmp_loc_out=vc(ref)) = i2
 DECLARE drr_load_preserved_table_data(dlp_source=vc,dlp_file=vc) = i2
 DECLARE drr_prompt_preserve_data(null) = i2
 DECLARE drr_chk_for_preserved_data(dcf_chk_ret=i2(ref)) = i2
 DECLARE drr_display_summary_screen(null) = i2
 DECLARE drr_get_invalid_tables_list(null) = i2
 DECLARE drr_process_invalid_tables(null) = i2
 DECLARE drr_get_dbase_created_date(dgdcd_created_date=f8(ref)) = i2
 DECLARE drr_prompt_schema_date(dpsd_row=i4(ref)) = null
 DECLARE drr_prompt_loc(dpl_row=i4(ref),dpl_type=vc) = i2
 DECLARE drr_get_max_clin_copy_run_id(dgm_run_id=f8(ref)) = i2
 DECLARE drr_get_custom_tables_list(null) = i2
 DECLARE drr_validate_ref_data_link(null) = i2
 DECLARE drr_ads_domain_check(dadc_db_link=vc,dadc_ads_domain_ind=i2(ref)) = i2
 DECLARE drr_prompt_ads_config(dpac_response=c1(ref)) = i2
 DECLARE drr_validate_tgtdblink(dvt_tgt_host=vc,dvt_tgt_ora_ver=i2,dvt_src_host=vc) = i2
 DECLARE drr_validate_adm_env_csv(dvae_path=vc,dvae_src_env=vc) = i2
 DECLARE drr_set_src_env_path(null) = null
 DECLARE drr_confirm_invalid_tables(dcit_manage_opt_ind=i2,dcit_confirm_ret=i2(ref)) = i2
 DECLARE drr_column_and_ccldef_exists(dcce_table_name=vc,dcce_column_name=vc,dcce_exists_ind=i2(ref))
  = i2
 DECLARE drr_identify_was_usage(diwu_domain=vc,diwu_was_ind=i2(ref)) = i2
 DECLARE drr_restore_col_checks(drcc_src=vc,drcc_sti=i4,drcc_sci=i4,drcc_pti=i4,drcc_pci=i4,
  drcc_tti=i4,drcc_tc=i4) = i2
 DECLARE drr_restore_tbl_checks(drtc_src=vc,drtc_sti=i4,drtc_pti=i4) = i2
 DECLARE drr_restore_report(null) = i2
 DECLARE drr_restore_col_mismatch(null) = i2
 DECLARE drr_restore_tbl_mismatch(null) = i2
 DECLARE drr_cleanup_drr_copy(dcdc_drr_cleanup=vc(ref)) = i2
 DECLARE drr_load_chunk_imp_tbls(dlcit_db_link=vc,dlcit_get_chunks_ind=i2) = i2
 DECLARE drr_get_mixtbl_ref_rows(dgmrr_db_name=vc) = i2
 DECLARE drr_upd_mixtbl_ref_rows(dumrr_db_name=vc,dumrr_run_id=i2) = i2
 DECLARE drr_refresh_drop_restrict(drdr_mode=vc,drdr_restart_ind=i2) = i2
 DECLARE drr_drop_user_restrict_ksh(null) = i2
 DECLARE drr_verify_admin_content(dvac_inform_only_ind=i2,dvac_invalid_data_ind=i2(ref)) = i2
 DECLARE drr_add_default_scd_row(null) = i2
 DECLARE drr_verify_custom_users(dvcu_inform_only_ind=i2,dvcu_invalid_cust_user_ind=i2(ref)) = i2
 DECLARE drr_drop_db_link(dddl_link_name=vc) = i2
 DECLARE drr_check_db_link(dcdl_in_db_link_name=vc,dcdl_out_db_link_fnd_ind=i2(ref)) = i2
 DECLARE drr_del_preserved_ts(dcdl_tgt_db_name=vc) = i2
 IF (validate(drr_clin_copy_ddl->dccd_cnt,1)=1
  AND validate(drr_clin_copy_ddl->dccd_cnt,2)=2)
  FREE RECORD drr_clin_copy_ddl
  RECORD drr_clin_copy_ddl(
    1 dccd_cnt = i4
    1 qual[*]
      2 dccd_op_type = vc
      2 dccd_priority = i4
      2 dccd_operation = vc
  )
 ENDIF
 IF (validate(drr_preserved_tables_data->cnt,1)=1
  AND validate(drr_preserved_tables_data->cnt,2)=2)
  FREE RECORD drr_preserved_tables_data
  RECORD drr_preserved_tables_data(
    1 refresh_ind = i2
    1 restore_groups_str = vc
    1 restore_foul = i2
    1 foul_grp_str = vc
    1 res_rep_name = vc
    1 cnt = i4
    1 tbl[*]
      2 table_name = vc
      2 group = vc
      2 table_suffix = vc
      2 prefix = vc
      2 refresh_ind = i2
      2 tgtsch_idx = i4
      2 partial_ind = i2
      2 exp_where_clause = vc
      2 restore_in_phases = i2
      2 extra_src_cols = i2
      2 extra_pre_cols = i2
      2 pres_tbl_not_in_src = i2
      2 restore_foul = i2
      2 reason_cnt = i4
      2 restore_foul_reasons[*]
        3 text = vc
      2 long_cols_exist = i2
      2 col_diff = i2
      2 col_cnt = i4
      2 col[*]
        3 col_name = vc
        3 data_type = vc
        3 data_length = i4
        3 data_default = vc
        3 data_default_ni = i2
        3 nullable = vc
        3 diff_dtype_ind = i2
        3 diff_dlength_ind = i2
        3 diff_nullable_ind = i2
        3 diff_default_ind = i2
  )
  SET drr_preserved_tables_data->cnt = 0
  SET drr_preserved_tables_data->refresh_ind = 0
  SET drr_preserved_tables_data->restore_foul = 0
 ENDIF
 IF (validate(drr_group->cnt,1)=1
  AND validate(drr_group->cnt,2)=2)
  FREE RECORD drr_group
  RECORD drr_group(
    1 cnt = i4
    1 grp[*]
      2 group = vc
      2 restore = i2
      2 prompt_ind = i2
  )
 ENDIF
 IF (validate(drr_retain_db_users->cnt,1)=1
  AND validate(drr_retain_db_users->cnt,2)=2)
  FREE RECORD drr_retain_db_users
  RECORD drr_retain_db_users(
    1 cnt = i4
    1 user[*]
      2 user_name = vc
  )
  SET drr_retain_db_users->cnt = 0
 ENDIF
 IF (validate(drr_cleanup_warnings->cnt,1)=1
  AND validate(drr_cleanup_warnings->cnt,2)=2)
  RECORD drr_cleanup_warnings(
    1 cnt = i4
    1 qual[*]
      2 table_name = vc
      2 message = vc
  )
  SET drr_cleanup_warnings->cnt = 0
 ENDIF
 IF (validate(drr_cleanup_drop_list->cnt,1)=1
  AND validate(drr_cleanup_drop_list->cnt,2)=2)
  RECORD drr_cleanup_drop_list(
    1 list_loaded_ind = i2
    1 cnt = i4
    1 qual[*]
      2 owner = vc
      2 table_name = vc
  )
 ENDIF
 IF (validate(drr_mvdrop_list->cnt,1)=1
  AND validate(drr_mvdrop_list->cnt,2)=2)
  RECORD drr_mvdrop_list(
    1 list_loaded_ind = i2
    1 cnt = i4
    1 qual[*]
      2 owner = vc
      2 mv_name = vc
  )
 ENDIF
 IF (validate(drr_custom_tables->cnt,1)=1
  AND validate(drr_custom_tables->cnt,2)=2)
  RECORD drr_custom_tables(
    1 list_loaded_ind = i2
    1 cnt = i4
    1 qual[*]
      2 owner_table = vc
      2 owner = vc
      2 table_name = vc
  )
 ENDIF
 IF ((validate(drr_ads_ext->table_cnt,- (1))=- (1))
  AND validate(drr_ads_ext->table_cnt,2)=2)
  FREE SET drr_ads_ext
  RECORD drr_ads_ext(
    1 tbl_cnt = i4
    1 sample_percent = i2
    1 config_id = f8
    1 tgt_p_word = vc
    1 tgt_connect_str = vc
    1 tbl[*]
      2 owner = vc
      2 table_name = vc
      2 deldups_ind = i2
      2 dupind_name = vc
      2 pk_col_cnt = i2
      2 pk_col[*]
        3 col_name = vc
      2 col_fnd = i2
      2 object_id = vc
      2 extract_cnt = i4
      2 nomove = i2
      2 move_all = i2
      2 ext[*]
        3 config_extract_id = f8
        3 extract_id = f8
        3 driver_extract_id = f8
        3 table_extract_nbr = i4
        3 table_extract_inst = i4
        3 active_ind = i2
        3 extract_method = vc
        3 apply_where_ind = i2
        3 data_class_type = vc
        3 where_clause = vc
        3 purge_where_clause = vc
        3 expimp_level = i4
        3 driver_table_ind = i2
        3 driver_table_name = vc
        3 driver_keycol_name = vc
        3 expimp_parent_table_name = vc
        3 dupdel_skip_ind = i2
        3 nomove = i2
  )
 ENDIF
 IF (validate(drr_preserve_db_users->cnt,1)=1
  AND validate(drr_preserve_db_users->cnt,2)=2)
  FREE RECORD drr_preserve_db_users
  RECORD drr_preserve_db_users(
    1 cnt = i4
    1 user[*]
      2 user_name = vc
  )
  SET drr_preserve_db_users->cnt = 0
 ENDIF
 IF ((validate(drr_priority_group_matrix->cnt,- (1))=- (1)))
  FREE RECORD drr_priority_group_matrix
  RECORD drr_priority_group_matrix(
    1 cnt = i2
    1 priority_group[*]
      2 group_name = vc
      2 priority_from_range = i4
      2 priority_to_range = i4
      2 group_prefix = c10
  )
  SET drr_priority_group_matrix->cnt = 0
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "EXPORTS"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 0
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range = 9
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "ex"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "CREATE TABLES"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 9
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  100
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "ct"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "IMPORTS"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 99
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  200
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "im"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "CREATE INDEXES"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 199
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  400
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "ci"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "CREATE CONSTRAINTS"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 399
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  500
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "cc"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "RUN UTILITIES"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 699
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  800
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "ru"
  SET drr_priority_group_matrix->cnt = (drr_priority_group_matrix->cnt+ 1)
  SET stat = alterlist(drr_priority_group_matrix->priority_group,drr_priority_group_matrix->cnt)
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_name =
  "ALL DDL"
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_from_range
   = 0
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].priority_to_range =
  2000
  SET drr_priority_group_matrix->priority_group[drr_priority_group_matrix->cnt].group_prefix = "all"
 ENDIF
 IF (validate(drr_clin_copy_data->temp_location,"-x")="-x"
  AND validate(drr_clin_copy_data->temp_location,"y")="y")
  FREE RECORD drr_clin_copy_data
  RECORD drr_clin_copy_data(
    1 temp_location = vc
    1 ref_par_file_cnt = i2
    1 mixed_tables_parfile_name = vc
    1 ind_mixed_parfile_prefix = vc
    1 exp_all_prefix = vc
    1 imp_all_prefix = vc
    1 exp_ref_prefix = vc
    1 imp_ref_prefix = vc
    1 exp_pts_prefix = vc
    1 imp_pts_prefix = vc
    1 export_rpt_name = vc
    1 import_rpt_name = vc
    1 starting_point = vc
    1 checkpoint_ind = i2
    1 exp_file_prefix = vc
    1 imp_file_prefix = vc
    1 create_truncate_cmds = i2
    1 src_was_ind = i2
    1 src_env_name = vc
    1 src_env_id = f8
    1 tgt_was_ind = i2
    1 tgt_env_name = vc
    1 tgt_db_env_name = vc
    1 tgt_env_id = f8
    1 exp_imp_utility_location = vc
    1 process = vc
    1 preserve_tbl_pre = vc
    1 preserve_sch_dt = vc
    1 summary_screen_issued = i2
    1 src_db_created = f8
    1 tgt_db_created = f8
    1 tgt_mock_env = i2
    1 exp_rdds_prefix = vc
    1 imp_rdds_prefix = vc
    1 standalone_expimp_process = i2
    1 licensed_to_ads = i2
    1 ads_chosen_ind = i2
    1 ads_config_id = f8
    1 ads_name = vc
    1 ads_mod_dt_tm = f8
    1 ads_pct = f8
    1 src_ads_ind = i2
    1 tgt_domain_name = vc
    1 src_domain_name = vc
    1 purge_chosen_ind = i2
    1 ddl_excl_rpt_name = vc
  )
  SET drr_clin_copy_data->process = "DM2NOTSET"
  SET drr_clin_copy_data->preserve_tbl_pre = "dm2_preserve_table"
  SET drr_clin_copy_data->preserve_sch_dt = "02022002"
  SET drr_clin_copy_data->summary_screen_issued = 0
  SET drr_clin_copy_data->temp_location = "DM2NOTSET"
  SET drr_clin_copy_data->ref_par_file_cnt = 0
  SET drr_clin_copy_data->mixed_tables_parfile_name = "dm2_mixed_tables.par"
  SET drr_clin_copy_data->ind_mixed_parfile_prefix = "dm2_mixtbl_"
  SET drr_clin_copy_data->exp_all_prefix = "exp_v500_all"
  SET drr_clin_copy_data->imp_all_prefix = "imp_v500_all"
  SET drr_clin_copy_data->exp_ref_prefix = "exp_v500_ref"
  SET drr_clin_copy_data->imp_ref_prefix = "imp_v500_ref"
  SET drr_clin_copy_data->exp_pts_prefix = "exp_v500_pts"
  SET drr_clin_copy_data->imp_pts_prefix = "imp_v500_pts"
  SET drr_clin_copy_data->exp_file_prefix = "dm2_export"
  SET drr_clin_copy_data->imp_file_prefix = "dm2_import"
  SET drr_clin_copy_data->starting_point = "DM2NOTSET"
  SET drr_clin_copy_data->src_env_name = "DM2NOTSET"
  SET drr_clin_copy_data->tgt_env_name = "DM2NOTSET"
  SET drr_clin_copy_data->tgt_db_env_name = "DM2NOTSET"
  SET drr_clin_copy_data->create_truncate_cmds = 0
  IF (validate(dm2_troubleshoot_replicate,1)=1
   AND validate(dm2_troubleshoot_replicate,2)=2)
   SET drr_clin_copy_data->checkpoint_ind = 0
  ELSE
   SET drr_clin_copy_data->checkpoint_ind = 1
  ENDIF
  SET drr_clin_copy_data->tgt_mock_env = 1
  SET drr_clin_copy_data->exp_rdds_prefix = "exp_v500_rdds"
  SET drr_clin_copy_data->imp_rdds_prefix = "imp_v500_rdds"
  SET drr_clin_copy_data->standalone_expimp_process = 0
  SET drr_clin_copy_data->ads_name = "DM2NOTSET"
  SET drr_clin_copy_data->src_was_ind = 0
  SET drr_clin_copy_data->tgt_was_ind = 0
  SET drr_clin_copy_data->ddl_excl_rpt_name = ""
 ENDIF
 IF (validate(drr_mixed_tables_data->cnt,1)=1
  AND validate(drr_mixed_tables_data->cnt,2)=2)
  FREE RECORD drr_mixed_tables_data
  RECORD drr_mixed_tables_data(
    1 cnt = i4
    1 tbl[*]
      2 table_name = vc
      2 table_suffix = vc
      2 where_clause_cnt = i2
      2 qual[*]
        3 process_type = vc
        3 data_type = vc
        3 where_clause = vc
      2 prefix = vc
      2 num_rows = f8
      2 last_analyzed = dq8
      2 ref_num_rows_set_ind = i2
      2 ref_num_rows = f8
  )
  SET drr_mixed_tables_data->cnt = 0
 ENDIF
 IF (validate(drr_ignored_errors->cnt,1)=1
  AND validate(drr_ignored_errors->cnt,2)=2)
  FREE RECORD drr_ignored_errors
  RECORD drr_ignored_errors(
    1 cnt = i4
    1 drr_ignorable_errfile = vc
    1 qual[*]
      2 error = vc
  )
  SET drr_ignored_errors->cnt = 0
  SET drr_ignored_errors->drr_ignorable_errfile = "dm2_ignorable_errors.dat"
 ENDIF
 IF (validate(drr_errors_encountered->cmd_cnt,1)=1
  AND validate(drr_errors_encountered->cmd_cnt,2)=2)
  FREE RECORD drr_errors_encountered
  RECORD drr_errors_encountered(
    1 cmd_cnt = i4
    1 qual[*]
      2 dee_op_id = f8
      2 error_cnt = i4
      2 logfile_name = vc
      2 force_reset_ind = i2
      2 qual[*]
        3 error = vc
        3 error_desc = vc
  )
  SET drr_errors_encountered->cmd_cnt = 0
 ENDIF
 IF (validate(drr_ref_tables_data->cnt,1)=1
  AND validate(drr_ref_tables_data->cnt,2)=2)
  FREE RECORD drr_ref_tables_data
  RECORD drr_ref_tables_data(
    1 cnt = i4
    1 tbl[*]
      2 table_name = vc
      2 par_group = i2
  )
  SET drr_ref_tables_data->cnt = 0
 ENDIF
 IF (validate(drr_all_tables_data->cnt,1)=1
  AND validate(drr_all_tables_data->cnt,2)=2)
  FREE RECORD drr_all_tables_data
  RECORD drr_all_tables_data(
    1 par_file_cnt = i2
    1 cnt = i4
    1 tbl[*]
      2 table_name = vc
      2 par_group = i2
  )
  SET drr_all_tables_data->cnt = 0
  SET drr_all_tables_data->par_file_cnt = 0
 ENDIF
 IF (validate(drr_rdds_tables_data->cnt,1)=1
  AND validate(drr_rdds_tables_data->cnt,2)=2)
  FREE RECORD drr_rdds_tables_data
  RECORD drr_rdds_tables_data(
    1 par_file_cnt = i2
    1 cnt = i4
    1 tbl[*]
      2 table_name = vc
      2 par_group = i2
  )
  SET drr_rdds_tables_data->cnt = 0
  SET drr_rdds_tables_data->par_file_cnt = 0
 ENDIF
 IF ((validate(drr_env_hist_misc->cnt,- (1))=- (1))
  AND (validate(drr_env_hist_misc->cnt,- (2))=- (2)))
  FREE RECORD drr_env_hist_misc
  RECORD drr_env_hist_misc(
    1 path = vc
    1 summary_file = vc
    1 cnt = i4
    1 qual[*]
      2 table_name = vc
      2 table_alias = vc
      2 csv_file_name = vc
      2 row_count = vc
      2 date = vc
      2 load = i2
  )
  SET drr_env_hist_misc->cnt = 0
  SET drr_env_hist_misc->path = "DM2NOTSET"
  SET drr_env_hist_misc->summary_file = "DM2NOTSET"
 ENDIF
 IF ((validate(drr_retry_imp_data->tbl_cnt,- (1))=- (1))
  AND (validate(drr_retry_imp_data->tbl_cnt,- (2))=- (2)))
  FREE RECORD drr_retry_imp_data
  RECORD drr_retry_imp_data(
    1 create_chunk_cmds = i2
    1 tbl_cnt = i4
    1 tbl[*]
      2 owner = vc
      2 table_name = vc
      2 op_type = vc
  )
 ENDIF
 IF ((validate(drr_chunk_imp_tbls->tbl_cnt,- (1))=- (1))
  AND (validate(drr_chunk_imp_tbls->tbl_cnt,- (2))=- (2)))
  FREE RECORD drr_chunk_imp_tbls
  RECORD drr_chunk_imp_tbls(
    1 tbl_cnt = i4
    1 tbl[*]
      2 owner = vc
      2 table_name = vc
      2 segment_name = vc
      2 part_ind = i2
      2 part_cnt = i4
      2 orig_num_chunks = i4
      2 num_chunks = i4
      2 chunk_cnt = i4
      2 chunks[*]
        3 min_rid = vc
        3 max_rid = vc
  )
 ENDIF
 SUBROUTINE drr_get_dmp_log_loc(dgdll_op_id,dgdll_dmp_loc_out)
   DECLARE dgdll_strt_pt = i4 WITH protect, noconstant(0)
   DECLARE dgdll_end_pt = i4 WITH protect, noconstant(0)
   DECLARE dgdll_str = vc WITH protect, noconstant(" ")
   SET dm_err->eproc = concat("Find logfile for OP_ID:",build(dgdll_op_id))
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm2_ddl_ops_log d
    WHERE d.op_id=dgdll_op_id
    DETAIL
     dgdll_strt_pt = (findstring("log=",d.operation,1)+ 4), dgdll_end_pt = findstring(" ",d.operation,
      dgdll_strt_pt), dgdll_dmp_loc_out = substring(dgdll_strt_pt,(dgdll_end_pt - dgdll_strt_pt),d
      .operation)
     IF ((dm_err->debug_flag > 2))
      CALL echo(d.operation),
      CALL echo(dgdll_strt_pt),
      CALL echo(dgdll_end_pt),
      CALL echo(dgdll_dmp_loc_out)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dgdll_dmp_loc_out = "NOT_VALID_OP_ID"
   ELSE
    IF (dgdll_dmp_loc_out > " ")
     IF (findfile(dgdll_dmp_loc_out)=0)
      SET dgdll_dmp_loc_out = concat("NO_FILE_IN_OS:",dgdll_dmp_loc_out)
     ENDIF
    ELSE
     SET dgdll_dmp_loc_out = "NO_FILE_IN_COMMAND"
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_load_ref_table_data(force_load_ind)
   DECLARE dlrtd_mix_ndx = i4 WITH protect, noconstant(0)
   DECLARE dlrtd_ref_ndx = i4 WITH protect, noconstant(0)
   DECLARE dlrtd_mix = i4 WITH protect, noconstant(0)
   DECLARE dlrtd_ref = i4 WITH protect, noconstant(0)
   IF ((drr_ref_tables_data->cnt > 0)
    AND force_load_ind=0)
    SET dm_err->eproc = "Skipping load of reference table list."
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF (drr_load_mixed_table_data(1)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Loading reference table list."
   CALL disp_msg(" ",dm_err->logfile,0)
   SET drr_ref_tables_data->cnt = 0
   SET stat = alterlist(drr_ref_tables_data->tbl,drr_ref_tables_data->cnt)
   SELECT INTO "nl:"
    dut.table_name
    FROM dm_tables_doc dtd,
     dm2_user_tables dut
    PLAN (dtd
     WHERE dtd.table_name=dtd.full_table_name
      AND dtd.reference_ind=1
      AND  NOT ( EXISTS (
     (SELECT
      "x"
      FROM user_mviews um
      WHERE um.mview_name=dut.table_name)))
      AND  NOT (dtd.table_name IN (
     (SELECT DISTINCT
      dt.drr_table_name
      FROM dm_table_relationships dt
      WHERE dt.drr_table_name="*DRR"
       AND dt.drr_flag=1))))
     JOIN (dut
     WHERE dut.table_name=dtd.table_name)
    ORDER BY dut.table_name
    DETAIL
     IF (locateval(dlrtd_mix_ndx,1,value(drr_mixed_tables_data->cnt),dut.table_name,
      drr_mixed_tables_data->tbl[dlrtd_mix_ndx].table_name)=0)
      drr_ref_tables_data->cnt = (drr_ref_tables_data->cnt+ 1)
      IF (mod(drr_ref_tables_data->cnt,2000)=1)
       stat = alterlist(drr_ref_tables_data->tbl,(drr_ref_tables_data->cnt+ 1999))
      ENDIF
      drr_ref_tables_data->tbl[drr_ref_tables_data->cnt].table_name = dut.table_name
     ELSE
      IF ((dm_err->debug_flag > 0))
       CALL echo(concat(trim(dut.table_name),
        " is a mixed table and not loaded into Reference listing."))
      ENDIF
     ENDIF
    FOOT REPORT
     stat = alterlist(drr_ref_tables_data->tbl,drr_ref_tables_data->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((validate(dm2_skip_cust_ref_tables,- (1))=- (1))
    AND (validate(dm2_skip_cust_ref_tables,- (2))=- (2)))
    SET dm_err->eproc = "Loading custom reference table list."
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dm_info i,
      dm2_user_tables u
     WHERE i.info_domain="DM2_CUST_REF_TABLES"
      AND i.info_name=u.table_name
     ORDER BY u.table_name
     HEAD REPORT
      dlrtd_mix_ndx = 0, dlrtd_ref_ndx = 0
     DETAIL
      dlrtd_mix = 0, dlrtd_ref = 0, dlrtd_mix = locateval(dlrtd_mix_ndx,1,value(drr_mixed_tables_data
        ->cnt),u.table_name,drr_mixed_tables_data->tbl[dlrtd_mix_ndx].table_name),
      dlrtd_ref = locateval(dlrtd_ref_ndx,1,value(drr_ref_tables_data->cnt),u.table_name,
       drr_ref_tables_data->tbl[dlrtd_ref_ndx].table_name)
      IF (dlrtd_mix=0
       AND dlrtd_ref=0)
       drr_ref_tables_data->cnt = (drr_ref_tables_data->cnt+ 1), stat = alterlist(drr_ref_tables_data
        ->tbl,drr_ref_tables_data->cnt), drr_ref_tables_data->tbl[drr_ref_tables_data->cnt].
       table_name = u.table_name
      ELSEIF (dlrtd_mix > 0)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dlrtd_mix = ",dlrtd_mix)),
        CALL echo(build("dlrtd_ref = ",dlrtd_ref)),
        CALL echo(concat(trim(u.table_name),
         " is a mixed table and not loaded into Reference listing."))
       ENDIF
      ELSEIF (dlrtd_ref > 0)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dlrtd_mix = ",dlrtd_mix)),
        CALL echo(build("dlrtd_ref = ",dlrtd_ref)),
        CALL echo(concat(trim(u.table_name)," is already in the Reference list."))
       ENDIF
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((drr_ref_tables_data->cnt=0))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Checking count of reference tables."
    SET dm_err->emsg = "No reference tables found."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(drr_ref_tables_data)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_check_log_for_errors(dclfe_op_id,dclfe_oper_logfile,dclfe_force_load_ind,
  dclfe_err_ind)
   DECLARE dclfe_ndx = i4 WITH protect, noconstant(0)
   DECLARE dclfe_err_type = vc WITH protect, noconstant("")
   DECLARE dclfe_start = i4 WITH protect, noconstant(0)
   DECLARE dclfe_end = i4 WITH protect, noconstant(0)
   DECLARE dclfe_add_cmd = i2 WITH protect, noconstant(1)
   DECLARE dclfe_err_cnt = i4 WITH protect, noconstant(0)
   DECLARE dclfe_err_str = vc WITH protect, noconstant("")
   DECLARE dclfe_x = i4 WITH protect, noconstant(0)
   DECLARE dclfe_start = i4 WITH protect, noconstant(0)
   DECLARE dclfe_end = i4 WITH protect, noconstant(0)
   DECLARE dclfe_length = i4 WITH protect, noconstant(0)
   DECLARE dclfe_error = vc WITH protect, noconstant(" ")
   DECLARE dclfe_err_msg = vc WITH protect, noconstant("")
   DECLARE dclfe_err_msg_length = i4 WITH protect, noconstant(0)
   IF (dclfe_force_load_ind != 2)
    SET dm_err->eproc = "Check if ignorable errors file exists."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(dm_err->eproc,dm_err->logfile,0)
    ENDIF
    IF (findfile(value(drr_ignored_errors->drr_ignorable_errfile)) > 0)
     SET dm_err->eproc = "Load ignorable errors."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg(dm_err->eproc,dm_err->logfile,0)
     ENDIF
     FREE DEFINE rtl2
     DEFINE rtl2 value(drr_ignored_errors->drr_ignorable_errfile)
     SELECT INTO "nl:"
      FROM rtl2t t
      WHERE t.line > " "
      HEAD REPORT
       drr_ignored_errors->cnt = 0
      DETAIL
       drr_ignored_errors->cnt = (drr_ignored_errors->cnt+ 1)
       IF (mod(drr_ignored_errors->cnt,10)=1)
        stat = alterlist(drr_ignored_errors->qual,(drr_ignored_errors->cnt+ 9))
       ENDIF
       drr_ignored_errors->qual[drr_ignored_errors->cnt].error = trim(t.line)
      FOOT REPORT
       stat = alterlist(drr_ignored_errors->qual,drr_ignored_errors->cnt)
      WITH nocounter
     ;end select
    ENDIF
    IF ((dm_err->debug_flag > 2))
     CALL echorecord(drr_ignored_errors)
    ENDIF
   ENDIF
   IF (((dclfe_force_load_ind=2
    AND dclfe_op_id=0) OR (dclfe_force_load_ind=1)) )
    IF ((dm_err->debug_flag > 0))
     SET dm_err->eproc = "Resetting error structure due to force load ind."
     CALL disp_msg(dm_err->eproc,dm_err->logfile,0)
    ENDIF
    FOR (dclfe_err_cnt = 1 TO size(drr_errors_encountered->qual,5))
      SET stat = alterlist(drr_errors_encountered->qual[dclfe_err_cnt].qual,0)
    ENDFOR
    SET stat = alterlist(drr_errors_encountered->qual,0)
    SET dclfe_err_cnt = 0
    SET drr_errors_encountered->cmd_cnt = 0
   ENDIF
   IF (dclfe_force_load_ind=2
    AND dclfe_op_id > 0)
    SET dm_err->eproc = "Check Operation Error Message from DM2_DDL_OPS_LOG for Errors."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(dm_err->eproc,dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_ddl_ops_log d
     WHERE d.op_id=dclfe_op_id
     DETAIL
      dclfe_err_msg = trim(d.error_msg,3), dclfe_err_msg_length = size(dclfe_err_msg)
      FOR (dclfe_x = 1 TO dclfe_err_msg_length)
        dclfe_start = (findstring("<<<",dclfe_err_msg,dclfe_x)+ 3), dclfe_end = (findstring(">>>",
         dclfe_err_msg,dclfe_x) - 1), dclfe_length = ((dclfe_end - dclfe_start)+ 1)
        IF (((dclfe_x+ 3) > dclfe_err_msg_length))
         dclfe_x = dclfe_err_msg_length
        ELSE
         dclfe_x = (dclfe_end+ 3)
        ENDIF
        dclfe_error = substring(dclfe_start,dclfe_length,dclfe_err_msg)
        IF ((dm_err->debug_flag > 2))
         CALL echo(concat("dclfe_error = ",dclfe_error))
        ENDIF
        dclfe_err_type = "", dclfe_ndx = 0, dclfe_start = 0,
        dclfe_end = 0, dclfe_err_str = ""
        IF (findstring("ORA-",dclfe_error,0) > 0)
         dclfe_err_type = "ORA-"
        ELSEIF (findstring("EXP-",dclfe_error,0) > 0)
         dclfe_err_type = "EXP-"
        ELSEIF (findstring("IMP-",dclfe_error,0) > 0)
         dclfe_err_type = "IMP-"
        ELSEIF (findstring("LRM-",dclfe_error,0) > 0)
         dclfe_err_type = "LRM-"
        ELSEIF (findstring("CER-",dclfe_error,0) > 0)
         dclfe_err_type = "CER-"
        ELSEIF (findstring("UDI-",dclfe_error,0) > 0)
         dclfe_err_type = "UDI-"
        ENDIF
        IF ((dm_err->debug_flag > 2))
         CALL echo(concat("dclfe_err_type = ",dclfe_err_type))
        ENDIF
        IF (dclfe_err_type > "")
         dclfe_start = findstring(dclfe_err_type,dclfe_error,0), dclfe_end = findstring(" ",
          dclfe_error,dclfe_start), dclfe_err_str = substring(dclfe_start,((dclfe_end - dclfe_start)
           - 1),dclfe_error)
         IF (dclfe_add_cmd=1)
          dclfe_err_ind = 1, drr_errors_encountered->cmd_cnt = (drr_errors_encountered->cmd_cnt+ 1),
          stat = alterlist(drr_errors_encountered->qual,drr_errors_encountered->cmd_cnt),
          drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].logfile_name =
          dclfe_oper_logfile, drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].dee_op_id
           = dclfe_op_id
          IF (dclfe_err_str="*EXP-00002*"
           AND d.parent_execution_order=1)
           drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].force_reset_ind = 1
          ENDIF
          dclfe_add_cmd = 0
         ENDIF
         dclfe_ndx = 0
         IF (locateval(dclfe_ndx,1,drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].
          error_cnt,dclfe_err_str,drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[
          dclfe_ndx].error)=0)
          dclfe_err_cnt = (dclfe_err_cnt+ 1), drr_errors_encountered->qual[drr_errors_encountered->
          cmd_cnt].error_cnt = dclfe_err_cnt, stat = alterlist(drr_errors_encountered->qual[
           drr_errors_encountered->cmd_cnt].qual,dclfe_err_cnt),
          drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[dclfe_err_cnt].error =
          dclfe_err_str, drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[
          dclfe_err_cnt].error_desc = substring(dclfe_end,(size(trim(d.error_msg)) - dclfe_end),
           dclfe_error)
          IF (dclfe_err_str="*EXP-00002*"
           AND d.parent_execution_order=1)
           drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].force_reset_ind = 1
          ENDIF
         ELSE
          IF ((dm_err->debug_flag > 0))
           CALL echo(concat("Skipped ",dclfe_err_str," because already in list."))
          ENDIF
         ENDIF
        ENDIF
      ENDFOR
     WITH nocounter
    ;end select
    IF ((dm_err->debug_flag > 721))
     CALL echorecord(drr_errors_encountered)
    ENDIF
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ELSEIF (dclfe_force_load_ind != 2)
    SET dm_err->eproc = "Check Operation Logfile for Errors."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(dm_err->eproc,dm_err->logfile,0)
    ENDIF
    FREE DEFINE rtl2
    SET logical dclfe_operlogfile_logical dclfe_oper_logfile
    DEFINE rtl2 "dclfe_operlogfile_logical"
    SELECT INTO "nl:"
     FROM rtl2t t
     WHERE t.line > " "
     DETAIL
      dclfe_err_type = "", dclfe_ndx = 0, dclfe_start = 0,
      dclfe_end = 0, dclfe_err_str = ""
      IF (findstring("ORA-",t.line,0) > 0)
       dclfe_err_type = "ORA-"
      ELSEIF (findstring("EXP-",t.line,0) > 0)
       dclfe_err_type = "EXP-"
      ELSEIF (findstring("IMP-",t.line,0) > 0)
       dclfe_err_type = "IMP-"
      ELSEIF (findstring("LRM-",t.line,0) > 0)
       dclfe_err_type = "LRM-"
      ELSEIF (findstring("LOG FILE NOT FOUND",t.line,0) > 0)
       dclfe_err_type = "OTHER"
      ENDIF
      IF (dclfe_err_type > "")
       IF (dclfe_err_type="OTHER")
        dclfe_err_str = "", dclfe_end = 1
       ELSE
        dclfe_start = findstring(dclfe_err_type,t.line,0), dclfe_end = findstring(" ",t.line,
         dclfe_start), dclfe_err_str = substring(dclfe_start,((dclfe_end - dclfe_start) - 1),t.line)
       ENDIF
       dclfe_ndx = 0
       IF (locateval(dclfe_ndx,1,drr_ignored_errors->cnt,dclfe_err_str,drr_ignored_errors->qual[
        dclfe_ndx].error)=0)
        IF (dclfe_add_cmd=1)
         dclfe_err_ind = 1, drr_errors_encountered->cmd_cnt = (drr_errors_encountered->cmd_cnt+ 1),
         stat = alterlist(drr_errors_encountered->qual,drr_errors_encountered->cmd_cnt),
         drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].logfile_name =
         dclfe_oper_logfile, drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].dee_op_id
          = dclfe_op_id, dclfe_add_cmd = 0
        ENDIF
        dclfe_ndx = 0
        IF (locateval(dclfe_ndx,1,drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].
         error_cnt,dclfe_err_str,drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[
         dclfe_ndx].error)=0)
         dclfe_err_cnt = (dclfe_err_cnt+ 1), drr_errors_encountered->qual[drr_errors_encountered->
         cmd_cnt].error_cnt = dclfe_err_cnt, stat = alterlist(drr_errors_encountered->qual[
          drr_errors_encountered->cmd_cnt].qual,dclfe_err_cnt),
         drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[dclfe_err_cnt].error =
         dclfe_err_str, drr_errors_encountered->qual[drr_errors_encountered->cmd_cnt].qual[
         dclfe_err_cnt].error_desc = substring(dclfe_end,(size(trim(t.line)) - dclfe_end),t.line)
        ELSE
         IF ((dm_err->debug_flag > 0))
          CALL echo(concat("Skipped ",dclfe_err_str," because already in list."))
         ENDIF
        ENDIF
       ELSE
        IF ((dm_err->debug_flag > 0))
         CALL echo(concat("Ignored error:",drr_ignored_errors->qual[dclfe_ndx].error," from file:",
          dclfe_oper_logfile))
        ENDIF
       ENDIF
      ENDIF
     WITH nocounter
    ;end select
    IF ((dm_err->debug_flag > 721))
     CALL echorecord(drr_errors_encountered)
    ENDIF
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_load_mixed_table_data(dlmtd_force_load_ind)
   DECLARE dlmtd_start = i2 WITH protect, noconstant(0)
   DECLARE dlmtd_end = i2 WITH protect, noconstant(0)
   DECLARE dlmtd_qual_cnt = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Get mixed tables"
   IF ((drr_mixed_tables_data->cnt > 0)
    AND dlmtd_force_load_ind=0)
    RETURN(1)
   ENDIF
   SET drr_mixed_tables_data->cnt = 0
   SET stat = alterlist(drr_mixed_tables_data->tbl,0)
   SELECT INTO "nl:"
    FROM dm_info di,
     dm_user_tables_actual_stats dut,
     dm_tables_doc dtd
    PLAN (di
     WHERE di.info_domain="DM2_MIXED_TABLE-*")
     JOIN (dut
     WHERE di.info_name=dut.table_name)
     JOIN (dtd
     WHERE dut.table_name=dtd.table_name)
    ORDER BY di.info_name
    HEAD di.info_name
     drr_mixed_tables_data->cnt = (drr_mixed_tables_data->cnt+ 1)
     IF (mod(drr_mixed_tables_data->cnt,10)=1)
      stat = alterlist(drr_mixed_tables_data->tbl,(drr_mixed_tables_data->cnt+ 9))
     ENDIF
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].table_name = di.info_name,
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].table_suffix = dtd.table_suffix,
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].prefix = cnvtlower(build(
       drr_clin_copy_data->ind_mixed_parfile_prefix,dtd.table_suffix)),
     dlmtd_qual_cnt = 0, drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].num_rows = dut
     .num_rows, drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].last_analyzed = dut
     .last_analyzed,
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].ref_num_rows_set_ind = 0,
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].ref_num_rows = 0.0
    DETAIL
     dlmtd_qual_cnt = (dlmtd_qual_cnt+ 1)
     IF (mod(dlmtd_qual_cnt,10)=1)
      stat = alterlist(drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].qual,(dlmtd_qual_cnt+ 9
       ))
     ENDIF
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].qual[dlmtd_qual_cnt].where_clause = di
     .info_char, dlmtd_start = 0, dlmtd_end = 0,
     dlmtd_start = (findstring("-",trim(di.info_domain),0)+ 1), dlmtd_end = findstring("-",trim(di
       .info_domain),dlmtd_start,1), drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].qual[
     dlmtd_qual_cnt].process_type = substring(dlmtd_start,(dlmtd_end - dlmtd_start),di.info_domain),
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].qual[dlmtd_qual_cnt].data_type =
     substring((dlmtd_end+ 1),(size(trim(di.info_domain)) - dlmtd_start),trim(di.info_domain))
    FOOT  di.info_name
     stat = alterlist(drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].qual,dlmtd_qual_cnt),
     drr_mixed_tables_data->tbl[drr_mixed_tables_data->cnt].where_clause_cnt = dlmtd_qual_cnt
    FOOT REPORT
     stat = alterlist(drr_mixed_tables_data->tbl,drr_mixed_tables_data->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "No Mixed Tables Exist in DM_INFO."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(drr_mixed_tables_data)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_get_exp_dmp_loc(dgedl_dmp_loc_out)
   DECLARE dgedl_strt_pt = i4 WITH protect, noconstant(0)
   DECLARE dgedl_end_pt = i4 WITH protect, noconstant(0)
   DECLARE dgedl_str = vc WITH protect, noconstant(" ")
   DECLARE dgedl_file_delim = vc WITH protect, noconstant(" ")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dgedl_file_delim = "]"
   ELSE
    SET dgedl_file_delim = "/"
   ENDIF
   SET dgedl_dmp_loc_out = "NONE"
   SET dm_err->eproc = "Verify existance of DDL Ops tables in prep for previous exp location check."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM user_tables u
    WHERE u.table_name IN ("DM2_DDL_OPS1", "DM2_DDL_OPS_LOG1")
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual != 2)
    RETURN(1)
   ENDIF
   IF ((drr_clin_copy_data->process="RESTORE")
    AND (dm2_install_schema->run_id=0))
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Check for prior export to grab location."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT
    IF ((drr_clin_copy_data->process="RESTORE")
     AND (dm2_install_schema->run_id > 0))
     FROM dm2_ddl_ops_log d
     WHERE (d.run_id=dm2_install_schema->run_id)
      AND d.op_type="IMPORT*"
      AND d.op_type != "*(REMOTE)*"
    ELSE
     FROM dm2_ddl_ops_log d
     WHERE d.op_type="EXPORT*"
      AND d.op_type != "*(REMOTE)*"
    ENDIF
    INTO "nl:"
    ORDER BY d.run_id DESC
    HEAD d.run_id
     dgedl_strt_pt = (findstring("file=",d.operation,1)+ 5), dgedl_end_pt = findstring(" ",d
      .operation,dgedl_strt_pt), dgedl_str = substring(dgedl_strt_pt,(dgedl_end_pt - dgedl_strt_pt),d
      .operation),
     dgedl_strt_pt = 0, dgedl_end_pt = 0, dgedl_end_pt = findstring(dgedl_file_delim,dgedl_str,1,1),
     dgedl_dmp_loc_out = substring(dgedl_strt_pt,(dgedl_end_pt - dgedl_strt_pt),dgedl_str)
    WITH nocounter, maxqual(d,1)
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgedl_dmp_loc_out != "NONE")
    IF (findfile(dgedl_dmp_loc_out)=0)
     SET dgedl_dmp_loc_out = "NONE"
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_val_write_privs(dvwp_full_dir)
   DECLARE full_fname = vc WITH protect
   IF (get_unique_file("dm2wrtprvtst",".dat")=0)
    RETURN(0)
   ENDIF
   SET full_fname = build(dvwp_full_dir,cnvtlower(dm_err->unique_fname))
   SELECT INTO value(full_fname)
    d.seq
    FROM (dummyt d  WITH seq = 1)
    DETAIL
     row + 1, "This is a test of writing to ", dvwp_full_dir
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    IF (dm2_push_dcl(concat("del ",dvwp_full_dir,cnvtlower(dm_err->unique_fname),";"))=0)
     RETURN(0)
    ENDIF
   ELSE
    IF (dm2_push_dcl(concat("rm ",dvwp_full_dir,cnvtlower(dm_err->unique_fname)))=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_clin_copy_restart_chk(null)
   DECLARE dccrc_run_id = f8 WITH protect, noconstant(0.0)
   DECLARE dccrc_schema_date = f8 WITH protect, noconstant(0.0)
   DECLARE dccrc_ops_complete = i2 WITH protect, noconstant(0)
   DECLARE dccrc_ops_tbl_fnd = i2 WITH protect, noconstant(0)
   DECLARE dccrc_ops_log_tbl_fnd = i2 WITH protect, noconstant(0)
   DECLARE dccrc_running_ind = i2 WITH protect, noconstant(0)
   DECLARE dccrc_mig_dbx_tab_cnt = i2 WITH protect, noconstant(0)
   IF ((drr_clin_copy_data->starting_point != "DM2NOTSET"))
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Check status of DDL tables"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM user_tables u
    WHERE u.table_name IN ("DM2_DDL_OPS1", "DM2_DDL_OPS_LOG1")
    DETAIL
     IF (u.table_name="DM2_DDL_OPS1")
      dccrc_ops_tbl_fnd = 1
     ELSE
      dccrc_ops_log_tbl_fnd = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dccrc_ops_log_tbl_fnd=1)
    IF (dm2_cleanup_stranded_appl(null)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Get max Clin Copy run id from Target and determine if any are RUNNING."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_ddl_ops_log d
     WHERE d.run_id IN (
     (SELECT
      max(r.run_id)
      FROM dm2_ddl_ops r
      WHERE r.process_option="CLIN COPY*"
       AND (r.run_id > dm2_install_schema->src_run_id)))
      AND d.status="RUNNING"
     DETAIL
      dccrc_running_ind = 1
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((drr_clin_copy_data->process="RESTORE"))
    IF (((dccrc_ops_tbl_fnd=0) OR (dccrc_ops_log_tbl_fnd=0)) )
     SET dm_err->emsg = "Error:Missing one or both DDL tables"
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc =
    "Get max Clin Copy run id from Target that is greater than Source Clin Copy run id."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_ddl_ops d
     WHERE d.run_id IN (
     (SELECT
      max(r.run_id)
      FROM dm2_ddl_ops r
      WHERE r.process_option="CLIN COPY*"
       AND (r.run_id > dm2_install_schema->src_run_id)))
     DETAIL
      dccrc_run_id = d.run_id, dccrc_schema_date = d.schema_date
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSEIF (curqual=0)
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     RETURN(1)
    ENDIF
    SET dm_err->eproc = build("Find operations for run id ",dccrc_run_id)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_ddl_ops_log d
     WHERE d.run_id=dccrc_run_id
     DETAIL
      IF (d.status="COMPLETE")
       dccrc_ops_complete = 1
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dccrc_ops_complete=0)
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     IF (dccrc_running_ind=1)
      SET dm_err->eproc = concat("Replicate to be restarted - (Run Id ",trim(cnvtstring(dccrc_run_id)
        ),").  Checking for RUNNING operations.")
      SET dm_err->emsg = "Cannot start process from beginning, operations still in RUNNING status."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (curqual > 0)
      SET dm_err->eproc = build("Delete ops for Clin Copy run id ",dccrc_run_id)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      DELETE  FROM dm2_ddl_ops_log a
       WHERE a.run_id=dccrc_run_id
       WITH nocounter
      ;end delete
      IF (check_error(dm_err->eproc)=1)
       ROLLBACK
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ELSE
       COMMIT
      ENDIF
     ENDIF
     SET dm_err->eproc = build("Delete from DM2_DDL_OPS for Clin Copy run id ",dm2_install_schema->
      run_id)
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     DELETE  FROM dm2_ddl_ops
      WHERE run_id=dccrc_run_id
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      COMMIT
     ENDIF
     RETURN(1)
    ELSE
     SET drr_clin_copy_data->starting_point = "DDL_EXECUTION"
     SET dm2_install_schema->run_id = dccrc_run_id
     SET dm2_install_schema->schema_prefix = "dm2s"
     SET dm2_install_schema->file_prefix = cnvtalphanum(format(dccrc_schema_date,"MM/DD/YYYY;;D"))
    ENDIF
   ELSEIF ((drr_clin_copy_data->process="PRESERVE"))
    IF (((dccrc_ops_tbl_fnd=0) OR (dccrc_ops_log_tbl_fnd=0)) )
     SET dm_err->emsg = "Error:Missing one or both DDL tables"
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Get Clin Copy-Preserve run id from Target."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_ddl_ops d
     WHERE d.process_option="CLIN COPY-PRESERVE"
     DETAIL
      dccrc_run_id = d.run_id
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual > 0
     AND (der_expimp_data->preserve_from_begin=1))
     IF (dccrc_running_ind=1)
      SET dm_err->eproc = concat("Replicate to be restarted - (Run Id ",trim(cnvtstring(dccrc_run_id)
        ),").  Checking for RUNNING operations.")
      SET dm_err->emsg = "Cannot start process from beginning, operations still in RUNNING status."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Delete Clin Copy-Preserve DM2_DDL_OPS_LOG rows."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     DELETE  FROM dm2_ddl_ops_log d
      WHERE (d.run_id=
      (SELECT
       a.run_id
       FROM dm2_ddl_ops a
       WHERE a.process_option="CLIN COPY-PRESERVE"))
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      COMMIT
     ENDIF
     SET dm_err->eproc = "Delete Clin Copy-Preserve DM2_DDL_OPS rows."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     DELETE  FROM dm2_ddl_ops d
      WHERE d.process_option="CLIN COPY-PRESERVE"
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     COMMIT
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     RETURN(1)
    ELSEIF (curqual > 0
     AND (der_expimp_data->preserve_from_begin=0))
     SET dm2_install_schema->run_id = dccrc_run_id
     SET drr_clin_copy_data->starting_point = "DDL_EXECUTION"
     RETURN(1)
    ELSE
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     RETURN(1)
    ENDIF
   ELSE
    IF ((drr_clin_copy_data->process="MIGRATION")
     AND validate(dm2_mig_dbx_in_use,- (1))=1)
     SET dm_err->eproc = "Check if DBX tables exist"
     SELECT INTO "nl:"
      dbx_tab_cnt = count(*)
      FROM dba_tables
      WHERE owner="DBX"
       AND table_name="DBX_OPS"
      DETAIL
       dccrc_mig_dbx_tab_cnt = dbx_tab_cnt
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (dccrc_mig_dbx_tab_cnt > 0)
      SET drr_clin_copy_data->starting_point = "DDL_EXECUTION"
      RETURN(1)
     ELSE
      SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
      RETURN(1)
     ENDIF
    ENDIF
    IF (((dccrc_ops_tbl_fnd=0) OR (dccrc_ops_log_tbl_fnd=0)) )
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     RETURN(1)
    ELSEIF (dccrc_ops_tbl_fnd=1
     AND dccrc_ops_log_tbl_fnd=0)
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     RETURN(1)
    ELSEIF (dccrc_ops_tbl_fnd=0
     AND dccrc_ops_log_tbl_fnd=1)
     SET dm_err->emsg = "Error:Only DM2_DDL_OPS_LOG exists"
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (drr_get_max_clin_copy_run_id(dccrc_run_id)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Check for completed operations other than export ops"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SELECT
     IF ((drr_clin_copy_data->process="MIGRATION"))
      FROM dm2_ddl_ops_log d
      WHERE d.run_id=dccrc_run_id
       AND d.op_type="CREATE TABLE"
       AND d.status IN ("COMPLETE", "RUNNING")
     ELSE
      FROM dm2_ddl_ops_log d
      WHERE d.run_id=dccrc_run_id
       AND d.op_type != "*EXPORT*"
       AND d.status IN ("COMPLETE", "RUNNING")
     ENDIF
     INTO "nl:"
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual=0)
     SET drr_clin_copy_data->starting_point = "FROM_BEGINNING"
     IF (dccrc_running_ind=1)
      SET dm_err->eproc = concat("Replicate to be restarted - (Run Id ",trim(cnvtstring(dccrc_run_id)
        ),").  Checking for RUNNING operations.")
      SET dm_err->emsg = "Cannot start process from beginning, operations still in RUNNING status."
      SET dm_err->err_ind = 1
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     RETURN(1)
    ELSE
     SET drr_clin_copy_data->starting_point = "DDL_EXECUTION"
     SET dm2_install_schema->run_id = dccrc_run_id
    ENDIF
   ENDIF
   SET dm_err->eproc = "Check for import ops which have failed (except for expired applid)"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm2_ddl_ops_log d
    WHERE d.run_id=dccrc_run_id
     AND d.op_type="IMPORT*"
     AND d.op_type != "*(REMOTE)*"
     AND d.status="ERROR"
     AND  NOT (substring(1,14,d.error_msg)="Application Id")
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual > 0)
    SET drr_clin_copy_data->create_truncate_cmds = 1
   ENDIF
   SET dm_err->eproc = "Check for refresh process ddl rows"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm2_ddl_ops_log d
    WHERE d.run_id=dccrc_run_id
     AND d.op_type="*PRESERVED DATA*"
     AND (( NOT (substring(1,14,d.error_msg)="Application Id")) OR (d.error_msg=null))
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual > 0)
    SET drr_preserved_tables_data->refresh_ind = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_clin_copy_setup(dccs_whereto)
   DECLARE dccs_exp_loc = vc WITH protect, noconstant("")
   DECLARE dccs_src_dbase_name = vc WITH protect, noconstant("")
   DECLARE dccs_log_prefix = vc WITH protect, noconstant("")
   DECLARE dccs_tgt_dbase_name = vc WITH protect, noconstant("")
   DECLARE dccs_ndx = i4 WITH protect, noconstant(0)
   DECLARE dccs_src_created_date = f8 WITH protect, noconstant(0.0)
   DECLARE dccs_tgt_created_date = f8 WITH protect, noconstant(0.0)
   DECLARE dccs_run_id = f8 WITH protect, noconstant(0.0)
   DECLARE dccs_row = i4 WITH protect, noconstant(0)
   DECLARE dccs_admin_dminfo_name = vc WITH protect, noconstant("")
   DECLARE dccs_ads_domain_ind = i2 WITH protect, noconstant(0)
   DECLARE dccs_refresh_row = i4 WITH protect, noconstant(0)
   DECLARE dccs_response = c1 WITH protect, noconstant(" ")
   DECLARE dccs_tgt_host = vc WITH protect, noconstant(" ")
   DECLARE dccs_str = vc WITH protect, noconstant("")
   DECLARE dccs_ret = vc WITH protect, noconstant("")
   DECLARE dccs_slash = vc WITH protect, noconstant("\\")
   DECLARE dccs_file = vc WITH protect, noconstant("")
   DECLARE misc_data_item = vc WITH protect, noconstant("")
   DECLARE misc_data_item_value = vc WITH protect, noconstant("")
   DECLARE dccs_reg_file = vc WITH protect, noconstant("")
   DECLARE dccs_cmd = vc WITH protect, noconstant("")
   DECLARE dccs_restore = vc WITH protect, noconstant("")
   DECLARE dccs_was_ind = i2 WITH protect, noconstant(0)
   DECLARE dccs_src_host = vc WITH protect, noconstant("")
   DECLARE dccs_part_enabled_ind = i2 WITH protect, noconstant(0)
   DECLARE dccs_part_usage_ind = i2 WITH protect, noconstant(0)
   DECLARE dccs_tgt_ora_ver = i2 WITH protect, noconstant(0)
   FREE RECORD dccs_env
   RECORD dccs_env(
     1 env_cnt = i4
     1 qual[*]
       2 env_name = vc
       2 env_id = f8
       2 database_name = vc
   )
   FREE RECORD dccs_data_move
   RECORD dccs_data_move(
     1 cnt = i4
     1 qual[*]
       2 name = vc
       2 desc = vc
   )
   SET dccs_data_move->cnt = 4
   SET stat = alterlist(dccs_data_move->qual,4)
   SET dccs_data_move->qual[1].name = "REF"
   SET dccs_data_move->qual[1].desc = "Reference Data Only"
   SET dccs_data_move->qual[2].name = "ALL"
   SET dccs_data_move->qual[2].desc = "Reference and Activity Data"
   SET dccs_data_move->qual[3].name = "ADS"
   SET dccs_data_move->qual[3].desc = "Reference with Activity Data Sample"
   SET dccs_data_move->qual[4].name = "PRG"
   SET dccs_data_move->qual[4].desc = "Activity Data Purge"
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dm2_install_schema->cdba_p_word = drrr_rf_data->adm_db_user_pwd
    SET dm2_install_schema->cdba_connect_str = drrr_rf_data->adm_db_cnct_str
    SET dm2_install_schema->src_v500_p_word = drrr_rf_data->src_db_user_pwd
    SET dm2_install_schema->src_v500_connect_str = drrr_rf_data->src_db_cnct_str
    SET drr_clin_copy_data->src_domain_name = drrr_rf_data->src_domain_name
    SET dm2_install_schema->v500_p_word = drrr_rf_data->tgt_db_user_pwd
    SET dm2_install_schema->v500_connect_str = drrr_rf_data->tgt_db_cnct_str
    SET dm2_install_schema->schema_prefix = "dm2s"
    SET dm2_install_schema->file_prefix = cnvtalphanum(drrr_rf_data->tgt_capture_schema_date)
    IF ((drrr_rf_data->tgt_db_copy_type="ALTERNATE"))
     SET dm2_install_schema->data_to_move = "ALL"
     SET drr_clin_copy_data->process = "RESTORE"
    ELSEIF ((drrr_rf_data->tgt_db_copy_type="REFERENCE"))
     SET dm2_install_schema->data_to_move = "REF"
    ELSEIF ((drrr_rf_data->tgt_db_copy_type="ALL"))
     SET dm2_install_schema->data_to_move = "ALL"
    ELSEIF ((drrr_rf_data->tgt_db_copy_type="ADS"))
     SET dm2_install_schema->data_to_move = "ADS"
    ENDIF
    SET drr_clin_copy_data->tgt_env_name = cnvtupper(drrr_rf_data->tgt_env_name)
    SET drr_clin_copy_data->tgt_db_env_name = cnvtupper(drrr_rf_data->tgt_db_env_name)
    SET dm2_install_schema->percent_tspace = drrr_rf_data->tgt_tspace_increase_pct
    IF ((drrr_rf_data->tgt_db_copy_type="ALTERNATE"))
     SET dm2_install_schema->percent_tspace = 10
    ENDIF
    SET drr_clin_copy_data->temp_location = drrr_rf_data->tgt_app_temp_dir
    IF (findstring(drr_clin_copy_data->tgt_env_name,drr_clin_copy_data->temp_location,1,0)=0)
     SET drr_clin_copy_data->temp_location = concat(drr_clin_copy_data->temp_location,cnvtlower(
       drr_clin_copy_data->tgt_env_name),"/")
    ENDIF
    SET dccs_restore = evaluate(drrr_rf_data->tgt_restore_preserve_data,"YES","Y","N")
    SET drr_clin_copy_data->tgt_mock_env = 1
   ENDIF
   SET dm_err->eproc = "ADMIN CONNECTION"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm2_install_schema->dbase_name = "ADMIN"
   SET dm2_install_schema->u_name = "CDBA"
   IF ((drr_clin_copy_data->process="MIGRATION")
    AND validate(dmr_mig_data->adm_cdba_pwd,"DM2NOTSET") != "DM2NOTSET"
    AND validate(dmr_mig_data->adm_cdba_cnct_str,"DM2NOTSET") != "DM2NOTSET")
    SET dm2_install_schema->p_word = dmr_mig_data->adm_cdba_pwd
    SET dm2_install_schema->connect_str = dmr_mig_data->adm_cdba_cnct_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->cdba_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->cdba_connect_str = dm2_install_schema->connect_str
   ELSEIF ((dm2_install_schema->cdba_p_word != "NONE")
    AND (dm2_install_schema->cdba_connect_str != "NONE"))
    SET dm2_install_schema->p_word = dm2_install_schema->cdba_p_word
    SET dm2_install_schema->connect_str = dm2_install_schema->cdba_connect_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    SET dm2_force_connect_string = 1
    EXECUTE dm2_connect_to_dbase "PC"
    SET dm2_force_connect_string = 0
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->cdba_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->cdba_connect_str = dm2_install_schema->connect_str
   ENDIF
   SET dm_err->eproc = "Populate environemnt listing while connected to admin."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_environment d
    ORDER BY d.environment_id DESC
    DETAIL
     dccs_env->env_cnt = (dccs_env->env_cnt+ 1), stat = alterlist(dccs_env->qual,dccs_env->env_cnt),
     dccs_env->qual[dccs_env->env_cnt].env_name = cnvtupper(d.environment_name),
     dccs_env->qual[dccs_env->env_cnt].env_id = d.environment_id, dccs_env->qual[dccs_env->env_cnt].
     database_name = d.database_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "SOURCE CONNECTION"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm2_install_schema->dbase_name = '"SOURCE"'
   SET dm2_install_schema->u_name = "V500"
   IF ((drr_clin_copy_data->process="MIGRATION")
    AND validate(dmr_mig_data->src_v500_pwd,"DM2NOTSET") != "DM2NOTSET"
    AND validate(dmr_mig_data->src_v500_cnct_str,"DM2NOTSET") != "DM2NOTSET")
    SET dm2_install_schema->p_word = dmr_mig_data->src_v500_pwd
    SET dm2_install_schema->connect_str = dmr_mig_data->src_v500_cnct_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->src_v500_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->src_v500_connect_str = dm2_install_schema->connect_str
   ELSEIF ((dm2_install_schema->src_v500_p_word != "NONE")
    AND (dm2_install_schema->src_v500_connect_str != "NONE"))
    SET dm2_install_schema->p_word = dm2_install_schema->src_v500_p_word
    SET dm2_install_schema->connect_str = dm2_install_schema->src_v500_connect_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    SET dm2_force_connect_string = 1
    EXECUTE dm2_connect_to_dbase "PC"
    SET dm2_force_connect_string = 0
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->src_v500_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->src_v500_connect_str = dm2_install_schema->connect_str
   ENDIF
   IF ((dm2_db_options->load_ind=0))
    EXECUTE dm2_set_db_options
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = "Get source environment_name."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_info d,
     dm_environment de
    PLAN (d
     WHERE d.info_domain="DATA MANAGEMENT"
      AND d.info_name="DM_ENV_ID")
     JOIN (de
     WHERE d.info_number=de.environment_id)
    DETAIL
     drr_clin_copy_data->src_env_name = cnvtupper(de.environment_name), drr_clin_copy_data->
     src_env_id = de.environment_id
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dccs_src_dbase_name = currdbname
   SET dm2_install_schema->src_dbase_name = dccs_src_dbase_name
   IF (drr_get_dbase_created_date(dccs_src_created_date)=0)
    RETURN(0)
   ENDIF
   SET drr_clin_copy_data->src_db_created = dccs_src_created_date
   SET dm_err->eproc = "Get Source node name"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM v$instance v
    DETAIL
     dccs_src_host = v.host_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drr_get_max_clin_copy_run_id(dccs_run_id)=0)
    RETURN(0)
   ENDIF
   SET dm2_install_schema->src_run_id = dccs_run_id
   SET dm_err->eproc = "Check if source has partitioning option enabled and has partitioned objects."
   CALL disp_msg("",dm_err->logfile,0)
   IF (dpr_identify_partition_usage(1,dccs_part_enabled_ind,dccs_part_usage_ind)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "TARGET CONNECTION."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET dm2_install_schema->dbase_name = '"TARGET"'
   SET dm2_install_schema->u_name = "V500"
   IF ((drr_clin_copy_data->process="MIGRATION")
    AND validate(dmr_mig_data->tgt_v500_pwd,"DM2NOTSET") != "DM2NOTSET"
    AND validate(dmr_mig_data->tgt_v500_cnct_str,"DM2NOTSET") != "DM2NOTSET")
    SET dm2_install_schema->p_word = dmr_mig_data->tgt_v500_pwd
    SET dm2_install_schema->connect_str = dmr_mig_data->tgt_v500_cnct_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->v500_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->v500_connect_str = dm2_install_schema->connect_str
   ELSEIF ((dm2_install_schema->v500_p_word != "NONE")
    AND (dm2_install_schema->v500_connect_str != "NONE"))
    SET dm2_install_schema->p_word = dm2_install_schema->v500_p_word
    SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ELSE
    SET dm2_force_connect_string = 1
    EXECUTE dm2_connect_to_dbase "PC"
    SET dm2_force_connect_string = 0
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    SET dm2_install_schema->v500_p_word = dm2_install_schema->p_word
    SET dm2_install_schema->v500_connect_str = dm2_install_schema->connect_str
   ENDIF
   SET dm_err->eproc = "Validate Database Connect Information"
   SET dccs_tgt_dbase_name = currdbname
   SET dm2_install_schema->target_dbase_name = dccs_tgt_dbase_name
   IF (dccs_tgt_dbase_name=dccs_src_dbase_name
    AND (validate(dm2_allow_same_db_name,- (1))=- (1)))
    SET message = nowindow
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Source:",dccs_src_dbase_name," and Target:",trim(dccs_tgt_dbase_name),
     " databases may not be the same.")
    SET dm2_install_schema->p_word = "NONE"
    SET dm2_install_schema->v500_p_word = "NONE"
    SET dm2_install_schema->v500_connect_str = "NONE"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drr_get_dbase_created_date(dccs_tgt_created_date)=0)
    RETURN(0)
   ENDIF
   SET drr_clin_copy_data->tgt_db_created = dccs_tgt_created_date
   SET dccs_tgt_ora_ver = dm2_rdbms_version->level1
   SET dm_err->eproc = concat("Get Target node name")
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM v$instance v
    DETAIL
     dccs_tgt_host = v.host_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dccs_part_usage_ind=1)
    SET dm_err->eproc = "Check if target partitioning option is enabled."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dpr_identify_partition_usage(0,dccs_part_enabled_ind,dccs_part_usage_ind)=0)
     RETURN(0)
    ENDIF
    IF (dccs_part_enabled_ind=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat(
      "Target partitioning option (v$option) is disabled and Source has partitioned objects. ",
      "Partitioning must be enabled in Target to proceed.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dccs_ndx = locateval(dccs_ndx,1,size(dccs_env->qual,5),cnvtupper(drr_clin_copy_data->
      tgt_db_env_name),dccs_env->qual[dccs_ndx].env_name)
    IF (dccs_ndx=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Unable to obtain environment_id for environment_name:",cnvtupper(
       drr_clin_copy_data->tgt_db_env_name))
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET drr_clin_copy_data->tgt_env_id = dccs_env->qual[dccs_ndx].env_id
    ENDIF
   ELSE
    SET dm_err->eproc = "Get environment name via environment logical"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SET drr_clin_copy_data->tgt_env_name = cnvtupper(logical("environment"))
    IF ((dm_err->debug_flag=722))
     SET message = nowindow
    ELSE
     SET message = window
    ENDIF
    CALL clear(1,1)
    CALL box(1,1,5,131)
    CALL text(3,8,"Enter TARGET environment name :                  ")
    SET help =
    SELECT INTO "nl:"
     environment_name____________ = dccs_env->qual[d.seq].env_name
     FROM (dummyt d  WITH seq = size(dccs_env->qual,5))
     PLAN (d
      WHERE d.seq > 0)
     WITH nocounter
    ;end select
    SET validate =
    SELECT INTO "nl:"
     dccs_env->qual[d.seq].env_name
     FROM (dummyt d  WITH seq = size(dccs_env->qual,5))
     PLAN (d
      WHERE d.seq > 0)
     WITH nocounter
    ;end select
    CALL accept(3,70,"P(20);CUF"
     WHERE  NOT (curaccept=" "))
    SET drr_clin_copy_data->tgt_db_env_name = dccs_env->qual[curhelp].env_name
    SET drr_clin_copy_data->tgt_env_id = dccs_env->qual[curhelp].env_id
    SET dm2_install_schema->target_dbase_name = dccs_env->qual[curhelp].database_name
    SET validate = off
    SET help = off
    SET message = window
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("drr_clin_copy_data->tgt_env_id = ",drr_clin_copy_data->tgt_env_id))
    CALL echo(build("drr_clin_copy_data->tgt_env_name = ",drr_clin_copy_data->tgt_env_name))
    CALL echo(build("drr_clin_copy_data->src_env_id = ",drr_clin_copy_data->src_env_id))
    CALL echo(build("drr_clin_copy_data->src_env_name = ",drr_clin_copy_data->src_env_name))
    CALL echo(build("drr_clin_copy_data->tgt_db_env_name = ",drr_clin_copy_data->tgt_db_env_name))
   ENDIF
   SET drr_clin_copy_data->standalone_expimp_process = 1
   IF ( NOT ((drr_clin_copy_data->process IN ("MIGRATION", "RESTORE"))))
    IF ((drr_clin_copy_data->standalone_expimp_process=1))
     SET dm2_install_schema->dbase_name = "ADMIN"
     SET dm2_install_schema->u_name = "CDBA"
     SET dm2_install_schema->p_word = dm2_install_schema->cdba_p_word
     SET dm2_install_schema->connect_str = dm2_install_schema->cdba_connect_str
     EXECUTE dm2_connect_to_dbase "CO"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     IF (der_manage_admin_data(dm2_install_schema->target_dbase_name,"DM_INFO","S","ALL","")=0)
      RETURN(0)
     ENDIF
     IF ((der_expimp_data->setup_complete_ind=0))
      SET message = nowindow
      SET dm_err->err_ind = 1
      SET dm_err->eproc = "Validating standalone export/import setup work has been completed."
      SET dm_err->emsg = "Setup work not completed for standalone export/import process."
      SET dm2_install_schema->p_word = "NONE"
      SET dm2_install_schema->v500_p_word = "NONE"
      SET dm2_install_schema->v500_connect_str = "NONE"
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dm2_install_schema->dbase_name = dm2_install_schema->target_dbase_name
     SET dm2_install_schema->u_name = "V500"
     SET dm2_install_schema->p_word = dm2_install_schema->v500_p_word
     SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
     EXECUTE dm2_connect_to_dbase "CO"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     IF (drr_validate_ref_data_link(null)=0)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Look for ADS license key on Source DM_INFO."
     CALL disp_msg("",dm_err->logfile,0)
     SELECT INTO "nl:"
      FROM dm_info@ref_data_link
      WHERE info_domain="DM2_ADS_REPLICATE"
       AND info_name="LICENSE_KEY"
       AND info_number=214
      DETAIL
       drr_clin_copy_data->licensed_to_ads = 1
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (validate(drrr_responsefile_in_use,0)=1)
      IF ((drr_clin_copy_data->licensed_to_ads=0)
       AND (drrr_rf_data->tgt_db_copy_type="ADS"))
       SET dm_err->emsg = "Database is missing ADS license."
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
   ELSEIF ((drr_clin_copy_data->process="MIGRATION"))
    SET drr_clin_copy_data->standalone_expimp_process = 0
   ENDIF
   IF ((drr_clin_copy_data->process != "MIGRATION"))
    SET dccs_str = concat(dccs_slash,"environment",dccs_slash,drr_clin_copy_data->tgt_env_name,
     " domain")
    IF (get_unique_file("ddr_get_reg",evaluate(dm2_sys_misc->cur_os,"AXP",".com",".ksh"))=0)
     RETURN(0)
    ELSE
     SET dccs_reg_file = dm_err->unique_fname
    ENDIF
    SET dm_err->eproc = concat("Create file to obtain target registry info:",dccs_reg_file)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg(" ",dm_err->logfile,0)
    ENDIF
    SELECT INTO value(dccs_reg_file)
     DETAIL
      IF ((dm2_sys_misc->cur_os="AXP"))
       CALL print(concat("$ mcr cer_exe:lreg -getp ",dccs_str)), row + 1,
       CALL print("$ write sys$output lreg_result"),
       row + 1
      ELSE
       CALL print(concat("$cer_exe/lreg -getp ",dccs_str)), row + 1
      ENDIF
     WITH nocounter, maxcol = 500, format = variable,
      maxrow = 1
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Operation for registry:",dccs_str)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dccs_cmd = concat("@",dccs_reg_file)
    ELSE
     SET dccs_cmd = concat(". $CCLUSERDIR/",dccs_reg_file)
    ENDIF
    SET dm_err->disp_dcl_err_ind = 0
    SET dccs_no_error = dm2_push_dcl(dccs_cmd)
    IF (dccs_no_error=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ELSE
     IF (parse_errfile(dm_err->errfile)=0)
      RETURN(0)
     ENDIF
     IF ((dm_err->debug_flag > 0))
      CALL echorecord(dm_err)
     ENDIF
    ENDIF
    IF (((findstring("unable",dm_err->errtext,1,1)) OR ((((dm_err->errtext="")) OR (((findstring(
     "key not found",dm_err->errtext,1,1)) OR (findstring("property not found",dm_err->errtext,1,1)
    )) )) )) )
     SET dccs_no_error = 1
     SET dccs_ret = "NOPARMRETURNED"
    ELSE
     SET dccs_ret = dm_err->errtext
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("parm_value:",dccs_ret))
    ENDIF
    IF (dccs_no_error=0)
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (cnvtupper(dccs_ret)="NOPARMRETURNED")
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Retieving domain name for Target environment ",drr_clin_copy_data->
      tgt_env_name)
     SET dm_err->emsg = "Failed to retrieve domain name for Target."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     SET drr_clin_copy_data->tgt_domain_name = cnvtupper(dccs_ret)
    ENDIF
   ENDIF
   IF (drr_clin_copy_restart_chk(null)=0)
    RETURN(0)
   ENDIF
   IF ((drr_clin_copy_data->starting_point="DDL_EXECUTION"))
    SET message = nowindow
    IF ((drr_clin_copy_data->standalone_expimp_process=0))
     SET dm_err->eproc = "Pull directory location for completed export operations"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     IF (drr_get_exp_dmp_loc(dccs_exp_loc)=0)
      RETURN(0)
     ENDIF
     IF (dccs_exp_loc="NONE"
      AND  NOT ((drr_clin_copy_data->process IN ("RESTORE", "MIGRATION"))))
      SET dm_err->err_ind = 1
      SET dm_err->emsg = "Could not find logfile location for completed export operation."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET drr_clin_copy_data->temp_location = dccs_exp_loc
     ENDIF
    ENDIF
    SET dm_err->eproc = "Retrieve All stored information from Admin DM_INFO."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm2_admin_dm_info di
     WHERE di.info_domain="DM2_REPLICATE_DATA"
      AND di.info_name=patstring(cnvtupper(build(dm2_install_schema->target_dbase_name,"*")))
     DETAIL
      IF (di.info_name="*DATA_TO_MOVE")
       dm2_install_schema->data_to_move = di.info_char
      ELSEIF (di.info_name="*_TEMP_LOCATION")
       drr_clin_copy_data->temp_location = di.info_char
      ELSEIF (di.info_name="*_PERCENT_TSPACE")
       dm2_install_schema->percent_tspace = cnvtreal(di.info_char)
      ELSEIF (di.info_name="*_SRC_DOMAIN_NAME")
       drr_clin_copy_data->src_domain_name = di.info_char
      ELSEIF (di.info_name="*_RESTORE_PREV_TGT_DATA_IND")
       IF (di.info_char="Y")
        drr_preserved_tables_data->refresh_ind = 1
       ENDIF
      ELSEIF (di.info_name="*_WAS_ARCH_IND")
       IF (di.info_char="Y")
        drr_clin_copy_data->tgt_was_ind = 1
       ENDIF
      ELSEIF (di.info_name="*ADS_CONFIG_NAME")
       drr_clin_copy_data->ads_name = di.info_char, drr_clin_copy_data->ads_mod_dt_tm = di.info_date
      ELSEIF (di.info_name="*ADS_CONFIG_PCT")
       drr_clin_copy_data->ads_pct = di.info_number
      ELSEIF (di.info_name="*ADS_CONFIG_ID")
       drr_clin_copy_data->ads_config_id = di.info_number, drr_clin_copy_data->ads_chosen_ind = 1
      ELSEIF (di.info_name="*ADS_PURGE")
       drr_clin_copy_data->purge_chosen_ind = 1
      ELSEIF (di.info_name="*DDL_EXCL_RPT")
       IF (di.info_number=0)
        drr_clin_copy_data->ddl_excl_rpt_name = di.info_char
       ENDIF
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 5))
     CALL echorecord(drr_clin_copy_data)
    ENDIF
    CALL drr_set_src_env_path(null)
    IF ( NOT ((dm2_install_schema->data_to_move IN ("REF", "ALL"))))
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Invalid DATA_TO_MOVE value ",trim(dm2_install_schema->data_to_move),
      " found in DM2_ADMIN_DM_INFO on Replicate restart.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    RETURN(1)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=0)
    SET dm_err->eproc = "Displaying Clin Copy Window"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dm_err->debug_flag=722))
     SET message = nowindow
    ELSE
     SET message = window
    ENDIF
    CALL clear(1,1)
    CALL box(1,1,24,131)
   ENDIF
   IF ((drr_clin_copy_data->process="RESTORE"))
    IF (validate(drrr_responsefile_in_use,0)=0)
     CALL text(2,2,"Complete Copy of Clinical Database (Alternate Database Restore Method)")
     CALL text(4,8,"Restore data previously saved from TARGET database (Y/N) : ")
     CALL accept(4,70,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     SET dccs_restore = curaccept
     SET dccs_row = 4
     IF (dccs_restore="Y")
      SET dccs_row = (dccs_row+ 2)
      CALL drr_prompt_schema_date(dccs_row)
     ENDIF
     SET dccs_row = (dccs_row+ 2)
     IF (drr_prompt_loc(dccs_row,"IMPORT")=0)
      RETURN(0)
     ENDIF
     SET dm2_install_schema->data_to_move = "ALL"
     SET dm2_install_schema->percent_tspace = 10
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,
      "Subsequent processing should NOT be performed against a production database.")
     SET dccs_row = (dccs_row+ 1)
     CALL text(dccs_row,8,
      "Please confirm that the following database represents a NON-production domain.")
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,"Is the TARGET database a Production domain (Y/N): ")
     CALL accept(dccs_row,70,"A;cu","Y"
      WHERE curaccept IN ("Y", "N"))
     IF (curaccept="Y")
      SET message = nowindow
      SET dm_err->err_ind = 1
      SET dm_err->emsg = "This process should not be against a production database."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ELSEIF ((drr_clin_copy_data->process="MIGRATION"))
    CALL text(2,2,"Create a Copy of a Clinical Database")
    SET dccs_row = 2
    SET dccs_row = (dccs_row+ 2)
    CALL drr_prompt_schema_date(dccs_row)
    SET dm2_install_schema->data_to_move = "ALL"
    SET dccs_row = (dccs_row+ 2)
    IF (validate(dm2_mig_dbx_in_use,- (1)) != 1)
     CALL text(dccs_row,8,"Adjust tablespace size in target by what percent. (i.e. 10 or -10): ")
     SET dm2_install_schema->percent_tspace = 0
     CALL accept(dccs_row,77,"N(3)",dm2_install_schema->percent_tspace
      WHERE (curaccept > - (100))
       AND curaccept < 100)
     SET dm2_install_schema->percent_tspace = cnvtint(curaccept)
     SET drr_clin_copy_data->temp_location = dm2_install_schema->ccluserdir
     SET dccs_restore = "N"
    ENDIF
   ELSE
    IF (validate(drrr_responsefile_in_use,0)=0)
     CALL text(2,2,"Create a Copy of a Clinical Database")
     SET dccs_row = 2
     SET dccs_row = (dccs_row+ 2)
     CALL drr_prompt_schema_date(dccs_row)
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,"Data to move : ")
     IF ((drr_clin_copy_data->licensed_to_ads=1)
      AND (dm2_sys_misc->cur_db_os != "AXP"))
      SET help = pos(1,60,10,70)
      SET help =
      SELECT INTO "nl:"
       value = substring(1,6,dccs_data_move->qual[t.seq].name), description = substring(1,40,
        dccs_data_move->qual[t.seq].desc)
       FROM (dummyt t  WITH seq = value(dccs_data_move->cnt))
       WITH nocounter
      ;end select
      CALL accept(dccs_row,70,"P(6);CSF")
     ELSE
      SET help = fix('REF" - Reference Data Only",ALL" - Reference and Activity Data"')
      CALL accept(dccs_row,70,"P(3);CSF")
     ENDIF
     SET dm2_install_schema->data_to_move = build(cnvtupper(trim(curaccept)))
     SET help = off
    ENDIF
    IF ((dm2_install_schema->data_to_move IN ("ADS", "PRG")))
     IF ((dm2_install_schema->data_to_move="PRG"))
      SET drr_clin_copy_data->purge_chosen_ind = 1
     ENDIF
     SET dm2_install_schema->data_to_move = "ALL"
     SET drr_clin_copy_data->ads_chosen_ind = 1
     IF (drr_ads_domain_check("ref_data_link",dccs_ads_domain_ind)=0)
      RETURN(0)
     ENDIF
     IF (dccs_ads_domain_ind=1)
      IF (validate(drrr_responsefile_in_use,0)=0)
       SET dccs_refresh_row = dccs_row
       SET dccs_row = (dccs_row+ 2)
       CALL text(dccs_row,8,
        "WARNING : The Source database for this Replicate is already a ADS Domain.")
       SET dccs_row = (dccs_row+ 1)
       CALL text(dccs_row,8,"Do you wish to (C)ontinue or (Q)uit?")
       SET dccs_row = (dccs_row+ 4)
       CALL text(dccs_row,8,"Enter 'C' to continue or 'Q' to quit (C or Q) :")
       CALL accept(dccs_row,70,"A;cu"," "
        WHERE curaccept IN ("Q", "C"))
       IF (curaccept="Q")
        SET message = nowindow
        SET dm_err->err_ind = 1
        SET dm_err->emsg =
        "User choose to quit due to Source database for this Replicate is already a ADS Domain."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       CALL clear((dccs_refresh_row+ 2),8,120)
       CALL clear((dccs_refresh_row+ 3),8,120)
       CALL clear(dccs_row,8,120)
       SET dccs_row = dccs_refresh_row
      ELSE
       IF ((drrr_rf_data->src_ads_domain_ind=0))
        SET dm_err->err_ind = 1
        SET dm_err->emsg = "Quit due to Source database for this Replicate is already a ADS Domain."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
    IF (validate(drrr_responsefile_in_use,0)=0)
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,"Increase tablespace size in target by what percent : ")
     SET dm2_install_schema->percent_tspace = 10
     CALL accept(dccs_row,70,"9(3)",dm2_install_schema->percent_tspace
      WHERE curaccept > 0
       AND curaccept < 100)
     SET dm2_install_schema->percent_tspace = cnvtint(curaccept)
     SET dccs_row = (dccs_row+ 2)
     IF (drr_prompt_loc(dccs_row,"EXPORT")=0)
      RETURN(0)
     ENDIF
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,"Restore data previously saved from TARGET database (Y/N) : ")
     CALL accept(dccs_row,70,"A;cu"," "
      WHERE curaccept IN ("Y", "N"))
     SET dccs_restore = curaccept
     SET drr_clin_copy_data->tgt_mock_env = 1
    ENDIF
   ENDIF
   IF ((drr_clin_copy_data->process != "MIGRATION"))
    IF ((((drr_clin_copy_data->src_domain_name="")) OR ((drr_clin_copy_data->src_domain_name=
    "DM2NOTSET"))) )
     SET dccs_row = (dccs_row+ 2)
     CALL text(dccs_row,8,"Please enter the SOURCE domain: ")
     CALL accept(dccs_row,40,"P(20);CU"
      WHERE  NOT (curaccept=" "))
     SET drr_clin_copy_data->src_domain_name = curaccept
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=0)
    SET dccs_row = (dccs_row+ 2)
    CALL text(dccs_row,8,"Enter 'C' to continue or 'Q' to quit (C or Q) :")
    CALL accept(dccs_row,70,"A;cu",""
     WHERE curaccept IN ("Q", "C"))
    SET dccs_whereto = curaccept
    IF (dccs_whereto="Q")
     SET message = nowindow
     SET dm_err->eproc = "Prompt user for information needed during CLIN COPY process."
     SET dm_err->emsg = "User chose to quit from Information entry screen for CLIN COPY."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm2_install_schema->dbase_name = dm2_install_schema->src_dbase_name
   SET dm2_install_schema->u_name = "V500"
   SET dm2_install_schema->p_word = dm2_install_schema->src_v500_p_word
   SET dm2_install_schema->connect_str = dm2_install_schema->src_v500_connect_str
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF ((validate(dm2_bypass_was_check,- (1))=- (1)))
    IF (drr_identify_was_usage(drr_clin_copy_data->src_domain_name,dccs_was_ind)=0)
     RETURN(0)
    ENDIF
    SET drr_clin_copy_data->src_was_ind = dccs_was_ind
    SET drr_clin_copy_data->tgt_was_ind = drr_clin_copy_data->src_was_ind
   ENDIF
   IF ((drr_clin_copy_data->ads_chosen_ind=1))
    IF (drr_prompt_ads_config(dccs_response)=0)
     RETURN(0)
    ELSEIF (dccs_response="Q")
     SET message = nowindow
     SET dm_err->eproc = "Prompt user for ADS information needed during CLIN COPY process."
     SET dm_err->emsg = "User chose to quit from Information entry screen for ADS."
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((((drr_clin_copy_data->ads_chosen_ind=1)) OR ((((drr_clin_copy_data->process="MIGRATION")) OR
   ((dm2_rdbms_version->level1 >= 11)
    AND (dm2_install_schema->data_to_move="REF"))) )) )
    IF (drr_validate_tgtdblink(dccs_tgt_host,dccs_tgt_ora_ver,dccs_src_host)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((drr_clin_copy_data->process != "MIGRATION")
    AND validate(dm2_bypass_adm_csv_load,- (1)) != 1)
    SET message = nowindow
    CALL drr_set_src_env_path(null)
    IF (drr_validate_adm_env_csv(drr_env_hist_misc->path,drr_clin_copy_data->src_env_name)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm2_install_schema->dbase_name = "ADMIN"
   SET dm2_install_schema->u_name = "CDBA"
   SET dm2_install_schema->p_word = dm2_install_schema->cdba_p_word
   SET dm2_install_schema->connect_str = dm2_install_schema->cdba_connect_str
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF (((dccs_restore="Y") OR ((drr_retain_db_users->cnt > 0))) )
    IF ((drr_clin_copy_data->standalone_expimp_process=1)
     AND (drr_clin_copy_data->process="RESTORE"))
     IF (der_manage_admin_data(dm2_install_schema->target_dbase_name,"DM_INFO","S","ALL","")=0)
      RETURN(0)
     ENDIF
     IF ((der_expimp_data->setup_complete_ind=0))
      SET message = nowindow
      SET dm_err->err_ind = 1
      SET dm_err->eproc =
      "Validating standalone export/import setup work has been completed to restore data."
      SET dm_err->emsg = "Setup work not completed for standalone export/import process."
      SET dm2_install_schema->p_word = "NONE"
      SET dm2_install_schema->v500_p_word = "NONE"
      SET dm2_install_schema->v500_connect_str = "NONE"
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF (dccs_restore="Y")
     IF (drr_prompt_preserve_data(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Delete DM2_REPLICATE_DATA for database ",dm2_install_schema->
    target_dbase_name)
   CALL disp_msg("",dm_err->logfile,0)
   DELETE  FROM dm_info di
    WHERE di.info_domain="DM2_REPLICATE_DATA"
     AND di.info_name=patstring(cnvtupper(build(dm2_install_schema->target_dbase_name,"*")))
    WITH nocounter
   ;end delete
   IF (check_error(dm_err->eproc)=1)
    ROLLBACK
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Insert DATA_TO_MOVE for database ",dm2_install_schema->
    target_dbase_name)
   CALL disp_msg("",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_DATA_TO_MOVE"))), di.info_char = cnvtstring(
      dm2_install_schema->data_to_move)
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    ROLLBACK
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Insert TEMP_DIRECTORY for database ",dm2_install_schema->
    target_dbase_name)
   CALL disp_msg("",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_TEMP_LOCATION"))), di.info_char = cnvtstring(
      drr_clin_copy_data->temp_location)
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    ROLLBACK
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Insert PERCENT_TSPACE for database ",dm2_install_schema->
    target_dbase_name)
   CALL disp_msg("",dm_err->logfile,0)
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_PERCENT_TSPACE"))), di.info_char = cnvtstring(
      dm2_install_schema->percent_tspace)
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    ROLLBACK
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting Restore Previous Target Data Indicator row into Admin dm_info."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_RESTORE_PREV_TGT_DATA_IND"))), di.info_char =
     cnvtstring(dccs_restore)
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting Restore Groups row into Admin dm_info."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_RESTORE_GROUPS_STR"))), di.info_char =
     drr_preserved_tables_data->restore_groups_str
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting Source Domain Name row into Admin dm_info."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_SRC_DOMAIN_NAME"))), di.info_char = cnvtstring(
      drr_clin_copy_data->src_domain_name)
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Inserting WAS Architecture Indicator row into Admin dm_info."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   INSERT  FROM dm_info di
    SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
        dm2_install_schema->target_dbase_name,"_WAS_ARCH_IND"))), di.info_char = evaluate(
      drr_clin_copy_data->tgt_was_ind,1,"Y","N")
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    ROLLBACK
    RETURN(0)
   ENDIF
   IF ((drr_clin_copy_data->ads_chosen_ind=1))
    SET dm_err->eproc = concat("Insert CONFIG_NAME for database ",dm2_install_schema->
     target_dbase_name)
    CALL disp_msg("",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
         dm2_install_schema->target_dbase_name,"_ADS_CONFIG_NAME"))), di.info_char = cnvtstring(
       drr_clin_copy_data->ads_name),
      di.info_date = cnvtdatetime(drr_clin_copy_data->ads_mod_dt_tm)
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Insert CONFIG_ID for database ",dm2_install_schema->target_dbase_name
     )
    CALL disp_msg("",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
         dm2_install_schema->target_dbase_name,"_ADS_CONFIG_ID"))), di.info_number =
      drr_clin_copy_data->ads_config_id
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Insert CONFIG_PCT for database ",dm2_install_schema->
     target_dbase_name)
    CALL disp_msg("",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
         dm2_install_schema->target_dbase_name,"_ADS_CONFIG_PCT"))), di.info_number =
      drr_clin_copy_data->ads_pct
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((drr_clin_copy_data->purge_chosen_ind=1))
    SET dm_err->eproc = concat("Insert ADS Purge indicator for database ",dm2_install_schema->
     target_dbase_name)
    CALL disp_msg("",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
         dm2_install_schema->target_dbase_name,"_ADS_PURGE")))
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((drr_clin_copy_data->process != "DM2NOTSET"))
    SET dm_err->eproc = concat("Insert PROCESS NAME for database ",dm2_install_schema->
     target_dbase_name)
    CALL disp_msg("",dm_err->logfile,0)
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_DATA", di.info_name = patstring(cnvtupper(build(
         dm2_install_schema->target_dbase_name,"_PROCESS"))), di.info_char = drr_clin_copy_data->
      process
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   COMMIT
   SET dm2_install_schema->dbase_name = dm2_install_schema->target_dbase_name
   SET dm2_install_schema->u_name = "V500"
   SET dm2_install_schema->p_word = dm2_install_schema->v500_p_word
   SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(dm2_install_schema)
    CALL echorecord(drr_clin_copy_data)
   ENDIF
   SET dm_err->eproc = "Prompt user to confirm summary screen."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=0)
    IF (drr_display_summary_screen(null)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET message = nowindow
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_prompt_schema_date(dpsd_row)
   DECLARE dpsd_sch_date_str = vc WITH protect, noconstant("")
   CALL text(dpsd_row,8,"Enter schema date to use to capture source (in mm-dd-yyyy format ) :  ")
   SET dpsd_row = (dpsd_row+ 1)
   CALL text(dpsd_row,17,"* Do not choose date older than 30 days")
   SET dpsd_sch_date_str = "  -  -    "
   CALL accept((dpsd_row - 1),81,"NNDNNDNNNN;C",dpsd_sch_date_str
    WHERE format(cnvtdate(cnvtalphanum(curaccept)),"MM-DD-YYYY;;D")=curaccept
     AND datetimeadd(cnvtdatetime(format(cnvtdate2(curaccept,"MM-DD-YYYY"),"DD-MMM-YYYY;;D")),30) >=
    cnvtdatetime(curdate,curtime3))
   SET dpsd_sch_date_str = curaccept
   SET dm2_install_schema->schema_prefix = "dm2s"
   SET dm2_install_schema->file_prefix = cnvtalphanum(dpsd_sch_date_str)
 END ;Subroutine
 SUBROUTINE drr_prompt_loc(dpl_row,dpl_type)
   DECLARE dpl_file_delim = vc WITH protect, noconstant("")
   DECLARE dpl_exp_loc = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dpl_file_delim = "]"
   ELSE
    SET dpl_file_delim = "/"
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(dpl_file_delim)
   ENDIF
   CALL text(dpl_row,8,"Enter Temporary Directory for Replicate/Refresh : ")
   IF (dpl_type="IMPORT")
    SET dm_err->eproc = "Get Import Location."
   ELSEIF (dpl_type="EXPORT")
    SET dm_err->eproc = "Get Export Location."
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF (dpl_type="IMPORT"
    AND (dm2_install_schema->run_id=0))
    SET dpl_exp_loc = "NONE"
   ELSE
    IF (drr_get_exp_dmp_loc(dpl_exp_loc)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dpl_exp_loc="NONE")
    SET drr_clin_copy_data->temp_location = ""
   ELSE
    SET drr_clin_copy_data->temp_location = dpl_exp_loc
   ENDIF
   SET dpl_row = (dpl_row+ 1)
   IF ((dm2_sys_misc->cur_os="AXP"))
    CALL accept(dpl_row,8,"P(90);C",drr_clin_copy_data->temp_location
     WHERE  NOT (curaccept="")
      AND findstring(dpl_file_delim,trim(curaccept),1,1)=size(trim(curaccept)))
   ELSE
    CALL accept(dpl_row,8,"P(90);C",drr_clin_copy_data->temp_location
     WHERE  NOT (curaccept="")
      AND substring(1,1,curaccept)="/")
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET drr_clin_copy_data->temp_location = curaccept
   ELSE
    IF (findstring(dpl_file_delim,trim(curaccept),1,1) != size(trim(curaccept)))
     SET drr_clin_copy_data->temp_location = concat(trim(curaccept),dpl_file_delim)
    ELSE
     SET drr_clin_copy_data->temp_location = curaccept
    ENDIF
   ENDIF
   IF (dpl_type="IMPORT")
    SET dm_err->eproc = "Validate Import Location."
   ELSEIF (dpl_type="EXPORT")
    SET dm_err->eproc = "Validate Export Location."
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
    CALL echo(curaccept)
   ENDIF
   IF (findfile(trim(curaccept))=0)
    CALL clear(1,1)
    SET message = nowindow
    SET dm_err->emsg = concat("The Export Location:",drr_clin_copy_data->temp_location,
     " was not found.")
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drr_val_write_privs(drr_clin_copy_data->temp_location)=0)
    SET message = nowindow
    SET dm_err->user_action = concat("Please log in as a user that has full privileges to ",
     drr_clin_copy_data->temp_location)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_load_preserved_table_data(dlp_source,dlp_file)
   DECLARE dlp_locate_var = i4 WITH protect, noconstant(0)
   DECLARE dlp_grpname = vc WITH protect, noconstant(" ")
   DECLARE dlp_excl_autotester = i2 WITH protect, noconstant(0)
   DECLARE dlp_excl_file = vc WITH protect, noconstant(" ")
   DECLARE dlp_cnt = i4 WITH protect, noconstant(0)
   FREE RECORD dlp_excl_tbl
   RECORD dlp_excl_tbl(
     1 tbl_cnt = i4
     1 qual[*]
       2 table_name = vc
       2 grpname = vc
   )
   SET dlp_excl_tbl->tbl_cnt = 0
   FREE RECORD dlp_tmp_data
   RECORD dlp_tmp_data(
     1 cnt = i4
     1 tbl[*]
       2 table_name = vc
       2 group = vc
       2 table_suffix = vc
       2 prefix = vc
       2 partial_ind = i2
       2 exp_where_clause = vc
       2 excl_ind = i2
   )
   SET drr_preserved_tables_data->cnt = 0
   SET drr_preserved_tables_data->refresh_ind = 0
   SET stat = alterlist(drr_preserved_tables_data->tbl,0)
   IF (dlp_source="TABLE")
    IF (dpr_sub_ddl_excl(" ")=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Verifying dm_info rows for preserved tables exist"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM dm_info di
     WHERE di.info_domain="DM2_PRESERVED_TABLE-*"
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg =
     "DM_INFO rows for preserved tables are NOT present. Verify that readme 3932 has been run"
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Load specific tables that are to be preserved on a Refresh."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF ((dpr_obj_list->tbl_cnt=0))
     SELECT INTO "nl:"
      FROM dm_info di,
       dm_tables_doc dtd,
       dm2_user_tables u
      PLAN (di
       WHERE di.info_domain="DM2_PRESERVED_TABLE-*"
        AND di.info_number=1)
       JOIN (dtd
       WHERE di.info_name=dtd.table_name)
       JOIN (u
       WHERE dtd.table_name=u.table_name)
      ORDER BY di.info_name
      HEAD REPORT
       pos = 0, pos = findstring("-",di.info_domain)
      HEAD di.info_name
       drr_preserved_tables_data->cnt = (drr_preserved_tables_data->cnt+ 1)
       IF (mod(drr_preserved_tables_data->cnt,10)=1)
        stat = alterlist(drr_preserved_tables_data->tbl,(drr_preserved_tables_data->cnt+ 9))
       ENDIF
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].group = substring((pos+ 1),size
        (di.info_domain),di.info_domain), drr_preserved_tables_data->tbl[drr_preserved_tables_data->
       cnt].table_name = di.info_name, drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt]
       .table_suffix = dtd.table_suffix,
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].prefix = cnvtlower(build(
         drr_clin_copy_data->preserve_tbl_pre,dtd.table_suffix)), drr_preserved_tables_data->tbl[
       drr_preserved_tables_data->cnt].refresh_ind = 0
       IF (di.info_char > " ")
        drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].partial_ind = 1,
        drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].exp_where_clause = di
        .info_char
       ENDIF
      FOOT REPORT
       stat = alterlist(drr_preserved_tables_data->tbl,drr_preserved_tables_data->cnt)
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     SELECT INTO "nl:"
      FROM dm_info di,
       dm_tables_doc dtd,
       dm2_user_tables u
      PLAN (di
       WHERE di.info_domain="DM2_PRESERVED_TABLE-*"
        AND di.info_number=1)
       JOIN (dtd
       WHERE di.info_name=dtd.table_name)
       JOIN (u
       WHERE dtd.table_name=u.table_name)
      ORDER BY di.info_name
      HEAD REPORT
       pos = 0, pos = findstring("-",di.info_domain)
      HEAD di.info_name
       dpl_grpname = substring((pos+ 1),size(di.info_domain),di.info_domain), dlp_locate_var = 0,
       dlp_locate_var = locateval(dlp_locate_var,1,dpr_obj_list->tbl_cnt,di.info_name,dpr_obj_list->
        obj_tbl[dlp_locate_var].dpr_tbl)
       IF (dlp_locate_var > 0)
        dlp_excl_tbl->tbl_cnt = (dlp_excl_tbl->tbl_cnt+ 1), stat = alterlist(dlp_excl_tbl->qual,
         dlp_excl_tbl->tbl_cnt), dlp_excl_tbl->qual[dlp_excl_tbl->tbl_cnt].table_name = di.info_name,
        dlp_excl_tbl->qual[dlp_excl_tbl->tbl_cnt].grpname = dpl_grpname
       ENDIF
       dlp_tmp_data->cnt = (dlp_tmp_data->cnt+ 1)
       IF (mod(dlp_tmp_data->cnt,10)=1)
        stat = alterlist(dlp_tmp_data->tbl,(dlp_tmp_data->cnt+ 9))
       ENDIF
       dlp_tmp_data->tbl[dlp_tmp_data->cnt].group = dpl_grpname, dlp_tmp_data->tbl[dlp_tmp_data->cnt]
       .table_name = di.info_name, dlp_tmp_data->tbl[dlp_tmp_data->cnt].table_suffix = dtd
       .table_suffix,
       dlp_tmp_data->tbl[dlp_tmp_data->cnt].prefix = cnvtlower(build(drr_clin_copy_data->
         preserve_tbl_pre,dtd.table_suffix))
       IF (di.info_char > " ")
        dlp_tmp_data->tbl[dlp_tmp_data->cnt].partial_ind = 1, dlp_tmp_data->tbl[dlp_tmp_data->cnt].
        exp_where_clause = di.info_char
       ENDIF
       dlp_tmp_data->tbl[dlp_tmp_data->cnt].excl_ind = 0
      FOOT REPORT
       stat = alterlist(dlp_tmp_data->tbl,dlp_tmp_data->cnt)
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     FOR (dlp_cnt = 1 TO dlp_tmp_data->cnt)
       SET dlp_locate_var = 0
       SET dlp_locate_var = locateval(dlp_locate_var,1,dlp_excl_tbl->tbl_cnt,dlp_tmp_data->tbl[
        dlp_cnt].group,dlp_excl_tbl->qual[dlp_locate_var].grpname)
       IF (dlp_locate_var=0)
        SET drr_preserved_tables_data->cnt = (drr_preserved_tables_data->cnt+ 1)
        IF (mod(drr_preserved_tables_data->cnt,10)=1)
         SET stat = alterlist(drr_preserved_tables_data->tbl,(drr_preserved_tables_data->cnt+ 9))
        ENDIF
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].group = dlp_tmp_data->tbl[
        dlp_cnt].group
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].table_name = dlp_tmp_data
        ->tbl[dlp_cnt].table_name
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].table_suffix =
        dlp_tmp_data->tbl[dlp_cnt].table_suffix
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].prefix = dlp_tmp_data->
        tbl[dlp_cnt].prefix
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].refresh_ind = 0
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].partial_ind = dlp_tmp_data
        ->tbl[dlp_cnt].partial_ind
        SET drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].exp_where_clause =
        dlp_tmp_data->tbl[dlp_cnt].exp_where_clause
       ELSE
        SET dlp_tmp_data->tbl[dlp_cnt].excl_ind = 1
       ENDIF
     ENDFOR
     SET stat = alterlist(drr_preserved_tables_data->tbl,drr_preserved_tables_data->cnt)
     SET dm_err->eproc = "Load partitioned AutoTester table."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SELECT INTO "nl:"
      FROM dm_tables_doc dtd,
       dm2_user_tables u
      PLAN (dtd
       WHERE dtd.table_name=dtd.full_table_name
        AND dtd.data_model_section="AUTOTESTER")
       JOIN (u
       WHERE dtd.table_name=u.table_name)
      ORDER BY dtd.table_name
      DETAIL
       dlp_locate_var = 0, dlp_locate_var = locateval(dlp_locate_var,1,dpr_obj_list->tbl_cnt,dtd
        .table_name,dpr_obj_list->obj_tbl[dlp_locate_var].dpr_tbl)
       IF (dlp_locate_var > 0)
        dlp_excl_tbl->tbl_cnt = (dlp_excl_tbl->tbl_cnt+ 1), stat = alterlist(dlp_excl_tbl->qual,
         dlp_excl_tbl->tbl_cnt), dlp_excl_tbl->qual[dlp_excl_tbl->tbl_cnt].table_name = dtd
        .table_name,
        dlp_excl_tbl->qual[dlp_excl_tbl->tbl_cnt].grpname = "AUTOTESTER", dlp_excl_autotester = 1
       ENDIF
       dlp_tmp_data->cnt = (dlp_tmp_data->cnt+ 1), stat = alterlist(dlp_tmp_data->tbl,dlp_tmp_data->
        cnt), dlp_tmp_data->tbl[dlp_tmp_data->cnt].group = "AUTOTESTER",
       dlp_tmp_data->tbl[dlp_tmp_data->cnt].table_name = dtd.table_name
      FOOT REPORT
       stat = alterlist(dlp_tmp_data->tbl,dlp_tmp_data->cnt)
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF (dlp_excl_autotester=0)
     SET dm_err->eproc = "Load the group of tables that are used by AutoTester."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SELECT INTO "nl:"
      FROM dm_tables_doc dtd,
       dm2_user_tables u
      PLAN (dtd
       WHERE dtd.table_name=dtd.full_table_name
        AND dtd.data_model_section="AUTOTESTER")
       JOIN (u
       WHERE dtd.table_name=u.table_name)
      ORDER BY dtd.table_name
      DETAIL
       drr_preserved_tables_data->cnt = (drr_preserved_tables_data->cnt+ 1), stat = alterlist(
        drr_preserved_tables_data->tbl,drr_preserved_tables_data->cnt), drr_preserved_tables_data->
       tbl[drr_preserved_tables_data->cnt].table_name = dtd.table_name,
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].group = dtd.data_model_section,
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].table_suffix = dtd.table_suffix,
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].prefix = cnvtlower(build(
         drr_clin_copy_data->preserve_tbl_pre,dtd.table_suffix)),
       drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].refresh_ind = 0
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSEIF (dlp_excl_autotester=1)
     SET dm_err->eproc = "Set preserve exclude indicator for AutoTester."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SELECT INTO "nl:"
      FROM (dummyt t  WITH seq = dlp_tmp_data->cnt)
      WHERE (dlp_tmp_data->tbl[t.seq].group="AUTOTESTER")
      DETAIL
       dlp_tmp_data->tbl[t.seq].excl_ind = 1
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((dlp_excl_tbl->tbl_cnt > 0)
     AND validate(dpt_preserve_tables,- (1))=1)
     SET dm_err->eproc = "Create exclusion report for partitioned preserved tables."
     CALL disp_msg(" ",dm_err->logfile,0)
     IF (get_unique_file("dm2_preserve_excl",".rpt")=0)
      RETURN(0)
     ENDIF
     SET dlp_excl_file = dm_err->unique_fname
     IF (validate(drrr_responsefile_in_use,0)=1)
      SET dlp_excl_file = build(drrr_misc_data->active_dir,dlp_excl_file)
     ENDIF
     SELECT INTO value(dlp_excl_file)
      FROM (dummyt t  WITH seq = dlp_tmp_data->cnt)
      WHERE (dlp_tmp_data->tbl[t.seq].excl_ind=1)
      ORDER BY dlp_tmp_data->tbl[t.seq].group, dlp_tmp_data->tbl[t.seq].table_name
      HEAD REPORT
       row + 1, col 1,
       "***************************WARNING: Preserve Table Exclusion have been detected.************************",
       row + 1, col 1,
       "Tables displayed below cannot be preserved due to one or more tables within its group are partitioned.",
       row + 1, col 1,
       "********************************************************************************************************",
       row + 2, col 10, "TABLE NAME",
       col 50, "GROUP_NAME", row + 1
      DETAIL
       col 10, dlp_tmp_data->tbl[t.seq].table_name, col 50,
       dlp_tmp_data->tbl[t.seq].group, row + 1
      FOOT REPORT
       col 0, "END OF REPORT"
      WITH nocounter, maxcol = 300, formfeed = none,
       maxrow = 1, nullreport
     ;end select
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (validate(drrr_responsefile_in_use,0)=1)
      SET dm_err->eproc = concat(
       "Using response file - Bypassing displaying of Preserve exclusion report.  ",
       "Report File may be found in :  ",dlp_excl_file)
      CALL disp_msg(" ",dm_err->logfile,0)
      IF ((drer_email_list->email_cnt > 0))
       SET drer_email_det->msgtype = "PROGRESS"
       SET drer_email_det->status = "REPORT"
       SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
       SET drer_email_det->step = "Preserve Table Exclusion Report"
       SET drer_email_det->email_level = 1
       SET drer_email_det->logfile = dm_err->logfile
       SET drer_email_det->err_ind = dm_err->err_ind
       SET drer_email_det->eproc = dm_err->eproc
       SET drer_email_det->emsg = dm_err->emsg
       SET drer_email_det->user_action = dm_err->user_action
       SET drer_email_det->attachment = dlp_excl_file
       CALL drer_add_body_text(concat("Preserve Table Exclusion report was generated at ",format(
          drer_email_det->status_dt_tm,";;q")),1)
       CALL drer_add_body_text(concat("Report file name is : ",dlp_excl_file),0)
       IF (drer_compose_email(null)=1)
        CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
         email_level)
       ENDIF
       CALL drer_reset_pre_err(null)
      ENDIF
     ELSE
      SET drer_email_det->process = "PRESERVE"
      SET drer_email_det->msgtype = "PROGRESS"
      SET drer_email_det->status = "REPORT"
      SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
      SET drer_email_det->step = "Preserve Table Exclusion Report"
      SET drer_email_det->email_level = 1
      SET drer_email_det->logfile = dm_err->logfile
      SET drer_email_det->err_ind = dm_err->err_ind
      SET drer_email_det->eproc = dm_err->eproc
      SET drer_email_det->emsg = dm_err->emsg
      SET drer_email_det->user_action = dm_err->user_action
      SET drer_email_det->attachment = dlp_excl_file
      CALL drer_add_body_text(concat("Preserve Table Exclusion report was displayed at ",format(
         drer_email_det->status_dt_tm,";;q")),1)
      CALL drer_add_body_text(concat("Report file name is ccluserdir: ",dlp_excl_file),0)
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("ddr_domain_data->tgt_env = ",ddr_domain_data->tgt_env))
       CALL echo(build("ddr_domain_data->src_env = ",ddr_domain_data->src_env))
       CALL echo(build("ddr_domain_data->src_domain_name = ",ddr_domain_data->src_domain_name))
      ENDIF
      SET drer_email_det->src_env = ddr_domain_data->src_env
      SET drer_email_det->tgt_env = ddr_domain_data->tgt_env
      IF (drer_fill_email_list(drer_email_det->src_env,drer_email_det->tgt_env)=1
       AND (drer_email_list->email_cnt > 0))
       IF (drer_compose_email(null)=1)
        CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
         email_level)
       ENDIF
      ENDIF
      CALL drer_reset_pre_err(null)
      IF (dm2_disp_file(dlp_excl_file,"Preserve Table Exclusion Report")=0)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
   ELSEIF (dlp_source="FILE")
    SET dm_err->eproc = concat("Load preserved tables from ",dlp_file)
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    FREE DEFINE rtl2
    FREE SET dlp_filename
    SET logical dlp_filename value(dlp_file)
    DEFINE rtl2 "dlp_filename"
    SELECT INTO "nl:"
     t.line
     FROM rtl2t t
     WHERE t.line > " "
     HEAD REPORT
      beg_pos = 1, end_pos = 0
     DETAIL
      beg_pos = 1, end_pos = 0, drr_preserved_tables_data->cnt = (drr_preserved_tables_data->cnt+ 1)
      IF (mod(drr_preserved_tables_data->cnt,10)=1)
       stat = alterlist(drr_preserved_tables_data->tbl,(drr_preserved_tables_data->cnt+ 9))
      ENDIF
      end_pos = findstring(",",t.line,beg_pos,0)
      IF ((dm_err->debug_flag > 2))
       CALL echo(build("end_pos =",end_pos))
      ENDIF
      drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].group = substring(beg_pos,(
       end_pos - beg_pos),t.line), beg_pos = (end_pos+ 1), end_pos = findstring(",",t.line,beg_pos,0)
      IF ((dm_err->debug_flag > 2))
       CALL echo(build("end_pos =",end_pos))
      ENDIF
      drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].table_name = substring(beg_pos,(
       end_pos - beg_pos),t.line), beg_pos = (end_pos+ 1), end_pos = findstring(",",t.line,beg_pos,0)
      IF ((dm_err->debug_flag > 2))
       CALL echo(build("end_pos =",end_pos))
      ENDIF
      drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].partial_ind = evaluate(substring
       (beg_pos,(end_pos - beg_pos),t.line),"PARTIAL",1,0), beg_pos = (end_pos+ 1), end_pos =
      findstring(",",t.line,beg_pos,0)
      IF ((dm_err->debug_flag > 2))
       CALL echo(build("end_pos =",end_pos))
      ENDIF
      drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].exp_where_clause = substring(
       beg_pos,(end_pos - beg_pos),t.line), drr_preserved_tables_data->tbl[drr_preserved_tables_data
      ->cnt].table_suffix = substring((end_pos+ 1),size(t.line),t.line), drr_preserved_tables_data->
      tbl[drr_preserved_tables_data->cnt].prefix = cnvtlower(build(drr_clin_copy_data->
        preserve_tbl_pre,drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].table_suffix)
       ),
      drr_preserved_tables_data->tbl[drr_preserved_tables_data->cnt].refresh_ind = 0
     FOOT REPORT
      stat = alterlist(drr_preserved_tables_data->tbl,drr_preserved_tables_data->cnt)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(drr_preserved_tables_data)
    CALL echorecord(dlp_excl_tbl)
    CALL echorecord(dlp_tmp_data)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_prompt_preserve_data(null)
   DECLARE dpp_pd_present = i2 WITH protect, noconstant(0)
   SET message = nowindow
   SET dm_err->eproc = "Prompt user if restore is needed for preserved data."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   DECLARE dpp_prev_group = vc WITH protect, noconstant(" ")
   DECLARE dpp_row = i4 WITH protect, noconstant(0)
   DECLARE dpp_cnt = i4 WITH protect, noconstant(0)
   DECLARE dpp_restore = c1 WITH protect, noconstant(" ")
   DECLARE dpp_grp = i4 WITH protect, noconstant(0)
   DECLARE dpp_rrd = i4 WITH protect, noconstant(0)
   DECLARE dpp_printers = i4 WITH protect, noconstant(0)
   DECLARE dpp_restore_grps_str = vc WITH protect, noconstant("")
   DECLARE dpp_ndx = i4 WITH protect, noconstant(0)
   IF (drr_chk_for_preserved_data(dpp_pd_present)=0)
    RETURN(0)
   ENDIF
   IF (dpp_pd_present=0)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Components required for restoring preserved data NOT found"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   FOR (dpp_cnt = 1 TO drr_preserved_tables_data->cnt)
    SET dpp_grp = locateval(dpp_grp,1,drr_group->cnt,drr_preserved_tables_data->tbl[dpp_cnt].group,
     drr_group->grp[dpp_grp].group)
    IF (dpp_grp > 0)
     SET drr_preserved_tables_data->tbl[dpp_cnt].refresh_ind = drr_group->grp[dpp_grp].restore
    ELSE
     SET drr_group->cnt = (drr_group->cnt+ 1)
     SET stat = alterlist(drr_group->grp,drr_group->cnt)
     SET drr_group->grp[drr_group->cnt].group = drr_preserved_tables_data->tbl[dpp_cnt].group
     IF ((drr_group->grp[drr_group->cnt].group="NOPROMPT"))
      SET drr_group->grp[drr_group->cnt].prompt_ind = 0
      SET drr_preserved_tables_data->refresh_ind = 1
      SET drr_preserved_tables_data->tbl[dpp_cnt].refresh_ind = 1
      SET drr_group->grp[drr_group->cnt].restore = 1
     ELSE
      SET drr_group->grp[drr_group->cnt].prompt_ind = 1
     ENDIF
     IF ((drr_preserved_tables_data->tbl[dpp_cnt].group != "NOPROMPT"))
      IF (validate(drrr_responsefile_in_use,0)=1)
       SET dpp_ndx = 0
       SET dpp_ndx = locateval(dpp_ndx,1,drrr_misc_data->tgt_restore_list_cnt,
        drr_preserved_tables_data->tbl[dpp_cnt].group,drrr_misc_data->tgt_restore_list[dpp_ndx].
        restore_group)
       IF (dpp_ndx > 0
        AND (drrr_misc_data->tgt_restore_list[dpp_ndx].restore_ind=1))
        SET drr_preserved_tables_data->refresh_ind = 1
        SET drr_preserved_tables_data->tbl[dpp_cnt].refresh_ind = 1
        SET drr_group->grp[drr_group->cnt].restore = 1
       ELSE
        SET drr_group->grp[drr_group->cnt].restore = 0
       ENDIF
      ELSE
       IF ((drr_group->grp[drr_group->cnt].prompt_ind=1))
        SET message = window
        CALL clear(1,1)
        CALL box(1,1,24,131)
        CALL text(2,2,"Restoring Preserved Data")
        SET dpp_restore = " "
        CALL text(4,8,concat("Restore ",drr_preserved_tables_data->tbl[dpp_cnt].group," (Y/N): "))
        CALL accept(4,70,"A;cu"," "
         WHERE curaccept IN ("Y", "N"))
        SET dpp_restore = curaccept
        IF (dpp_restore="Y")
         SET drr_preserved_tables_data->refresh_ind = 1
         SET drr_preserved_tables_data->tbl[dpp_cnt].refresh_ind = 1
         SET drr_group->grp[drr_group->cnt].restore = 1
        ELSE
         SET drr_group->grp[drr_group->cnt].restore = 0
        ENDIF
        CALL text(8,8,"Enter 'C' to continue or 'Q' to quit (C or Q) :")
        CALL accept(8,70,"A;cu",""
         WHERE curaccept IN ("Q", "C"))
        SET dccs_whereto = curaccept
        SET message = nowindow
        IF (dccs_whereto="Q")
         SET message = nowindow
         SET dm_err->eproc = "Prompt user to restore Preserve data."
         SET dm_err->emsg = "User chose to quit from Restoring Preserved Data menu."
         SET dm_err->err_ind = 1
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDFOR
   SET dpp_rrd = locateval(dpp_rrd,1,drr_group->cnt,"RRD",drr_group->grp[dpp_rrd].group)
   SET dpp_printers = locateval(dpp_printers,1,drr_group->cnt,"PRINTERS",drr_group->grp[dpp_printers]
    .group)
   IF ((drr_group->grp[dpp_rrd].restore=1)
    AND (drr_group->grp[dpp_printers].restore=0))
    SET drr_group->grp[dpp_printers].restore = 1
    FOR (dpp_cnt = 1 TO drr_preserved_tables_data->cnt)
      IF ((drr_preserved_tables_data->tbl[dpp_cnt].group="PRINTERS"))
       SET drr_preserved_tables_data->tbl[dpp_cnt].refresh_ind = 1
      ENDIF
    ENDFOR
    IF (validate(drrr_responsefile_in_use,0)=0)
     SET message = window
     CALL clear(1,1)
     CALL box(1,1,24,131)
     CALL text(2,2,"Restoring Preserved Data")
     CALL text(4,8,"PRINTERS will be restored when RRD group is marked to be restored.")
     CALL text(8,8,"Enter 'C' to continue or 'Q' to quit (C or Q) :")
     CALL accept(8,70,"A;cu",""
      WHERE curaccept IN ("Q", "C"))
     SET dccs_whereto = curaccept
     SET message = nowindow
    ENDIF
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET dccs_whereto = "C"
   ENDIF
   IF (dccs_whereto="C")
    IF ((dm_err->debug_flag > 2))
     CALL echorecord(drr_preserved_tables_data)
    ENDIF
    SET drr_preserved_tables_data->restore_groups_str = ""
    FOR (dpp_cnt = 1 TO drr_group->cnt)
      IF ((drr_group->grp[dpp_cnt].restore=1))
       IF ((drr_preserved_tables_data->restore_groups_str=""))
        SET drr_preserved_tables_data->restore_groups_str = build("<",drr_group->grp[dpp_cnt].group,
         ">",",")
       ELSE
        SET drr_preserved_tables_data->restore_groups_str = build(drr_preserved_tables_data->
         restore_groups_str,",","<",drr_group->grp[dpp_cnt].group,">")
       ENDIF
      ENDIF
    ENDFOR
    RETURN(1)
   ELSE
    SET message = nowindow
    SET dm_err->eproc = "Prompt user to restore Preserve data."
    SET dm_err->emsg = "User chose to quit from Restoring Preserved Data menu."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE drr_chk_for_preserved_data(dcf_chk_ret)
   SET dm_err->eproc = "Check if preserved data was stored off before a Refresh was initiated."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   DECLARE dcf_cnt = i4 WITH protect, noconstant(0)
   DECLARE dcf_dat_file = vc WITH protect, noconstant(" ")
   DECLARE dcf_dmp_file = vc WITH protect, noconstant(" ")
   DECLARE dcf_sch_file = vc WITH protect, noconstant(" ")
   DECLARE dcf_par_file = vc WITH protect, noconstant(" ")
   SET dcf_dat_file = concat(drr_clin_copy_data->temp_location,drr_clin_copy_data->preserve_tbl_pre,
    "_summary.dat")
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("summary_file =",dcf_dat_file))
   ENDIF
   IF (dm2_findfile(dcf_dat_file)=0)
    SET dcf_chk_ret = 0
    RETURN(1)
   ENDIF
   IF (drr_load_preserved_table_data("FILE",dcf_dat_file)=0)
    RETURN(0)
   ENDIF
   IF ((drr_clin_copy_data->standalone_expimp_process=0))
    FOR (dcf_cnt = 1 TO drr_preserved_tables_data->cnt)
      SET dcf_dmp_file = concat(drr_clin_copy_data->temp_location,drr_clin_copy_data->
       preserve_tbl_pre,drr_preserved_tables_data->tbl[dcf_cnt].table_suffix,".dmp")
      IF ((dm_err->debug_flag > 2))
       CALL echo(build("dmp_file =",dcf_dmp_file))
      ENDIF
      IF (dm2_findfile(dcf_dmp_file)=0)
       SET dcf_chk_ret = 0
       RETURN(1)
      ENDIF
    ENDFOR
   ENDIF
   CALL dsfi_load_schema_file_defs("table_info")
   FOR (dsfi = 1 TO dm2_sch_file->file_cnt)
    SET dcf_sch_file = build(drr_clin_copy_data->temp_location,dm2_install_schema->schema_prefix,
     drr_clin_copy_data->preserve_sch_dt,cnvtlower(dm2_sch_file->qual[dsfi].file_suffix),".dat")
    IF (dm2_findfile(dcf_sch_file)=0)
     SET dcf_chk_ret = 0
     RETURN(1)
    ENDIF
   ENDFOR
   CALL dsfi_load_schema_file_defs("tspace")
   FOR (dsfi = 1 TO dm2_sch_file->file_cnt)
    SET dcf_sch_file = build(drr_clin_copy_data->temp_location,dm2_install_schema->schema_prefix,
     drr_clin_copy_data->preserve_sch_dt,cnvtlower(dm2_sch_file->qual[dsfi].file_suffix),".dat")
    IF (dm2_findfile(dcf_sch_file)=0)
     SET dcf_chk_ret = 0
     RETURN(1)
    ENDIF
   ENDFOR
   CALL dsfi_load_schema_file_defs("table_info")
   SET dcf_par_file = concat(drr_clin_copy_data->temp_location,drr_clin_copy_data->preserve_tbl_pre,
    "_imp.par")
   IF ((dm_err->debug_flag > 2))
    CALL echo(build("par_file =",dcf_par_file))
   ENDIF
   IF (dm2_findfile(dcf_par_file)=0)
    SET dcf_chk_ret = 0
    RETURN(1)
   ENDIF
   SET dcf_chk_ret = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_display_summary_screen(null)
   DECLARE dds_sch_date_str = vc WITH protect, noconstant(" ")
   DECLARE dds_row = i4 WITH protect, noconstant(0)
   DECLARE dds_cnt = i4 WITH protect, noconstant(0)
   DECLARE dds_prev_group = vc WITH protect, noconstant(" ")
   DECLARE dds_file = vc WITH protect, noconstant(" ")
   SET dm_err->eproc = "Display summary report."
   IF ((drr_clin_copy_data->summary_screen_issued=1))
    RETURN(1)
   ENDIF
   IF (get_unique_file("dm2_summary_report",".rpt")=0)
    RETURN(0)
   ELSE
    SET dds_file = dm_err->unique_fname
   ENDIF
   SELECT INTO value(dds_file)
    FROM dummyt d
    HEAD REPORT
     CALL print(fillstring(90,"-")), row + 1
     IF ((drr_clin_copy_data->starting_point="FROM_BEGINNING"))
      IF ((drr_clin_copy_data->process="RESTORE"))
       col 0,
       CALL print("Complete Copy of Clinical Database (Alternate Database Restore Method) Summary")
      ELSE
       col 0,
       CALL print("Create a Copy of a Clinical Database Summary")
      ENDIF
     ELSE
      IF ((drr_clin_copy_data->process="RESTORE"))
       col 0,
       CALL print(
       "Restart Complete Copy of Clinical Database (Alternate Database Restore Method) Summary")
      ELSE
       col 0,
       CALL print("Restart Copy of a Clinical Database Summary")
      ENDIF
     ENDIF
     row + 1,
     CALL print(fillstring(90,"-")), row + 1,
     col 0,
     CALL print(
     "***** PLEASE REVIEW THE VALUES BELOW. WHEN DONE, PRESS ENTER FOR CONFIRMATION SCREEN! *****"),
     row + 1,
     row + 1, col 0,
     CALL print("SOURCE"),
     col 60,
     CALL print("TARGET"), row + 1,
     col 0,
     CALL print(concat("Environment Name : ",trim(drr_clin_copy_data->src_env_name))), col 60,
     CALL print(concat("Environment Name : ",trim(drr_clin_copy_data->tgt_db_env_name))), row + 1,
     col 0,
     CALL print(concat("Database Name : ",trim(dm2_install_schema->src_dbase_name))), col 60,
     CALL print(concat("Database Name : ",trim(dm2_install_schema->target_dbase_name))),
     row + 1, col 0,
     CALL print(concat("Database Create Date  : ",format(drr_clin_copy_data->src_db_created,
       "mm-dd-yyyy;;d"))),
     col 60,
     CALL print(concat("Database Create Date  : ",format(drr_clin_copy_data->tgt_db_created,
       "mm-dd-yyyy;;d"))), row + 1,
     col 0,
     CALL print(concat("Database Password : ",trim(dm2_install_schema->src_v500_p_word))), col 60,
     CALL print(concat("Database Password : ",trim(dm2_install_schema->v500_p_word))), row + 1, col 0,
     CALL print(concat("Database Connect String : ",trim(dm2_install_schema->src_v500_connect_str))),
     col 60,
     CALL print(concat("Database Connect String : ",trim(dm2_install_schema->v500_connect_str)))
     IF ((((drr_clin_copy_data->process != "RESTORE")) OR ((drr_clin_copy_data->process="RESTORE")
      AND (drr_preserved_tables_data->refresh_ind=1))) )
      IF ((drr_clin_copy_data->starting_point="FROM_BEGINNING"))
       IF ((dm2_install_schema->file_prefix > " "))
        dds_sch_date_str = format(cnvtdate(cnvtint(build(substring(1,8,dm2_install_schema->
             file_prefix)))),"mm-dd-yyyy;;d"), row + 1, col 0,
        CALL print(concat("Schema Date = ",dds_sch_date_str))
       ENDIF
       IF ((drr_clin_copy_data->process != "MIGRATION"))
        IF ((drr_clin_copy_data->ads_chosen_ind=1))
         row + 1, col 0,
         CALL print(concat("Data to Move = Reference with Activity Data Sample Name : ",
          drr_clin_copy_data->ads_name))
        ELSE
         row + 1, col 0,
         CALL print(concat("Data to Move = ",evaluate(dm2_install_schema->data_to_move,"REF",
           "Reference Only","All")))
        ENDIF
        row + 1, col 0,
        CALL print(concat("% Tablespace Increase = ",trim(cnvtstring(dm2_install_schema->
           percent_tspace)),"%")),
        row + 1, col 0,
        CALL print(concat("Temporary Directory for Replicate/Refresh = ",drr_clin_copy_data->
         temp_location))
        IF ((drr_preserved_tables_data->refresh_ind=1))
         row + 1, col 6,
         CALL print("Restore data previously saved from TARGET database = Yes")
         FOR (dds_cnt = 1 TO drr_group->cnt)
           IF ((drr_group->grp[dds_cnt].restore=1)
            AND (drr_group->grp[dds_cnt].group != "NOPROMPT"))
            row + 1, col 6,
            CALL print(concat("Restore ",drr_group->grp[dds_cnt].group," = Yes"))
           ENDIF
         ENDFOR
        ENDIF
       ELSE
        row + 1, col 0,
        CALL print(concat("% Tablespace Adjustment = ",trim(cnvtstring(dm2_install_schema->
           percent_tspace)),"%"))
       ENDIF
      ENDIF
      IF ((drr_clin_copy_data->starting_point != "FROM_BEGINNING"))
       row + 1
      ENDIF
      IF ((drr_clin_copy_data->process="MIGRATION"))
       row + 1, col 0,
       CALL print("For parallel processing, open additional sessions and execute the following:"),
       row + 1, col 0,
       CALL print("            ccl> dm2_mig_replicate_runner go "),
       row + 1, col 0,
       CALL print("To monitor the progress of a clinical copy, execute the following:"),
       row + 1, col 0,
       CALL print("            ccl> dm2_mig_replicate_monitor go "),
       row + 1
      ELSE
       row + 1, col 0,
       CALL print("For parallel processing, open additional sessions and execute the following:"),
       row + 1, col 0,
       CALL print("            ccl> dm2_replicate_runner go "),
       row + 1, col 0,
       CALL print("To monitor the progress of a clinical copy, execute the following:"),
       row + 1, col 0,
       CALL print("            ccl> dm2_domain_maint go "),
       row + 1, col 0,
       CALL print("            Replicate/Refresh a Domain -> Monitor Copy of Clinical Database"),
       row + 1, row + 1
      ENDIF
      IF ((drr_clin_copy_data->starting_point != "FROM_BEGINNING"))
       row + 1
      ENDIF
     ENDIF
    FOOT REPORT
     col 0, "END OF REPORT"
    WITH nocounter, maxcol = 300, formfeed = none,
     maxrow = 1, nullreport
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_disp_file(dds_file,"Clinical Database Summary Report")=0)
    RETURN(0)
   ENDIF
   SET message = window
   CALL clear(1,1)
   CALL text(4,2,"Database Summary Report Confirmation")
   CALL text(7,2,"Enter 'C' to continue or 'Q' to quit (C or Q) :")
   CALL accept(7,60,"p;cu",""
    WHERE curaccept IN ("C", "Q"))
   IF (curaccept="Q")
    SET message = nowindow
    SET dm_err->eproc = "Displaying Clinical Database Summary."
    SET dm_err->emsg = "User chose to quit from Clinical Database Summary."
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET drr_clin_copy_data->summary_screen_issued = 1
    SET message = nowindow
    RETURN(1)
   ENDIF
 END ;Subroutine
 SUBROUTINE drr_get_invalid_tables_list(null)
   DECLARE dgitl_iter = i4 WITH protect, noconstant(0)
   DECLARE dgitl_found = i4 WITH protect, noconstant(0)
   DECLARE dgitl_found2 = i4 WITH protect, noconstant(0)
   DECLARE dgitl_found3 = i4 WITH protect, noconstant(0)
   FREE RECORD tables_doc_list
   RECORD tables_doc_list(
     1 cnt = i4
     1 qual[*]
       2 table_name = vc
   )
   FREE RECORD exception_list
   RECORD exception_list(
     1 cnt = i4
     1 qual[*]
       2 table_name = vc
       2 owner = vc
   )
   SET dm_err->eproc = "Determining if CQM* exception row exists in dm_info."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "DM2_REPLICATE_CLEANUP_EXCEPTION"=di.info_domain
     AND "CQM\*"=di.info_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->eproc = "Inserting CQM* row as exception into dm_info."
    INSERT  FROM dm_info di
     SET di.info_domain = "DM2_REPLICATE_CLEANUP_EXCEPTION", di.info_name = "CQM*", di.info_number =
      1
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ROLLBACK
     RETURN(0)
    ENDIF
    COMMIT
   ENDIF
   SET dm_err->eproc = "Selecting list of exception tables from dm_info."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "DM2_REPLICATE_CLEANUP_EXCEPTION"=di.info_domain
     AND 1=di.info_number
    HEAD REPORT
     exception_list->cnt = 0, stat = alterlist(exception_list->qual,0)
    DETAIL
     exception_list->cnt = (exception_list->cnt+ 1), stat = alterlist(exception_list->qual,
      exception_list->cnt), exception_list->qual[exception_list->cnt].table_name = di.info_name,
     exception_list->qual[exception_list->cnt].owner = "V500"
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((drr_clin_copy_data->tgt_mock_env=1))
    SET exception_list->cnt = (exception_list->cnt+ 1)
    SET stat = alterlist(exception_list->qual,exception_list->cnt)
    SET exception_list->qual[exception_list->cnt].table_name = "*$R"
    SET exception_list->qual[exception_list->cnt].owner = "V500"
   ENDIF
   SET exception_list->cnt = (exception_list->cnt+ 1)
   SET stat = alterlist(exception_list->qual,exception_list->cnt)
   SET exception_list->qual[exception_list->cnt].table_name = "*$C"
   SET exception_list->qual[exception_list->cnt].owner = "V500"
   SET exception_list->cnt = (exception_list->cnt+ 1)
   SET stat = alterlist(exception_list->qual,exception_list->cnt)
   SET exception_list->qual[exception_list->cnt].table_name = "*$O"
   SET exception_list->qual[exception_list->cnt].owner = "V500"
   SET exception_list->cnt = (exception_list->cnt+ 1)
   SET stat = alterlist(exception_list->qual,exception_list->cnt)
   SET exception_list->qual[exception_list->cnt].table_name = "*GTTD"
   SET exception_list->qual[exception_list->cnt].owner = "V500"
   SET exception_list->cnt = (exception_list->cnt+ 1)
   SET stat = alterlist(exception_list->qual,exception_list->cnt)
   SET exception_list->qual[exception_list->cnt].table_name = "*GTTP"
   SET exception_list->qual[exception_list->cnt].owner = "V500"
   SET exception_list->cnt = (exception_list->cnt+ 1)
   SET stat = alterlist(exception_list->qual,exception_list->cnt)
   SET exception_list->qual[exception_list->cnt].table_name = "*GTMP"
   SET exception_list->qual[exception_list->cnt].owner = "V500"
   IF ((drr_retain_db_users->cnt > 0))
    FOR (dgitl_iter = 1 TO drr_retain_db_users->cnt)
      SET exception_list->cnt = (exception_list->cnt+ 1)
      SET stat = alterlist(exception_list->qual,exception_list->cnt)
      SET exception_list->qual[exception_list->cnt].table_name = "*"
      SET exception_list->qual[exception_list->cnt].owner = drr_retain_db_users->user[dgitl_iter].
      user_name
    ENDFOR
   ENDIF
   SET dgitl_iter = 0
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(exception_list)
   ENDIF
   SET dm_err->eproc = "Selecting list of tables from dm_tables_doc."
   SELECT DISTINCT INTO "nl:"
    dtd.table_name
    FROM dm_tables_doc dtd
    ORDER BY dtd.table_name
    HEAD REPORT
     tables_doc_list->cnt = 0, stat = alterlist(tables_doc_list->qual,tables_doc_list->cnt)
    DETAIL
     tables_doc_list->cnt = (tables_doc_list->cnt+ 1)
     IF (mod(tables_doc_list->cnt,250)=1)
      stat = alterlist(tables_doc_list->qual,(tables_doc_list->cnt+ 249))
     ENDIF
     tables_doc_list->qual[tables_doc_list->cnt].table_name = dtd.table_name
    FOOT REPORT
     stat = alterlist(tables_doc_list->qual,tables_doc_list->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_fill_sch_except("LOCAL")=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dm2_sch_except)
   ENDIF
   IF (drr_get_custom_tables_list(null)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Selecting list of invalid tables from dm2_dba_tables."
   SELECT INTO "nl:"
    FROM dm2_dba_tables ddt
    WHERE "CDBA" != ddt.owner
     AND  NOT (ddt.owner IN (
    (SELECT
     di.info_name
     FROM dm_info di
     WHERE ((di.info_domain IN ("DM2_ORACLE_USER", "DM2_CERNER_USER")
      AND di.info_number=1) OR (di.info_domain="DM2_CUSTOM_USER"))
     WITH nordbbindcons)))
     AND ddt.table_name != "MLOG*"
    ORDER BY ddt.table_name
    HEAD REPORT
     drr_cleanup_drop_list->cnt = 0, stat = alterlist(drr_cleanup_drop_list->qual,
      drr_cleanup_drop_list->cnt), exception_ind = 0
    DETAIL
     exception_ind = 0
     FOR (dgitl_iter = 1 TO exception_list->cnt)
       IF (ddt.table_name=patstring(exception_list->qual[dgitl_iter].table_name,0)
        AND (ddt.owner=exception_list->qual[dgitl_iter].owner))
        exception_ind = 1, dgitl_iter = (exception_list->cnt+ 1)
       ENDIF
     ENDFOR
     IF (exception_ind=0)
      dgitl_found = locateval(dgitl_iter,1,tables_doc_list->cnt,ddt.table_name,tables_doc_list->qual[
       dgitl_iter].table_name), dgitl_found2 = locateval(dgitl_iter,1,dm2_sch_except->tcnt,ddt
       .table_name,dm2_sch_except->tbl[dgitl_iter].tbl_name), dgitl_found3 = locateval(dgitl_iter,1,
       drr_custom_tables->cnt,ddt.table_name,drr_custom_tables->qual[dgitl_iter].table_name,
       ddt.owner,drr_custom_tables->qual[dgitl_iter].owner)
      IF (((dgitl_found=0) OR (ddt.owner != "V500"))
       AND dgitl_found3=0
       AND dgitl_found2=0)
       drr_cleanup_drop_list->cnt = (drr_cleanup_drop_list->cnt+ 1)
       IF (mod(drr_cleanup_drop_list->cnt,25)=1)
        stat = alterlist(drr_cleanup_drop_list->qual,(drr_cleanup_drop_list->cnt+ 24))
       ENDIF
       drr_cleanup_drop_list->qual[drr_cleanup_drop_list->cnt].owner = ddt.owner,
       drr_cleanup_drop_list->qual[drr_cleanup_drop_list->cnt].table_name = ddt.table_name
      ENDIF
     ENDIF
    FOOT REPORT
     stat = alterlist(drr_cleanup_drop_list->qual,drr_cleanup_drop_list->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_cleanup_drop_list)
   ENDIF
   SET dm_err->eproc = "Getting list of Invalid Materialized Views for Invalid Tables being dropped."
   SELECT INTO "nl:"
    FROM dba_mviews dm
    WHERE (list(dm.owner,dm.mview_name)=
    (SELECT
     ddt.owner, ddt.table_name
     FROM dm2_dba_tables ddt
     WHERE "CDBA" != ddt.owner
      AND ((ddt.owner="V500"
      AND ddt.table_name != "CUST*") OR (ddt.owner != "V500"))
      AND  NOT (ddt.owner IN (
     (SELECT
      di.info_name
      FROM dm_info di
      WHERE ((di.info_domain IN ("DM2_ORACLE_USER", "DM2_CERNER_USER")
       AND di.info_number=1) OR (di.info_domain="DM2_CUSTOM_USER"))
      WITH nordbbindcons)))
      AND ddt.table_name != "MLOG*"
      AND  NOT ( EXISTS (
     (SELECT
      "x"
      FROM dm_tables_doc dtd
      WHERE ddt.table_name=dtd.table_name)))))
    HEAD REPORT
     drr_mvdrop_list->cnt = 0, stat = alterlist(drr_mvdrop_list->qual,drr_mvdrop_list->cnt)
    DETAIL
     drr_mvdrop_list->cnt = (drr_mvdrop_list->cnt+ 1)
     IF (mod(drr_mvdrop_list->cnt,10)=1)
      stat = alterlist(drr_mvdrop_list->qual,(drr_mvdrop_list->cnt+ 9))
     ENDIF
     drr_mvdrop_list->qual[drr_mvdrop_list->cnt].owner = dm.owner, drr_mvdrop_list->qual[
     drr_mvdrop_list->cnt].mv_name = dm.mview_name
    FOOT REPORT
     stat = alterlist(drr_mvdrop_list->qual,drr_mvdrop_list->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_mvdrop_list)
   ENDIF
   SET drr_cleanup_drop_list->list_loaded_ind = 1
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_get_custom_tables_list(null)
   DECLARE dgct_idx = i4 WITH protect, noconstant(0)
   DECLARE dgct_purge_string = vc WITH protect, noconstant("")
   DECLARE dgct_pos = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = "Selecting list of custom tables from dm_info and dm2_dba_tables."
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE "DM2_CUSTOM_TABLE"=di.info_domain
    HEAD REPORT
     drr_custom_tables->cnt = 0, stat = alterlist(drr_custom_tables->qual,0)
    DETAIL
     drr_custom_tables->cnt = (drr_custom_tables->cnt+ 1), stat = alterlist(drr_custom_tables->qual,
      drr_custom_tables->cnt), dgct_pos = findstring(":",trim(di.info_name),1,0)
     IF (dgct_pos > 0)
      drr_custom_tables->qual[drr_custom_tables->cnt].owner = substring(1,(dgct_pos - 1),trim(di
        .info_name)), drr_custom_tables->qual[drr_custom_tables->cnt].table_name = substring((
       dgct_pos+ 1),(textlen(trim(di.info_name)) - dgct_pos),trim(di.info_name)), drr_custom_tables->
      qual[drr_custom_tables->cnt].owner_table = concat(trim(drr_custom_tables->qual[
        drr_custom_tables->cnt].owner),trim(drr_custom_tables->qual[drr_custom_tables->cnt].
        table_name))
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm2_dba_tables ddt
    WHERE ddt.owner="V500"
     AND ddt.table_name=patstring("CUST*")
    DETAIL
     IF (locateval(dgct_idx,1,drr_custom_tables->cnt,ddt.table_name,drr_custom_tables->qual[dgct_idx]
      .table_name)=0)
      drr_custom_tables->cnt = (drr_custom_tables->cnt+ 1), stat = alterlist(drr_custom_tables->qual,
       drr_custom_tables->cnt), drr_custom_tables->qual[drr_custom_tables->cnt].table_name = ddt
      .table_name,
      drr_custom_tables->qual[drr_custom_tables->cnt].owner = ddt.owner, drr_custom_tables->qual[
      drr_custom_tables->cnt].owner_table = concat(trim(ddt.owner),trim(ddt.table_name))
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_custom_tables)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_process_invalid_tables(null)
   DECLARE dpit_iter = i4 WITH protect, noconstant(0)
   DECLARE dpit_purge_string = vc WITH protect, noconstant("")
   DECLARE dpit_drop_cmd = vc WITH protect, noconstant("")
   DECLARE dpit_nodrop_ind = i2 WITH protect, noconstant(0)
   FREE RECORD all_objects_list
   RECORD all_objects_list(
     1 cnt = i4
     1 qual[*]
       2 object_name = vc
   )
   CALL dm2_get_rdbms_version(null)
   IF ((dm2_rdbms_version->level1 <= 9))
    SET dpit_purge_string = " "
   ELSE
    SET dpit_purge_string = "PURGE"
   ENDIF
   IF ((dm2_install_schema->process_option != patstring("CLIN COPY*")))
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Processing of invalid tables is only allowed during CLIN COPY"
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   FOR (dpit_iter = 1 TO drr_mvdrop_list->cnt)
     SET dpit_nodrop_ind = 0
     IF ((drr_clin_copy_data->process != "RESTORE")
      AND (drr_mvdrop_list->qual[dpit_iter].owner != "V500"))
      SET dpit_nodrop_ind = 1
     ENDIF
     IF (dpit_nodrop_ind=0)
      SET dpit_drop_cmd = concat('RDB ASIS(^DROP MATERIALIZED VIEW "',drr_mvdrop_list->qual[dpit_iter
       ].owner,'"."',drr_mvdrop_list->qual[dpit_iter].mv_name,'" ^) GO')
      IF ((dm_err->debug_flag=318))
       CALL echo(dpit_drop_cmd)
      ELSE
       IF (dm2_push_cmd(dpit_drop_cmd,1)=0)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   FOR (dpit_iter = 1 TO drr_cleanup_drop_list->cnt)
     SET dpit_nodrop_ind = 0
     IF ((drr_clin_copy_data->process != "RESTORE")
      AND (drr_cleanup_drop_list->qual[dpit_iter].owner != "V500"))
      SET dpit_nodrop_ind = 1
     ENDIF
     IF (dpit_nodrop_ind=0)
      SET dpit_drop_cmd = concat('RDB ASIS(^DROP TABLE "',drr_cleanup_drop_list->qual[dpit_iter].
       owner,'"."',drr_cleanup_drop_list->qual[dpit_iter].table_name,'" CASCADE CONSTRAINTS ',
       dpit_purge_string," ^) GO")
      IF ((dm_err->debug_flag=318))
       CALL echo(dpit_drop_cmd)
      ELSE
       IF (dm2_push_cmd(dpit_drop_cmd,1)=0)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_cleanup_drop_list)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_confirm_invalid_tables(dcit_manage_opt_ind,dcit_confirm_ret)
   SET message = window
   CALL clear(1,1)
   CALL box(1,1,24,131)
   CALL text(2,36,"INVALID TABLES REPORT CONFIRMATION")
   CALL text(4,2,"Is the invalid tables report correct?")
   IF (dcit_manage_opt_ind=1)
    CALL text(6,2,"The Manage Custom Users option can be leveraged to manage custom users ")
    CALL text(7,2,"that will then be exempt from the invalid tables process.")
    CALL text(8,2,
     "It will be the clients responsibility to evaluate that there is no data copied to TARGET")
    CALL text(9,2,"that still points back to the SOURCE domain/database.")
    CALL text(21,2,"(M)anage Custom Users, (C)onfirm, (Q)uit : ")
    CALL accept(21,45,"A;cu"," "
     WHERE curaccept IN ("M", "C", "Q"))
   ELSE
    CALL text(21,2,"(C)onfirm, (Q)uit : ")
    CALL accept(21,25,"A;cu"," "
     WHERE curaccept IN ("C", "Q"))
   ENDIF
   CASE (curaccept)
    OF "M":
     SET dcit_confirm_ret = 2
    OF "C":
     SET dcit_confirm_ret = 1
    OF "Q":
     SET dcit_confirm_ret = 0
   ENDCASE
   SET message = nowindow
   RETURN(1)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_get_dbase_created_date(dgdcd_created_date)
   IF (dm2_get_rdbms_version(null)=0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Retrieving database created date"
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dm2_rdbms_version->level1 <= 11))
    SELECT INTO "nl:"
     FROM v$database v
     DETAIL
      dgdcd_created_date = v.created
     WITH nocounter
    ;end select
   ELSE
    SELECT INTO "nl:"
     FROM (
      (
      (SELECT
       creation_time = x.creation_time
       FROM (parser("v$pdbs") x)
       WITH sqltype("DQ8")))
      v)
     DETAIL
      dgdcd_created_date = v.creation_time
     WITH nocounter
    ;end select
   ENDIF
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_get_max_clin_copy_run_id(dgm_run_id)
   SET dm_err->eproc = "Retrieving max run_id for CLIN COPY"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm2_ddl_ops d
    WHERE d.run_id IN (
    (SELECT
     max(r.run_id)
     FROM dm2_ddl_ops r
     WHERE r.process_option="CLIN COPY"))
    DETAIL
     dgm_run_id = d.run_id
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_validate_ref_data_link(null)
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    EXECUTE dm2_create_database_link "REF_DATA_LINK", drrr_rf_data->src_db_link_cnct_desc,
    drrr_rf_data->src_db_user,
    drrr_rf_data->src_db_user_pwd, drrr_rf_data->src_db_link_host, drrr_rf_data->src_db_link_port,
    drrr_rf_data->src_db_link_svc_nm, drrr_rf_data->src_db_cred_nm, 1,
    1
   ELSE
    EXECUTE dm2_create_database_link "REF_DATA_LINK", dm2_install_schema->src_v500_connect_str,
    "V500",
    dm2_install_schema->src_v500_p_word, " ", " ",
    " ", " ", 1,
    1
   ENDIF
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    EXECUTE dm2_create_database_link "REPL_SOURCE", drrr_rf_data->src_db_link_cnct_desc, drrr_rf_data
    ->src_db_user,
    drrr_rf_data->src_db_user_pwd, drrr_rf_data->src_db_link_host, drrr_rf_data->src_db_link_port,
    drrr_rf_data->src_db_link_svc_nm, drrr_rf_data->src_db_cred_nm, 1,
    1
   ELSE
    EXECUTE dm2_create_database_link "REPL_SOURCE", dm2_install_schema->src_v500_connect_str, "V500",
    dm2_install_schema->src_v500_p_word, " ", " ",
    " ", " ", 1,
    1
   ENDIF
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_drop_db_link(dddl_link_name)
   DECLARE dddl_dblink_fnd_ind = i2 WITH protect, noconstant(0)
   DECLARE dddl_adb_ind = i2 WITH protect, noconstant(0)
   DECLARE drop_database_link(db_link_name=vc,public_link=i4) = null WITH sql =
   "DBMS_CLOUD_ADMIN.DROP_DATABASE_LINK", parameter
   IF (drr_check_db_link(dddl_link_name,dddl_dblink_fnd_ind)=0)
    RETURN(0)
   ENDIF
   IF (dddl_dblink_fnd_ind=1)
    IF (dm2_adb_check("",dddl_adb_ind)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Removing existing database link for ",dddl_link_name)
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (dddl_adb_ind=1)
     CALL drop_database_link(dddl_link_name,cnvtbool(true))
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF (dm2_push_cmd(concat("rdb drop public database link ",dddl_link_name," go"),1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Database link ",dddl_link_name," does not exist in database.")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_ads_domain_check(dadc_db_link,dadc_ads_domain_ind)
   SET dm_err->eproc = concat("Check if domain is configured for ADS.")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT
    IF (dadc_db_link > "")
     FROM (parser(concat("dm_info@",dadc_db_link)) d)
    ELSE
     FROM dm_info d
    ENDIF
    INTO "nl:"
    WHERE d.info_domain="DM2_REPL_METADATA"
     AND d.info_name=parser("'ADS_CONFIG_ID'")
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (curqual > 0)
    SET dadc_ads_domain_ind = 1
   ELSE
    SET dadc_ads_domain_ind = 0
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_prompt_ads_config(dpac_response)
   DECLARE dpac_config_name = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dpac_config_status = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dpac_config_selected = i2 WITH protect, noconstant(0)
   DECLARE dpac_config_idx = i2 WITH protect, noconstant(0)
   DECLARE dpac_purge_cnt = i2 WITH protect, noconstant(0)
   EXECUTE dm2_ads_validate_configs
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   CALL dar_clear_dads_list(null)
   SET dm_err->eproc = "Load ADS Config."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT
    IF ((drr_clin_copy_data->purge_chosen_ind=1))
     WHERE s.config_status IN ("COMPLETE", "REPLICATE_RUNNING")
      AND s.sample_method=dpl_purge
    ELSE
     WHERE s.config_status="COMPLETE"
    ENDIF
    INTO "nl:"
    FROM dm_ads_config s
    ORDER BY s.updt_dt_tm DESC
    HEAD REPORT
     cnt = 0
    DETAIL
     cnt = (cnt+ 1)
     IF (mod(cnt,10)=1)
      stat = alterlist(dads_list->config_qual,(cnt+ 9))
     ENDIF
     dads_list->config_qual[cnt].config_id = s.dm_ads_config_id, dads_list->config_qual[cnt].
     config_name = cnvtupper(trim(s.config_name)), dads_list->config_qual[cnt].config_method = s
     .sample_method,
     dads_list->config_qual[cnt].config_status = s.config_status, dads_list->config_qual[cnt].
     config_pct = s.sample_percent_nbr, dads_list->config_qual[cnt].config_updt_dt_tm = s.updt_dt_tm
    FOOT REPORT
     dads_list->config_cnt = cnt, stat = alterlist(dads_list->config_qual,cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dads_list)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=0)
    IF (curqual=0)
     SET message = window
     CALL clear(1,1)
     CALL box(6,1,12,131)
     CALL text(7,5,"No valid sample was found. Please exit this menu and go to ")
     IF ((drr_clin_copy_data->purge_chosen_ind=1))
      CALL text(8,5,concat("dm2_ads_purge_adm->Manage ADS Sample. ",
        " Only Sample Names with a Status of REPLICATE READY"))
     ELSE
      CALL text(8,5,concat("dm2_domain_maint->Activity Data Sampler->Manage Activity Data Sample. ",
        " Only Sample Names with a Status of COMPLETE"))
     ENDIF
     CALL text(9,5,"can be used for Database Replicates.")
     CALL text(11,5,"Press Enter to exit the Replicate Process")
     CALL accept(11,51,"P;E"," ")
     SET dpac_config_selected = 1
     SET dpac_response = "Q"
    ENDIF
    WHILE (dpac_config_selected=0)
      SET message = window
      CALL clear(1,1)
      CALL box(1,1,24,131)
      IF ((drr_clin_copy_data->purge_chosen_ind=1))
       CALL text(2,2,"Activity Data Purge Sample Selection")
       CALL text(4,2,"Current Sample : ")
      ELSE
       CALL text(2,2,"Activity Data Sample Selection")
       CALL text(4,2,"Current Sample Name : ")
      ENDIF
      CALL text(15,2,
       "If you wish to create or modify a Sample Name, please exit this menu and go to ")
      IF ((drr_clin_copy_data->purge_chosen_ind=1))
       CALL text(16,2,concat("dm2_ads_purge_adm->Manage ADS Sample. ",
         " Only Sample Names with a Status of REPLICATE READY"))
      ELSE
       CALL text(16,2,concat("dm2_domain_maint->Activity Data Sampler->Manage Activity Data Sample. ",
         " Only Sample Names with a Status of COMPLETE"))
      ENDIF
      CALL text(17,2,"can be used for Database Replicates.")
      IF ((drr_clin_copy_data->purge_chosen_ind=1))
       SELECT INTO "nl:"
        num_keys = count(dacd.driver_key_id)
        FROM dm_ads_config_driver dacd
        WHERE (dacd.dm_ads_config_id=dads_list->config_qual[1].config_id)
        DETAIL
         dpac_purge_cnt = num_keys
        WITH nocounter
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       CALL text(6,5,"SAMPLE NAME")
       CALL text(6,31,"NUMBER OF PERSONS TO PURGE")
       CALL text(6,61,"LAST MODIFIED")
       CALL line(7,5,69)
       CALL text(8,5,substring(1,30,dads_list->config_qual[1].config_name))
       CALL text(8,31,cnvtstring(dpac_purge_cnt))
       CALL text(8,61,substring(1,13,format(dads_list->config_qual[1].config_updt_dt_tm,
          "DD-MMM-YYYY;;D")))
       SET dpac_config_name = dads_list->config_qual[1].config_name
      ELSE
       SET help = pos(5,2,10,128)
       SET help =
       SELECT INTO "nl:"
        sample_name = substring(1,30,dads_list->config_qual[t.seq].config_name), status = substring(1,
         11,dads_list->config_qual[t.seq].config_status), method = substring(1,12,dads_list->
         config_qual[t.seq].config_method),
        pct = build(dads_list->config_qual[t.seq].config_pct), last_modified = substring(1,14,format(
          dads_list->config_qual[t.seq].config_updt_dt_tm,"DD-MMM-YYYY;;D"))
        FROM (dummyt t  WITH seq = value(dads_list->config_cnt))
        WITH nocounter
       ;end select
       CALL accept(4,30,"P(30);CSF")
       SET help = off
       SET dpac_config_name = build(curaccept)
      ENDIF
      SET dpac_config_selected = 1
      IF ((drr_clin_copy_data->purge_chosen_ind=1))
       CALL text(21,2,"(C)ontinue, (Q)uit : ")
       CALL accept(21,52,"A;cu"," "
        WHERE curaccept IN ("C", "Q"))
      ELSE
       CALL text(21,2,"(S)elect a Sample Name, (V)iew Driver Table Report, (C)ontinue, (Q)uit : ")
       CALL accept(21,52,"A;cu"," "
        WHERE curaccept IN ("S", "V", "C", "Q"))
      ENDIF
      IF (curaccept="S")
       SET dpac_config_selected = 0
      ELSEIF (curaccept="V")
       SET dpac_config_idx = 0
       SET dpac_config_idx = locateval(dpac_config_idx,1,dads_list->config_cnt,dpac_config_name,
        dads_list->config_qual[dpac_config_idx].config_name)
       IF (dpac_config_idx > 0)
        IF ((dads_list->config_qual[dpac_config_idx].config_status="COMPLETE"))
         SET dads_list->config_id = dads_list->config_qual[dpac_config_idx].config_id
         EXECUTE dm2_ads_rpt_dkeys
         IF ((dm_err->err_ind=1))
          SET message = nowindow
          RETURN(0)
         ENDIF
        ENDIF
       ENDIF
       SET dpac_config_selected = 0
      ELSEIF (curaccept="C")
       SET dpac_config_idx = 0
       SET dpac_config_idx = locateval(dpac_config_idx,1,dads_list->config_cnt,dpac_config_name,
        dads_list->config_qual[dpac_config_idx].config_name)
       IF (dpac_config_idx > 0)
        IF ((drr_clin_copy_data->purge_chosen_ind=1)
         AND  NOT ((dads_list->config_qual[dpac_config_idx].config_status IN ("COMPLETE",
        "REPLICATE_RUNNING"))))
         SET dpac_config_selected = 0
        ELSEIF ((drr_clin_copy_data->purge_chosen_ind=0)
         AND (dads_list->config_qual[dpac_config_idx].config_status != "COMPLETE"))
         SET dpac_config_selected = 0
        ELSE
         SET drr_clin_copy_data->ads_config_id = dads_list->config_qual[dpac_config_idx].config_id
         SET drr_clin_copy_data->ads_name = dads_list->config_qual[dpac_config_idx].config_name
         SET drr_clin_copy_data->ads_mod_dt_tm = dads_list->config_qual[dpac_config_idx].
         config_updt_dt_tm
         SET drr_clin_copy_data->ads_pct = dads_list->config_qual[dpac_config_idx].config_pct
         SET dpac_response = "C"
        ENDIF
       ELSE
        SET dpac_config_selected = 0
       ENDIF
      ELSEIF (curaccept="Q")
       SET dpac_response = "Q"
      ENDIF
    ENDWHILE
   ELSE
    SET dpac_config_idx = 0
    SET dpac_config_idx = locateval(dpac_config_idx,1,dads_list->config_cnt,drrr_rf_data->
     ads_config_name,dads_list->config_qual[dpac_config_idx].config_name)
    IF (dpac_config_idx > 0)
     SET dads_list->config_id = dads_list->config_qual[dpac_config_idx].config_id
     EXECUTE dm2_ads_rpt_dkeys
     IF ((dm_err->err_ind=1))
      SET message = nowindow
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Find config name ",drrr_rf_data->ads_config_name,
      " in completed ADS config list.")
     SET dm_err->emsg = "Failed to find config name."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drr_clin_copy_data->ads_config_id = dads_list->config_qual[dpac_config_idx].config_id
    SET drr_clin_copy_data->ads_name = dads_list->config_qual[dpac_config_idx].config_name
    SET drr_clin_copy_data->ads_mod_dt_tm = dads_list->config_qual[dpac_config_idx].config_updt_dt_tm
    SET drr_clin_copy_data->ads_pct = dads_list->config_qual[dpac_config_idx].config_pct
    SET dpac_response = "C"
   ENDIF
   SET message = nowindow
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_validate_tgtdblink(dvt_tgt_host,dvt_tgt_ora_ver,dvt_src_host)
   DECLARE dvt_create_link = i2 WITH protect, noconstant(0)
   DECLARE dvt_link_name = vc WITH protect, noconstant("")
   DECLARE dvt_database_name = vc WITH protect, noconstant("")
   DECLARE dvt_link_validated = i2 WITH protect, noconstant(0)
   DECLARE dvt_owner = vc WITH protect, noconstant("")
   IF ((drr_clin_copy_data->process="MIGRATION"))
    SET dvt_link_name = "MIG_TARGET"
   ELSE
    SET dvt_link_name = concat("REPL_",trim(cnvtupper(dm2_install_schema->v500_connect_str)))
   ENDIF
   IF (validate(drrr_responsefile_in_use,- (1))=1)
    EXECUTE dm2_create_database_link dvt_link_name, drrr_rf_data->tgt_db_link_cnct_desc, drrr_rf_data
    ->tgt_db_user,
    drrr_rf_data->tgt_db_user_pwd, drrr_rf_data->tgt_db_link_host, drrr_rf_data->tgt_db_link_port,
    drrr_rf_data->tgt_db_link_svc_nm, drrr_rf_data->tgt_db_cred_nm, 1,
    0
   ELSE
    EXECUTE dm2_create_database_link dvt_link_name, dm2_install_schema->v500_connect_str, "V500",
    dm2_install_schema->v500_p_word, " ", " ",
    " ", " ", 1,
    0
   ENDIF
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF (validate(dm2_bypass_src_to_tgt_dblink_verify_ind,- (1)) != 1)
    WHILE (dvt_link_validated=0)
      SET dm_err->eproc = concat("Validating database link ",trim(dvt_link_name),
       " in Source database ",trim(dm2_install_schema->src_dbase_name)," to Target database ",
       trim(dm2_install_schema->target_dbase_name))
      CALL disp_msg(" ",dm_err->logfile,0)
      SELECT
       IF (dvt_tgt_ora_ver <= 11)
        FROM (parser(concat("v$database@",trim(dvt_link_name))) v)
       ELSE
        FROM (parser(concat("v$pdbs@",trim(dvt_link_name))) v)
       ENDIF
       INTO "nl:"
       DETAIL
        dvt_database_name = v.name
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL echo("ABOVE ERROR IS IGNORABLE")
      ENDIF
      IF ((((dm_err->err_ind=1)) OR (cnvtupper(dvt_database_name) != cnvtupper(dm2_install_schema->
       target_dbase_name))) )
       SET dm_err->err_ind = 0
       IF (validate(drrr_responsefile_in_use,0)=0)
        SET message = window
        CALL clear(1,1)
        CALL box(1,1,24,131)
        CALL text(2,2,"[Replicate] Source TNS Entry confirmation for Target Database")
        CALL text(4,2,concat("Please verify that appropriate",
          " TNS connect string entry exists for Target database [",trim(dm2_install_schema->
           target_dbase_name),"]."))
        CALL text(5,2,concat("on the SOURCE database node [",trim(dvt_src_host),"]"))
        CALL text(21,2,"Enter 'C' to Continue or 'Q' to Quit (C or Q) :")
        CALL accept(21,80,"A;cu"," "
         WHERE curaccept IN ("C", "Q"))
        SET message = nowindow
        IF (curaccept="Q")
         SET dm_err->err_ind = 1
         SET dm_err->emsg =
         "User choose to Quit from [Replicate] Source TNS Entry confirmation screen."
         CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
         RETURN(0)
        ENDIF
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->emsg = concat("Failed to validate database link ",trim(dvt_link_name),
         " in Source database ",trim(dm2_install_schema->src_dbase_name)," to Target database ",
         trim(dm2_install_schema->target_dbase_name))
        SET dm_err->user_action = concat("Please verify that appropriate Target database ",
         "TNS connect string entry exists for Target database [",trim(dm2_install_schema->
          target_dbase_name),"] on the Source database [",trim(dm2_install_schema->src_dbase_name),
         "] node [",trim(dvt_src_host),"].")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
      ELSE
       SET dvt_link_validated = 1
      ENDIF
    ENDWHILE
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_set_src_env_path(null)
   DECLARE dsse_str = vc WITH protect, noconstant("")
   DECLARE dsse_tmp_str = vc WITH protext, noconstant("")
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("temp_location = ",drr_clin_copy_data->temp_location))
    CALL echo(build("tgt_env_name = ",drr_clin_copy_data->tgt_env_name))
    CALL echo(build("src_env_name = ",drr_clin_copy_data->src_domain_name))
   ENDIF
   SET dsse_str = substring(1,(size(drr_clin_copy_data->temp_location) - 1),drr_clin_copy_data->
    temp_location)
   CALL echo(build("dsse_str =",dsse_str))
   SET dsse_tmp_str = cnvtlower(substring((findstring("/",dsse_str,1,1)+ 1),size(drr_clin_copy_data->
      tgt_env_name),dsse_str))
   CALL echo(build("search_str =",dsse_tmp_str))
   IF (cnvtlower(drr_clin_copy_data->tgt_env_name)=dsse_tmp_str)
    SET drr_env_hist_misc->path = replace(drr_clin_copy_data->temp_location,cnvtlower(
      drr_clin_copy_data->tgt_env_name),cnvtlower(drr_clin_copy_data->src_domain_name),2)
   ELSE
    IF ((dm2_sys_misc->cur_os != "AXP"))
     SET drr_env_hist_misc->path = concat(drr_clin_copy_data->temp_location,cnvtlower(
       drr_clin_copy_data->src_domain_name),"/")
    ELSE
     SET dsse_str = concat(".",drr_clin_copy_data->src_domain_name,"]")
     SET drr_env_hist_misc->path = replace(drr_clin_copy_data->temp_location,"]",dsse_str,2)
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("drr_env_hist_misc->path = ",drr_env_hist_misc->path))
   ENDIF
 END ;Subroutine
 SUBROUTINE drr_validate_adm_env_csv(dvae_path,dvae_src_env)
   SET dm_err->eproc = "Validate Source environment history files."
   CALL disp_msg("",dm_err->logfile,0)
   DECLARE dvae_idx = i4 WITH protect, noconstant(0)
   DECLARE dvae_summary_file = vc WITH protect, noconstant("")
   SET drr_env_hist_misc->cnt = 0
   SET stat = alterlist(drr_env_hist_misc->qual,0)
   IF ( NOT (dm2_find_dir(dvae_path)))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validate directory passed in during drr_validate_adm_env_csv."
    SET dm_err->emsg = concat("Fail to find directory ",dvae_path)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drr_env_hist_misc->summary_file = concat("dm2_",trim(cnvtlower(dvae_src_env)),
    "_env_hist_summary.txt")
   IF (dm2_findfile(concat(dvae_path,drr_env_hist_misc->summary_file))=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validate if file ",dvae_path,trim(drr_env_hist_misc->summary_file),
     " exists.")
    SET dm_err->emsg =
    "Source environment history summary files could not be found in temporary directory provided."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvae_summary_file = concat(dvae_path,drr_env_hist_misc->summary_file)
   SET dm_err->eproc = concat("Load file ",dvae_summary_file)
   CALL disp_msg("",dm_err->logfile,0)
   FREE SET inputfile
   SET logical inputfile dvae_summary_file
   FREE DEFINE rtl2
   DEFINE rtl2 "inputfile"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     cnt = 0, begin_ptr = 0, end_ptr = 0
    DETAIL
     IF (trim(r.line) != "")
      drr_env_hist_misc->cnt = (drr_env_hist_misc->cnt+ 1), cnt = drr_env_hist_misc->cnt, stat =
      alterlist(drr_env_hist_misc->qual,cnt),
      begin_ptr = findstring(",",r.line), end_ptr = findstring(",",r.line,(begin_ptr+ 1)),
      drr_env_hist_misc->qual[cnt].table_name = trim(substring(1,(begin_ptr - 1),r.line)),
      drr_env_hist_misc->qual[cnt].table_alias = trim(substring((begin_ptr+ 1),((end_ptr - begin_ptr)
         - 1),r.line)), begin_ptr = findstring(",",r.line,(end_ptr+ 1)), drr_env_hist_misc->qual[cnt]
      .csv_file_name = trim(substring((end_ptr+ 1),((begin_ptr - end_ptr) - 1),r.line)),
      end_ptr = findstring(",",r.line,(begin_ptr+ 1)), drr_env_hist_misc->qual[cnt].row_count = trim(
       substring((begin_ptr+ 1),((end_ptr - begin_ptr) - 1),r.line)), drr_env_hist_misc->qual[cnt].
      date = trim(substring((end_ptr+ 1),(textlen(r.line) - end_ptr),r.line))
     ENDIF
    FOOT REPORT
     stat = alterlist(drr_env_hist_misc->qual,cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_env_hist_misc)
   ENDIF
   FOR (dvae_idx = 1 TO drr_env_hist_misc->cnt)
     IF (cnvtint(drr_env_hist_misc->qual[dvae_idx].row_count) > 0)
      IF (dm2_findfile(concat(dvae_path,drr_env_hist_misc->qual[dvae_idx].csv_file_name))=0)
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat("Validate if file ",dvae_path,trim(drr_env_hist_misc->qual[dvae_idx
         ].csv_file_name)," exists.")
       SET dm_err->emsg =
       "Source environment history files could not be found in temporary directory provided."
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_column_and_ccldef_exists(dcce_table_name,dcce_column_name,dcce_exists_ind)
   DECLARE dcce_col_oradef_ind = i2 WITH protect, noconstant(0)
   DECLARE dcce_col_ccldef_ind = i2 WITH protect, noconstant(0)
   DECLARE dcce_data_type = vc WITH protect, noconstant("")
   SET dm_err->eproc = concat("Validate existance of column ",dcce_column_name," on ",dcce_table_name
    )
   CALL disp_msg("",dm_err->logfile,0)
   IF (dm2_table_column_exists(value(currdbuser),dcce_table_name,dcce_column_name,1,1,
    1,dcce_col_oradef_ind,dcce_col_ccldef_ind,dcce_data_type)=0)
    RETURN(0)
   ENDIF
   IF (dcce_col_oradef_ind=1
    AND dcce_col_ccldef_ind=1)
    SET dcce_exists_ind = 1
   ELSE
    SET dcce_exists_ind = 0
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_identify_was_usage(diwu_domain,diwu_was_ind)
   DECLARE diwu_exists_ind = i2 WITH protect, noconstant(0)
   SET diwu_was_ind = 0
   IF (dm2_table_and_ccldef_exists("EA_USER",diwu_exists_ind)=0)
    RETURN(0)
   ENDIF
   IF (diwu_exists_ind=0)
    SET diwu_was_ind = 0
    RETURN(1)
   ENDIF
   SELECT INTO "nl:"
    FROM ea_user eu
    WHERE cnvtupper(eu.realm)=cnvtupper(diwu_domain)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual > 0)
    SET diwu_was_ind = 1
    SET dm_err->eproc = "WAS Security architecture is turned ON"
   ELSE
    SET dm_err->eproc = "WAS Security architecture is turned OFF"
   ENDIF
   CALL disp_msg("",dm_err->logfile,0)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_restore_col_checks(drcc_src,drcc_sti,drcc_sci,drcc_pti,drcc_pci,drcc_tti,drcc_tc)
   IF (drcc_src="T")
    SET curalias drcc_src_col tgtsch->tbl[drcc_sti].tbl_col[drcc_sci]
   ELSEIF (drcc_src="C")
    SET curalias drcc_src_col cur_sch->tbl[drcc_sti].tbl_col[drcc_sci]
   ENDIF
   SET curalias drcc_pre_tbl drr_preserved_tables_data->tbl[drcc_pti]
   SET curalias drcc_pre_col drr_preserved_tables_data->tbl[drcc_pti].col[drcc_pci]
   SET curalias drcc_tgt_col tgtsch->tbl[drcc_tti].tbl_col[drcc_tc]
   SET dm_err->eproc = "Check for preserve restore column mismatch for source and target"
   IF ((drcc_src_col->data_length != drcc_pre_col->data_length))
    SET drcc_pre_col->diff_dlength_ind = 1
    SET drcc_pre_tbl->col_diff = 1
    IF ((drcc_pre_col->data_length > drcc_src_col->data_length))
     SET drcc_tgt_col->data_length = drcc_pre_col->data_length
    ELSE
     SET drcc_tgt_col->data_length = drcc_src_col->data_length
    ENDIF
   ENDIF
   IF ((drcc_src_col->data_type != drcc_pre_col->data_type))
    SET drcc_pre_col->diff_dtype_ind = 1
    SET drcc_pre_tbl->col_diff = 1
    IF ( NOT ((drcc_src_col->data_type IN ("CHAR*", "VARCHAR*", "NUMBER", "FLOAT")))
     AND  NOT ((drcc_pre_col->data_type IN ("CHAR*", "VARCHAR*", "NUMBER", "FLOAT"))))
     SET drr_preserved_tables_data->restore_foul = 1
     SET drcc_pre_tbl->restore_foul = 1
     SET drcc_pre_tbl->reason_cnt = (drcc_pre_tbl->reason_cnt+ 1)
     SET stat = alterlist(drcc_pre_tbl->restore_foul_reasons,drcc_pre_tbl->reason_cnt)
     SET drcc_pre_tbl->restore_foul_reasons[drcc_pre_tbl->reason_cnt].text =
     "Column data type differences found that are not supported."
    ELSE
     IF ((drcc_src_col->data_type="*CHAR*"))
      SET drcc_tgt_col->data_type = "VARCHAR2"
     ELSE
      SET drcc_tgt_col->data_type = drcc_src_col->data_type
     ENDIF
    ENDIF
   ENDIF
   IF ((((drcc_src_col->data_default_ni != drcc_pre_col->data_default_ni)) OR ((drcc_src_col->
   data_default_ni=drcc_pre_col->data_default_ni)
    AND (drcc_src_col->data_default != drcc_pre_col->data_default))) )
    SET drcc_pre_col->diff_default_ind = 1
    SET drcc_pre_tbl->col_diff = 1
    SET drcc_tgt_col->data_default = drcc_src_col->data_default
    SET drcc_tgt_col->data_default_ni = drcc_src_col->data_default_ni
   ENDIF
   IF ((drcc_src_col->nullable != drcc_pre_col->nullable))
    SET drcc_pre_col->diff_nullable_ind = 1
    SET drcc_pre_tbl->col_diff = 1
    SET drcc_tgt_col->nullable = drcc_pre_col->nullable
   ENDIF
   SET curalias drcc_src_col off
   SET curalias drcc_pre_tbl off
   SET curalias drcc_pre_col off
   SET curalias drcc_tgt_col off
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_restore_tbl_checks(drtc_src,drtc_sti,drtc_pti)
   DECLARE drtc_col_idx = i2 WITH protect, noconstant(0)
   DECLARE drtc_pre_col_idx = i2 WITH protect, noconstant(0)
   DECLARE drtc_src_col_idx = i2 WITH protect, noconstant(0)
   IF (drtc_src="T")
    SET curalias drtc_src_rs tgtsch->tbl[drtc_sti]
   ELSEIF (drtc_src="C")
    SET curalias drtc_src_rs cur_sch->tbl[drtc_sti]
   ENDIF
   SET curalias drtc_pre_tbl drr_preserved_tables_data->tbl[drtc_pti]
   SET dm_err->eproc = "Check for preserve restore table mismatch for source and target"
   FOR (drtc_src_idx = 1 TO drtc_src_rs->tbl_col_cnt)
     SET drtc_col_idx = 0
     SET drtc_col_idx = locateval(drtc_col_idx,1,drtc_pre_tbl->col_cnt,drtc_src_rs->tbl_col[
      drtc_src_idx].col_name,drtc_pre_tbl->col[drtc_col_idx].col_name)
     IF (drtc_col_idx=0)
      SET drtc_pre_tbl->extra_src_cols = 1
      IF ((dm2_rdbms_version->level1 >= 11))
       SET drtc_pre_tbl->restore_in_phases = 1
       IF ((drtc_pre_tbl->long_cols_exist > 0))
        SET drr_preserved_tables_data->restore_foul = 1
        SET drtc_pre_tbl->restore_foul = 1
        SET drtc_pre_tbl->reason_cnt = (drtc_pre_tbl->reason_cnt+ 1)
        SET stat = alterlist(drtc_pre_tbl->restore_foul_reasons,drtc_pre_tbl->reason_cnt)
        SET drtc_pre_tbl->restore_foul_reasons[drtc_pre_tbl->reason_cnt].text =
        "Extra Source columns not in Preserved table and Preserved table contains [long/long raw] columns."
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   IF (drtc_src="C")
    FOR (drtc_pre_col_idx = 1 TO drtc_pre_tbl->col_cnt)
      SET drtc_src_col_idx = 0
      SET drtc_src_col_idx = locateval(drtc_src_col_idx,1,drtc_src_rs->tbl_col_cnt,drtc_pre_tbl->col[
       drtc_pre_col_idx].col_name,drtc_src_rs->tbl_col[drtc_src_col_idx].col_name)
      IF (drtc_src_col_idx=0)
       SET drtc_pre_tbl->extra_pre_cols = 1
      ENDIF
    ENDFOR
   ENDIF
   SET curalias drtc_pre_tbl off
   SET curalias drtc_src_rs off
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_restore_report(null)
   DECLARE drr_tbl_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_col_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_grp_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_tblr_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_grpr_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_foul_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_rpt_file = vc WITH protect, noconstant("")
   DECLARE drr_tbl_first = i2 WITH protect, noconstant(0)
   DECLARE drr_col_first = i2 WITH protect, noconstant(0)
   DECLARE drr_res_first = i2 WITH protect, noconstant(0)
   DECLARE drr_grp_str = vc WITH protect, noconstant("")
   DECLARE drr_fact_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_fact_idxg = i2 WITH protect, noconstant(0)
   DECLARE drr_grp_cnt = i2 WITH protect, noconstant(0)
   DECLARE drr_tbl_cnt = i2 WITH protect, noconstant(0)
   DECLARE drr_col_cnt = i2 WITH protect, noconstant(0)
   DECLARE drr_rep_col_idx = i2 WITH protect, noconstant(0)
   DECLARE drr_str = vc WITH protect, noconstant("")
   DECLARE drr_rrd_str = vc WITH protect, noconstant("")
   DECLARE drr_no_cols = i2 WITH protect, noconstant(0)
   IF (validate(drr_res_rpt->grp_cnt,1)=1
    AND validate(drr_res_rpt->grp_cnt,2)=2)
    FREE RECORD drr_res_rpt
    RECORD drr_res_rpt(
      1 grp_cnt = i2
      1 grp[*]
        2 group = vc
        2 refresh_ind = i2
        2 tbl_cnt = i2
        2 tbl[*]
          3 tbl_name = vc
          3 foul_reason = vc
        2 fact_cnt = i2
        2 fact[*]
          3 tbl_name = vc
          3 tbl_not_in_src = i2
          3 extra_src_cols = i2
          3 extra_pre_cols = i2
          3 col_diff = i2
          3 refresh_ind = i2
          3 restore_foul = i2
          3 col_cnt = i2
          3 col[*]
            4 col_name = vc
            4 diff_dtype_ind = i2
            4 diff_dlength_ind = i2
            4 diff_nullable_ind = i2
            4 diff_default_ind = i2
    )
    SET drr_res_rpt->grp_cnt = 0
   ENDIF
   SET dm_err->eproc = "Loading Foul Reason and Table Facts into record structure"
   FOR (drr_tbl_idx = 1 TO drr_preserved_tables_data->cnt)
     SET drr_grp_idx = 0
     SET drr_grp_idx = locateval(drr_grp_idx,1,drr_res_rpt->grp_cnt,drr_preserved_tables_data->tbl[
      drr_tbl_idx].group,drr_res_rpt->grp[drr_grp_idx].group)
     IF (drr_grp_idx=0)
      SET drr_res_rpt->grp_cnt = (drr_res_rpt->grp_cnt+ 1)
      SET stat = alterlist(drr_res_rpt->grp,drr_res_rpt->grp_cnt)
      SET drr_res_rpt->grp[drr_res_rpt->grp_cnt].group = drr_preserved_tables_data->tbl[drr_tbl_idx].
      group
      SET drr_res_rpt->grp[drr_res_rpt->grp_cnt].refresh_ind = drr_preserved_tables_data->tbl[
      drr_tbl_idx].refresh_ind
      SET drr_grp_idx = drr_res_rpt->grp_cnt
     ENDIF
     IF ((drr_preserved_tables_data->tbl[drr_tbl_idx].refresh_ind=1)
      AND (drr_preserved_tables_data->tbl[drr_tbl_idx].restore_foul=1))
      FOR (drr_foul_idx = 1 TO drr_preserved_tables_data->tbl[drr_tbl_idx].reason_cnt)
        SET drr_res_rpt->grp[drr_grp_idx].tbl_cnt = (drr_res_rpt->grp[drr_res_rpt->grp_cnt].tbl_cnt+
        1)
        SET stat = alterlist(drr_res_rpt->grp[drr_grp_idx].tbl,drr_res_rpt->grp[drr_grp_idx].tbl_cnt)
        SET drr_res_rpt->grp[drr_grp_idx].tbl[drr_res_rpt->grp[drr_grp_idx].tbl_cnt].tbl_name =
        drr_preserved_tables_data->tbl[drr_tbl_idx].table_name
        SET drr_res_rpt->grp[drr_grp_idx].tbl[drr_res_rpt->grp[drr_grp_idx].tbl_cnt].foul_reason =
        drr_preserved_tables_data->tbl[drr_tbl_idx].restore_foul_reasons[drr_foul_idx].text
      ENDFOR
     ENDIF
     IF ((((drr_preserved_tables_data->tbl[drr_tbl_idx].refresh_ind=1)) OR ((
     drr_preserved_tables_data->tbl[drr_tbl_idx].refresh_ind=0)
      AND (drr_preserved_tables_data->tbl[drr_tbl_idx].pres_tbl_not_in_src=1))) )
      SET drr_res_rpt->grp[drr_grp_idx].fact_cnt = (drr_res_rpt->grp[drr_grp_idx].fact_cnt+ 1)
      SET stat = alterlist(drr_res_rpt->grp[drr_grp_idx].fact,drr_res_rpt->grp[drr_grp_idx].fact_cnt)
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].tbl_name =
      drr_preserved_tables_data->tbl[drr_tbl_idx].table_name
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].tbl_not_in_src
       = drr_preserved_tables_data->tbl[drr_tbl_idx].pres_tbl_not_in_src
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].extra_src_cols
       = drr_preserved_tables_data->tbl[drr_tbl_idx].extra_src_cols
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].extra_pre_cols
       = drr_preserved_tables_data->tbl[drr_tbl_idx].extra_pre_cols
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].col_diff =
      drr_preserved_tables_data->tbl[drr_tbl_idx].col_diff
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].refresh_ind =
      drr_preserved_tables_data->tbl[drr_tbl_idx].refresh_ind
      SET drr_res_rpt->grp[drr_grp_idx].fact[drr_res_rpt->grp[drr_grp_idx].fact_cnt].restore_foul =
      drr_preserved_tables_data->tbl[drr_tbl_idx].restore_foul
      SET drr_tbl_cnt = drr_res_rpt->grp[drr_grp_idx].fact_cnt
      FOR (drr_col_idx = 1 TO drr_preserved_tables_data->tbl[drr_tbl_idx].col_cnt)
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col_cnt = (drr_res_rpt->grp[drr_grp_idx].
        fact[drr_tbl_cnt].col_cnt+ 1)
        SET drr_col_cnt = drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col_cnt
        SET stat = alterlist(drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col,drr_col_cnt)
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col[drr_col_cnt].col_name =
        drr_preserved_tables_data->tbl[drr_tbl_idx].col[drr_col_idx].col_name
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col[drr_col_cnt].diff_dtype_ind =
        drr_preserved_tables_data->tbl[drr_tbl_idx].col[drr_col_idx].diff_dtype_ind
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col[drr_col_cnt].diff_dlength_ind =
        drr_preserved_tables_data->tbl[drr_tbl_idx].col[drr_col_idx].diff_dlength_ind
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col[drr_col_cnt].diff_nullable_ind =
        drr_preserved_tables_data->tbl[drr_tbl_idx].col[drr_col_idx].diff_nullable_ind
        SET drr_res_rpt->grp[drr_grp_idx].fact[drr_tbl_cnt].col[drr_col_cnt].diff_default_ind =
        drr_preserved_tables_data->tbl[drr_tbl_idx].col[drr_col_idx].diff_default_ind
      ENDFOR
     ENDIF
   ENDFOR
   IF (get_unique_file("dm2_res_rpt",".rpt")=0)
    RETURN(0)
   ENDIF
   SET drr_rpt_file = dm_err->unique_fname
   IF (validate(drrr_responsefile_in_use,0)=1)
    SET drr_rpt_file = build(drrr_misc_data->active_dir,drr_rpt_file)
   ENDIF
   SET drr_preserved_tables_data->res_rep_name = drr_rpt_file
   SET dm_err->eproc = "Generating report for Restore Preserve Tables"
   IF ((drr_res_rpt->grp_cnt > 0))
    SET drr_preserved_tables_data->foul_grp_str = " "
    SET drr_rrd_str = " "
    SELECT INTO value(drr_rpt_file)
     FROM (dummyt t  WITH seq = 1)
     HEAD REPORT
      col 90, "RESTORE GROUP REPORT", row + 2,
      col 0, "Restore Groups: "
      FOR (drr_grp_idx = 1 TO drr_res_rpt->grp_cnt)
        IF ((drr_res_rpt->grp[drr_grp_idx].refresh_ind=1))
         IF ((drr_res_rpt->grp[drr_grp_idx].group != "NOPROMPT"))
          IF (drr_grp_idx=1
           AND (drr_grp_idx != drr_res_rpt->grp_cnt))
           drr_grp_str = concat(drr_res_rpt->grp[drr_grp_idx].group,", ")
          ELSEIF ((drr_grp_idx=drr_res_rpt->grp_cnt))
           drr_grp_str = concat(drr_grp_str,drr_res_rpt->grp[drr_grp_idx].group)
          ELSE
           drr_grp_str = concat(drr_grp_str,drr_res_rpt->grp[drr_grp_idx].group,", ")
          ENDIF
         ENDIF
        ENDIF
      ENDFOR
      col 30, drr_grp_str
     DETAIL
      FOR (drr_grp_idx = 1 TO drr_res_rpt->grp_cnt)
        IF ((drr_res_rpt->grp[drr_grp_idx].tbl_cnt > 0))
         IF ((drr_preserved_tables_data->foul_grp_str=""))
          drr_preserved_tables_data->foul_grp_str = drr_res_rpt->grp[drr_grp_idx].group
         ELSE
          drr_preserved_tables_data->foul_grp_str = concat(drr_preserved_tables_data->foul_grp_str,
           ",",drr_res_rpt->grp[drr_grp_idx].group)
         ENDIF
        ENDIF
      ENDFOR
      IF ((drr_preserved_tables_data->foul_grp_str="*PRINTERS*")
       AND (drr_preserved_tables_data->foul_grp_str != "*RRD*")
       AND drr_grp_str="*RRD*")
       drr_preserved_tables_data->foul_grp_str = concat(drr_preserved_tables_data->foul_grp_str,
        ",RRD"), drr_rrd_str =
       "* RRD forced to be deselected along with PRINTERS (RRD  has no invalid tables)."
      ENDIF
      IF ((drr_preserved_tables_data->restore_foul=1))
       row + 1, col 0, "Invalid Restore Groups: ",
       col 30, drr_preserved_tables_data->foul_grp_str
       IF (drr_rrd_str != " ")
        row + 2, col 0, drr_rrd_str,
        row + 1, col 0,
        "USER ACTION: Invalid Restore Groups must be deselected in order to continue process."
       ELSE
        row + 2, col 0,
        "USER ACTION: Invalid Restore Groups must be deselected in order to continue process."
       ENDIF
       row + 2, col 0, "INVALID RESTORE GROUP/TABLE REASONS",
       row + 2, col 0, "GROUP",
       col 17, "TABLE", col 49,
       "REASON", row + 1, col 0,
       CALL print(fillstring(15,"-")), col 17,
       CALL print(fillstring(30,"-")),
       col 49,
       CALL print(fillstring(30,"-"))
       FOR (drr_grpr_idx = 1 TO drr_res_rpt->grp_cnt)
         IF ((drr_res_rpt->grp[drr_grpr_idx].tbl_cnt > 0))
          row + 1, col 0, drr_res_rpt->grp[drr_grpr_idx].group,
          drr_res_first = 1
          FOR (drr_tblr_idx = 1 TO drr_res_rpt->grp[drr_grpr_idx].tbl_cnt)
            IF (drr_res_first=1)
             drr_res_first = 0, col 17, drr_res_rpt->grp[drr_grpr_idx].tbl[drr_tblr_idx].tbl_name,
             col 49, drr_res_rpt->grp[drr_grpr_idx].tbl[drr_tblr_idx].foul_reason
            ELSE
             row + 1, col 17, drr_res_rpt->grp[drr_grpr_idx].tbl[drr_tblr_idx].tbl_name,
             col 49, drr_res_rpt->grp[drr_grpr_idx].tbl[drr_tblr_idx].foul_reason
            ENDIF
          ENDFOR
         ENDIF
       ENDFOR
       drr_str = concat(
        "* Tables with an asterisk (*) in following RESTORE TABLE/COLUMN DIFFERENCES section",
        "are those tables that are part of a restore group that must be deselected."), row + 2, col 0,
       drr_str
      ENDIF
      row + 2, col 0, "RESTORE TABLE/COLUMN DIFFERENCES",
      row + 2, col 49, "TABLE EXISTS",
      col 63, "MARK FOR", col 73,
      "EXTRA COLUMNS", col 88, "EXTRA COLUMNS",
      col 103, "  COLUMN", col 147,
      "DIFF", col 153, "DIFF",
      col 161, "DIFF", col 171,
      "DIFF", row + 1, col 0,
      "GROUP", col 17, "TABLE NAME",
      col 49, "IN SOURCE", col 63,
      "RESTORE", col 73, "IN SOURCE",
      col 88, "IN TARGET", col 103,
      "DIFFERENCE", col 115, "COLUMN NAME",
      col 147, "TYPE", col 153,
      "LENGTH", col 161, "NULLABLE",
      col 171, "DEFAULT", row + 1,
      col 0,
      CALL print(fillstring(15,"-")), col 17,
      CALL print(fillstring(30,"-")), col 49,
      CALL print(fillstring(12,"-")),
      col 63,
      CALL print(fillstring(8,"-")), col 73,
      CALL print(fillstring(13,"-")), col 88,
      CALL print(fillstring(13,"-")),
      col 103,
      CALL print(fillstring(10,"-")), col 115,
      CALL print(fillstring(30,"-")), col 147,
      CALL print(fillstring(4,"-")),
      col 153,
      CALL print(fillstring(6,"-")), col 161,
      CALL print(fillstring(8,"-")), col 171,
      CALL print(fillstring(7,"-")),
      drr_no_cols = 1
      FOR (drr_fact_idxg = 1 TO drr_res_rpt->grp_cnt)
        IF ((drr_res_rpt->grp[drr_fact_idxg].group != "NOPROMPT"))
         drr_tbl_first = 1
         FOR (drr_fact_idx = 1 TO drr_res_rpt->grp[drr_fact_idxg].fact_cnt)
           IF ((((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
            AND (((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_not_in_src=1)) OR ((((
           drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].extra_src_cols=1)) OR ((((drr_res_rpt->
           grp[drr_fact_idxg].fact[drr_fact_idx].extra_pre_cols=1)) OR ((drr_res_rpt->grp[
           drr_fact_idxg].fact[drr_fact_idx].col_diff=1))) )) )) ) OR ((drr_res_rpt->grp[
           drr_fact_idxg].fact[drr_fact_idx].refresh_ind=0)
            AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_not_in_src=1))) )
            IF (drr_tbl_first=1)
             IF (drr_no_cols=1)
              drr_no_cols = 0
             ENDIF
             drr_tbl_first = 0
             IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
              AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].restore_foul=1))
              row + 1, col 0, drr_res_rpt->grp[drr_fact_idxg].group,
              col 16, "*"
             ELSE
              row + 1, col 0, drr_res_rpt->grp[drr_fact_idxg].group
             ENDIF
             col 17, drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_name
            ELSE
             IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
              AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].restore_foul=1))
              row + 1, col 16, "*",
              col 17, drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_name
             ELSE
              row + 1, col 17, drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_name
             ENDIF
            ENDIF
            IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
             AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_not_in_src != 1))
             col 49, "Y"
            ELSE
             col 49, "N"
            ENDIF
            IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=0)
             AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_not_in_src=1))
             col 63, "N"
            ELSE
             col 63, "Y"
            ENDIF
            IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].tbl_not_in_src != 1))
             IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
              AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].extra_src_cols=1))
              col 73, "Y"
             ELSE
              col 73, "N"
             ENDIF
             IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
              AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].extra_pre_cols=1))
              col 88, "Y"
             ELSE
              col 88, "N"
             ENDIF
             IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].refresh_ind=1)
              AND (drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col_diff=1))
              col 103, "Y", drr_col_first = 1
              FOR (drr_rep_col_idx = 1 TO drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col_cnt)
                IF ((((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].
                diff_dtype_ind=1)) OR ((((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[
                drr_rep_col_idx].diff_dlength_ind=1)) OR ((((drr_res_rpt->grp[drr_fact_idxg].fact[
                drr_fact_idx].col[drr_rep_col_idx].diff_nullable_ind=1)) OR ((drr_res_rpt->grp[
                drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].diff_default_ind=1))) )) )) )
                 IF (drr_col_first=1)
                  drr_col_first = 0, col 115, drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[
                  drr_rep_col_idx].col_name
                 ELSE
                  row + 1, col 115, drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[
                  drr_rep_col_idx].col_name
                 ENDIF
                ENDIF
                IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].
                diff_dtype_ind=1))
                 col 147, "Y"
                ENDIF
                IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].
                diff_dlength_ind=1))
                 col 153, "Y"
                ENDIF
                IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].
                diff_nullable_ind=1))
                 col 161, "Y"
                ENDIF
                IF ((drr_res_rpt->grp[drr_fact_idxg].fact[drr_fact_idx].col[drr_rep_col_idx].
                diff_default_ind=1))
                 col 171, "Y"
                ENDIF
              ENDFOR
             ELSE
              col 103, "N"
             ENDIF
            ENDIF
           ENDIF
         ENDFOR
        ENDIF
      ENDFOR
      IF (drr_no_cols=1)
       row + 2, col 0, "No table/column differences found."
      ENDIF
     WITH nocounter, maxcol = 250, format = variable,
      formfeed = none
    ;end select
   ENDIF
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drr_no_cols=1)
    SET dm_err->eproc = concat("Skipping display of RESTORE GROUP REPORT (",drr_rpt_file,
     ") upon no differences")
    CALL disp_msg("",dm_err->logfile,0)
    RETURN(1)
   ELSE
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm_err->eproc = concat("Skipping display of RESTORE GROUP REPORT (",drr_rpt_file,")")
     CALL disp_msg("",dm_err->logfile,0)
     IF ((drer_email_list->email_cnt > 0)
      AND (drr_res_rpt->grp_cnt > 0))
      SET drer_email_det->msgtype = "ACTIONREQ"
      SET drer_email_det->status = "REPORT"
      SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
      SET drer_email_det->step = "RESTORE GROUP REPORT"
      SET drer_email_det->email_level = 1
      SET drer_email_det->logfile = dm_err->logfile
      SET drer_email_det->err_ind = dm_err->err_ind
      SET drer_email_det->eproc = dm_err->eproc
      SET drer_email_det->emsg = dm_err->emsg
      SET drer_email_det->user_action = dm_err->user_action
      SET drer_email_det->attachment = drr_rpt_file
      CALL drer_add_body_text(concat("RESTORE GROUP REPORT was generated at ",format(drer_email_det->
         status_dt_tm,";;q")),1)
      CALL drer_add_body_text(concat("User Action : Please review the report to ensure ",
        "no invalid reasons exist for the tables."),0)
      CALL drer_add_body_text(concat("Report file name : ",trim(drr_rpt_file,3)),0)
      IF (drer_compose_email(null)=1)
       CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
        email_level)
      ENDIF
      CALL drer_reset_pre_err(null)
     ENDIF
    ELSE
     IF ((dm2_install_schema->process_option="CLIN COPY")
      AND (drer_email_list->email_cnt > 0))
      SET drer_email_det->process = drr_clin_copy_data->process
      SET drer_email_det->msgtype = "ACTIONREQ"
      SET drer_email_det->status = "PAUSED"
      SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
      SET drer_email_det->step = "RESTORE GROUP REPORT"
      SET drer_email_det->email_level = 1
      SET drer_email_det->logfile = dm_err->logfile
      SET drer_email_det->err_ind = dm_err->err_ind
      SET drer_email_det->eproc = dm_err->eproc
      SET drer_email_det->emsg = dm_err->emsg
      SET drer_email_det->user_action = dm_err->user_action
      CALL drer_add_body_text(concat("RESTORE GROUP REPORT ","was displayed at ",format(
         drer_email_det->status_dt_tm,";;q")),1)
      CALL drer_add_body_text(concat("User Action : Return to dm2_domain_maint main session and ",
        "review Restore Group Report displayed on the screen.  Press <enter> to continue."),0)
      CALL drer_add_body_text(concat("Report file name is ccluserdir: ",drr_rpt_file),0)
      IF (drer_compose_email(null)=1)
       CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
        email_level)
      ENDIF
      CALL drer_reset_pre_err(null)
     ENDIF
     IF (dm2_disp_file(drr_rpt_file," ")=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_restore_col_mismatch(null)
   DECLARE drcm_pre_t = i2 WITH protect, noconstant(0)
   DECLARE drcm_tgt_t = i2 WITH protect, noconstant(0)
   DECLARE drcm_cur_t = i2 WITH protect, noconstant(0)
   DECLARE drcm_tgt_c = i2 WITH protect, noconstant(0)
   DECLARE drcm_cur_c = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Check for preserve restore column mismatch for source and target"
   FOR (drcm_pre_t = 1 TO drr_preserved_tables_data->cnt)
     IF ((drr_preserved_tables_data->tbl[drcm_pre_t].refresh_ind=1))
      SET drcm_tgt_t = drr_preserved_tables_data->tbl[drcm_pre_t].tgtsch_idx
      IF (drcm_tgt_t > 0)
       SET drcm_cur_t = 0
       SET drcm_cur_t = locateval(drcm_cur_t,1,cur_sch->tbl_cnt,drr_preserved_tables_data->tbl[
        drcm_pre_t].table_name,cur_sch->tbl[drcm_cur_t].tbl_name)
       IF (drcm_cur_t > 0)
        FOR (drcm_pre_c = 1 TO drr_preserved_tables_data->tbl[drcm_pre_t].col_cnt)
          SET drcm_tgt_c = 0
          SET drcm_tgt_c = locateval(drcm_tgt_c,1,tgtsch->tbl[drcm_tgt_t].tbl_col_cnt,
           drr_preserved_tables_data->tbl[drcm_pre_t].col[drcm_pre_c].col_name,tgtsch->tbl[drcm_tgt_t
           ].tbl_col[drcm_tgt_c].col_name)
          IF (drcm_tgt_c > 0)
           SET drcm_cur_c = 0
           SET drcm_cur_c = locateval(drcm_cur_c,1,cur_sch->tbl[drcm_cur_t].tbl_col_cnt,
            drr_preserved_tables_data->tbl[drcm_pre_t].col[drcm_pre_c].col_name,cur_sch->tbl[
            drcm_cur_t].tbl_col[drcm_cur_c].col_name)
           IF (drcm_cur_c > 0)
            IF (drr_restore_col_checks("C",drcm_cur_t,drcm_cur_c,drcm_pre_t,drcm_pre_c,
             drcm_tgt_t,drcm_tgt_c)=0)
             SET dm_err->err_ind = 1
             RETURN(0)
            ENDIF
           ENDIF
          ENDIF
        ENDFOR
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_restore_tbl_mismatch(null)
   DECLARE drtm_pre_t = i2 WITH protect, noconstant(0)
   DECLARE drtm_tgt_t = i2 WITH protect, noconstant(0)
   DECLARE drtm_cur_t = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Check for preserve restore table mismatch for source and target"
   FOR (drtm_pre_t = 1 TO drr_preserved_tables_data->cnt)
     IF ((drr_preserved_tables_data->tbl[drtm_pre_t].refresh_ind=1))
      SET drtm_tgt_t = 0
      SET drtm_tgt_t = locateval(drtm_tgt_t,1,tgtsch->tbl_cnt,drr_preserved_tables_data->tbl[
       drtm_pre_t].table_name,tgtsch->tbl[drtm_tgt_t].tbl_name)
      IF (drtm_tgt_t > 0)
       IF ((drr_clin_copy_data->process="RESTORE"))
        SET drtm_cur_t = 0
        SET drtm_cur_t = locateval(drtm_cur_t,1,cur_sch->tbl_cnt,drr_preserved_tables_data->tbl[
         drtm_pre_t].table_name,cur_sch->tbl[drtm_cur_t].tbl_name)
        IF (drtm_cur_t > 0)
         IF (drr_restore_tbl_checks("C",drtm_cur_t,drtm_pre_t)=0)
          RETURN(0)
         ENDIF
        ENDIF
       ELSE
        IF (drr_restore_tbl_checks("T",drtm_tgt_t,drtm_pre_t)=0)
         RETURN(0)
        ENDIF
       ENDIF
      ENDIF
     ENDIF
   ENDFOR
   IF (drr_restore_report(null)=0)
    RETURN(0)
   ENDIF
   IF ((drr_preserved_tables_data->restore_foul=1))
    SET dm_err->err_ind = 1
    SET dm_err->eproc =
    "Validating preserved tables to be restored for acceptable column differences in order to successfully complete restore."
    SET dm_err->emsg = concat(
     "Preserved tables to be restored have column differences that prevent ability to restore table(s)",
     ".  The following preserved table groups cannot be restored:  ",drr_preserved_tables_data->
     foul_grp_str,".  In order to continue process, de-select these groups that cannot be restored",
     ".  For explanation of those table column differences preventing restore, see")
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm_err->emsg = concat(dm_err->emsg," ",drr_preserved_tables_data->res_rep_name,".")
    ELSE
     SET dm_err->emsg = concat(dm_err->emsg," ",drr_preserved_tables_data->res_rep_name,
      " located in CCLUSERDIR.")
    ENDIF
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_cleanup_drr_copy(dcdc_drr_cleanup)
   SET dcdc_drr_cleanup = "NONE"
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (cnvtupper(drrr_rf_data->tgt_expimp_drr_shadow_tables)="NO"
     AND cnvtupper(drr_clin_copy_data->process)="RESTORE")
     SET dcdc_drr_cleanup = "RR_ALL"
    ENDIF
   ELSEIF (cnvtupper(drr_clin_copy_data->process)="RESTORE")
    SET dcdc_drr_cleanup = "ALL"
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_load_chunk_imp_tbls(dlcit_db_link,dlcit_load_chunks_ind)
   DECLARE dlcit_dblink_exists = i2 WITH protect, noconstant(0)
   DECLARE dlcit_chunk_tbl_ndx = i4 WITH protect, noconstant(0)
   DECLARE dlcit_tmp = i4 WITH protect, noconstant(0)
   DECLARE dlcit_clu_tbl_ndx = i4 WITH protect, noconstant(0)
   DECLARE dlcit_di_tbl_owner = vc WITH protect, noconstant("")
   DECLARE dlcit_di_tbl_name = vc WITH protect, noconstant("")
   DECLARE dlcit_where_clause = vc WITH protect, noconstant("")
   DECLARE dlcit_dba_extents = vc WITH protect, noconstant("")
   DECLARE dlcit_dba_objects = vc WITH protect, noconstant("")
   DECLARE dlcit_part_cnt = i4 WITH protect, noconstant(0)
   IF (textlen(trim(dlcit_db_link))=0)
    SET dm_err->eproc = "No database link was specified. Skipping database link validation."
    CALL disp_msg(" ",dm_err->logfile,0)
   ELSE
    IF (drr_check_db_link(cnvtupper(trim(dlcit_db_link)),dlcit_dblink_exists)=0)
     RETURN(0)
    ENDIF
    IF (dlcit_dblink_exists=0)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat(dlcit_db_link," dblink does not exist. Cannot progress further.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET stat = initrec(drr_chunk_imp_tbls)
   SET dm_err->eproc = concat("Querying dm_info to check if any tables are marked for chunk imports")
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT
    IF (dlcit_dblink_exists=0)
     FROM dm_info di
    ELSE
     FROM (parser(concat("dm_info@",dlcit_db_link)) di)
    ENDIF
    INTO "nl:"
    di.info_name, di.info_number
    WHERE di.info_domain="DM2_RR_CHUNK_IMPORTS"
    ORDER BY di.info_name
    DETAIL
     dlcit_di_tbl_owner = substring(1,(findstring(".",di.info_name,1,0) - 1),di.info_name),
     dlcit_di_tbl_name = substring((findstring(".",di.info_name,1,1)+ 1),textlen(di.info_name),di
      .info_name), drr_chunk_imp_tbls->tbl_cnt = (drr_chunk_imp_tbls->tbl_cnt+ 1)
     IF (mod(drr_chunk_imp_tbls->tbl_cnt,10)=1)
      stat = alterlist(drr_chunk_imp_tbls->tbl,(drr_chunk_imp_tbls->tbl_cnt+ 9))
     ENDIF
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].owner = dlcit_di_tbl_owner,
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].table_name = dlcit_di_tbl_name,
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].segment_name = dlcit_di_tbl_name,
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].orig_num_chunks = di.info_number,
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].num_chunks = di.info_number,
     drr_chunk_imp_tbls->tbl[drr_chunk_imp_tbls->tbl_cnt].chunk_cnt = 0
    FOOT REPORT
     stat = alterlist(drr_chunk_imp_tbls->tbl,drr_chunk_imp_tbls->tbl_cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((drr_chunk_imp_tbls->tbl_cnt > 0))
    CALL echo(concat("***",build(drr_chunk_imp_tbls->tbl_cnt," tables qualified for chunk imports***"
       )))
   ELSE
    CALL echo("***No tables qualified for chunk imports***")
   ENDIF
   SET dm_err->eproc = "Querying dba_tables to fetch the list of clustered tables"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT
    IF (dlcit_dblink_exists=0)
     FROM dba_tables dt
    ELSE
     FROM (parser(concat("dba_tables@",dlcit_db_link)) dt)
    ENDIF
    INTO "nl:"
    WHERE dt.owner=currdbuser
     AND dt.cluster_name IS NOT null
    DETAIL
     IF (locateval(dlcit_clu_tbl_ndx,1,drr_chunk_imp_tbls->tbl_cnt,dt.table_name,drr_chunk_imp_tbls->
      tbl[dlcit_clu_tbl_ndx].table_name) > 0)
      drr_chunk_imp_tbls->tbl[dlcit_clu_tbl_ndx].segment_name = dt.cluster_name
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Querying dba_tables to fetch the list of partitioned tables"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT
    IF (dlcit_dblink_exists=0)
     FROM dba_tables dt
    ELSE
     FROM (parser(concat("dba_tables@",dlcit_db_link)) dt)
    ENDIF
    INTO "nl:"
    WHERE dt.owner=currdbuser
     AND dt.partitioned="YES"
    DETAIL
     IF (locateval(dlcit_clu_tbl_ndx,1,drr_chunk_imp_tbls->tbl_cnt,dt.table_name,drr_chunk_imp_tbls->
      tbl[dlcit_clu_tbl_ndx].table_name) > 0)
      drr_chunk_imp_tbls->tbl[dlcit_clu_tbl_ndx].part_ind = 1
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drr_chunk_imp_tbls)
   ENDIF
   IF (dlcit_load_chunks_ind=1)
    SET dlcit_dba_extents = concat("dba_extents",evaluate(dlcit_dblink_exists,1,concat("@",
       dlcit_db_link," ")," "))
    SET dlcit_dba_objects = concat("dba_objects",evaluate(dlcit_dblink_exists,1,concat("@",
       dlcit_db_link," ")," "))
    IF ((dm_err->debug_flag > 1))
     CALL echo(concat("dlcit_dba_extents = ",dlcit_dba_extents))
     CALL echo(concat("dlcit_dba_objects = ",dlcit_dba_objects))
    ENDIF
    FOR (dlcit_tbl_idx = 1 TO drr_chunk_imp_tbls->tbl_cnt)
      SET dlcit_where_clause = concat("de.segment_type = 'TABLE'")
      IF ((drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].part_ind=1))
       SET dm_err->eproc = "Obtain number of partitions for partitioned table."
       CALL disp_msg(" ",dm_err->logfile,0)
       SELECT
        IF (dlcit_dblink_exists=0)
         FROM dba_objects do
        ELSE
         FROM (parser(concat("dba_objects@",dlcit_db_link)) do)
        ENDIF
        INTO "nl:"
        tbl_part_cnt = count(*)
        WHERE do.owner=currdbuser
         AND do.object_type="TABLE PARTITION"
         AND (do.object_name=drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].table_name)
        DETAIL
         dlcit_part_cnt = tbl_part_cnt
        WITH nocounter
       ;end select
       IF (check_error(dm_err->eproc)=1)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
        RETURN(0)
       ENDIF
       IF ((dlcit_part_cnt > drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].num_chunks))
        SET drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].num_chunks = 1
       ELSE
        SET drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].num_chunks = round((drr_chunk_imp_tbls->tbl[
         dlcit_tbl_idx].num_chunks/ dlcit_part_cnt),0)
       ENDIF
       SET dlcit_where_clause = concat("de.segment_type = 'TABLE PARTITION'")
       SET drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].part_cnt = dlcit_part_cnt
      ENDIF
      SET dm_err->eproc = concat("Load chunk tables to import during reference copy. Processing ",
       drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].table_name)
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg(" ",dm_err->logfile,0)
      ENDIF
      SELECT INTO "nl:"
       FROM (
        (
        (SELECT
         min_rid = sqlpassthru(
          "dbms_rowid.rowid_create( 1, t.data_object_id, t.lo_fno, t.lo_block, 0 )"), max_rid =
         sqlpassthru("dbms_rowid.rowid_create( 1, t.data_object_id, t.hi_fno, t.hi_block, 10000 )")
         FROM (
          (
          (SELECT DISTINCT
           p.grp, sqlpassthru(concat(
             "first_value(p.relative_fno) over (partition by grp order by p.relative_fno, p.block_id rows ",
             "between unbounded preceding and unbounded following) lo_fno")), sqlpassthru(concat(
             "first_value(p.block_id) over (partition by grp order by p.relative_fno, p.block_id rows ",
             "between unbounded preceding and unbounded following) lo_block")),
           sqlpassthru(concat(
             "last_value(p.relative_fno) over (partition by grp order by p.relative_fno, p.block_id rows ",
             "between unbounded preceding and unbounded following) hi_fno")), sqlpassthru(concat(
             "last_value(p.block_id+blocks-1) over (partition by grp order by p.relative_fno, p.block_id rows ",
             "between unbounded preceding and unbounded following) hi_block")), sqlpassthru(
            "sum(blocks) over (partition by grp) sum_blocks"),
           p.data_object_id
           FROM (
            (
            (SELECT
             de.relative_fno, de.block_id, de.blocks,
             sqlpassthru(concat(
               "trunc((sum(de.blocks) over (order by de.relative_fno, de.block_id)-0.01)/(sum(de.blocks) ",
               "over ()/",cnvtstring(drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].num_chunks),")) grp")),
             do.data_object_id
             FROM (parser(concat(dlcit_dba_extents)) de),
              (parser(concat(dlcit_dba_objects)) do)
             WHERE parser(dlcit_where_clause)
              AND parser(concat("de.owner = '",drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].owner,"'"))
              AND parser(concat("de.segment_name = '",drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].
               segment_name,"'"))
              AND de.owner=do.owner
              AND de.segment_name=do.object_name
              AND de.segment_type=do.object_type))
            p)))
          t)
         ORDER BY min_rid
         WITH sqltype("c30","c30")))
        a)
       DETAIL
        drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunk_cnt = (drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].
        chunk_cnt+ 1), dlcit_tmp = drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunk_cnt
        IF (mod(dlcit_tmp,50)=1)
         stat = alterlist(drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunks,(dlcit_tmp+ 49))
        ENDIF
        drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunks[dlcit_tmp].min_rid = a.min_rid,
        drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunks[dlcit_tmp].max_rid = a.max_rid
       FOOT REPORT
        stat = alterlist(drr_chunk_imp_tbls->tbl[dlcit_tbl_idx].chunks,drr_chunk_imp_tbls->tbl[
         dlcit_tbl_idx].chunk_cnt)
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
       RETURN(0)
      ENDIF
    ENDFOR
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(drr_chunk_imp_tbls)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_get_mixtbl_ref_rows(dgmrr_db_name)
   DECLARE dgmrr_table_name = vc WITH protect, noconstant("")
   DECLARE dgmrr_mix_idx = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Check if there are mixed table reference rows in ",trim(cnvtupper(
      dgmrr_db_name)),".")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm_info d
    WHERE d.info_domain="DM2_MIXTBL_REFDATA_CNT"
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->emsg = concat("There are no mixed table reference rows for ",trim(cnvtupper(
       dgmrr_db_name)),".")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,0)
   ELSE
    SET dm_err->eproc = concat("Merge DM2_MIXTBL_REFDATA_CNT rows from ",trim(cnvtupper(dgmrr_db_name
       ))," to Admin DM_INFO.")
    CALL disp_msg("",dm_err->logfile,0)
    MERGE INTO dm2_admin_dm_info d
    USING (SELECT
     info_domain, info_name, info_number
     FROM dm_info
     WHERE info_domain="DM2_MIXTBL_REFDATA_CNT")
    DI ON (d.info_domain=di.info_domain
     AND d.info_name=concat(trim(dgmrr_db_name),"_",di.info_name))
    WHEN MATCHED THEN
    (UPDATE
     SET d.info_number = di.info_number, d.updt_dt_tm = cnvtdatetime(curdate,curtime3)
     WHERE 1=1
    ;end update
    )
    WHEN NOT MATCHED THEN
    (INSERT  FROM d
     (info_domain, info_name, info_number,
     updt_dt_tm)
     VALUES("DM2_MIXTBL_REFDATA_CNT", concat(trim(dgmrr_db_name),"_",di.info_name), di.info_number,
     cnvtdatetime(curdate,curtime3))
     WITH nocounter
    ;end insert
    )
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Remove DM2_MIXTBL_REFDATA_CNT rows from ",trim(cnvtupper(
       dgmrr_db_name))," DM_INFO.")
    CALL disp_msg("",dm_err->logfile,0)
    DELETE  FROM dm_info di
     WHERE di.info_domain="DM2_MIXTBL_REFDATA_CNT"
    ;end delete
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Obtain latest mixed table reference rows for ",trim(cnvtupper(
      dgmrr_db_name)),".")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dm2_admin_dm_info d
    WHERE d.info_domain="DM2_MIXTBL_REFDATA_CNT"
     AND d.info_name=patstring(concat(dgmrr_db_name,"_*"))
     AND d.info_number > 0
    DETAIL
     dgmrr_table_name = replace(d.info_name,concat(dgmrr_db_name,"_"),""), dgmrr_mix_idx = 0,
     dgmrr_mix_idx = locateval(dgmrr_mix_idx,1,drr_mixed_tables_data->cnt,dgmrr_table_name,
      drr_mixed_tables_data->tbl[dgmrr_mix_idx].table_name)
     IF (dgmrr_mix_idx > 0)
      drr_mixed_tables_data->tbl[dgmrr_mix_idx].ref_num_rows_set_ind = 1, drr_mixed_tables_data->tbl[
      dgmrr_mix_idx].ref_num_rows = d.info_number
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_upd_mixtbl_ref_rows(dumrr_db_name,dumrr_run_id)
   FREE RECORD dumrr_mixed_tables_data
   RECORD dumrr_mixed_tables_data(
     1 cnt = i4
     1 tbl[*]
       2 table_name = vc
       2 num_rows = f8
   )
   DECLARE dumrr_info_name = vc WITH protect, noconstant("")
   DECLARE dumrr_info_number = i4 WITH protect, noconstant(0)
   DECLARE dumrr_idx = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Obtain latest mixed table reference rows for ",trim(cnvtupper(
      dumrr_db_name)),".")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    d.table_name, dumrr_mixed_row_cnt_sum = sum(d.row_cnt)
    FROM dm2_ddl_ops_log d
    WHERE d.run_id=dumrr_run_id
     AND d.op_type="EXPORT/IMPORT - MIXED DATA (REMOTE)"
     AND d.status="COMPLETE"
    GROUP BY d.table_name
    HEAD REPORT
     dumrr_mixed_tables_data->cnt = 0, stat = alterlist(dumrr_mixed_tables_data->tbl,0)
    DETAIL
     dumrr_mixed_tables_data->cnt = (dumrr_mixed_tables_data->cnt+ 1)
     IF (mod(dumrr_mixed_tables_data->cnt,10)=1)
      stat = alterlist(dumrr_mixed_tables_data->tbl,(dumrr_mixed_tables_data->cnt+ 9))
     ENDIF
     dumrr_mixed_tables_data->tbl[dumrr_mixed_tables_data->cnt].table_name = d.table_name,
     dumrr_mixed_tables_data->tbl[dumrr_mixed_tables_data->cnt].num_rows = dumrr_mixed_row_cnt_sum
    FOOT REPORT
     stat = alterlist(dumrr_mixed_tables_data->tbl,dumrr_mixed_tables_data->cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = concat("Update Admin DM_INFO rows for ",trim(cnvtupper(dumrr_db_name)),".")
   CALL disp_msg("",dm_err->logfile,0)
   FOR (dumrr_idx = 1 TO dumrr_mixed_tables_data->cnt)
     SET dm_err->eproc = concat("Update Admin DM_INFO row for ",trim(dumrr_mixed_tables_data->tbl[
       dumrr_idx].table_name))
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SET dumrr_info_name = concat(trim(cnvtupper(dumrr_db_name)),"_",trim(dumrr_mixed_tables_data->
       tbl[dumrr_idx].table_name))
     SET dumrr_info_number = dumrr_mixed_tables_data->tbl[dumrr_idx].num_rows
     MERGE INTO dm2_admin_dm_info d
     USING DUAL ON (d.info_domain="DM2_MIXTBL_REFDATA_CNT"
      AND d.info_name=trim(dumrr_info_name))
     WHEN MATCHED THEN
     (UPDATE
      SET d.info_number = dumrr_info_number, d.updt_dt_tm = cnvtdatetime(curdate,curtime3)
      WHERE 1=1
     ;end update
     )
     WHEN NOT MATCHED THEN
     (INSERT  FROM d
      (info_domain, info_name, info_number,
      updt_dt_tm)
      VALUES("DM2_MIXTBL_REFDATA_CNT", trim(dumrr_info_name), dumrr_info_number,
      cnvtdatetime(curdate,curtime3))
      WITH nocounter
     ;end insert
     )
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     COMMIT
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_refresh_drop_restrict(drdr_mode,drdr_restart_ind)
   DECLARE drdr_info_char = vc WITH protect, noconstant("")
   IF ( NOT (drdr_mode IN ("I", "D")))
    SET dm_err->eproc = "Verify the input mode in DM_INFO to drop V500 user in restrict mode."
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "Invalid input mode option."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm2_install_schema->dbase_name = "ADMIN"
   SET dm2_install_schema->u_name = "CDBA"
   SET dm2_install_schema->p_word = drrr_rf_data->adm_db_user_pwd
   SET dm2_install_schema->connect_str = drrr_rf_data->adm_db_cnct_str
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Querying DM_INFO for the row to restart target database checkpoint row."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DM2_REFRESH_RESTRICT_DATABASE"
     AND di.info_name=cnvtupper(drrr_rf_data->tgt_db_name)
    DETAIL
     drdr_info_char = di.info_char
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (drdr_mode="D")
    IF (curqual=1)
     SET dm_err->eproc = "Removing the restrict database row from DM_INFO."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     DELETE  FROM dm_info di
      WHERE di.info_domain="DM2_REFRESH_RESTRICT_DATABASE"
       AND di.info_name=cnvtupper(drrr_rf_data->tgt_db_name)
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      RETURN(0)
     ENDIF
     COMMIT
    ELSE
     SET dm_err->eproc =
     "Could not find the restrict database checkpoint row from DM_INFO. Possible manual intervention occurred."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
    ENDIF
   ELSE
    IF (((curqual=1
     AND drdr_restart_ind=1
     AND drdr_info_char="INITIATED") OR (curqual=0
     AND drdr_restart_ind=0)) )
     IF (drr_drop_user_restrict_ksh(null)=0)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->eproc =
     "Database should be in stable state to continue without the need to put database in restricted mode."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
    ENDIF
   ENDIF
   SET dm2_install_schema->u_name = "SYS"
   SET dm2_install_schema->p_word = drrr_rf_data->tgt_sys_pwd
   SET dm2_install_schema->connect_str = drrr_rf_data->tgt_db_cnct_str
   SET dm2_install_schema->dbase_name = '"TARGET"'
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_drop_user_restrict_ksh(null)
   DECLARE ddurk_full_ksh_name = vc WITH protect, noconstant("")
   DECLARE ddurk_line = vc WITH protect, noconstant("")
   DECLARE ddurk_text = vc WITH protect, noconstant("")
   DECLARE ddurk_tgt_db_ver = i4 WITH protect, noconstant(0)
   DECLARE ddurk_tgt_ora_home = vc WITH protect, noconstant("")
   DECLARE ddurk_sqlfile = vc WITH protect, noconstant("")
   DECLARE ddurk_logfile = vc WITH protect, noconstant("")
   DECLARE ddurk_full_logfile = vc WITH protect, noconstant("")
   DECLARE ddurk_file_loc = vc WITH protect, noconstant("")
   DECLARE ddurk_cmd = vc WITH protect, noconstant("")
   DECLARE ddurk_ksh_error_msg = vc WITH protect, noconstant("")
   SET ddurk_full_ksh_name = concat("dm2_restrict_",cnvtlower(drrr_rf_data->tgt_db_name),"_db.ksh")
   SET ddurk_file_loc = drrr_rf_data->tgt_db_temp_dir
   SET ddurk_sqlfile = concat(ddurk_file_loc,"restrict_drop_v500.sql")
   SET ddurk_du_sqlfile = concat(ddurk_file_loc,"restrict_drop_user_v500.sql")
   SET ddurk_logfile = concat(ddurk_file_loc,"restrict_drop_v500.log")
   SET ddurk_du_logfile = concat(ddurk_file_loc,"restrict_drop_user_v500.log")
   SET ddurk_full_logfile = concat(ddurk_file_loc,"restrict_drop_v500_full.log")
   SET ddurk_tgt_db_ver = cnvtint(drrr_rf_data->tgt_db_oracle_ver)
   IF (findstring("/",drrr_rf_data->tgt_db_oracle_home,1,1)=size(drrr_rf_data->tgt_db_oracle_home))
    SET ddurk_tgt_ora_home = substring(1,(size(drrr_rf_data->tgt_db_oracle_home,1) - 1),drrr_rf_data
     ->tgt_db_oracle_home)
   ELSE
    SET ddurk_tgt_ora_home = drrr_rf_data->tgt_db_oracle_home
   ENDIF
   SET dm_err->eproc = concat("Create ksh file ",ddurk_full_ksh_name)
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO value(ddurk_full_ksh_name)
    FROM (dummyt d  WITH seq = 1)
    DETAIL
     IF (ddurk_tgt_db_ver=19)
      col 0, "#!/bin/ksh", row + 1,
      ddurk_line = build("TGT_DB_NAME=",cnvtupper(drrr_rf_data->tgt_db_name)), col 0, ddurk_line,
      row + 1, ddurk_line = concat("export ORACLE_SID=",cnvtlower(drrr_rf_data->tgt_cdb_cnct_str)),
      col 0,
      ddurk_line, row + 1, ddurk_line = concat("export ORACLE_HOME=",ddurk_tgt_ora_home),
      col 0, ddurk_line, row + 1,
      col 0, "USER_TO_DROP=V500", row + 1,
      ddurk_line = build("DROP_V500_SQLFILE=",ddurk_sqlfile), col 0, ddurk_line,
      row + 1, ddurk_line = build("DROP_USER_V500_SQLFILE=",ddurk_du_sqlfile), col 0,
      ddurk_line, row + 1, ddurk_line = build("DROP_V500_SQL_LOGFILE=",ddurk_logfile),
      col 0, ddurk_line, row + 1,
      ddurk_line = build("DROP_USER_V500_SQL_LOGFILE=",ddurk_du_logfile), col 0, ddurk_line,
      row + 1, ddurk_line = build("DROP_V500_LOGFILE=",ddurk_full_logfile), col 0,
      ddurk_line, row + 1, col 0,
      "USER_EXISTS_IND=0", row + 1, col 0,
      " ", row + 1, col 0,
      "CheckDBMode()", row + 1, col 0,
      "{", row + 1, col 0,
      "  rm -f ${DROP_V500_SQLFILE}", row + 1, col 0,
      "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1, col 0,
      '  echo "alter session set container=${TGT_DB_NAME};" > ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "set serveroutput on;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "declare " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  db_mode varchar2(10);" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  restricted_mode varchar2(10);" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "begin" >> ${DROP_V500_SQLFILE}', row + 1, ddurk_line = concat(
       '  echo " select open_mode,restricted into db_mode,restricted_mode from v\$pdbs ',
       ^ where name = '${TGT_DB_NAME}';" >> ${DROP_V500_SQLFILE}^),
      col 0, ddurk_line, row + 1,
      col 0, ^  echo " dbms_output.put_line('DB_MODE is: ' || db_mode);" >> ${DROP_V500_SQLFILE}^,
      row + 1,
      col 0,
      ^  echo " dbms_output.put_line('RESTRICTED_MODE is: ' || restricted_mode);" >> ${DROP_V500_SQLFILE}^,
      row + 1,
      col 0, '  echo " EXCEPTION" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "  when others then raise;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "end;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "/" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "exit" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1,
      col 0, "  ", row + 1,
      col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '   EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1,
      col 0, '   EchoMessage `date` "KSH for Setup ending in error."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "  ", row + 1,
      col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0001:error - Error retrieving database mode info."', row + 1,
      col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '    EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, '  DB_MODE=`grep "DB_MODE is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3-4`', row + 1,
      col 0,
      '  RESTRICTED_MODE=`grep "RESTRICTED_MODE is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3`', row
       + 1,
      col 0, '  EchoMessage "`date`: DB_MODE=${DB_MODE}"', row + 1,
      col 0, '  EchoMessage "`date`: RESTRICTED=${RESTRICTED_MODE}"', row + 1,
      col 0, "}", row + 1,
      col 0, " ", row + 1,
      col 0, "StartupDB()", row + 1,
      col 0, "{", row + 1,
      col 0, "  rm -f ${DROP_V500_SQLFILE}", row + 1,
      col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1,
      col 0,
      "  #Logfile will not be removed since output from CheckDBMode function is evaluated from the logfile.",
      row + 1,
      col 0, "  arg1=$1", row + 1,
      col 0, "  ", row + 1,
      col 0, '  echo "alter session set container=${TGT_DB_NAME};" > ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  if [[ "$arg1" = "READ WRITE" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo "startup;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  elif [[ "$arg1" = "RESTRICT" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo "startup restrict;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1,
      col 0, " ", row + 1,
      col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1,
      col 0, '    EchoMessage `date` "KSH for Setup ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0003:error - Error while starting the database in $arg1 mode."',
      row + 1,
      col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '    EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0, "  CheckDBMode", row + 1,
      col 0, "   ", row + 1,
      col 0, '  if [[ ${DB_MODE} == "READ WRITE" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "`date`: Pluggable database has been opened in $arg1 mode."', row + 1,
      col 0, "  else", row + 1,
      col 0,
      '    EchoMessage "CER-0010:error - Pluggable database is not running in READ WRITE mode."', row
       + 1,
      col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '    EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      ddurk_line = concat('  if [[ $arg1 == "RESTRICT" && ${RESTRICTED_MODE} == "YES" || ',
       '$arg1 == "READ WRITE" && ${RESTRICTED_MODE} == "NO" ]]'), col 0, ddurk_line,
      row + 1, col 0, "  then",
      row + 1, col 0, '    EchoMessage "`date`: Pluggable database is opened in $arg1 mode."',
      row + 1, col 0, "  else",
      row + 1, col 0,
      '    EchoMessage "CER-0011:error - Pluggable database is not in appropriate RESTRICTED mode." "1"',
      row + 1, col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}",
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  fi",
      row + 1, col 0, "  ",
      row + 1, col 0, "  #Starting DB service",
      row + 1, col 0, "  StartupService ",
      row + 1, col 0, "}",
      row + 1, col 0, " ",
      row + 1, col 0, "StartupService() ",
      row + 1, col 0, "{ ",
      row + 1, col 0, "  rm -f ${DROP_V500_SQL_LOGFILE} ",
      row + 1, col 0,
      "  ${ORACLE_HOME}/bin/srvctl start service -d c${TGT_DB_NAME} > ${DROP_V500_SQL_LOGFILE} ",
      row + 1, col 0, " ",
      row + 1, col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]] ",
      row + 1, col 0, "  then ",
      row + 1, col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"',
      row + 1, col 0, '    EchoMessage `date` "KSH for Setup ending in error."',
      row + 1, col 0, "    exit 1 ",
      row + 1, col 0, "  fi ",
      row + 1, col 0, " ",
      row + 1, col 0,
      "  $ORACLE_HOME/bin/srvctl status service -d c${TGT_DB_NAME} -s s${TGT_DB_NAME} > ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0,
      '  SERVICE_RUNNING_IND=`grep -i "Service s${TGT_DB_NAME} is running" ${DROP_V500_SQL_LOGFILE} | wc -l`',
      row + 1, col 0,
      '  echo "`date`:Service running indicator(1 - up/0 - down): ${SERVICE_RUNNING_IND}" >>${DROP_V500_SQL_LOGFILE}',
      row + 1, col 0, "  if [[ ${SERVICE_RUNNING_IND} -eq 0 ]]",
      row + 1, col 0, "  then",
      row + 1, col 0, '    EchoMessage "CER-0009:error - Database service is not running."',
      row + 1, col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}",
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  else ",
      row + 1, col 0, '    EchoMessage "`date`: Database service is up and running."',
      row + 1, col 0, "  fi",
      row + 1, col 0, "} ",
      row + 1, col 0, " ",
      row + 1, col 0, "OpenDB()",
      row + 1, col 0, "{",
      row + 1, col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0, "  rm -f ${DROP_V500_SQLFILE}",
      row + 1, ddurk_line = concat('  echo "alter session set container=${TGT_DB_NAME};" | ',
       'echo "alter pluggable database ${TGT_DB_NAME} open force;" | ',
       "${ORACLE_HOME}/bin/sqlplus '/as sysdba' > ${DROP_V500_SQL_LOGFILE}"), col 0,
      ddurk_line, row + 1, col 0,
      " ", row + 1, col 0,
      "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1, col 0,
      '    EchoMessage `date` "KSH for Setup ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi", row + 1, col 0,
      " ", row + 1, col 0,
      '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0004:error - Error while starting the database in READ WRITE mode."', row
       + 1, col 0,
      "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '    EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi ", row + 1, col 0,
      '  EchoMessage "`date`: Pluggable database is opened with force."', row + 1, col 0,
      "}", row + 1, col 0,
      " ", row + 1, col 0,
      "UpdateAdminCheckpointRow()", row + 1, col 0,
      "{", row + 1, col 0,
      "  rm -f ${DROP_V500_SQLFILE}", row + 1, col 0,
      "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1, col 0,
      "  arg1=$1", row + 1, col 0,
      '  EchoMessage "`date`: Attempting to merge Admin checkpoint row with $arg1 status."', row + 1,
      col 0,
      "  #Merging into dm_info to mark the initiation of restrict database", row + 1, col 0,
      '  echo "begin " > ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  merge into dm_info x " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  using dual " >> ${DROP_V500_SQLFILE}', row + 1, ddurk_line = concat(
       ^  echo "  on (x.info_domain='DM2_REFRESH_RESTRICT_DATABASE' and x.info_name='${TGT_DB_NAME}')"^,
       "  >> ${DROP_V500_SQLFILE}"),
      col 0, ddurk_line, row + 1,
      col 0, '  echo "  when matched then " >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, ^  echo "   update set x.info_char = '$arg1', " >> ${DROP_V500_SQLFILE}^, row + 1,
      col 0, '  echo "   x.updt_dt_tm = sysdate " >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "  when not matched then " >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      '  echo "   insert(x.info_domain, x.info_name, x.info_char, x.updt_dt_tm) " >> ${DROP_V500_SQLFILE}',
      row + 1,
      col 0,
      ^  echo "   values ('DM2_REFRESH_RESTRICT_DATABASE','${TGT_DB_NAME}','$arg1',sysdate); " >> ${DROP_V500_SQLFILE}^,
      row + 1,
      col 0, '  echo "   commit;"   >> ${DROP_V500_SQLFILE}     ', row + 1,
      col 0, '  echo "exception "  >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "  when others then"  >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "    dbms_output.put_line(sqlerrm);"  >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  echo "    rollback; "  >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "end; "  >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "/"   >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "exit; " >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, "  ", row + 1,
      ddurk_line = build(" ${ORACLE_HOME}/bin/sqlplus -L '",drrr_rf_data->adm_db_user,"/",
       drrr_rf_data->adm_db_user_pwd,"@",
       drrr_rf_data->adm_db_cnct_str,"' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE} "), col 0,
      ddurk_line,
      row + 1, col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]",
      row + 1, col 0, "  then",
      row + 1, col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"',
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  fi",
      row + 1, col 0, " ",
      row + 1, col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]',
      row + 1, col 0, "  then",
      row + 1, col 0,
      '    EchoMessage "CER-0005:error - Error while merging dm_info row with $arg1 status."',
      row + 1, col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}",
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  fi",
      row + 1, col 0, '  EchoMessage "`date`: Admin checkpoint row merged with $arg1 status."',
      row + 1, col 0, "}",
      row + 1, col 0, " ",
      row + 1, col 0, "CheckDBUserExistence()",
      row + 1, col 0, "{",
      row + 1, col 0, "  rm -f ${DROP_V500_SQLFILE}",
      row + 1, col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0, "  USER_EXISTS_IND=0",
      row + 1, col 0, '  echo "alter session set container=${TGT_DB_NAME};" > ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "set serveroutput on;" >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "declare " >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "  user_exists_ind number := 0;" >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "begin" >> ${DROP_V500_SQLFILE}',
      row + 1, ddurk_line = concat('  echo "select count(*) into user_exists_ind from dba_users ',
       ^where username='${USER_TO_DROP}';" >> ${DROP_V500_SQLFILE}^), col 0,
      ddurk_line, row + 1, col 0,
      ^  echo " dbms_output.put_line('USER_EXISTS_IND is: ' || user_exists_ind);" >> ${DROP_V500_SQLFILE}^,
      row + 1, col 0,
      '  echo " EXCEPTION" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  when others then raise;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "end;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "/" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "exit" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      "  ", row + 1, col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0,
      " ", row + 1, col 0,
      "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]] ", row + 1, col 0,
      "  then ", row + 1, col 0,
      '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1, col 0,
      '    EchoMessage `date` "KSH for Setup ending in error."', row + 1, col 0,
      "    exit 1 ", row + 1, col 0,
      "  fi ", row + 1, col 0,
      "  ", row + 1, col 0,
      '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]] ', row + 1, col 0,
      "  then ", row + 1, col 0,
      '    EchoMessage "CER-0008:error - Error retrieving user info."', row + 1, col 0,
      "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '    EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "    exit 1 ", row + 1, col 0,
      "  fi ", row + 1, col 0,
      "  ", row + 1, col 0,
      '  USER_EXISTS_IND=`grep "USER_EXISTS_IND is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3`    ',
      row + 1, col 0,
      "  ", row + 1, col 0,
      "  if [[ ${USER_EXISTS_IND} -eq 0 ]] ", row + 1, col 0,
      "  then ", row + 1, col 0,
      '    EchoMessage "`date`: User ${USER_TO_DROP} does not exist."', row + 1, col 0,
      "  else ", row + 1, col 0,
      '    EchoMessage "`date`: User ${USER_TO_DROP} exists."', row + 1, col 0,
      "  fi ", row + 1, col 0,
      "} ", row + 1, col 0,
      " ", row + 1, col 0,
      "EchoMessage()", row + 1, col 0,
      "{", row + 1, col 0,
      " echo $1", row + 1, col 0,
      ' echo "`date`: $1" >> ${DROP_V500_LOGFILE}', row + 1, col 0,
      "}", row + 1, col 0,
      " ", row + 1, col 0,
      "#Main process", row + 1, col 0,
      "rm -f ${DROP_V500_LOGFILE}", row + 1, col 0,
      'EchoMessage "`date`: Beginning of the logfile to drop ${USER_TO_DROP} user."', row + 1, col 0,
      " ", row + 1, col 0,
      "#Check the status of the database.", row + 1, col 0,
      "#Verify the open_mode is in a valid state to be shutdown.", row + 1, col 0,
      "CheckDBMode", row + 1, col 0,
      " ", row + 1, col 0,
      "#If the database is in any mode other than READ WRITE, open the database in READ WRITE mode.",
      row + 1, col 0,
      'if [[ ${DB_MODE} != "READ WRITE" ]]', row + 1, col 0,
      "then  ", row + 1, col 0,
      "  StartupDB 'READ WRITE'", row + 1, col 0,
      "fi", row + 1, col 0,
      'if [[ ${RESTRICTED_MODE} == "YES" ]]', row + 1, col 0,
      "then", row + 1, col 0,
      "  OpenDB", row + 1, col 0,
      "fi", row + 1, col 0,
      " ", row + 1, col 0,
      "UpdateAdminCheckpointRow 'INITIATED' ", row + 1, col 0,
      " ", row + 1, col 0,
      "CheckDBMode", row + 1, col 0,
      "#Check if user exists.", row + 1, col 0,
      "CheckDBUserExistence", row + 1, col 0,
      " ", row + 1, col 0,
      "#Perform shutting down the database, startup in restrict to drop the user operations only ",
      row + 1, col 0,
      "#when the user exists, otherwise ignore all below code and move on.", row + 1, col 0,
      "if [[ ${USER_EXISTS_IND} -eq 1 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      "  #Shutdown the database if open_mode of the pdb is 'READ WRITE'", row + 1, col 0,
      '  if [[ ${DB_MODE} == "READ WRITE" ]]', row + 1, col 0,
      "  then", row + 1, ddurk_line = concat(
       '    EchoMessage "`date`: User ${USER_TO_DROP} exists and the pdb is in ${DB_MODE} mode. ',
       'Shutting down."'),
      col 0, ddurk_line, row + 1,
      col 0, "    rm -f ${DROP_V500_SQLFILE}", row + 1,
      col 0, "    rm -f ${DROP_V500_SQL_LOGFILE}", row + 1,
      col 0, '    echo "alter session set container=${TGT_DB_NAME};" > ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "shutdown immediate;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;"  >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      "    ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1,
      col 0, "    ", row + 1,
      col 0, "    if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1,
      col 0, '      EchoMessage `date` "KSH for Setup ending in error."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "    ", row + 1,
      col 0, '    if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1,
      col 0, "    then", row + 1,
      col 0, '      EchoMessage "CER-0002:error - Error while shutting down the database."', row + 1,
      col 0, "      cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '      EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  fi", row + 1,
      col 0, "  ", row + 1,
      col 0, "  #Verify the open_mode is in a valid state to be started up.", row + 1,
      col 0, "  CheckDBMode", row + 1,
      col 0, "   ", row + 1,
      col 0, "  #Startup the database", row + 1,
      col 0, '  if [[ ${DB_MODE} == "MOUNTED" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0,
      '    EchoMessage "`date`: Pluggable database in ${DB_MODE} mode.Starting the DB in RESTRICT mode."',
      row + 1,
      col 0, "    StartupDB 'RESTRICT'", row + 1,
      col 0, "    CheckDBMode", row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0, '  if [[ ${DB_MODE} == "READ WRITE" && ${RESTRICTED_MODE} == "YES" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0,
      '    EchoMessage "`date`: Pluggable database in restricted mode. Attempting to drop the user."',
      row + 1,
      col 0, "    #Lock and drop the user. Confirm it is dropped.", row + 1,
      col 0, "    rm -f ${DROP_V500_SQLFILE}", row + 1,
      col 0, "    rm -f ${DROP_V500_SQL_LOGFILE}", row + 1,
      col 0, '    echo "alter session set container=${TGT_DB_NAME};" > ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "set serveroutput on;"  >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "begin " >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      "    #Putting the session to sleep after startup, so Oracle catches up to the execution.", row
       + 1,
      col 0, '    echo "  dbms_session.sleep(5);"  >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      ^    echo "  execute immediate 'alter user ${USER_TO_DROP} account lock';"  >> ${DROP_V500_SQLFILE}^,
      row + 1,
      col 0,
      "    #Putting the session to sleep after locking V500, to give time so new connections are not established.",
      row + 1,
      col 0, '    echo "  dbms_session.sleep(15);"  >> ${DROP_V500_SQLFILE}', row + 1,
      col 0,
      ^    echo "  execute immediate 'drop user ${USER_TO_DROP} cascade';"  >> ${DROP_V500_SQLFILE}^,
      row + 1,
      col 0, '    echo "EXCEPTION" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo " when others then raise;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "end;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "/" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, "    ", row + 1,
      col 0, "    cat ${DROP_V500_SQLFILE} > ${DROP_USER_V500_SQLFILE}", row + 1,
      col 0, "    ", row + 1,
      col 0,
      "    ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_USER_V500_SQLFILE} > ${DROP_USER_V500_SQL_LOGFILE}",
      row + 1,
      col 0, "    CheckDBUserExistence", row + 1,
      col 0, "    if [[ $USER_EXISTS_IND -eq 1 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      COUNTER=1", row + 1,
      col 0, "      while [[ ${COUNTER} -le 3 ]]", row + 1,
      col 0, "      do", row + 1,
      col 0, '        EchoMessage "`date`: Attempt ${COUNTER} to drop the user."', row + 1,
      col 0,
      "        ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_USER_V500_SQLFILE} > ${DROP_USER_V500_SQL_LOGFILE}",
      row + 1,
      col 0, "        ((COUNTER++))", row + 1,
      col 0, "        CheckDBUserExistence", row + 1,
      col 0, "        if [[ $USER_EXISTS_IND -eq 0 ]]", row + 1,
      col 0, "        then", row + 1,
      col 0, "          COUNTER=4", row + 1,
      col 0, "        fi    ", row + 1,
      col 0, "      done", row + 1,
      col 0, " ", row + 1,
      col 0, "      if [[ $USER_EXISTS_IND -eq 1 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '        EchoMessage "CER-0006:error - Error while dropping the user."', row + 1,
      col 0, "        cat ${DROP_USER_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '        EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "        exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "    fi    ", row + 1,
      col 0, " ", row + 1,
      col 0, "    OpenDB", row + 1,
      col 0, "  fi", row + 1,
      col 0, "fi  ", row + 1,
      col 0, " ", row + 1,
      col 0, "UpdateAdminCheckpointRow 'COMPLETED' ", row + 1,
      col 0, 'EchoMessage "`date`: Drop user in restricted mode successful."', row + 1
     ELSE
      col 0, "#!/bin/ksh", row + 1,
      ddurk_text = build("TGT_DB_NAME=",cnvtupper(drrr_rf_data->tgt_db_name)), col 0, ddurk_text,
      row + 1, ddurk_text = concat("export ORACLE_SID=",cnvtlower(drrr_rf_data->tgt_db_cnct_str)),
      col 0,
      ddurk_text, row + 1, ddurk_text = concat("export ORACLE_HOME=",ddurk_tgt_ora_home),
      col 0, ddurk_text, row + 1,
      ddurk_text = build("USER_TO_DROP=V500"), col 0, ddurk_text,
      row + 1, ddurk_text = build("DROP_V500_SQLFILE=",ddurk_sqlfile), col 0,
      ddurk_text, row + 1, ddurk_line = build("DROP_USER_V500_SQLFILE=",ddurk_du_sqlfile),
      col 0, ddurk_line, row + 1,
      ddurk_text = build("DROP_V500_SQL_LOGFILE=",ddurk_logfile), col 0, ddurk_text,
      row + 1, ddurk_line = build("DROP_USER_V500_SQL_LOGFILE=",ddurk_du_logfile), col 0,
      ddurk_line, row + 1, ddurk_text = build("DROP_V500_LOGFILE=",ddurk_full_logfile),
      col 0, ddurk_text, row + 1,
      col 0, "USER_EXISTS_IND=0", row + 1,
      col 0, " ", row + 1,
      col 0, "StartupDB()", row + 1,
      col 0, "{", row + 1,
      col 0, "  rm -f ${DROP_V500_SQLFILE}", row + 1,
      col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1,
      col 0, "  arg1=$1", row + 1,
      col 0, "  ", row + 1,
      col 0, '  if [[ "$arg1" = "READ WRITE" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo "startup;" > ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, '  elif [[ "$arg1" = "RESTRICT" ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo "startup restrict;" > ${DROP_V500_SQLFILE}', row + 1,
      col 0, '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1,
      col 0, " ", row + 1,
      col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1,
      col 0, '    EchoMessage `date` "KSH for Setup ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, " ", row + 1,
      col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0003:error - Error while starting the database in $arg1 mode."',
      row + 1,
      col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '    EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, '  EchoMessage "`date`: Database is opened in $arg1 mode."', row + 1,
      col 0, "}", row + 1,
      col 0, " ", row + 1,
      col 0, "OpenDB()", row + 1,
      col 0, "{", row + 1,
      col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1,
      col 0, "  rm -f ${DROP_V500_SQLFILE}", row + 1,
      ddurk_text = concat(
       ^  echo "alter system disable restricted session;" | ${ORACLE_HOME}/bin/sqlplus '/as sysdba' ^,
       "> ${DROP_V500_SQL_LOGFILE}"), col 0, ddurk_text,
      row + 1, col 0, " ",
      row + 1, col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]",
      row + 1, col 0, "  then",
      row + 1, col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"',
      row + 1, col 0, '    EchoMessage `date` "KSH for Setup ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  fi",
      row + 1, col 0, " ",
      row + 1, col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]',
      row + 1, col 0, "  then",
      row + 1, col 0, '    EchoMessage "CER-0004:error - Error disabling restricted session."',
      row + 1, col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}",
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1",
      row + 1, col 0, "  fi ",
      row + 1, col 0, '  EchoMessage "`date`: Restrict mode on databse is disabled."',
      row + 1, col 0, "}",
      row + 1, col 0, " ",
      row + 1, col 0, "UpdateAdminCheckpointRow() ",
      row + 1, col 0, "{",
      row + 1, col 0, "  rm -f ${DROP_V500_SQLFILE}",
      row + 1, col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0, "  arg1=$1",
      row + 1, col 0,
      '  EchoMessage "`date`: Attempting to merge Admin checkpoint row with $arg1 status."',
      row + 1, col 0, "  #Merging into dm_info to mark the initiation of restrict database",
      row + 1, col 0, '  echo "begin" > ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "  merge into dm_info x " >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "  using dual " >> ${DROP_V500_SQLFILE}',
      row + 1, ddurk_text = concat(
       ^  echo "  on (x.info_domain='DM2_REFRESH_RESTRICT_DATABASE' and x.info_name='${TGT_DB_NAME}')"^,
       " >> ${DROP_V500_SQLFILE}"), col 0,
      ddurk_text, row + 1, col 0,
      '  echo "  when matched then " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      ^  echo "   update set x.info_char = '$arg1', " >> ${DROP_V500_SQLFILE}^, row + 1, col 0,
      '  echo "   x.updt_dt_tm = sysdate " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  when not matched then " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "   insert(x.info_domain, x.info_name, x.info_char, x.updt_dt_tm) " >> ${DROP_V500_SQLFILE}',
      row + 1, col 0,
      ^  echo "   values ('DM2_REFRESH_RESTRICT_DATABASE','${TGT_DB_NAME}','$arg1',sysdate); " >> ${DROP_V500_SQLFILE}^,
      row + 1, col 0,
      '  echo "  commit;"   >> ${DROP_V500_SQLFILE}     ', row + 1, col 0,
      '  echo "exception" >> ${DROP_V500_SQLFILE} ', row + 1, col 0,
      '  echo "  when others then"  >> ${DROP_V500_SQLFILE} ', row + 1, col 0,
      '  echo "    dbms_output.put_line(sqlerrm);"  >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "    rollback; "  >> ${DROP_V500_SQLFILE} ', row + 1, col 0,
      '  echo "end; "  >> ${DROP_V500_SQLFILE} ', row + 1, col 0,
      '  echo "/"   >> ${DROP_V500_SQLFILE} ', row + 1, col 0,
      '  echo "exit; " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      "  ", row + 1, ddurk_line = build(" ${ORACLE_HOME}/bin/sqlplus -L  '",drrr_rf_data->adm_db_user,
       "/",drrr_rf_data->adm_db_user_pwd,"@",
       drrr_rf_data->adm_db_cnct_str,"' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE} "),
      col 0, ddurk_line, row + 1,
      col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1,
      col 0, '    EchoMessage `date` "KSH for Setup ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "  ", row + 1,
      col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1,
      col 0, "  then", row + 1,
      col 0, '    EchoMessage "CER-0005:error - Error while merging dm_info row with $arg1 status."',
      row + 1,
      col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1,
      col 0, '    EchoMessage "`date`: KSH ending in error."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, '  EchoMessage "`date`: Admin checkpoint row merged with $arg1 status."', row + 1,
      col 0, "} ", row + 1,
      col 0, " ", row + 1,
      col 0, "CheckDBUserExistence() ", row + 1,
      col 0, "{ ", row + 1,
      col 0, "  rm -f ${DROP_V500_SQLFILE} ", row + 1,
      col 0, "  rm -f ${DROP_V500_SQL_LOGFILE} ", row + 1,
      col 0, "  USER_EXISTS_IND=0 ", row + 1,
      col 0, '  echo "set serveroutput on;" > ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "declare " >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "  user_exists_ind number := 0;" >> ${DROP_V500_SQLFILE} ', row + 1,
      col 0, '  echo "begin" >> ${DROP_V500_SQLFILE} ', row + 1,
      ddurk_text = concat(
       ^  echo "select count(*) into user_exists_ind from dba_users where username='${USER_TO_DROP}';"^,
       "  >> ${DROP_V500_SQLFILE}"), col 0, ddurk_text,
      row + 1, col 0,
      ^  echo " dbms_output.put_line('USER_EXISTS_IND is: ' || user_exists_ind);" >> ${DROP_V500_SQLFILE} ^,
      row + 1, col 0, '  echo " EXCEPTION" >> ${DROP_V500_SQLFILE} ',
      row + 1, col 0, '  echo "  when others then raise;" >> ${DROP_V500_SQLFILE} ',
      row + 1, col 0, '  echo "end;" >> ${DROP_V500_SQLFILE} ',
      row + 1, col 0, '  echo "/" >> ${DROP_V500_SQLFILE} ',
      row + 1, col 0, '  echo "exit" >> ${DROP_V500_SQLFILE} ',
      row + 1, col 0, " ",
      row + 1, col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE} ",
      row + 1, col 0, " ",
      row + 1, col 0, "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]] ",
      row + 1, col 0, "  then ",
      row + 1, col 0, '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"',
      row + 1, col 0, '    EchoMessage `date` "KSH for Setup ending in error."',
      row + 1, col 0, "    exit 1 ",
      row + 1, col 0, "  fi ",
      row + 1, col 0, "  ",
      row + 1, col 0, '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]] ',
      row + 1, col 0, "  then ",
      row + 1, col 0, '    EchoMessage "CER-0008:error - Error retrieving user info."',
      row + 1, col 0, "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}",
      row + 1, col 0, '    EchoMessage "`date`: KSH ending in error."',
      row + 1, col 0, "    exit 1 ",
      row + 1, col 0, "  fi ",
      row + 1, col 0, " ",
      row + 1, col 0,
      '  USER_EXISTS_IND=`grep "USER_EXISTS_IND is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3` ',
      row + 1, col 0, " ",
      row + 1, col 0, "  if [[ ${USER_EXISTS_IND} -eq 0 ]] ",
      row + 1, col 0, "  then ",
      row + 1, col 0, '    EchoMessage "`date`: User ${USER_TO_DROP} does not exist."',
      row + 1, col 0, "  else ",
      row + 1, col 0, '    EchoMessage "`date`: User ${USER_TO_DROP} exists."',
      row + 1, col 0, "  fi ",
      row + 1, col 0, "} ",
      row + 1, col 0, " ",
      row + 1, col 0, "EchoMessage()",
      row + 1, col 0, "{",
      row + 1, col 0, " echo $1",
      row + 1, col 0, ' echo "`date`: $1" >> ${DROP_V500_LOGFILE}',
      row + 1, col 0, "}",
      row + 1, col 0, " ",
      row + 1, col 0, "#Main process",
      row + 1, col 0, "rm -f ${DROP_V500_LOGFILE}",
      row + 1, col 0, 'EchoMessage "`date`: Beginning of the logfile to drop ${USER_TO_DROP} user."',
      row + 1, col 0, " ",
      row + 1, col 0, "TGT_DB_STATUS_IND=$(ps -ef | grep pmon | grep ${ORACLE_SID} | wc -l)",
      row + 1, col 0, "#If the database is down during the first run, startup in readwrite mode.",
      row + 1, col 0, "if [[ ${TGT_DB_STATUS_IND} -eq 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '  EchoMessage "`date`: Database is down. Starting up in READ WRITE mode."',
      row + 1, col 0, "  StartupDB 'READ WRITE'",
      row + 1, col 0, "fi",
      row + 1, col 0, " ",
      row + 1, col 0, "TGT_DB_STATUS_IND=$(ps -ef | grep pmon | grep ${ORACLE_SID} | wc -l)",
      row + 1, col 0, "#Check the status of the database.",
      row + 1, col 0, "if [[ ${TGT_DB_STATUS_IND} -gt 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0,
      '  echo "`date`: DB is running. Retrieving the db_mode and restricted_mode." >> ${DROP_V500_SQL_LOGFILE} ',
      row + 1, col 0, "  #Verify the open_mode is in a valid state to be shutdown.",
      row + 1, col 0, "  rm -f ${DROP_V500_SQLFILE}",
      row + 1, col 0, "  rm -f ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0, '  echo "set serveroutput on;" > ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "declare " >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "  db_mode varchar2(10);" >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "  restricted_mode varchar2(10);" >> ${DROP_V500_SQLFILE}',
      row + 1, col 0, '  echo "begin" >> ${DROP_V500_SQLFILE}',
      row + 1, ddurk_text = build('  echo " select open_mode into db_mode from v\$database ',
       ^ where name = '${TGT_DB_NAME}';" >> ${DROP_V500_SQLFILE}^), col 0,
      ddurk_text, row + 1, col 0,
      '  echo " select logins into restricted_mode from v\$instance;" >> ${DROP_V500_SQLFILE}', row
       + 1, col 0,
      ^  echo " dbms_output.put_line('DB_MODE is: ' || db_mode);" >> ${DROP_V500_SQLFILE}^, row + 1,
      col 0,
      ^  echo " dbms_output.put_line('RESTRICTED_MODE is: ' || restricted_mode);" >> ${DROP_V500_SQLFILE}^,
      row + 1, col 0,
      '  echo " EXCEPTION" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "  when others then raise;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "end;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "/" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '  echo "exit" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      "  ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0,
      "  ", row + 1, col 0,
      "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1, col 0,
      '    EchoMessage `date` "KSH for Setup ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi", row + 1, col 0,
      "  ", row + 1, col 0,
      '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0001:error - Error retrieving database mode info."', row + 1, col 0,
      "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '    EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi", row + 1, col 0,
      '  DB_MODE=`grep "DB_MODE is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3-4`', row + 1, col 0,
      '  RESTRICTED_MODE=`grep "RESTRICTED_MODE is: " ${DROP_V500_SQL_LOGFILE} | cut -d" " -f3`', row
       + 1, col 0,
      '  EchoMessage "`date`: DB_MODE=${DB_MODE}"', row + 1, col 0,
      '  EchoMessage "`date`: RESTRICTED=${RESTRICTED_MODE}"', row + 1, col 0,
      "fi", row + 1, col 0,
      "#If the database is in any mode other than READ WRITE, open the database in READ WRITE mode.",
      row + 1, col 0,
      'if [[ ${DB_MODE} != "READ WRITE" ]]', row + 1, col 0,
      "then  ", row + 1, col 0,
      '  EchoMessage "`date`: Database is in ${DB_MODE} mode. Opening database."', row + 1, col 0,
      "  rm -f ${DROP_V500_SQL_LOGFILE}", row + 1, col 0,
      "  echo 'alter database open;' | ${ORACLE_HOME}/bin/sqlplus '/as sysdba' > ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0,
      " ", row + 1, col 0,
      "  if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1, col 0,
      '    EchoMessage `date` "KSH for Setup ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi", row + 1, col 0,
      " ", row + 1, col 0,
      '  if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "CER-0007:error - Error while starting the database in READ WRITE mode."', row
       + 1, col 0,
      "    cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '    EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "    exit 1", row + 1, col 0,
      "  fi ", row + 1, col 0,
      "fi", row + 1, col 0,
      'if [[ ${RESTRICTED_MODE} == "RESTRICTED" ]]', row + 1, col 0,
      "then", row + 1, col 0,
      '  EchoMessage "`date`: Database is restricted. Opening DB to disable restriction."', row + 1,
      col 0,
      "  #Call disable restricted session module.", row + 1, col 0,
      "  OpenDB", row + 1, col 0,
      "fi", row + 1, col 0,
      " ", row + 1, col 0,
      "UpdateAdminCheckpointRow 'INITIATED' ", row + 1, col 0,
      " ", row + 1, col 0,
      "CheckDBUserExistence", row + 1, col 0,
      " ", row + 1, col 0,
      "#Perform shutting down the database, startup in restrict to drop the user operations only ",
      row + 1, col 0,
      "#when the user exists, otherwise ignore all below code and move on.", row + 1, col 0,
      "if [[ ${USER_EXISTS_IND} -eq 1 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      "  #Shutdown the database", row + 1, col 0,
      "  if [[ ${TGT_DB_STATUS_IND} -gt 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "`date`: User ${USER_TO_DROP} exists. Shutting down the database."', row + 1,
      col 0,
      "    rm -f ${DROP_V500_SQLFILE}", row + 1, col 0,
      "    rm -f ${DROP_V500_SQL_LOGFILE}", row + 1, col 0,
      '    echo "shutdown immediate;" > ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "exit;"  >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      "    ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_V500_SQLFILE} > ${DROP_V500_SQL_LOGFILE}",
      row + 1, col 0,
      "    ", row + 1, col 0,
      "    if [[ ! -f ${DROP_V500_SQL_LOGFILE} ]]", row + 1, col 0,
      "    then", row + 1, col 0,
      '      EchoMessage "CER-0000:error - ${DROP_V500_SQL_LOGFILE} file not found"', row + 1, col 0,
      '      EchoMessage `date` "KSH for Setup ending in error."', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "    fi", row + 1, col 0,
      "    ", row + 1, col 0,
      '    if [[ `grep -E "^ORA-" ${DROP_V500_SQL_LOGFILE} | wc -l` -ne 0 ]]', row + 1, col 0,
      "    then", row + 1, col 0,
      '      EchoMessage "CER-0002:error - Error while shutting down the database."', row + 1, col 0,
      "      cat ${DROP_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '      EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "    fi", row + 1, col 0,
      "    ", row + 1, col 0,
      "  fi", row + 1, col 0,
      "  ", row + 1, col 0,
      "  #Check the database status before starting in restrict mode.", row + 1, col 0,
      "  TGT_DB_STATUS_IND=$(ps -ef | grep pmon | grep ${ORACLE_SID} | wc -l)", row + 1, col 0,
      "  ", row + 1, col 0,
      "  #Startup the database", row + 1, col 0,
      "  if [[ ${TGT_DB_STATUS_IND} -eq 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "`date`: Starting the database in RESTRICT mode."', row + 1, col 0,
      "    StartupDB 'RESTRICT'", row + 1, col 0,
      "  fi", row + 1, col 0,
      "  ", row + 1, col 0,
      "  TGT_DB_STATUS_IND=$(ps -ef | grep pmon | grep ${ORACLE_SID} | wc -l)", row + 1, col 0,
      "  if [[ ${TGT_DB_STATUS_IND} -gt 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      '    EchoMessage "`date`: Attempting to drop the user ${USER_TO_DROP}."', row + 1, col 0,
      "    #Lock and drop the user. Confirm it is dropped.", row + 1, col 0,
      "    rm -f ${DROP_V500_SQLFILE}", row + 1, col 0,
      "    rm -f ${DROP_V500_SQL_LOGFILE}", row + 1, col 0,
      '    echo "set serveroutput on;"  > ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "begin " >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "  dbms_lock.sleep(5);"  >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      ^    echo "  execute immediate 'alter user ${USER_TO_DROP} account lock';"  >> ${DROP_V500_SQLFILE}^,
      row + 1, col 0,
      '    echo "  dbms_lock.sleep(15);"  >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      ^    echo "  execute immediate 'drop user ${USER_TO_DROP} cascade';"  >> ${DROP_V500_SQLFILE}^,
      row + 1, col 0,
      '    echo "EXCEPTION" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo " when others then raise;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "end;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "/" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      '    echo "exit;" >> ${DROP_V500_SQLFILE}', row + 1, col 0,
      "    ", row + 1, col 0,
      "    cat ${DROP_V500_SQLFILE} > ${DROP_USER_V500_SQLFILE}", row + 1, col 0,
      "    ", row + 1, col 0,
      "    ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_USER_V500_SQLFILE} > ${DROP_USER_V500_SQL_LOGFILE}",
      row + 1, col 0,
      "    CheckDBUserExistence", row + 1, col 0,
      "    if [[ $USER_EXISTS_IND -eq 1 ]]", row + 1, col 0,
      "    then", row + 1, col 0,
      "      COUNTER=1", row + 1, col 0,
      "      while [[ ${COUNTER} -le 3 ]]", row + 1, col 0,
      "      do", row + 1, col 0,
      '        EchoMessage "`date`: Attempt ${COUNTER} to drop the user."', row + 1, col 0,
      "        ${ORACLE_HOME}/bin/sqlplus '/as sysdba' @${DROP_USER_V500_SQLFILE} > ${DROP_USER_V500_SQL_LOGFILE}",
      row + 1, col 0,
      "        ((COUNTER++))", row + 1, col 0,
      "        CheckDBUserExistence", row + 1, col 0,
      "        if [[ $USER_EXISTS_IND -eq 0 ]]", row + 1, col 0,
      "        then", row + 1, col 0,
      "          COUNTER=4", row + 1, col 0,
      "        fi    ", row + 1, col 0,
      "      done", row + 1, col 0,
      "      ", row + 1, col 0,
      "      if [[ $USER_EXISTS_IND -eq 1 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '        EchoMessage "CER-0006:error - Error while dropping the user."', row + 1, col 0,
      "        cat ${DROP_USER_V500_SQL_LOGFILE} >> ${DROP_V500_LOGFILE}", row + 1, col 0,
      '        EchoMessage "`date`: KSH ending in error."', row + 1, col 0,
      "        exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "    fi    ", row + 1, col 0,
      " ", row + 1, col 0,
      "    OpenDB", row + 1, col 0,
      "    ", row + 1, col 0,
      "  fi", row + 1, col 0,
      "fi  ", row + 1, col 0,
      " ", row + 1, col 0,
      "UpdateAdminCheckpointRow 'COMPLETED' ", row + 1, col 0,
      " ", row + 1, col 0,
      'EchoMessage "`date`: Drop user in restricted mode successful."', row + 1
     ENDIF
    WITH nocounter, format = lfstream, formfeed = none,
     maxrow = 1, maxcol = 512
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (dfr_init(null)=0)
    RETURN(0)
   ENDIF
   SET dm2ftpr->user_name = "oracle"
   SET dm2ftpr->user_pwd = "oracle"
   SET dm2ftpr->remote_host = drrr_rf_data->tgt_db_node
   SET dm2ftpr->options = "-b"
   CALL dfr_add_putops_line(" "," "," "," "," ",
    1)
   CALL dfr_add_putops_line(" ",build(trim(logical("ccluserdir")),"/"),ddurk_full_ksh_name,concat(
     ddurk_file_loc,"/"),ddurk_full_ksh_name,
    0)
   IF (dfr_put_file(null)=0)
    RETURN(0)
   ENDIF
   CALL dfr_add_putops_line(" "," "," "," "," ",
    1)
   SET ddurk_cmd = concat("su - oracle -c 'ssh oracle@",drrr_rf_data->tgt_db_node," ",ddurk_file_loc,
    ddurk_full_ksh_name,
    "'")
   SET dm_err->disp_dcl_err_ind = 0
   IF (dm2_push_dcl(ddurk_cmd)=0)
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   SET dm_err->errfile = "NONE"
   IF (findstring("CER-",cnvtupper(dm_err->errtext),1,0) > 0)
    SET ddurk_ksh_error_msg = concat("Fatal error:  ",substring(findstring("CER-",cnvtupper(dm_err->
        errtext),1,1),(size(dm_err->errtext) - findstring("CER-",cnvtupper(dm_err->errtext),1,1)),
      dm_err->errtext),".")
    SET dm_err->eproc = concat("Executing ksh script ",ddurk_full_ksh_name," from ",ddurk_file_loc,
     " on Target ",
     "database node ",drrr_rf_data->tgt_db_node,".")
    SET dm_err->emsg = concat("Error(s) detected during ksh execution. ",ddurk_ksh_error_msg)
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (findstring("DROP USER IN RESTRICTED MODE SUCCESSFUL",cnvtupper(dm_err->errtext),1,0) > 0)
    SET dm_err->eproc = concat("Execution of ksh script ",ddurk_full_ksh_name," from ",ddurk_file_loc,
     " on Target database node (",
     drrr_rf_data->tgt_db_node,") to drop V500 user was successful.")
    CALL disp_msg("",dm_err->logfile,0)
   ELSE
    SET dm_err->eproc = concat("Executing ksh script ",ddurk_full_ksh_name," from ",ddurk_file_loc,
     " on Target ",
     "database node ",drrr_rf_data->tgt_db_node,".")
    SET dm_err->emsg = concat(
     "Unable to verify successful execution of ksh file. Command executed:  ",build(ddurk_cmd))
    SET dm_err->err_ind = 1
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag=0))
    SET dm_err->eproc = concat("Removing ksh script ",ddurk_full_ksh_name," from ",ddurk_file_loc,
     " on Target database node ",
     drrr_rf_data->tgt_db_node)
    CALL disp_msg("",dm_err->logfile,0)
    IF (dm2_findfile(concat(build(logical("ccluserdir"),"/"),ddurk_full_ksh_name)))
     IF (dm2_push_dcl(concat("rm ",build(logical("ccluserdir"),"/"),ddurk_full_ksh_name))=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET ddurk_cmd = ""
    SET ddurk_cmd = concat("su - oracle -c 'ssh oracle@",drrr_rf_data->tgt_db_node,' "rm -f ',
     ddurk_file_loc,ddurk_full_ksh_name,
     ^"'^)
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(ddurk_cmd)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
    SET ddurk_cmd = ""
    SET ddurk_cmd = concat("su - oracle -c 'ssh oracle@",drrr_rf_data->tgt_db_node,' "rm -f ',
     ddurk_full_logfile," ",
     ddurk_logfile," ",ddurk_sqlfile," ",ddurk_du_logfile,
     " ",ddurk_du_sqlfile,^"'^)
    SET dm_err->disp_dcl_err_ind = 0
    IF (dm2_push_dcl(ddurk_cmd)=0)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_verify_admin_content(dvac_inform_only_ind,dvac_invalid_data_ind)
   DECLARE dvac_msg = vc WITH protect, noconstant("")
   DECLARE dvac_idx = i4 WITH protect, noconstant(0)
   DECLARE dvac_tidx = i4 WITH protect, noconstant(0)
   DECLARE dvac_invalid_tbl_file = vc WITH protect, noconstant("")
   IF (validate(dm2_bypass_verify_adm_cont,- (1))=1)
    SET dm_err->eproc = "Bypassing validation of Admin content before data collection."
    CALL disp_msg("",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   FREE RECORD dvac_invalid_tbl
   RECORD dvac_invalid_tbl(
     1 cnt = i4
     1 tables[*]
       2 tbl_name = vc
   )
   SET dvac_invalid_tbl->cnt = 0
   FREE RECORD dvac_dup_tbl
   RECORD dvac_dup_tbl(
     1 cnt = i4
     1 suffixes[*]
       2 suffix = vc
       2 tbl_cnt = i4
       2 tables[*]
         3 tbl_name = vc
   )
   SET dvac_dup_tbl->cnt = 0
   FREE RECORD dvac_missing_tp_tbl
   RECORD dvac_missing_tp_tbl(
     1 cnt = i4
     1 tables[*]
       2 tbl_name = vc
   )
   SET dvac_missing_tp_tbl->cnt = 0
   SET dm_err->eproc =
   "Verify if any INVALID table documentation rows are found for the existing Millennium tables."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_tables_doc dt
    WHERE ((dt.table_suffix="0") OR (((dt.full_table_name=null) OR (dt.full_table_name="")) ))
     AND table_name IN (
    (SELECT
     x.table_name
     FROM dba_tables x
     WHERE x.owner=currdbuser))
    DETAIL
     dvac_invalid_tbl->cnt = (dvac_invalid_tbl->cnt+ 1), stat = alterlist(dvac_invalid_tbl->tables,
      dvac_invalid_tbl->cnt), dvac_invalid_tbl->tables[dvac_invalid_tbl->cnt].tbl_name = dt
     .table_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc =
   "Verify if any DUPLICATE table documentation rows are found for the existing Millennium tables."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_tables_doc dt
    WHERE ((table_name=full_table_name) OR (((full_table_name = null) OR (textlen(trim(
      full_table_name,5))=0)) ))
     AND table_suffix IN (
    (SELECT
     x.table_suffix
     FROM dm_tables_doc x
     WHERE ((x.full_table_name=x.table_name) OR (((textlen(trim(full_table_name,5))=0) OR (x
     .full_table_name = null)) ))
      AND x.table_name IN (
     (SELECT
      t.table_name
      FROM dba_tables t
      WHERE t.owner=currdbuser))
     GROUP BY x.table_suffix
     HAVING count(*) > 1))
     AND table_name IN (
    (SELECT
     x.table_name
     FROM dba_tables x
     WHERE x.owner=currdbuser))
    DETAIL
     dvac_idx = 0
     IF (locateval(dvac_idx,1,size(dvac_dup_tbl->suffixes,5),dt.table_suffix,dvac_dup_tbl->suffixes[
      dvac_idx].suffix)=0)
      dvac_dup_tbl->cnt = (dvac_dup_tbl->cnt+ 1), stat = alterlist(dvac_dup_tbl->suffixes,
       dvac_dup_tbl->cnt), dvac_dup_tbl->suffixes[dvac_dup_tbl->cnt].suffix = dt.table_suffix,
      dvac_idx = dvac_dup_tbl->cnt
     ENDIF
     dvac_dup_tbl->suffixes[dvac_idx].tbl_cnt = (dvac_dup_tbl->suffixes[dvac_idx].tbl_cnt+ 1), stat
      = alterlist(dvac_dup_tbl->suffixes[dvac_idx].tables,dvac_dup_tbl->suffixes[dvac_idx].tbl_cnt),
     dvac_dup_tbl->suffixes[dvac_idx].tables[dvac_dup_tbl->suffixes[dvac_idx].tbl_cnt].tbl_name = dt
     .table_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc =
   "Verify if any MISSING table precedence documentation rows are found for the existing Millennium tables."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    td.table_name
    FROM dba_tables t,
     dm_tables_doc td
    WHERE t.owner=currdbuser
     AND  NOT (t.table_name IN ("DM2_DDL_OPS1", "DM2_DDL_OPS_LOG1"))
     AND t.table_name=td.table_name
     AND td.owner=t.owner
     AND  NOT ( EXISTS (
    (SELECT
     "x"
     FROM dm_ts_precedence tp
     WHERE t.table_name=tp.table_name
      AND t.owner=tp.owner)))
    DETAIL
     dvac_missing_tp_tbl->cnt = (dvac_missing_tp_tbl->cnt+ 1), stat = alterlist(dvac_missing_tp_tbl->
      tables,dvac_missing_tp_tbl->cnt), dvac_missing_tp_tbl->tables[dvac_missing_tp_tbl->cnt].
     tbl_name = td.table_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(dvac_invalid_tbl)
    CALL echorecord(dvac_dup_tbl)
    CALL echorecord(dvac_missing_tp_tbl)
   ENDIF
   IF ((((dvac_invalid_tbl->cnt > 0)) OR ((((dvac_dup_tbl->cnt > 0)) OR ((dvac_missing_tp_tbl->cnt >
   0))) )) )
    SET dvac_invalid_data_ind = 1
    SET dm_err->eproc = "Create invalid admin content report gathered before data collection."
    CALL disp_msg(" ",dm_err->logfile,0)
    IF (get_unique_file("dm2_invalid_adm_cont",".rpt")=0)
     RETURN(0)
    ENDIF
    SET dvac_invalid_tbl_file = concat(build(logical("ccluserdir"),"/"),dm_err->unique_fname)
    SELECT INTO value(dvac_invalid_tbl_file)
     FROM dual
     DETAIL
      row + 1, col 1,
      "***************************WARNING: Invalid Admin Content has been detected.************************",
      row + 1
      IF ((dvac_invalid_tbl->cnt > 0))
       row + 1, col 1, "Tables displayed below have invalid documentation rows.",
       row + 1, col 1,
       "********************************************************************************************************",
       row + 2, col 10, "TABLE NAME",
       row + 1
       FOR (dvac_idx = 1 TO dvac_invalid_tbl->cnt)
         col 10, dvac_invalid_tbl->tables[dvac_idx].tbl_name, row + 1
       ENDFOR
      ENDIF
      IF ((dvac_dup_tbl->cnt > 0))
       row + 1, col 1, "Tables displayed below have duplicate suffixes.",
       row + 1, col 1,
       "********************************************************************************************************",
       row + 2, col 10, "SUFFIX NAME",
       col 40, "TABLE NAME", row + 1
       FOR (dvac_idx = 1 TO dvac_dup_tbl->cnt)
         col 10, dvac_dup_tbl->suffixes[dvac_idx].suffix
         FOR (dvac_tidx = 1 TO dvac_dup_tbl->suffixes[dvac_idx].tbl_cnt)
           col 40, dvac_dup_tbl->suffixes[dvac_idx].tables[dvac_tidx].tbl_name, row + 1
         ENDFOR
       ENDFOR
      ENDIF
      IF ((dvac_missing_tp_tbl->cnt > 0))
       row + 1, col 1, "Tables displayed below are missing table precedence rows.",
       row + 1, col 1,
       "********************************************************************************************************",
       row + 2, col 10, "TABLE NAME",
       row + 1
       FOR (dvac_idx = 1 TO dvac_missing_tp_tbl->cnt)
         col 10, dvac_missing_tp_tbl->tables[dvac_idx].tbl_name, row + 1
       ENDFOR
      ENDIF
     FOOT REPORT
      row + 1, col 0, "END OF REPORT"
     WITH nocounter, maxcol = 300, formfeed = none,
      maxrow = 1, nullreport
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drer_email_list->email_cnt > 0))
     SET drer_email_det->msgtype = "ACTIONREQ"
     SET drer_email_det->status = "REPORT"
     SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
     SET drer_email_det->step = "Invalid Admin Content Report"
     SET drer_email_det->email_level = 1
     SET drer_email_det->logfile = dm_err->logfile
     SET drer_email_det->err_ind = dm_err->err_ind
     SET drer_email_det->eproc = dm_err->eproc
     SET drer_email_det->emsg = dm_err->emsg
     SET drer_email_det->user_action = dm_err->user_action
     SET drer_email_det->attachment = dvac_invalid_tbl_file
     CALL drer_add_body_text(concat("Invalid Admin Content Report created at ",format(drer_email_det
        ->status_dt_tm,";;q")),1)
     CALL drer_add_body_text(concat("Report file name is : ",dvac_invalid_tbl_file),0)
     IF (drer_compose_email(null)=1)
      CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
       email_level)
     ENDIF
     CALL drer_reset_pre_err(null)
    ENDIF
    SET dvac_msg = "Invalid Admin Content found."
    IF (dvac_inform_only_ind=1)
     SET dm_err->eproc = dvac_msg
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validating if invalid admin content found for the Millennium tables."
     SET dm_err->emsg = dvac_msg
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_add_default_scd_row(null)
   DECLARE dadsr_def_row_id = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = "Verify if default row needs to be added for SCD_TERM_DATA table."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dma_sql_obj_inst dsoi
    WHERE dsoi.process_type="ADD_DEFAULT_ROW"
     AND dsoi.object_type="TABLE"
     AND dsoi.object_name="SCD_TERM_DATA"
     AND dsoi.table_name=dsoi.object_name
    DETAIL
     dadsr_def_row_id = dsoi.dma_sql_obj_inst_id
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (dadsr_def_row_id=0)
    SELECT INTO "nl:"
     seqval = seq(dm_seq,nextval)
     FROM dual
     DETAIL
      dadsr_def_row_id = seqval
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Inserting rows in dma_sql_obj_inst table for SCD_TERM_DATA table."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    INSERT  FROM dma_sql_obj_inst dsoi
     SET dsoi.dma_sql_obj_inst_id = dadsr_def_row_id, dsoi.process_type = "ADD_DEFAULT_ROW", dsoi
      .object_type = "TABLE",
      dsoi.object_owner = "V500", dsoi.object_name = "SCD_TERM_DATA", dsoi.table_name =
      "SCD_TERM_DATA",
      dsoi.object_instance = 1, dsoi.active_ind = 1, dsoi.updt_cnt = 0,
      dsoi.updt_id = 0, dsoi.updt_dt_tm = cnvtdatetime(curdate,curtime3), dsoi.updt_task = 15301,
      dsoi.updt_applctx = 0
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   SET dm_err->eproc =
   "Verifying if dma_sql_obj_inst_attr table has a matching row for SCD_TERM_DATA table."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dma_sql_obj_inst_attr dsoia
    WHERE dsoia.dma_sql_obj_inst_id=dadsr_def_row_id
     AND dsoia.attr_name="COLUMN_LIST"
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->eproc = "Inserting row in dma_sql_obj_inst_attr table for SCD_TERM_DATA table."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    INSERT  FROM dma_sql_obj_inst_attr dsoia
     SET dsoia.dma_sql_obj_inst_attr_id = seq(dm_seq,nextval), dsoia.dma_sql_obj_inst_id =
      dadsr_def_row_id, dsoia.attr_name = "COLUMN_LIST",
      dsoia.attr_seg_nbr = 1, dsoia.attr_value_char = "SCD_TERM_DATA_ID", dsoia.attr_value_num = 0.0,
      dsoia.updt_cnt = 0, dsoia.updt_id = 0, dsoia.updt_dt_tm = cnvtdatetime(curdate,curtime3),
      dsoia.updt_task = 15301, dsoia.updt_applctx = 0
     WITH nocounter
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     ROLLBACK
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ELSE
     COMMIT
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_verify_custom_users(dvcu_inform_only_ind,dvcu_invalid_cust_user_ind)
   DECLARE dvcu_custom_users_msg = vc WITH protect, noconstant("")
   DECLARE dvcu_invalid_custom_users = vc WITH protect, noconstant("")
   IF (validate(dm2_bypass_verify_cust_users,- (1))=1)
    SET dm_err->eproc = "Bypassing validation of any database users that are marked custom."
    CALL disp_msg("",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Verifying if any CERNER Solution users have been marked as CUSTOM users."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dm_info di
    WHERE di.info_domain="DM2_CUSTOM_USER"
     AND ((di.info_name IN ("V500_OTG", "CER_CASVC", "CER_CONF", "CER_PREF", "CER_IAWARE",
    "CER_CENTRAL")) OR (((di.info_name="V500_BO*") OR (((di.info_name="V500_ETL*") OR (((di.info_name
    ="V500_MODEL*") OR (di.info_name="V500_DM*")) )) )) ))
    DETAIL
     IF (textlen(trim(dvcu_invalid_custom_users))=0)
      dvcu_invalid_custom_users = trim(di.info_name)
     ELSE
      dvcu_invalid_custom_users = concat(dvcu_invalid_custom_users,", ",trim(di.info_name))
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   IF (curqual > 0)
    SET dvcu_invalid_cust_user_ind = 1
    SET dvcu_custom_users_msg = concat("Invalid database users found that are marked as custom: ",
     dvcu_invalid_custom_users)
    IF (dvcu_inform_only_ind=1)
     SET dm_err->eproc = dvcu_custom_users_msg
     CALL disp_msg("",dm_err->logfile,0)
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validating if any invalid database users exist."
     SET dm_err->emsg = dvcu_custom_users_msg
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_check_db_link(dcdl_in_db_link_name,dcdl_out_db_link_fnd_ind)
   DECLARE dcdl_cur_db_link_name = vc WITH protect, noconstant("")
   DECLARE dcdl_db_link_cnt = i2 WITH protect, noconstant(0)
   DECLARE dcdl_pos = i2 WITH protect, noconstant(0)
   SET dcdl_out_db_link_fnd_ind = 0
   SET dm_err->eproc = concat("Check if database link ",dcdl_in_db_link_name," exists.")
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO "nl:"
    dl.db_link
    FROM all_db_links dl
    WHERE parser(build(" dl.db_link = '",dcdl_in_db_link_name,"*'"))
    DETAIL
     dcdl_pos = 0, dcdl_pos = findstring(".",dl.db_link,1)
     IF (dcdl_pos > 0)
      dcdl_cur_db_link_name = substring(1,(dcdl_pos - 1),dl.db_link)
     ELSE
      dcdl_cur_db_link_name = dl.db_link
     ENDIF
     IF (trim(cnvtupper(dcdl_cur_db_link_name))=trim(cnvtupper(dcdl_in_db_link_name)))
      dcdl_db_link_cnt = (dcdl_db_link_cnt+ 1)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (dcdl_db_link_cnt > 1)
    SET dm_err->err_ind = 1
    SET dm_err->emsg = concat("Multiple database links match input database link (",
     dcdl_in_db_link_name,").")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ELSEIF (dcdl_db_link_cnt=1)
    SET dcdl_out_db_link_fnd_ind = 1
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drr_del_preserved_ts(dcdl_tgt_db_name)
   SET dm_err->eproc = concat("Delete DM2_REPLICATE_DATA for database ",dm2_install_schema->
    target_dbase_name)
   CALL disp_msg("",dm_err->logfile,0)
   DELETE  FROM dm2_admin_dm_info di
    WHERE di.info_domain="DM2_REPLICATE_USER_TS"
     AND di.info_name=patstring(cnvtupper(build(dcdl_tgt_db_name,"-DB-*")))
    WITH nocounter
   ;end delete
   IF (check_error(dm_err->eproc)=1)
    ROLLBACK
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   COMMIT
   RETURN(1)
 END ;Subroutine
 IF (validate(rdisk->qual[1].disk_name,"")=""
  AND validate(rdisk->qual[1].disk_name,"Z")="Z")
  FREE RECORD rdisk
  RECORD rdisk(
    1 disk_cnt = i4
    1 qual[*]
      2 disk_name = vc
      2 volume_label = vc
      2 vg_name = vc
      2 pp_size_mb = f8
      2 total_space_mb = f8
      2 free_space_mb = f8
      2 new_free_space_mb = f8
      2 root_ind = i2
      2 used_ind = vc
      2 data_tspace = i2
      2 index_tspace = i2
      2 datafile_dir_exists = i2
      2 mwc_flag = i2
      2 alloc_unit_b = f8
      2 block_size_b = f8
  )
  SET rdisk->disk_cnt = 0
 ENDIF
 IF (validate(pv_lv_list->qual[1].pv_name,"")=""
  AND validate(pv_lv_list->qual[1].pv_name,"Z")="Z")
  FREE RECORD pv_lv_list
  RECORD pv_lv_list(
    1 cnt = i4
    1 pv[*]
      2 pv_name = vc
      2 lv[*]
        3 lv_name = vc
  )
 ENDIF
 IF (validate(pv_mwc_list->pv[1].pv_name,"")=""
  AND validate(pv_mwc_list->pv[1].pv_name,"Z")="Z")
  FREE RECORD pv_mwc_list
  RECORD pv_mwc_list(
    1 cnt = i4
    1 pv[*]
      2 pv_name = vc
      2 mwc_flag = i2
  )
 ENDIF
 IF ((validate(autopop_screen->top_line,- (1))=- (1))
  AND (validate(autopop_screen->top_line,- (2))=- (2)))
  FREE RECORD autopop_screen
  RECORD autopop_screen(
    1 top_line = i4
    1 bottom_line = i4
    1 cur_line = i4
    1 max_scroll = i4
    1 max_value = i4
    1 disk_cnt = i4
    1 remain_space_add = f8
    1 user_bytes = f8
    1 disk[*]
      2 volume_label = vc
      2 disk_name = vc
      2 vg_name = vc
      2 disk_idx = i4
      2 lv_filename = vc
      2 free_disk_space_mb = f8
      2 pp_size_mb = f8
      2 pps_to_add = f8
      2 space_to_add = f8
      2 disk_tspace_rel_key = i4
      2 cont_size_mb = f8
      2 delete_ind = i4
      2 disk_full_ind = i2
      2 orig_disk_space_mb = f8
      2 mwc_flag = i2
      2 alloc_unit_b = f8
      2 block_size_b = f8
  )
 ENDIF
 IF ((validate(rvg->vg_cnt,- (1))=- (1))
  AND (validate(rvg->vg_cnt,- (2))=- (2)))
  FREE RECORD rvg
  RECORD rvg(
    1 vg_cnt = i2
    1 qual[*]
      2 vg_name = vc
      2 psize = i4
      2 ttl_pps = f8
      2 free_pps = f8
      2 free_mb = f8
  )
  SET rvg->vg_cnt = 0
 ENDIF
 IF (validate(dos_sys_filename,"X")="X"
  AND validate(dos_sys_filename,"Y")="Y")
  DECLARE dos_sys_filename = vc WITH public, noconstant("DM2NOTSET")
  IF ((dm2_sys_misc->cur_db_os="AXP"))
   SET dos_sys_filename = logical("sys$sysdevice")
  ENDIF
 ENDIF
 IF ((validate(dor_flex_cmd->dfc_cnt,- (1))=- (1))
  AND (validate(dor_flex_cmd->dfc_cnt,- (2))=- (2)))
  RECORD dor_flex_cmd(
    1 dfc_cnt = i4
    1 cmd[*]
      2 flex_cmd_file = vc
      2 flex_cmd = vc
      2 flex_output = vc
      2 flex_out_file = vc
      2 flex_cmd_type = vc
      2 flex_local = i2
      2 flex_rmt_user = vc
      2 flex_rmt_node = vc
  )
 ENDIF
 DECLARE dm2_find_dir(sbr_dir_name=vc) = i2
 DECLARE dm2_find_queue(sbr_que_name=vc) = i2
 DECLARE dm2_get_mnt_disk_info_axp(sbr_outfile=vc) = i2
 DECLARE convert_blocks_to_bytes(cbb_block_in=f8) = f8
 DECLARE convert_bytes(byte_value=f8,from_flag=c1,to_flag=c1) = f8 WITH public
 DECLARE dm2_get_vg_disk_info_aix(null) = i4 WITH public
 DECLARE dm2_parse_aix_vg_disk_file(sbr_dsk_fname=vc) = i4 WITH public
 DECLARE dm2_parse_hpux_disk_file(sbr_dsk_fname=vc) = i4 WITH public
 DECLARE dm2_assign_disk(agd_size_in=f8,agd_last_disk_ndx=i4) = i4
 DECLARE dm2_create_dir(sbr_new_dir=vc,sbr_new_dir_type=vc) = i2
 DECLARE dm2_get_vgs(null) = i2
 DECLARE dm2_get_novg_disk_info_aix(null) = i2
 DECLARE dm2_get_nomnt_disk_info_axp(null) = i2
 DECLARE dm2_extend_vg(dev_vg_name=vc,dev_disk_name=vc) = i2
 DECLARE dm2_make_vg(dmv_vg_name=vc,dmv_psize=i4,dmv_disk_name=vc) = i2
 DECLARE dm2_init_mount_disk(dim_disk_name=vc,dim_vol_lbl=vc) = vc
 DECLARE dm2_get_mwc_flag(dgm_disk_name=vc) = i2
 DECLARE dm2_sub_space_from_disk(dss_disk_ndx=i4,dss_file_size=f8) = i2
 DECLARE dm2_aix_remove_lv(sbr_arl_db_name=vc) = i2
 DECLARE dm2_rename_login_default(sbr_rld_mode=vc) = i2
 DECLARE dm2_delete_dir(ddd_dir=vc) = i2
 DECLARE dm2_reduce_vg(drv_vg_name=vc,drv_disk_name=vc) = i2
 DECLARE get_space_rounded(space_add_in=f8,pp_size_in=f8) = f8
 DECLARE dm2_parse_aix_vg(dpa_fname=vc,dpa_rvg_idx=i4) = i2
 DECLARE dm2_check_cluster_lic(null) = i2
 DECLARE dos_get_lv_for_pv(dglp_file=vc) = i2
 DECLARE dos_get_sys_dev(dgsd_file=vc) = i2
 DECLARE dos_get_mwc_value(dgmv_file=vc,dgmv_mode=i2) = i2
 DECLARE dor_get_diskgroup_info(null) = i2
 DECLARE dor_load_rdisk_into_rvg(dlrir_os=vc) = i2
 DECLARE dor_init_flex_cmds(null) = i2
 DECLARE dor_add_flex_cmd(dafc_local=i2,dafc_rmt_user=vc,dafc_rmt_node=vc,dafc_cmd_file=vc,dafc_cmd=
  vc,
  dafc_out_file=vc,dafc_cmd_type=vc) = i2
 DECLARE dm2_dismount_disk(ddd_vol_label=vc) = i2
 DECLARE dor_exec_flex_cmd(null) = i2
 DECLARE dm2_parse_mnt_disk_info_axp(dpmdia_outfile=vc) = i2
 DECLARE dor_flex_chmod_file(dfcf_file=vc,dfcf_ssh_str=vc) = i2
 SUBROUTINE dor_flex_chmod_file(dfcf_file,dfcf_ssh_str)
   DECLARE dfcf_str = vc WITH protect, noconstant(" ")
   DECLARE dfcf_stat = i2 WITH protect, noconstant(0)
   SET dfcf_str = concat(dfcf_ssh_str," chmod 777 ",dfcf_file," > ",trim(logical("ccluserdir")),
    "/dfcf_outfile.out 2>&1")
   SET dfcf_stat = 0
   SET dfcf_stat = dcl(dfcf_str,textlen(dfcf_str),dfcf_stat)
   IF ((dm_err->debug_flag > 0))
    CALL echo(dfcf_str)
   ENDIF
   IF (dfcf_stat != 1)
    IF (parse_errfile(concat(trim(logical("ccluserdir")),"/dfcf_outfile.out"))=0)
     RETURN(0)
    ENDIF
    SET dm_err->err_ind = 1
    SET dm_err->emsg = dm_err->errtext
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dor_exec_flex_cmd(null)
   DECLARE defc_stat = i2 WITH protect, noconstant(0)
   DECLARE defc_cnt = i2 WITH protect, noconstant(0)
   DECLARE defc_str = vc WITH protect, noconstant("")
   DECLARE defc_ssh_str = vc WITH protect, noconstant("")
   IF ((dm_err->debug_flag > 5))
    CALL echorecord(dor_flex_cmd)
   ENDIF
   FOR (defc_cnt = 1 TO dor_flex_cmd->dfc_cnt)
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
      SET defc_ssh_str = concat("ssh ",dor_flex_cmd->cmd[defc_cnt].flex_rmt_user,"@",dor_flex_cmd->
       cmd[defc_cnt].flex_rmt_node," ")
     ELSE
      SET defc_ssh_str = " "
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("EF", "EFRO")))
      IF (dor_flex_chmod_file(dor_flex_cmd->cmd[defc_cnt].flex_cmd_file,defc_ssh_str)=0)
       RETURN(0)
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("EF", "EFRO", "EFO")))
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type="EFRO"))
       IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=1))
        SET defc_str = concat(". ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file," > ",trim(logical(
           "ccluserdir")),"/defc_outfile.out")
       ELSE
        SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
       ENDIF
      ELSEIF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type="EF"))
       SET defc_str = concat(". ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
      ELSEIF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type="EFO"))
       IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=1))
        SET defc_str = concat("su - oracle -c ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
       ELSE
        SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
       ENDIF
      ENDIF
      SET defc_stat = 0
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
      IF ((dm_err->debug_flag > 0))
       CALL echo(defc_str)
      ENDIF
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type="EFRO"))
       IF (parse_errfile(concat(trim(logical("ccluserdir")),"/defc_outfile.out"))=0)
        RETURN(0)
       ENDIF
       SET dor_flex_cmd->cmd[defc_cnt].flex_output = dm_err->errtext
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("EC")))
      IF (findstring("update_reg",dor_flex_cmd->cmd[defc_cnt].flex_cmd,1,0) > 0)
       IF (drr_exec_update_reg(dor_flex_cmd->cmd[defc_cnt].flex_cmd)=0)
        RETURN(0)
       ENDIF
      ELSE
       IF ((dor_flex_cmd->cmd[defc_cnt].flex_out_file=""))
        SET dor_flex_cmd->cmd[defc_cnt].flex_out_file = concat(trim(logical("ccluserdir")),
         "/defc_outfile.out")
       ENDIF
       IF ((dor_flex_cmd->cmd[defc_cnt].flex_out_file="*:APPEND"))
        SET defc_stat = 0
        SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd," >> ",substring(
          1,(findstring(":",dor_flex_cmd->cmd[defc_cnt].flex_out_file,1,1) - 1),dor_flex_cmd->cmd[
          defc_cnt].flex_out_file),
         " 2>&1")
        IF ((dm_err->debug_flag > 0))
         CALL echo(defc_str)
        ENDIF
        SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       ELSEIF ((dor_flex_cmd->cmd[defc_cnt].flex_out_file="noout"))
        SET defc_stat = 0
        SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd)
        IF ((dm_err->debug_flag > 0))
         CALL echo(defc_str)
        ENDIF
        SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       ELSE
        SET defc_stat = 0
        SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd," > ",
         dor_flex_cmd->cmd[defc_cnt].flex_out_file,
         " 2>&1")
        IF ((dm_err->debug_flag > 0))
         CALL echo(defc_str)
        ENDIF
        SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
        IF (parse_errfile(dor_flex_cmd->cmd[defc_cnt].flex_out_file)=0)
         RETURN(0)
        ENDIF
        SET dor_flex_cmd->cmd[defc_cnt].flex_output = dm_err->errtext
       ENDIF
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("EFORO")))
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=1))
       SET defc_str = concat("su - oracle -c ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
      ELSE
       SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
      ENDIF
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_out_file=""))
       SET dor_flex_cmd->cmd[defc_cnt].flex_out_file = concat(trim(logical("ccluserdir")),
        "/defc_outfile.out")
      ENDIF
      SET defc_stat = 0
      SET defc_str = concat(defc_str," "," > ",dor_flex_cmd->cmd[defc_cnt].flex_out_file," 2>&1")
      IF ((dm_err->debug_flag > 0))
       CALL echo(defc_str)
      ENDIF
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
      IF (parse_errfile(dor_flex_cmd->cmd[defc_cnt].flex_out_file)=0)
       RETURN(0)
      ENDIF
      SET dor_flex_cmd->cmd[defc_cnt].flex_output = dm_err->errtext
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("EFRF")))
      SET defc_stat = 0
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
       SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file," > ",
        dor_flex_cmd->cmd[defc_cnt].flex_out_file,
        " 2>&1")
      ELSE
       SET defc_str = concat(dor_flex_cmd->cmd[defc_cnt].flex_cmd_file," > ",dor_flex_cmd->cmd[
        defc_cnt].flex_out_file," 2>&1")
      ENDIF
      IF ((dm_err->debug_flag > 0))
       CALL echo(defc_str)
      ENDIF
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
      IF (defc_stat != 1)
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat("Error returned from:",defc_str)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
       SET defc_str = concat("/usr/bin/scp ",dor_flex_cmd->cmd[defc_cnt].flex_rmt_user,"@",
        dor_flex_cmd->cmd[defc_cnt].flex_rmt_node,":",
        dor_flex_cmd->cmd[defc_cnt].flex_out_file," ",trim(logical("ccluserdir")),"/")
       IF ((dm_err->debug_flag > 0))
        CALL echo(defc_str)
       ENDIF
       SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       IF (defc_stat != 1)
        SET dm_err->err_ind = 1
        SET dm_err->emsg = concat("Error returned from:",defc_str)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("RCPBACK")))
      SET defc_str = concat("/usr/bin/scp ",dor_flex_cmd->cmd[defc_cnt].flex_rmt_user,"@",
       dor_flex_cmd->cmd[defc_cnt].flex_rmt_node,":",
       dor_flex_cmd->cmd[defc_cnt].flex_out_file," ",trim(logical("ccluserdir")),"/")
      IF ((dm_err->debug_flag > 0))
       CALL echo(defc_str)
      ENDIF
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
      IF (defc_stat != 1)
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat("Error returned from:",defc_str)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("ECRF")))
      SET defc_stat = 0
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
       SET defc_str = concat(defc_ssh_str," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd," > ",dor_flex_cmd
        ->cmd[defc_cnt].flex_out_file,
        " 2>&1")
      ELSE
       SET defc_str = concat(dor_flex_cmd->cmd[defc_cnt].flex_cmd," > ",dor_flex_cmd->cmd[defc_cnt].
        flex_out_file," 2>&1")
      ENDIF
      IF ((dm_err->debug_flag > 0))
       CALL echo(defc_str)
      ENDIF
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
      IF (defc_stat != 1)
       SET dm_err->err_ind = 1
       SET dm_err->emsg = concat("Error returned from:",defc_str)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
       SET defc_str = concat("/usr/bin/scp ",dor_flex_cmd->cmd[defc_cnt].flex_rmt_user,"@",
        dor_flex_cmd->cmd[defc_cnt].flex_rmt_node,":",
        dor_flex_cmd->cmd[defc_cnt].flex_out_file," ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file)
       IF ((dm_err->debug_flag > 0))
        CALL echo(defc_str)
       ENDIF
       SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       IF (defc_stat != 1)
        SET dm_err->err_ind = 1
        SET dm_err->emsg = concat("Error returned from:",defc_str)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
     IF ((dor_flex_cmd->cmd[defc_cnt].flex_cmd_type IN ("RCP")))
      IF ((dor_flex_cmd->cmd[defc_cnt].flex_local=0))
       SET defc_str = concat("/usr/bin/scp ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file," ",
        dor_flex_cmd->cmd[defc_cnt].flex_rmt_user,"@",
        dor_flex_cmd->cmd[defc_cnt].flex_rmt_node,":",dor_flex_cmd->cmd[defc_cnt].flex_out_file)
       IF ((dm_err->debug_flag > 0))
        CALL echo(defc_str)
       ENDIF
       SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       IF (defc_stat != 1)
        SET dm_err->err_ind = 1
        SET dm_err->emsg = concat("Error returned from:",defc_str)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       IF (dor_flex_chmod_file(dor_flex_cmd->cmd[defc_cnt].flex_out_file,defc_ssh_str)=0)
        RETURN(0)
       ENDIF
      ELSE
       SET defc_str = concat("cp ",dor_flex_cmd->cmd[defc_cnt].flex_cmd_file," ",dor_flex_cmd->cmd[
        defc_cnt].flex_out_file)
       IF ((dm_err->debug_flag > 0))
        CALL echo(defc_str)
       ENDIF
       SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
       IF (defc_stat != 1)
        SET dm_err->err_ind = 1
        SET dm_err->emsg = concat("Error returned from:",defc_str)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
     IF ((dm_err->debug_flag > 722))
      SET defc_str = concat("cat ",trim(logical("ccluserdir")),"/defc_outfile.out")
      SET defc_stat = 0
      SET defc_stat = dcl(defc_str,textlen(defc_str),defc_stat)
     ENDIF
     SET dor_flex_cmd->cmd[defc_cnt].flex_output = trim(dor_flex_cmd->cmd[defc_cnt].flex_output,3)
   ENDFOR
   IF ((dm_err->debug_flag > 5))
    CALL echorecord(dor_flex_cmd)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dor_add_flex_cmd(dafc_local,dafc_rmt_user,dafc_rmt_node,dafc_cmd_file,dafc_cmd,
  dafc_out_file,dafc_cmd_type)
   SET dor_flex_cmd->dfc_cnt = (dor_flex_cmd->dfc_cnt+ 1)
   SET stat = alterlist(dor_flex_cmd->cmd,dor_flex_cmd->dfc_cnt)
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd_file = dafc_cmd_file
   IF (dafc_local=0)
    SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd = concat('"',dafc_cmd,'"')
    IF (findstring("echo $\?",dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd,1,1) > 0)
     SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd = replace(dor_flex_cmd->cmd[dor_flex_cmd->
      dfc_cnt].flex_cmd,"echo $?","echo \$?",0)
    ENDIF
   ELSE
    SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd = dafc_cmd
   ENDIF
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_out_file = dafc_out_file
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_cmd_type = dafc_cmd_type
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_local = dafc_local
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_rmt_user = dafc_rmt_user
   SET dor_flex_cmd->cmd[dor_flex_cmd->dfc_cnt].flex_rmt_node = dafc_rmt_node
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dor_init_flex_cmds(null)
   SET dor_flex_cmd->dfc_cnt = 0
   SET stat = alterlist(dor_flex_cmd->cmd,0)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_find_dir(sbr_dir_name)
   DECLARE dfd_cmd_txt = vc WITH protect, noconstant(" ")
   DECLARE dfd_err_str = vc WITH protect, noconstant(" ")
   DECLARE dfd_err_str2 = vc WITH protect, noconstant(" ")
   DECLARE dfd_tmp_err_ind = i2 WITH protect, noconstant(0)
   DECLARE dfd_err_str3 = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dfd_cmd_txt = concat("dir ",sbr_dir_name)
    SET dfd_err_str = "directory not found"
    SET dfd_err_str2 = "no files found"
    SET dfd_err_str3 = "error in device name"
   ELSE
    SET dfd_cmd_txt = concat("test -d ",sbr_dir_name,";echo $?")
    SET dfd_err_str = "0"
   ENDIF
   SET dm_err->disp_dcl_err_ind = 0
   CALL dm2_push_dcl(dfd_cmd_txt)
   SET dm_err->disp_dcl_err_ind = 1
   IF ((dm_err->err_ind=1))
    SET dm_err->err_ind = 0
    SET dfd_tmp_err_ind = 1
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    IF (findstring(dfd_err_str,dm_err->errtext,1,0) > 0)
     SET dm_err->eproc = concat("Directory ",sbr_dir_name," not found.")
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(0)
    ELSEIF (findstring(dfd_err_str2,dm_err->errtext,1,0) > 0)
     SET dm_err->eproc = concat("Directory ",sbr_dir_name," exists with no files in directory.")
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(1)
    ELSEIF (findstring(dfd_err_str3,dm_err->errtext,1,0) > 0)
     SET dm_err->eproc = concat("Directory device ",sbr_dir_name," does not exist.")
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(0)
    ELSEIF (dfd_tmp_err_ind=1)
     SET dm_err->eproc = concat("Find directory  ",sbr_dir_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     SET dm_err->err_ind = 1
     RETURN(0)
    ENDIF
   ELSE
    IF (cnvtint(dm_err->errtext)=0)
     SET dm_err->eproc = concat("Directory ",sbr_dir_name," found.")
     IF ((dm_err->debug_flag > 1))
      CALL disp_msg(dm_err->emsg,dm_err->logfile,0)
     ENDIF
     RETURN(1)
    ELSE
     SET dm_err->eproc = concat("Directory ",sbr_dir_name," not found.")
     IF ((dm_err->debug_flag > 1))
      CALL disp_msg(dm_err->emsg,dm_err->logfile,0)
     ENDIF
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_find_queue(sbr_que_name)
   DECLARE dfd_cmd_txt = vc WITH protect, noconstant(" ")
   DECLARE dfd_err_str = vc WITH protect, noconstant(" ")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dfd_cmd_txt = concat("sho queue ",sbr_que_name)
    SET dfd_err_str = "no such queue"
   ELSE
    RETURN(0)
   ENDIF
   IF (dm2_push_dcl(dfd_cmd_txt)=0)
    RETURN(0)
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(dm_err->errtext)
   ENDIF
   IF (findstring("idle",dm_err->errtext,1,0) > 0)
    RETURN(1)
   ELSE
    SET dm_err->eproc = concat("Make sure que ",sbr_que_name," is idle.")
    SET dm_err->emsg = dm_err->errtext
    CALL disp_msg(dm_err->emsg,dm_err->logfile,0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dos_get_sys_dev(dgsd_file)
   DECLARE dgsd_device_name = vc WITH protect, noconstant("")
   DECLARE dgsd_start = i2 WITH protect, noconstant(0)
   SET dm_err->eproc = "Gather system device name"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET logical dgsd_sys_dev dgsd_file
   FREE DEFINE rtl
   DEFINE rtl "dgsd_sys_dev"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     dgsd_start = (findstring('"SYS$SYSDEVICE" = "',t.line)+ 19)
     IF ((dm_err->debug_flag > 1))
      CALL echo(t.line)
     ENDIF
     IF (dgsd_start > 0)
      dgsd_device_name = substring(dgsd_start,(findstring('"',t.line,(dgsd_start+ 1),1) - dgsd_start),
       t.line)
     ENDIF
     IF ((dm_err->debug_flag > 1))
      CALL echo(dgsd_device_name)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgsd_device_name="")
    SET dm_err->eproc = concat("Could not gather system device name from file:",dgsd_file)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,0)
   ENDIF
   SET dos_sys_filename = dgsd_device_name
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dos_get_mwc_value(dgmv_file,dgmv_mode)
   DECLARE dgmv_cmd = vc WITH protect, noconstant("")
   DECLARE dgmv_stat = i2 WITH protect, noconstant(0)
   DECLARE dgmv_cnt = i2 WITH protect, noconstant(0)
   IF (dgmv_mode=1)
    SET dgmv_cmd = concat(
     ^a=`lsvg -o | awk -v b="" '{b=sprintf("%s| %s ",b,$1)}END{print b}' | sed 's/^,
     "^| //g'`;for i in `lspv | egrep ",^"($a)" | awk '{print $1}'`;do lqueryvg -p /dev/$i -X | ^,
     ^echo $i `awk '{print" "$1}'` ;done >> ^,dgmv_file)
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("MWC command:",dgmv_cmd))
    ENDIF
    SET dm_err->eproc = "Gather MWC values"
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SET dgmv_stat = dcl(dgmv_cmd,textlen(dgmv_cmd),dgmv_stat)
    IF (dgmv_stat=1)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("pv mwc listing file =",dgmv_file))
     ENDIF
    ELSE
     IF (check_error(dm_err->eproc) != 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->eproc = concat("Validate that ",dgmv_file," exists")
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    IF (findfile(dgmv_file)=0)
     SET dm_err->emsg = concat(dgmv_file," does not exist, unable to obtain MWC information")
     SET dm_err->err_ind = 1
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = "Load MWC values"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET logical mwc_disk_info dgmv_file
   FREE DEFINE rtl
   DEFINE rtl "mwc_disk_info"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     dgmv_cnt = (dgmv_cnt+ 1)
     IF (mod(dgmv_cnt,10)=1)
      stat = alterlist(pv_mwc_list->pv,(dgmv_cnt+ 9))
     ENDIF
     pv_mwc_list->pv[dgmv_cnt].pv_name = substring(1,(findstring(" ",t.line) - 1),t.line),
     pv_mwc_list->pv[dgmv_cnt].mwc_flag = evaluate(cnvtint(substring((findstring(" ",t.line)+ 1),1,t
        .line)),1,0,1)
     IF ((pv_mwc_list->pv[dgmv_cnt].mwc_flag=0))
      pv_mwc_list->pv[dgmv_cnt].mwc_flag = 1
     ELSE
      pv_mwc_list->pv[dgmv_cnt].mwc_flag = 0
     ENDIF
    FOOT REPORT
     pv_mwc_list->cnt = dgmv_cnt, stat = alterlist(pv_mwc_list->pv,dgmv_cnt)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dos_get_lv_for_pv(dglp_file)
   DECLARE dglp_cmd = vc WITH protect, noconstant("")
   DECLARE dglp_rtl_file = vc WITH protect, noconstant("")
   DECLARE dglp_pv_cnt = i4 WITH protect, noconstant(0)
   DECLARE dglp_lv_cnt = i4 WITH protect, noconstant(0)
   DECLARE dglp_stat = i4 WITH protect, noconstant(0)
   SET dglp_rtl_file = concat("ccluserdir:",dglp_file)
   SET logical aix_disk_info dglp_rtl_file
   FREE DEFINE rtl
   DEFINE rtl "aix_disk_info"
   SET dm_err->eproc = "Parse list of PVs and related LVs"
   IF ((dm_err->debug_flag > 1))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     IF (findstring(":",t.line) > 0)
      dglp_pv_cnt = (dglp_pv_cnt+ 1), stat = alterlist(pv_lv_list->pv,dglp_pv_cnt), pv_lv_list->pv[
      dglp_pv_cnt].pv_name = substring(1,(findstring(":",t.line) - 1),t.line),
      dglp_lv_cnt = 0
     ELSE
      IF ( NOT (findstring("LV NAME",t.line)))
       dglp_lv_cnt = (dglp_lv_cnt+ 1), stat = alterlist(pv_lv_list->pv[dglp_pv_cnt].lv,dglp_lv_cnt),
       pv_lv_list->pv[dglp_pv_cnt].lv[dglp_lv_cnt].lv_name = substring(1,(findstring(" ",t.line) - 1),
        t.line)
      ENDIF
     ENDIF
    FOOT REPORT
     pv_lv_list->cnt = dglp_pv_cnt
    WITH nocounter, maxcol = 500
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 2))
    CALL echorecord(pv_lv_list)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_parse_mnt_disk_info_axp(dpmdia_outfile)
   DECLARE axp_rtl_file = vc WITH public, noconstant("")
   DECLARE disk_vg_hold = vc WITH public, noconstant("")
   DECLARE axp_count_hold = i4 WITH public, noconstant(0)
   DECLARE spot_end = i4 WITH public, noconstant(0)
   DECLARE spot = i4 WITH public, noconstant(0)
   SET axp_rtl_file = concat("ccluserdir:",dpmdia_outfile)
   SET logical axp_disk_info axp_rtl_file
   FREE DEFINE rtl
   DEFINE rtl "axp_disk_info"
   SET dm_err->eproc = "Parse list of mounted disks"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    HEAD REPORT
     axp_count_hold = 0
    DETAIL
     axp_count_hold = (axp_count_hold+ 1), stat = alterlist(rdisk->qual,axp_count_hold), spot =
     findstring(",",t.line,1),
     disk_name_hold = substring(1,(spot - 1),t.line), rdisk->qual[axp_count_hold].disk_name =
     disk_name_hold
     IF (disk_name_hold=dos_sys_filename)
      rdisk->qual[axp_count_hold].root_ind = 1
     ELSE
      rdisk->qual[axp_count_hold].root_ind = 0
     ENDIF
     disk_vg_hold = substring((spot+ 2),(textlen(t.line) - spot),t.line), spot = findstring(",",
      disk_vg_hold), disk_vg_hold = substring(1,(spot - 1),disk_vg_hold),
     rdisk->qual[axp_count_hold].volume_label = disk_vg_hold, spot = 0, spot = findstring(
      "Free Space:",t.line,1),
     spot_end = findstring("Total Space:",t.line,1), disk_free_space_mb = substring(spot,((spot_end
       - spot) - 1),t.line), spot = 0,
     spot = findstring(":",disk_free_space_mb,1), disk_free_space_mb = substring((spot+ 2),(textlen(
       disk_free_space_mb) - spot),disk_free_space_mb), rdisk->qual[axp_count_hold].free_space_mb =
     convert_bytes(convert_blocks_to_bytes(cnvtreal(disk_free_space_mb)),"b","m"),
     rdisk->qual[axp_count_hold].new_free_space_mb = rdisk->qual[axp_count_hold].free_space_mb, spot
      = 0, disk_free_space_mb = "",
     spot = findstring("Total Space:",t.line,1), disk_free_space_mb = substring(spot,(textlen(t.line)
       - spot),t.line), spot = 0,
     spot = findstring(":",disk_free_space_mb,1), disk_free_space_mb = substring((spot+ 2),(textlen(
       disk_free_space_mb) - spot),disk_free_space_mb), rdisk->qual[axp_count_hold].total_space_mb =
     convert_bytes(convert_blocks_to_bytes(cnvtreal(disk_free_space_mb)),"b","m")
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    SET message = nowindow
    CALL echorecord(rdisk)
    SET message = window
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_mnt_disk_info_axp(sbr_outfile)
   SET dm_err->eproc = "Get list of mounted disks"
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dcl_str = vc WITH protect, noconstant(" ")
   SET dcl_str = concat("@cer_install:dm2_get_mnt_disk_info.com ",sbr_outfile)
   IF ( NOT (dm2_push_dcl(dcl_str)))
    RETURN(0)
   ENDIF
   IF (dm2_parse_mnt_disk_info_axp(sbr_outfile)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_vg_disk_info_aix(null)
   DECLARE dcl_str = vc WITH protect, noconstant(" ")
   DECLARE dcl_stat = i2 WITH protect, noconstant(0)
   DECLARE dcl_temp_file = vc WITH protect, noconstant("")
   SET dm_err->eproc = "Get list of disks in a volume group"
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET dm_err->eproc = "DM2_GET_VG_DISK_INFO_AIX: Get unique filename for disk list"
   IF (get_unique_file("dm2_disk_aix_info",".dat"))
    SET dcl_temp_file = dm_err->unique_fname
   ELSE
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET dm_err->eproc = "DM2_GET_VG_DISK_INFO_AIX: Get list of disks in a volume group"
    SET dcl_str = concat(^a=`lsvg -o | awk -v b="" '{b=sprintf("%s| %s ",b,$1)}^,
     "END{print b}' | sed 's/^| //g'`",
     ^;for i in `lspv | egrep "($a)" | awk '{print $1}'`;do lspv $i >> ^,dcl_temp_file,";done")
    SET dcl_stat = dcl(dcl_str,textlen(dcl_str),dcl_stat)
    IF (dcl_stat=1)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("disk_file =",dcl_temp_file))
     ENDIF
     IF ( NOT (dm2_parse_aix_vg_disk_file(dcl_temp_file)))
      RETURN(0)
     ELSE
      RETURN(1)
     ENDIF
    ELSE
     IF (check_error(dm_err->eproc) != 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->eproc = "DM2_GET_VG_DISK_INFO_AIX: Use VGDISPLAY to get list of Volume Groups."
    SET dcl_str = concat("vgdisplay > ",dm_err->unique_fname," 2>/dev/null")
    SET dcl_stat = 0
    SET dcl_stat = dcl(dcl_str,textlen(dcl_str),dcl_stat)
    IF (dcl_stat=0)
     IF (check_error(dm_err->eproc) != 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
     RETURN(0)
    ELSE
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("disk_file =",dcl_temp_file))
     ENDIF
    ENDIF
    IF (dm2_parse_hpux_disk_file(dcl_temp_file)=0)
     RETURN(0)
    ELSE
     RETURN(1)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dor_load_rdisk_into_rvg(dlrir_os)
   DECLARE dlrir_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlrir_vg_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlrir_ndx = i4 WITH protect, noconstant(0)
   SET rvg->vg_cnt = 0
   SET stat = alterlist(rvg->qual,rvg->vg_cnt)
   FOR (dlrir_cnt = 1 TO rdisk->disk_cnt)
     IF ( NOT ((rdisk->qual[dlrir_cnt].vg_name IN ("rootvg", "/dev/vg00"))))
      IF (dlrir_cnt > 0
       AND locateval(dlrir_ndx,1,rvg->vg_cnt,rdisk->qual[dlrir_cnt].vg_name,rvg->qual[dlrir_ndx].
       vg_name) > 0)
       SET rvg->qual[dlrir_ndx].ttl_pps = (rvg->qual[dlrir_ndx].ttl_pps+ (rdisk->qual[dlrir_ndx].
       total_space_mb/ rdisk->qual[dlrir_ndx].pp_size_mb))
       SET rvg->qual[dlrir_ndx].free_pps = (rvg->qual[dlrir_ndx].free_pps+ (rdisk->qual[dlrir_cnt].
       free_space_mb/ rdisk->qual[dlrir_cnt].pp_size_mb))
       SET rvg->qual[dlrir_ndx].free_mb = (rvg->qual[dlrir_ndx].free_mb+ rdisk->qual[dlrir_cnt].
       free_space_mb)
      ELSE
       SET rvg->vg_cnt = (rvg->vg_cnt+ 1)
       SET stat = alterlist(rvg->qual,rvg->vg_cnt)
       IF (dlrir_os="HPX")
        SET rvg->qual[rvg->vg_cnt].vg_name = substring(6,(textlen(rdisk->qual[dlrir_cnt].vg_name) - 5
         ),rdisk->qual[dlrir_cnt].vg_name)
       ELSE
        SET rvg->qual[rvg->vg_cnt].vg_name = rdisk->qual[dlrir_cnt].vg_name
       ENDIF
       SET rvg->qual[rvg->vg_cnt].psize = rdisk->qual[dlrir_cnt].pp_size_mb
       SET rvg->qual[rvg->vg_cnt].ttl_pps = (rdisk->qual[dlrir_cnt].total_space_mb/ rdisk->qual[
       dlrir_cnt].pp_size_mb)
       SET rvg->qual[rvg->vg_cnt].free_pps = (rdisk->qual[dlrir_cnt].free_space_mb/ rdisk->qual[
       dlrir_cnt].pp_size_mb)
       SET rvg->qual[rvg->vg_cnt].free_mb = rdisk->qual[dlrir_cnt].free_space_mb
      ENDIF
     ENDIF
   ENDFOR
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(rdisk)
    CALL echorecord(rvg)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dor_get_diskgroup_info(null)
   SET stat = alterlist(rdisk->qual,0)
   SET rdisk->disk_cnt = 0
   SET dm_err->eproc = "Loading ASM diskgroups."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM v$asm_diskgroup v
    WHERE v.state IN ("CONNECTED", "MOUNTED")
    DETAIL
     rdisk->disk_cnt = (rdisk->disk_cnt+ 1), stat = alterlist(rdisk->qual,rdisk->disk_cnt), rdisk->
     qual[rdisk->disk_cnt].disk_name = v.name,
     rdisk->qual[rdisk->disk_cnt].total_space_mb = v.total_mb, rdisk->qual[rdisk->disk_cnt].
     free_space_mb = v.free_mb, rdisk->qual[rdisk->disk_cnt].new_free_space_mb = v.free_mb,
     rdisk->qual[rdisk->disk_cnt].alloc_unit_b = v.allocation_unit_size, rdisk->qual[rdisk->disk_cnt]
     .block_size_b = v.block_size
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echorecord(rdisk)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE convert_blocks_to_bytes(cbb_block_in)
   DECLARE cbb_bytes_per_block = f8 WITH public, noconstant(0.0)
   DECLARE cbb_return = f8 WITH public, noconstant(0.0)
   SET cbb_bytes_per_block = 512.0
   SET cbb_return = (cbb_block_in * cbb_bytes_per_block)
   RETURN(cbb_return)
 END ;Subroutine
 SUBROUTINE convert_bytes(byte_value,from_flag,to_flag)
   DECLARE mbyte_factor = f8 WITH constant(1048576.0)
   DECLARE kbyte_factor = f8 WITH constant(1024.0)
   DECLARE temp_byte_value = f8 WITH noconstant(0.0)
   CASE (from_flag)
    OF "m":
     SET byte_value = (byte_value * kbyte_factor)
    OF "k":
     SET byte_value = byte_value
    OF "b":
     SET byte_value = (byte_value/ kbyte_factor)
   ENDCASE
   CASE (to_flag)
    OF "b":
     SET temp_byte_value = byte_value
     SET temp_byte_value = (temp_byte_value * kbyte_factor)
    OF "m":
     SET temp_byte_value = byte_value
     SET temp_byte_value = (byte_value/ kbyte_factor)
    OF "k":
     SET temp_byte_value = byte_value
   ENDCASE
   SET temp_byte_value = dm2ceil(temp_byte_value)
   RETURN(temp_byte_value)
 END ;Subroutine
 SUBROUTINE dm2_assign_disk(agd_size_in,agd_last_disk_ndx)
   DECLARE agd_disk_ndx_ret = i4 WITH noconstant(0)
   DECLARE agd_disk_ndx = i4 WITH noconstant(0)
   DECLARE agd_disk_cnt = i4 WITH noconstant(0)
   DECLARE agd_size_check = f8 WITH noconstant(0.0)
   DECLARE agd_start_pt = i4 WITH noconstant(0)
   DECLARE agd_end_pt = i4 WITH noconstant(0)
   DECLARE agd_start_over = i4 WITH noconstant(0)
   IF ((dm_err->debug_flag > 1))
    SET dm_err->eproc = build("Assign file to disk: size_in=",agd_size_in,"; last_disk_ndx=",
     agd_last_disk_ndx)
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   IF (agd_last_disk_ndx=size(autopop_screen->disk,5))
    SET agd_start_pt = 1
   ELSE
    SET agd_start_pt = (agd_last_disk_ndx+ 1)
   ENDIF
   SET agd_end_pt = size(autopop_screen->disk,5)
   SET agd_disk_cnt = agd_start_pt
   WHILE (agd_start_over < 2
    AND agd_disk_ndx_ret=0)
     IF ((dm_err->debug_flag > 3))
      CALL echo("*************************BEGINWHILE********************")
      CALL echo(agd_disk_cnt)
      CALL echo(agd_end_pt)
      CALL echo(agd_start_over)
      CALL echo(agd_size_check)
      CALL echo(autopop_screen->disk[agd_disk_cnt].free_disk_space_mb)
      CALL echo(autopop_screen->disk[agd_disk_cnt].disk_name)
      CALL echo(agd_disk_ndx_ret)
      CALL echo("*************************BEGINWHILEx********************")
     ENDIF
     SET agd_size_check = 0.0
     IF ((dir_storage_misc->tgt_storage_type IN ("ASM", "AXP")))
      SET agd_size_check = agd_size_in
     ELSE
      SET agd_size_check = get_space_rounded(cnvtreal(agd_size_in),autopop_screen->disk[agd_disk_cnt]
       .pp_size_mb)
     ENDIF
     IF ((dm_err->debug_flag > 3))
      CALL echo("Autopop Values")
      CALL echo(autopop_screen->disk[agd_disk_cnt].free_disk_space_mb)
      CALL echo(agd_size_check)
     ENDIF
     IF ((autopop_screen->disk[agd_disk_cnt].free_disk_space_mb > agd_size_check))
      SET agd_disk_ndx_ret = agd_disk_cnt
      IF ((dm_err->debug_flag > 3))
       CALL echo(agd_disk_ndx_ret)
      ENDIF
     ENDIF
     IF (agd_disk_cnt=agd_end_pt
      AND agd_disk_ndx_ret=0)
      IF (agd_start_over=0)
       IF (agd_start_pt != 1)
        SET agd_disk_cnt = 1
        SET agd_end_pt = agd_last_disk_ndx
        SET agd_start_over = (agd_start_over+ 1)
       ELSE
        SET agd_start_over = 2
       ENDIF
      ELSE
       SET agd_start_over = 2
      ENDIF
     ELSE
      IF (((agd_disk_cnt+ 1) > size(autopop_screen->disk,5)))
       SET agd_disk_cnt = size(autopop_screen->disk,5)
      ELSE
       SET agd_disk_cnt = (agd_disk_cnt+ 1)
      ENDIF
     ENDIF
     IF ((dm_err->debug_flag > 3))
      CALL echo("*************************ENDWHILE********************")
      CALL echo(agd_disk_cnt)
      CALL echo(agd_end_pt)
      CALL echo(agd_start_over)
      CALL echo(agd_size_check)
      CALL echo(autopop_screen->disk[agd_disk_cnt].free_disk_space_mb)
      CALL echo(autopop_screen->disk[agd_disk_cnt].disk_name)
      CALL echo(agd_disk_ndx_ret)
      CALL echo("*************************ENDWHILEx********************")
     ENDIF
   ENDWHILE
   RETURN(agd_disk_ndx_ret)
 END ;Subroutine
 SUBROUTINE dm2_sub_space_from_disk(dss_disk_ndx,dss_file_size)
   SET dm_err->eproc =
   "Substract dfile size from selected disk and reset autopop_screen disk free space."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF ((dir_storage_misc->tgt_storage_type="RAW"))
    SET dss_file_size = get_space_rounded(cnvtreal(dss_file_size),autopop_screen->disk[dss_disk_ndx].
     pp_size_mb)
   ENDIF
   SET autopop_screen->disk[dss_disk_ndx].free_disk_space_mb = (autopop_screen->disk[dss_disk_ndx].
   free_disk_space_mb - dss_file_size)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE get_space_rounded(space_add_in,pp_size_in)
   DECLARE space_add_out = f8 WITH public, noconstant(0.0)
   IF ((dm_err->debug_flag > 1))
    SET dm_err->eproc = build("In get_space_rounded subroutine")
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SET space_add_out = 0.0
   IF (mod(cnvtint(space_add_in),cnvtint(pp_size_in)) > 0)
    SET space_add_out = (space_add_in+ (cnvtint(pp_size_in) - mod(cnvtint(space_add_in),cnvtint(
      pp_size_in))))
   ELSE
    SET space_add_out = space_add_in
   ENDIF
   RETURN(space_add_out)
 END ;Subroutine
 SUBROUTINE dm2_parse_aix_vg_disk_file(sbr_dsk_fname)
   DECLARE disk_str = vc WITH public
   FREE RECORD dm2parse
   RECORD dm2parse(
     1 attr1 = vc
     1 attr1sep = vc
     1 attr2 = vc
     1 attr2sep = vc
     1 attr3 = vc
     1 attr3sep = vc
     1 attr4 = vc
     1 attr4sep = vc
     1 attr5 = vc
     1 attr5sep = vc
     1 qual[*]
       2 attr1val = vc
       2 attr2val = vc
       2 attr3val = vc
       2 attr4val = vc
       2 attr5val = vc
   ) WITH public
   SET dm2parse->attr1 = "PHYSICAL VOLUME:"
   SET dm2parse->attr1sep = " "
   SET dm2parse->attr2 = "VOLUME GROUP:"
   SET dm2parse->attr2sep = " "
   SET dm2parse->attr3 = "PP SIZE:"
   SET dm2parse->attr3sep = " "
   SET dm2parse->attr4 = "TOTAL PPs:"
   SET dm2parse->attr4sep = " "
   SET dm2parse->attr5 = "FREE PPs:"
   SET dm2parse->attr5sep = " "
   SET dm_err->eproc = build("Parsing list of aix disks in volume groups")
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (dm2parse_output(5,sbr_dsk_fname,"H"))
    IF ((dm_err->debug_flag > 1))
     CALL echorecord(dm2parse)
    ENDIF
    SET stat = alterlist(rdisk->qual,size(dm2parse->qual,5))
    FOR (ts_cnt_var = 1 TO size(dm2parse->qual,5))
      SET end_pos = findstring(" ",dm2parse->qual[ts_cnt_var].attr1val)
      IF (end_pos > 1)
       SET rdisk->qual[ts_cnt_var].disk_name = substring(1,(end_pos - 1),dm2parse->qual[ts_cnt_var].
        attr1val)
       SET end_pos = 0
      ENDIF
      IF (trim(dm2parse->qual[ts_cnt_var].attr2val,3) > " ")
       SET rdisk->qual[ts_cnt_var].vg_name = trim(dm2parse->qual[ts_cnt_var].attr2val,3)
       IF (cnvtupper(rdisk->qual[ts_cnt_var].vg_name)="ROOTVG")
        SET rdisk->qual[ts_cnt_var].root_ind = 1
       ELSE
        SET rdisk->qual[ts_cnt_var].root_ind = 0
       ENDIF
      ENDIF
      SET end_pos = findstring(" ",dm2parse->qual[ts_cnt_var].attr3val)
      IF (end_pos > 1)
       SET rdisk->qual[ts_cnt_var].pp_size_mb = cnvtreal(substring(1,(end_pos - 1),dm2parse->qual[
         ts_cnt_var].attr3val))
       SET end_pos = 0
      ENDIF
      SET start_pos = findstring("(",dm2parse->qual[ts_cnt_var].attr4val)
      SET end_pos = findstring("m",dm2parse->qual[ts_cnt_var].attr4val)
      IF (start_pos > 0
       AND end_pos > 0)
       SET rdisk->qual[ts_cnt_var].total_space_mb = cnvtreal(substring((start_pos+ 1),((end_pos -
         start_pos) - 2),dm2parse->qual[ts_cnt_var].attr4val))
       SET start_pos = 0
       SET end_pos = 0
      ENDIF
      SET start_pos = findstring("(",dm2parse->qual[ts_cnt_var].attr5val)
      SET end_pos = findstring("m",dm2parse->qual[ts_cnt_var].attr5val)
      IF (start_pos > 0
       AND end_pos > 0)
       SET rdisk->qual[ts_cnt_var].free_space_mb = cnvtreal(substring((start_pos+ 1),((end_pos -
         start_pos) - 2),dm2parse->qual[ts_cnt_var].attr5val))
       SET rdisk->qual[ts_cnt_var].new_free_space_mb = rdisk->qual[ts_cnt_var].free_space_mb
       SET start_pos = 0
       SET end_pos = 0
      ENDIF
    ENDFOR
   ELSE
    RETURN(0)
   ENDIF
   IF (size(rdisk->qual,5) > 0)
    SET rdisk->disk_cnt = size(rdisk->qual,5)
    SET rdisk_filled = "Y"
    SET dm_err->eproc = build("Disk file parsed successfully")
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ELSE
    CALL clear(23,1,130)
    SET dm_err->eproc = build("Parsing disk file.  RDISK not filled.")
    SET dm_err->err_ind = 1
    CALL disp_msg(" ",dm_err->logfile,1)
    CALL text(23,2,"Unable to load system disk information - exiting application.")
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_parse_hpux_disk_file(sbr_dsk_fname)
   DECLARE disk_str = vc WITH public
   FREE RECORD dm2parse
   RECORD dm2parse(
     1 attr1 = vc
     1 attr1sep = vc
     1 attr2 = vc
     1 attr2sep = vc
     1 attr3 = vc
     1 attr3sep = vc
     1 attr4 = vc
     1 attr4sep = vc
     1 qual[*]
       2 attr1val = vc
       2 attr2val = vc
       2 attr3val = vc
       2 attr4val = vc
   )
   SET dm2parse->attr1 = "VG Name"
   SET dm2parse->attr1sep = " "
   SET dm2parse->attr2 = "PE Size (Mbytes)"
   SET dm2parse->attr2sep = " "
   SET dm2parse->attr3 = "Total PE"
   SET dm2parse->attr3sep = " "
   SET dm2parse->attr4 = "Free PE"
   SET dm2parse->attr4sep = " "
   IF (dm2parse_output(4,sbr_dsk_fname,"V"))
    SET stat = alterlist(rdisk->qual,size(dm2parse->qual,5))
    FOR (ts_cnt_var = 1 TO size(dm2parse->qual,5))
      SET rdisk->qual[ts_cnt_var].disk_name = dm2parse->qual[ts_cnt_var].attr1val
      SET rdisk->qual[ts_cnt_var].vg_name = rdisk->qual[ts_cnt_var].disk_name
      IF (cnvtupper(rdisk->qual[ts_cnt_var].disk_name)="/DEV/VG00")
       SET rdisk->qual[ts_cnt_var].root_ind = 1
      ELSE
       SET rdisk->qual[ts_cnt_var].root_ind = 0
      ENDIF
      SET rdisk->qual[ts_cnt_var].pp_size_mb = cnvtreal(dm2parse->qual[ts_cnt_var].attr2val)
      SET rdisk->qual[ts_cnt_var].total_space_mb = cnvtreal(dm2parse->qual[ts_cnt_var].attr3val)
      SET rdisk->qual[ts_cnt_var].free_space_mb = cnvtreal(dm2parse->qual[ts_cnt_var].attr4val)
      SET rdisk->qual[ts_cnt_var].new_free_space_mb = rdisk->qual[ts_cnt_var].free_space_mb
      SET rdisk->qual[ts_cnt_var].total_space_mb = (rdisk->qual[ts_cnt_var].pp_size_mb * rdisk->qual[
      ts_cnt_var].total_space_mb)
      SET rdisk->qual[ts_cnt_var].free_space_mb = (rdisk->qual[ts_cnt_var].pp_size_mb * rdisk->qual[
      ts_cnt_var].free_space_mb)
      SET rdisk->qual[ts_cnt_var].new_free_space_mb = (rdisk->qual[ts_cnt_var].pp_size_mb * rdisk->
      qual[ts_cnt_var].new_free_space_mb)
    ENDFOR
   ELSE
    RETURN(0)
   ENDIF
   IF (size(rdisk->qual,5) > 0)
    SET rdisk->disk_cnt = size(rdisk->qual,5)
    SET rdisk_filled = "Y"
    SET dm_err->eproc = build("Disk file parsed successfully")
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ELSE
    CALL clear(23,1,130)
    SET dm_err->eproc = build("Parsing disk file.  RDISK not filled.")
    SET dm_err->err_ind = 1
    CALL disp_msg(" ",dm_err->logfile,1)
    CALL text(23,2,"Unable to load system disk information - exiting application.")
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_create_dir(sbr_new_dir,sbr_new_dir_type)
   DECLARE dcd_cmd_txt = vc WITH protect, noconstant(" ")
   DECLARE dcd_stat = i2 WITH protect, noconstant(0)
   DECLARE dcd_strip_txt1 = vc WITH protect, noconstant("")
   DECLARE dcd_strip_txt2 = vc WITH protect, noconstant("")
   DECLARE dcd_num_hold = i2 WITH protect, noconstant(0)
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcd_cmd_txt = concat("create/dir ",sbr_new_dir)
   ELSE
    SET dcd_cmd_txt = concat("mkdir ",sbr_new_dir)
   ENDIF
   CALL dm2_push_dcl(dcd_cmd_txt)
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   IF (sbr_new_dir_type="DB")
    IF ((dm2_sys_misc->cur_os="AXP"))
     SET dcd_num_hold = findstring(".",sbr_new_dir,1,1)
     SET dcd_strip_txt1 = substring(1,(dcd_num_hold - 1),sbr_new_dir)
     SET dcd_strip_txt2 = substring((dcd_num_hold+ 1),((findstring("]",sbr_new_dir,1,1) -
      dcd_num_hold) - 1),sbr_new_dir)
     SET dcd_cmd_txt = concat("set file/prot=(s:rwed,o:rwed,g:rwed,w:rwe) ",dcd_strip_txt1,"]",
      dcd_strip_txt2,".dir")
     CALL dm2_push_dcl(dcd_cmd_txt)
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_delete_dir(ddd_dir)
   DECLARE ddd_cmd_txt = vc WITH protect, noconstant(" ")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET ddd_cmd_txt = concat("del ",trim(ddd_dir),";")
   ENDIF
   IF (dm2_push_dcl(ddd_cmd_txt)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_novg_disk_info_aix(null)
   IF ((dm_err->debug_flag > 0))
    SET message = nowindow
   ENDIF
   SET dm_err->eproc = "Get list of disks not in volume group and store them in rDisk."
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dgn_cmd = vc WITH protect, noconstant(" ")
   DECLARE dgn_drive = vc WITH protect, noconstant(" ")
   SET dgn_cmd = "lspv | grep vpath"
   IF (dm2_push_dcl(dgn_cmd)=0)
    IF ((dm_err->err_ind=1))
     IF ((dm_err->emsg > " "))
      RETURN(0)
     ELSE
      SET dm_err->eproc = "Message reported when getting vpath is okay - process continuing"
      CALL disp_msg(" ",dm_err->logfile,0)
      SET dm_err->err_ind = 0
     ENDIF
    ENDIF
   ELSE
    SET dgn_drive = "vpath"
   ENDIF
   IF (dgn_drive != "vpath")
    SET dgn_cmd = "lspv | grep hdisk"
    IF (dm2_push_dcl(dgn_cmd)=0)
     IF ((dm_err->err_ind=1))
      IF ((dm_err->emsg > " "))
       RETURN(0)
      ELSE
       SET dm_err->eproc = "Message reported when getting hdisk is okay - process continuing"
       CALL disp_msg(" ",dm_err->logfile,0)
       SET dm_err->err_ind = 0
      ENDIF
     ENDIF
    ELSE
     SET dgn_drive = "hdisk"
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("dgn_drive =",dgn_drive))
   ENDIF
   IF (dgn_drive=" ")
    SET message = nowidnow
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Get list of disks not in volume group and store them in rDisk."
    SET dm_err->emsg =
    "Cerner currently recognizes only VPATH and HDISK disk names.  Unable to find a recognized storage disk name."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dgn_drive="hdisk")
    SET dgn_cmd = "lspv | grep hdisk | grep None"
   ELSE
    SET dgn_cmd = "lspv | grep vpath | grep None"
   ENDIF
   IF (dm2_push_dcl(dgn_cmd)=0)
    IF ((dm_err->err_ind=1))
     IF ((dm_err->emsg > " "))
      RETURN(0)
     ELSE
      SET dm_err->eproc = "Message reported when getting list of disks is okay - process continuing"
      CALL disp_msg("",dm_err->logfile,0)
      SET dm_err->err_ind = 0
      RETURN(1)
     ENDIF
    ENDIF
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     end_pos = 0
    DETAIL
     end_pos = 0, end_pos = findstring(" ",r.line)
     IF (end_pos > 0)
      rdisk->disk_cnt = (rdisk->disk_cnt+ 1), stat = alterlist(rdisk->qual,rdisk->disk_cnt), rdisk->
      qual[rdisk->disk_cnt].disk_name = substring(1,(end_pos - 1),r.line)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Get list of disks not in volume group.")) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    SET message = window
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_vgs(null)
   SET dm_err->eproc = "Get list of volume groups."
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dgv_cmd = vc WITH protect, noconstant(" ")
   SET rvg->vg_cnt = 0
   SET stat = alterlist(rvg->qual,0)
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET dgv_cmd = "lsvg -o"
   ELSE
    SET dgv_cmd = 'vgdisplay|grep "VG Name"|cut -d/ -f3'
   ENDIF
   IF (dm2_push_dcl(dgv_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl logical("file_loc")
   SELECT INTO "nl:"
    r.line
    FROM rtlt r
    DETAIL
     IF (trim(r.line) != "rootvg")
      rvg->vg_cnt = (rvg->vg_cnt+ 1), stat = alterlist(rvg->qual,rvg->vg_cnt), rvg->qual[rvg->vg_cnt]
      .vg_name = trim(r.line)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error("Get list of volume groups.") != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   FOR (dgv_i = 1 TO rvg->vg_cnt)
     IF ((dm2_sys_misc->cur_os="AIX"))
      SET dgv_cmd = concat("lsvg ",trim(rvg->qual[dgv_i].vg_name))
     ELSE
      SET dgv_cmd = concat("vgdisplay ",trim(rvg->qual[dgv_i].vg_name))
     ENDIF
     IF (dm2_push_dcl(dgv_cmd)=0)
      RETURN(0)
     ENDIF
     IF (dm2_parse_aix_vg(dm_err->errfile,dgv_i)=0)
      RETURN(0)
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_parse_aix_vg(dpa_fname,dpa_rvg_idx)
   SET dm_err->eproc = build("Parsing volume group's infomation")
   CALL disp_msg(" ",dm_err->logfile,0)
   FREE RECORD dm2parse
   RECORD dm2parse(
     1 attr1 = vc
     1 attr1sep = vc
     1 attr2 = vc
     1 attr2sep = vc
     1 attr3 = vc
     1 attr3sep = vc
     1 qual[*]
       2 attr1val = vc
       2 attr2val = vc
       2 attr3val = vc
   ) WITH public
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET dm2parse->attr1 = "PP SIZE:"
    SET dm2parse->attr1sep = " "
    SET dm2parse->attr2 = "TOTAL PPs:"
    SET dm2parse->attr2sep = " "
    SET dm2parse->attr3 = "FREE PPs:"
    SET dm2parse->attr3sep = " "
   ELSE
    SET dm2parse->attr1 = "PE Size (Mbytes)"
    SET dm2parse->attr1sep = " "
    SET dm2parse->attr2 = "Total PE"
    SET dm2parse->attr2sep = " "
    SET dm2parse->attr3 = "Free PE"
    SET dm2parse->attr3sep = " "
   ENDIF
   IF (dm2parse_output(3,dpa_fname,"H"))
    IF (size(dm2parse->qual,5)=1)
     SET dpa_i = 1
     IF ((dm2_sys_misc->cur_os="AIX"))
      SET end_pos = findstring(" ",dm2parse->qual[dpa_i].attr1val)
      IF (end_pos > 1)
       SET rvg->qual[dpa_rvg_idx].psize = cnvtreal(substring(1,(end_pos - 1),dm2parse->qual[dpa_i].
         attr1val))
       SET end_pos = 0
      ENDIF
      SET end_pos = findstring(" ",dm2parse->qual[dpa_i].attr2val)
      IF (end_pos > 1)
       SET rvg->qual[dpa_rvg_idx].ttl_pps = cnvtreal(substring(1,(end_pos - 1),dm2parse->qual[dpa_i].
         attr2val))
       SET end_pos = 0
      ENDIF
      SET end_pos = findstring(" ",dm2parse->qual[dpa_i].attr3val)
      IF (end_pos > 1)
       SET rvg->qual[dpa_rvg_idx].free_pps = cnvtreal(substring(1,(end_pos - 1),dm2parse->qual[dpa_i]
         .attr3val))
       SET end_pos = 0
      ENDIF
      SET start_pos = findstring("(",dm2parse->qual[dpa_i].attr3val)
      SET end_pos = findstring("m",dm2parse->qual[dpa_i].attr3val)
      IF (start_pos > 0
       AND end_pos > 0)
       SET rvg->qual[dpa_rvg_idx].free_mb = cnvtreal(substring((start_pos+ 1),((end_pos - start_pos)
          - 2),dm2parse->qual[dpa_i].attr3val))
       SET start_pos = 0
       SET end_pos = 0
      ENDIF
     ELSE
      SET rvg->qual[dpa_rvg_idx].psize = cnvtreal(dm2parse->qual[dpa_i].attr1val)
      SET rvg->qual[dpa_rvg_idx].ttl_pps = cnvtreal(dm2parse->qual[dpa_i].attr2val)
      SET rvg->qual[dpa_rvg_idx].free_pps = cnvtreal(dm2parse->qual[dpa_i].attr3val)
      SET rvg->qual[dpa_rvg_idx].free_mb = (rvg->qual[dpa_rvg_idx].free_pps * rvg->qual[dpa_rvg_idx].
      psize)
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat(
      "Parse VG information failed.  Multiple lines of information found for VG ",rvg->qual[
      dpa_rvg_idx].vg_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_nomnt_disk_info_axp(null)
   SET dm_err->eproc = "Get list of not mounted disks"
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dgn_dcl_str = vc WITH protect, noconstant(" ")
   DECLARE dgn_rtl_file = vc WITH protect, noconstant("")
   DECLARE dgn_spot = i4 WITH protect, noconstant(0)
   FREE RECORD dgn_disks
   RECORD dgn_disks(
     1 disk_cnt = i4
     1 disk[*]
       2 disk_name = vc
       2 remote_ind = i2
   )
   SET dgn_dcl_str = "@cer_install:dm2_get_nomnt_disk_info.com"
   IF ( NOT (dm2_push_dcl(dgn_dcl_str)))
    RETURN(0)
   ENDIF
   SET dgn_rtl_file = "ccluserdir:dm2_disk_list.tmp"
   SET logical axp_disk_info dgn_rtl_file
   FREE DEFINE rtl
   DEFINE rtl "axp_disk_info"
   SELECT INTO "nl:"
    t.line
    FROM rtlt t
    WHERE t.line > " "
    DETAIL
     dgn_disks->disk_cnt = (dgn_disks->disk_cnt+ 1), stat = alterlist(dgn_disks->disk,dgn_disks->
      disk_cnt), dgn_spot = 0,
     dgn_spot = findstring(" ",t.line,1)
     IF (dgn_spot > 0)
      dgn_disks->disk[dgn_disks->disk_cnt].disk_name = substring(1,(dgn_spot - 1),t.line)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   FOR (dgn_i = 1 TO dgn_disks->disk_cnt)
     SET dgn_dcl_str = concat("sho device ",dgn_disks->disk[dgn_i].disk_name," /out=disk_info.tmp")
     IF ( NOT (dm2_push_dcl(dgn_dcl_str)))
      RETURN(0)
     ENDIF
     SET dgn_rtl_file = "ccluserdir:disk_info.tmp"
     SET logical axp_disk_info dgn_rtl_file
     FREE DEFINE rtl
     DEFINE rtl "axp_disk_info"
     SELECT INTO "nl:"
      t.line
      FROM rtlt t
      WHERE t.line > " "
      DETAIL
       dgn_spot = 0, dgn_spot = findstring("REMOTE MOUNT",cnvtupper(t.line),1)
       IF (dgn_spot > 0)
        dgn_disks->disk[dgn_i].remote_ind = 1
       ENDIF
      WITH nocounter
     ;end select
     IF (check_error("filter out disks that are remote mount") != 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
   ENDFOR
   SET rdisk->disk_cnt = size(rdisk->qual,5)
   SELECT INTO "nl:"
    dgn_disks->disk[d.seq].disk_name
    FROM (dummyt d  WITH seq = value(dgn_disks->disk_cnt))
    WHERE (dgn_disks->disk[d.seq].remote_ind=0)
    DETAIL
     rdisk->disk_cnt = (rdisk->disk_cnt+ 1), stat = alterlist(rdisk->qual,rdisk->disk_cnt), rdisk->
     qual[rdisk->disk_cnt].disk_name = dgn_disks->disk[d.seq].disk_name
    WITH nocounter
   ;end select
   IF (check_error("Populate rDisk with not mounted disks") != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 1))
    CALL echorecord(dgn_disks)
    CALL echorecord(rdisk)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_make_vg(dmv_vg_name,dmv_psize,dmv_disk_name)
   IF ((dm_err->debug_flag > 0))
    SET message = nowindow
   ENDIF
   SET dm_err->eproc = concat("Create new volume group ",dmv_vg_name," with disks ",dmv_disk_name)
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dmv_cmd = vc WITH protect, noconstant(" ")
   IF (substring(1,1,dmv_disk_name)="v")
    SET dmv_cmd = "mkvg4vp"
   ELSEIF (substring(1,1,dmv_disk_name)="h")
    SET dmv_cmd = "mkvg"
   ENDIF
   SET dmv_cmd = concat(dmv_cmd," -B -f -y ",dmv_vg_name," -s ",cnvtstring(dmv_psize),
    " ",dmv_disk_name)
   IF (dm2_push_dcl(dmv_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    SET message = window
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_extend_vg(dev_vg_name,dev_disk_name)
   IF ((dm_err->debug_flag > 0))
    SET message = nowindow
   ENDIF
   SET dm_err->eproc = concat("Extend existing volume group ",dev_vg_name," with disk ",dev_disk_name
    )
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dev_cmd = vc WITH protect, noconstant(" ")
   IF (substring(1,1,dev_disk_name)="v")
    SET dev_cmd = "extendvg4vp"
   ELSEIF (substring(1,1,dev_disk_name)="h")
    SET dev_cmd = "extendvg"
   ENDIF
   SET dev_cmd = concat(dev_cmd," -f ",dev_vg_name," ",dev_disk_name)
   IF (dm2_push_dcl(dev_cmd)=0)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    SET message = window
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_reduce_vg(drv_vg_name,drv_disk_name)
   SET dm_err->eproc = concat("Reduce existing volume group ",drv_vg_name," with disk ",drv_disk_name
    )
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE drv_del_vg = i2 WITH protect, noconstant(0)
   SET width = 132
   SET message = window
   CALL clear(1,1)
   CALL text(1,1,dm_err->eproc)
   CALL text(2,1,"Would you like to (C)ontinue or (Q)uit?")
   CALL accept(2,60,"P;CU","C"
    WHERE curaccept IN ("C", "Q"))
   IF (curaccept="Q")
    SET dm_err->emsg = "User choose to quit the program."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET message = nowindow
   DECLARE drv_cmd = vc WITH protect, noconstant(" ")
   SET drv_cmd = concat("reducevg ",drv_vg_name," ",drv_disk_name)
   IF (dm2_push_dcl(drv_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    DETAIL
     IF ( NOT (drv_del_vg))
      drv_del_vg = findstring("ldeletepv",r.line)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Parsing error file ",dm_err->errfile))=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drv_del_vg)
    IF ((dm_err->debug_flag > 0))
     SET message = nowindow
     CALL echo(concat("vg ",drv_vg_name," was deleted."))
     SET message = window
    ENDIF
    SET dpf_existing_vg_ind = 0
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_init_mount_disk(dim_disk_name,dim_vol_lbl)
   SET dm_err->eproc = concat("Mount disk ",trim(dim_disk_name)," on vol_lable ",dim_vol_lbl)
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dimd_cmd = vc WITH protect, noconstant(" ")
   DECLARE dimd_fnd = i2 WITH protect, noconstant(0)
   IF ((dm2_create_dom->dbtype != "ADMIN"))
    WHILE (dim_vol_lbl="dm2_not_set")
      SET width = 132
      SET message = window
      CALL clear(1,1)
      CALL text(2,1,concat("Please enter volume label to mount disk ",dim_disk_name,":"))
      CALL accept(2,60,"P(20);cu")
      SET dim_vol_lbl = curaccept
      SET dimd_fnd = 0
      SET dimd_fnd = locateval(dimd_fnd,1,size(rdisk->qual,5),dim_vol_lbl,rdisk->qual[dimd_fnd].
       volume_label)
      IF (dimd_fnd)
       CALL text(4,1,concat("The volume lable name ",dim_vol_lbl,
         " is used.  Please enter a different name."))
       CALL text(6,1,"Would you like to (C)ontinue or (Q)uit?")
       CALL accept(6,60,"P;CU","C"
        WHERE curaccept IN ("C", "Q"))
       IF (curaccept="Q")
        SET dm_err->emsg = "User choose to quit the program."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN("ERROR")
       ENDIF
       SET dim_vol_lbl = "dm2_not_set"
      ENDIF
      SET message = nowindow
    ENDWHILE
   ELSE
    SET dimd_fnd = 1
    WHILE (dimd_fnd)
      SET dimd_fnd = 0
      SET dimd_fnd = locateval(dimd_fnd,1,size(rdisk->qual,5),dim_vol_lbl,rdisk->qual[dimd_fnd].
       volume_label)
      IF (dimd_fnd)
       SET dim_vol_lbl = build("ADMIN",dpf_admin_lbl_cnt)
       SET dpf_admin_lbl_cnt = (dpf_admin_lbl_cnt+ 1)
      ENDIF
    ENDWHILE
   ENDIF
   SET width = 132
   SET message = window
   CALL clear(1,1)
   CALL text(1,1,concat("Initialize and Mount disk ",trim(dim_disk_name)," on vol_lable ",dim_vol_lbl
     ))
   CALL text(2,1,"Would you like to (C)ontinue or (Q)uit?")
   CALL accept(2,60,"P;CU","C"
    WHERE curaccept IN ("C", "Q"))
   IF (curaccept="Q")
    SET message = nowindow
    SET dm_err->emsg = "User choose to quit the program."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN("ERROR")
   ENDIF
   SET message = nowindow
   SET dimd_cmd = concat("$init/head=65536/clus=16/own=[500,0]/nohigh ",trim(dim_disk_name)," ",
    dim_vol_lbl)
   IF (dm2_push_dcl(dimd_cmd)=0)
    RETURN("ERROR")
   ENDIF
   IF (dm2_check_cluster_lic(null))
    SET dimd_cmd = concat("$mount/clus/win=28/noassist ",trim(dim_disk_name)," ",dim_vol_lbl," ",
     dim_vol_lbl)
   ELSE
    IF ((dm_err->err_ind=0))
     SET dimd_cmd = concat("$mount/sys/win=28/noassist ",trim(dim_disk_name)," ",dim_vol_lbl," ",
      dim_vol_lbl)
    ELSE
     RETURN("ERROR")
    ENDIF
   ENDIF
   IF (dm2_push_dcl(dimd_cmd)=0)
    RETURN("ERROR")
   ENDIF
   RETURN(dim_vol_lbl)
 END ;Subroutine
 SUBROUTINE dm2_check_cluster_lic(null)
   SET dm_err->eproc = "Checking if vmscluster license is loaded on the system."
   CALL disp_msg(" ",dm_err->logfile,0)
   DECLARE dcc_cmd = vc WITH protect, noconstant(" ")
   DECLARE dcc_str = vc WITH protect, noconstant(" ")
   DECLARE dcc_find = i2 WITH protect, noconstant(0)
   SET dcc_cmd = "$show license vmscluster"
   SET dcc_str = "%SHOW-I-NOLICMATCH, no licenses match search criteria"
   IF (dm2_push_dcl(dcc_cmd)=0)
    RETURN(0)
   ENDIF
   FREE DEFINE rtl2
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl2 "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtl2t r
    HEAD REPORT
     dcc_find = 0
    DETAIL
     IF (dcc_find=0)
      dcc_find = findstring(dcc_str,r.line)
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error("Checking if vmscluster license is loaded on the system.") != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dcc_find > 0)
    RETURN(1)
   ELSE
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_dismount_disk(ddd_vol_label)
   SET dm_err->eproc = concat("Dismount disk ",ddd_vol_label)
   CALL disp_msg("",dm_err->logfile,0)
   SET width = 132
   SET message = window
   CALL clear(1,1)
   CALL text(1,1,dm_err->eproc)
   CALL text(2,1,"Would you like to (C)ontinue or (Q)uit?")
   CALL accept(2,60,"P;CU","C"
    WHERE curaccept IN ("C", "Q"))
   IF (curaccept="Q")
    SET dm_err->emsg = "User choose to quit the program."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET message = nowindow
   DECLARE ddd_cmd = vc WITH protect, noconstant(" ")
   SET ddd_cmd = concat("dismount ",ddd_vol_label)
   IF (dm2_push_dcl(ddd_cmd)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_get_mwc_flag(dgm_disk_name)
   SET dm_err->eproc = concat("Get mirror-write consistency for disk ",trim(dgm_disk_name))
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   DECLARE dgm_cmd = vc WITH protect, noconstant(" ")
   DECLARE dgm_str = vc WITH protect, noconstant(" ")
   SET dgm_cmd = concat("lqueryvg -p /dev/",trim(dgm_disk_name)," -X")
   IF (dm2_push_dcl(dgm_cmd)=0)
    RETURN("e")
   ENDIF
   IF (parse_errfile(dm_err->errfile)=0)
    RETURN("e")
   ENDIF
   FREE DEFINE rtl
   FREE SET file_loc
   SET logical file_loc value(dm_err->errfile)
   DEFINE rtl "file_loc"
   SELECT INTO "nl:"
    r.line
    FROM rtlt r
    HEAD REPORT
     end_pos = 0
    DETAIL
     end_pos = findstring(" ",r.line)
     IF (end_pos > 0)
      dgm_str = substring(1,(end_pos - 1),r.line)
      IF ((dm_err->debug_flag > 0))
       CALL echo(dgm_str)
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(concat("Get mirror-write consistency for disk ",trim(dgm_disk_name))) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN("e")
   ENDIF
   IF (dgm_str="0")
    RETURN("y")
   ELSE
    RETURN("n")
   ENDIF
 END ;Subroutine
 SUBROUTINE dm2_aix_remove_lv(sbr_arl_db_name)
   DECLARE sbr_arl_outfile = vc WITH noconstant("dm2_not_set")
   DECLARE sbr_arl_rmlv_str = vc WITH noconstant("dm2_not_set")
   SET dm_err->eproc = "Removing raw logical volumes associated with the database."
   CALL disp_msg(" ",dm_err->logfile,0)
   IF (get_unique_file("dm2_rmlv_cmd",".out")=0)
    RETURN(0)
   ENDIF
   SET sbr_arl_outfile = dm_err->unique_fname
   IF ((dm2_sys_misc->cur_os="AIX"))
    SET sbr_arl_rmlv_str = concat("cd /dev; ls ",char(42),cnvtlower(sbr_arl_db_name),char(42),
     " | while read a; do if [ -b $a ]; then rmlv -f $a >> ",
     sbr_arl_outfile,"; fi; done 2>&1")
   ELSE
    SET sbr_arl_rmlv_str = concat(
     "vgdisplay|grep 'VG Name'|cut -d/ -f3 |while read a; do ls /dev/$a/",char(42),cnvtlower(
      sbr_arl_db_name),char(42)," | while read z; do if [ -b $z ]; then lvremove -f $z >> ",
     sbr_arl_outfile,"; fi; done; done 2>&1")
   ENDIF
   IF (dm2_push_dcl(sbr_arl_rmlv_str)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dm2_rename_login_default(sbr_rld_mode)
   DECLARE sbr_rld_backup = vc WITH constant("BACKUP")
   DECLARE sbr_rld_restore = vc WITH constant("RESTORE")
   DECLARE sbr_rld_bkup_name = vc WITH public, constant("login_save.ccl")
   DECLARE sbr_rld_real_name = vc WITH public, constant("login_default.ccl")
   DECLARE sbr_rld_cmd_str = vc WITH public, noconstant("dm2_not_set")
   DECLARE sbr_rld_ccludir = vc WITH public, noconstant("dm2_not_set")
   CASE (cnvtupper(sbr_rld_mode))
    OF sbr_rld_backup:
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF (findfile(concat("CCLUSERDIR:",sbr_rld_real_name))=0)
       SET dm_err->eproc = "No login_default.ccl file found in CCLUSERDIR."
       RETURN(1)
      ENDIF
      SET sbr_rld_cmd_str = concat("rename CCLUSERDIR:",sbr_rld_real_name," CCLUSERDIR:",
       sbr_rld_bkup_name)
     ELSE
      IF (findfile(concat("$CCLUSERDIR/",sbr_rld_real_name))=0)
       SET dm_err->eproc = "No login_default.ccl file found in CCLUSERDIR."
       RETURN(1)
      ENDIF
      SET sbr_rld_cmd_str = concat("mv -f $CCLUSERDIR/",sbr_rld_real_name," $CCLUSERDIR/",
       sbr_rld_bkup_name)
     ENDIF
    OF sbr_rld_restore:
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF (findfile(concat("CCLUSERDIR:",sbr_rld_bkup_name))=0)
       SET dm_err->eproc = "No login_save.ccl file found in CCLUSERDIR."
       RETURN(1)
      ENDIF
      SET sbr_rld_cmd_str = concat("rename CCLUSERDIR:",sbr_rld_bkup_name," CCLUSERDIR:",
       sbr_rld_real_name)
     ELSE
      IF (findfile(concat("$CCLUSERDIR/",sbr_rld_bkup_name))=0)
       SET dm_err->eproc = "No login_save.ccl file found in CCLUSERDIR."
       RETURN(1)
      ENDIF
      SET sbr_rld_cmd_str = concat("mv -f $CCLUSERDIR/",sbr_rld_bkup_name," $CCLUSERDIR/",
       sbr_rld_real_name)
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "DM2_RENAME_LOGIN_DEFAULT: validating mode."
     SET dm_err->emsg = concat("Invalid mode of operation: <",sbr_rld_mode,">")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
     RETURN(0)
   ENDCASE
   IF (dm2_push_dcl(sbr_rld_cmd_str)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE open_sch_files(sbr_for_modify=i4) = i4
 DECLARE create_sch_files(null) = i4
 DECLARE close_sch_files(null) = i4
 DECLARE copy_sch_files(null) = i4
 DECLARE open_sch_file(sbr_osf_modind=i4,sbr_osf_fname=vc,sbr_osf_rndx=i4) = i4
 DECLARE val_sch_file_ver(sbr_vsf_rndx=i4) = i4
 DECLARE make_sch_file_defs(sbr_msf_rndx=i4) = i4
 DECLARE del_sch_file(sbr_dsf_ffname=vc,sbr_dsf_fname=vc) = i4
 DECLARE del_sch_files(null) = i2
 DECLARE copy_sch_file(sbr_src_fname=vc,sbr_tgt_fname=vc) = i4
 DECLARE check_sch_files(null) = i4
 DECLARE prep_sch_file(rec_ndx=i4) = i4
 DECLARE gen_sch_files(null) = i4
 DECLARE dsfi_load_schema_file_defs(dsfi_schema_set=vc) = i4
 DECLARE dsfi_load_schema_files(dlsf_desc=vc,dlsf_process_option=vc) = i2
 DECLARE dsfi_pop_dmheader(sfidx=i4) = null
 DECLARE dsfi_pop_dmtable(sfidx=i4) = null
 DECLARE dsfi_pop_dmcolumn(sfidx=i4) = null
 DECLARE dsfi_pop_dmindex(sfidx=i4) = null
 DECLARE dsfi_pop_dmindcol(sfidx=i4) = null
 DECLARE dsfi_pop_dmcons(sfidx=i4) = null
 DECLARE dsfi_pop_dmconscol(sfidx=i4) = null
 DECLARE dsfi_pop_dmseq(sfidx=i4) = null
 DECLARE dsfi_pop_dmtbldoc(sfidx=i4) = null
 DECLARE dsfi_pop_dmcoldoc(sfidx=i4) = null
 DECLARE dsfi_pop_dmtdprec(sfidx=i4) = null
 DECLARE dsfi_pop_dmtspace(sfidx=i4) = null
 IF ((validate(dm2_sch_file->file_cnt,- (1))=- (1)))
  RECORD dm2_sch_file(
    1 sf_ver = i4
    1 file_cnt = i4
    1 src_dir_osfmt = vc
    1 dest_dir_cclfmt = vc
    1 dest_dir_osfmt = vc
    1 ending_punct = vc
    1 file_prefix = vc
    1 qual[*]
      2 file_suffix = vc
      2 table_name = vc
      2 db_name = vc
      2 size = vc
      2 data_size = vc
      2 key_size = vc
      2 db_key = vc
      2 key_cnt = i4
      2 kqual[*]
        3 key_col = vc
      2 data_cnt = i4
      2 dqual[*]
        3 data_col = vc
  )
  SET dm2_sch_file->sf_ver = 1
  CASE (dm2_sys_misc->cur_os)
   OF "AXP":
    SET dm2_sch_file->ending_punct = " "
   OF "WIN":
    SET dm2_sch_file->ending_punct = "\"
   ELSE
    SET dm2_sch_file->ending_punct = "/"
  ENDCASE
  IF (dsfi_load_schema_file_defs("TABLE_INFO") != 1)
   SET dm_err->err_ind = 1
  ENDIF
 ENDIF
 SUBROUTINE create_sch_files(null)
   DECLARE csf_concurrency_cnt = i4 WITH noconstant(0)
   DECLARE sch_file_status = i4
   DECLARE di_insert_ind = i2 WITH noconstant(0)
   DECLARE pause_length = i2 WITH noconstant(60)
   DECLARE csf_done_ind = i2 WITH noconstant(0)
   DECLARE csf_retry_cnt = i2 WITH noconstant(0)
   DECLARE csf_skip_ind = i2 WITH noconstant(0)
   SET dm2_sch_file->dest_dir_osfmt = build(logical(dm2_sch_file->dest_dir_cclfmt),dm2_sch_file->
    ending_punct)
   WHILE (csf_done_ind=0
    AND (dm_err->err_ind=0))
     SET csf_done_ind = 1
     SET csf_skip_ind = 0
     IF ((dm2_sch_file->qual[1].table_name != "DMTSPACE"))
      WHILE (csf_concurrency_cnt < 2
       AND (dm_err->err_ind=0))
        IF (dm2_set_autocommit(1)=1)
         SELECT INTO "nl:"
          FROM dm_info d
          WHERE d.info_domain="DM2 TOOLS"
           AND d.info_name="CREATING SCHEMA FILES"
          WITH nocounter
         ;end select
         IF (curqual > 0)
          SET csf_concurrency_cnt = (csf_concurrency_cnt+ 1)
          IF (csf_concurrency_cnt=2)
           SET dm_err->emsg =
           "Another process is currently generating schema file definitions, please try again later."
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           SET dm_err->err_ind = 1
          ELSE
           SET dm_err->eproc = concat(
            "Another process is currently generating schema file definitions.  Pausing ",trim(
             cnvtstring(pause_length))," seconds before trying again. Please wait.")
           CALL disp_msg(" ",dm_err->logfile,0)
           CALL pause(pause_length)
          ENDIF
         ELSE
          IF (check_error("Checking for concurrency row in dm_info ")=1)
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          ENDIF
          SET csf_concurrency_cnt = 2
         ENDIF
        ENDIF
      ENDWHILE
     ENDIF
     IF ((dm_err->err_ind=0))
      SET sch_file_status = check_sch_files(null)
      CASE (sch_file_status)
       OF 0:
        SET dm_err->err_ind = 1
       OF 1:
        SET dm_err->eproc = "ALL CORE SCHEMA FILE COMPONENTS EXIST"
        CALL disp_msg(" ",dm_err->logfile,0)
        FOR (csf_file_cnt = 1 TO dm2_sch_file->file_cnt)
          IF (prep_sch_file(csf_file_cnt)=0)
           SET dm_err->err_ind = 1
           SET csf_file_cnt = dm2_sch_file->file_cnt
          ENDIF
        ENDFOR
       OF 2:
        IF ((dm2_sch_file->qual[1].table_name != "DMTSPACE"))
         SET dm_err->eproc = "INSERT CONCURRENCY ROW INTO DM_INFO"
         CALL disp_msg(" ",dm_err->logfile,0)
         INSERT  FROM dm_info d
          SET d.info_domain = "DM2 TOOLS", d.info_name = "CREATING SCHEMA FILES", d.info_date = null,
           d.info_char = " ", d.info_number = 0.0, d.info_long_id = 0.0,
           d.updt_applctx = 0, d.updt_task = 0.0, d.updt_cnt = 0,
           d.updt_id = 0.0, d.updt_dt_tm = cnvtdatetime(curdate,curtime3)
          WITH nocounter
         ;end insert
         IF (check_error("Inserting dm_info row for concurrency ")=1)
          IF (findstring("ORA-00001",dm_err->emsg,1,0) > 0)
           SET csf_retry_cnt = (csf_retry_cnt+ 1)
           IF (csf_retry_cnt < 2)
            SET dm_err->err_ind = 0
            SET csf_done_ind = 0
            SET csf_skip_ind = 1
            SET dm_err->eproc = concat(
             "Another process is currently generating schema file definitions.  Pausing ",trim(
              cnvtstring(pause_length))," seconds before trying again. Please wait.")
            CALL disp_msg(" ",dm_err->logfile,0)
            CALL pause(pause_length)
           ELSE
            SET dm_err->emsg =
            "Another process is currently generating schema file definitions, please try again later."
            CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           ENDIF
          ELSE
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           ROLLBACK
          ENDIF
         ELSE
          COMMIT
          SET di_insert_ind = 1
         ENDIF
        ENDIF
        IF ((dm_err->err_ind=0)
         AND csf_skip_ind=0)
         SET dm_err->eproc = "REGENERATE CORE SCHEMA FILE COMPONENTS"
         CALL disp_msg(" ",dm_err->logfile,0)
         CALL gen_sch_files(null)
        ENDIF
      ENDCASE
     ENDIF
   ENDWHILE
   IF (di_insert_ind=1)
    SET dm_err->eproc = "REMOVE CONCURRENCY ROW FROM DM_INFO"
    CALL disp_msg(" ",dm_err->logfile,0)
    DELETE  FROM dm_info d
     WHERE d.info_domain="DM2 TOOLS"
      AND d.info_name="CREATING SCHEMA FILES"
     WITH nocounter
    ;end delete
    COMMIT
    IF ((dm_err->err_ind=0))
     IF (check_error("Deleting dm_info row for concurrency ")=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     ENDIF
    ENDIF
   ENDIF
   CALL dm2_set_autocommit(0)
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ELSE
    RETURN(1)
   ENDIF
 END ;Subroutine
 SUBROUTINE open_sch_file(sbr_osf_modind,sbr_osf_fname,sbr_osf_rndx)
   DECLARE osf_tempstr = vc WITH noconstant(" ")
   IF (dm2_push_cmd(concat("free define ",dm2_sch_file->qual[sbr_osf_rndx].db_name," go"),1)=0)
    SET dm_err->err_ind = 1
    RETURN(0)
   ENDIF
   CALL dm2_push_cmd(concat("define ",dm2_sch_file->qual[sbr_osf_rndx].db_name," is ",build("'",
      sbr_osf_fname,"'")),0)
   IF (sbr_osf_modind=1)
    CALL dm2_push_cmd(" with modify",0)
    SET osf_tempstr = " with modify"
   ENDIF
   IF (dm2_push_cmd(" go",1)=0)
    SET dm_err->err_ind = 1
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE open_sch_files(sbr_for_modify)
   DECLARE file_name_for_open = vc
   DECLARE dsfi = i4 WITH public, noconstant(0)
   FOR (dsfi = 1 TO dm2_sch_file->file_cnt)
     SET file_name_for_open = build(dm2_sch_file->dest_dir_cclfmt,":",cnvtlower(dm2_sch_file->
       file_prefix),cnvtlower(dm2_sch_file->qual[dsfi].file_suffix),".dat")
     IF (val_sch_file_ver(dsfi)=0)
      IF ((dm_err->err_ind=1))
       RETURN(0)
      ELSEIF (make_sch_file_defs(dsfi)=0)
       SET dm_err->err_ind = 1
       RETURN(0)
      ENDIF
     ENDIF
     IF ((dm_err->debug_flag=1))
      SET dm_err->eproc = concat("Opening ",file_name_for_open)
      CALL disp_msg(" ",dm_err->logfile,0)
     ENDIF
     IF (open_sch_file(sbr_for_modify,file_name_for_open,dsfi)=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE val_sch_file_ver(sbr_vsf_rndx)
   DECLARE vsfv_datacnt = i4 WITH noconstant(0)
   DECLARE vsfv_keycnt = i4 WITH noconstant(0)
   DECLARE vsfv_match_col_ind = i2 WITH noconstant(0)
   DECLARE vsfv_match_db_ind = i2 WITH noconstant(0)
   DECLARE vsfv_temp_str = vc WITH noconstant("")
   SELECT INTO "nl:"
    d.table_name
    FROM dtable d
    WHERE (d.file_name=dm2_sch_file->qual[sbr_vsf_rndx].db_name)
     AND (d.table_name=dm2_sch_file->qual[sbr_vsf_rndx].table_name)
    DETAIL
     vsfv_match_db_ind = 1
    WITH nocounter
   ;end select
   IF (check_error(concat("Checking for ",dm2_sch_file->qual[sbr_vsf_rndx].table_name,
     " in CCL dictionary"))=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SELECT INTO "nl:"
    l.attr_name
    FROM dtableattr a,
     dtableattrl l
    WHERE (a.table_name=dm2_sch_file->qual[sbr_vsf_rndx].table_name)
     AND l.structtype="F"
     AND btest(l.stat,11)=0
    HEAD REPORT
     start_pos = 0, end_pos = 0, x = 0,
     y = 0
    DETAIL
     FOR (x = 1 TO dm2_sch_file->qual[sbr_vsf_rndx].data_cnt)
      end_pos = findstring("=",dm2_sch_file->qual[sbr_vsf_rndx].dqual[x].data_col),
      IF (trim(l.attr_name,3)=substring(1,(end_pos - 1),dm2_sch_file->qual[sbr_vsf_rndx].dqual[x].
       data_col))
       end_pos = 0
       IF (trim(l.attr_name,3)="FILLER")
        start_pos = findstring("FILLER = c",dm2_sch_file->qual[sbr_vsf_rndx].dqual[x].data_col),
        start_pos = (start_pos+ 10), end_pos = findstring(" CCL(FILLER)",dm2_sch_file->qual[
         sbr_vsf_rndx].dqual[x].data_col)
        IF (l.len=cnvtint(substring(start_pos,(end_pos - start_pos),dm2_sch_file->qual[sbr_vsf_rndx].
          dqual[x].data_col)))
         vsfv_datacnt = (vsfv_datacnt+ 1), x = dm2_sch_file->qual[sbr_vsf_rndx].data_cnt
        ENDIF
       ELSE
        vsfv_datacnt = (vsfv_datacnt+ 1), x = dm2_sch_file->qual[sbr_vsf_rndx].data_cnt
       ENDIF
      ENDIF
     ENDFOR
     FOR (y = 1 TO dm2_sch_file->qual[sbr_vsf_rndx].key_cnt)
      end_pos = findstring("=",dm2_sch_file->qual[sbr_vsf_rndx].kqual[y].key_col),
      IF (trim(l.attr_name,3)=substring(1,(end_pos - 1),dm2_sch_file->qual[sbr_vsf_rndx].kqual[y].
       key_col))
       end_pos = 0, vsfv_keycnt = (vsfv_keycnt+ 1), y = dm2_sch_file->qual[sbr_vsf_rndx].key_cnt
      ENDIF
     ENDFOR
    WITH nocounter
   ;end select
   IF (check_error(concat("Checking for columns on ",dm2_sch_file->qual[sbr_vsf_rndx].table_name,
     " in CCL dictionary"))=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
    CALL echo(build("dm_err->err_ind = ",dm_err->err_ind))
   ENDIF
   IF ((vsfv_datacnt=dm2_sch_file->qual[sbr_vsf_rndx].data_cnt)
    AND (vsfv_keycnt=dm2_sch_file->qual[sbr_vsf_rndx].key_cnt))
    SET vsfv_match_col_ind = 1
   ENDIF
   IF (vsfv_match_col_ind=1
    AND vsfv_match_db_ind=1)
    RETURN(1)
   ELSE
    CALL disp_msg(concat(dm2_sch_file->qual[sbr_vsf_rndx].table_name,
      " definition not correct in CCL dictionary"),dm_err->logfile,0)
    RETURN(0)
   ENDIF
 END ;Subroutine
 SUBROUTINE make_sch_file_defs(sbr_msf_rndx)
   DECLARE current_db = vc
   DECLARE msfd_estr = vc
   DECLARE msfd_ret_val = i2 WITH noconstant(0)
   DECLARE drop_needed = i2 WITH noconstant(0)
   IF ((dm_err->debug_flag=1))
    SET dm_err->eproc = concat("Making CCL definition for ",dm2_sch_file->qual[sbr_msf_rndx].
     table_name)
    CALL disp_msg(" ",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM dtable d
    WHERE (d.table_name=dm2_sch_file->qual[sbr_msf_rndx].table_name)
    DETAIL
     drop_needed = 1, current_db = d.file_name
    WITH nocounter
   ;end select
   IF (drop_needed=1)
    IF (dm2_push_cmd(concat("drop table ",dm2_sch_file->qual[sbr_msf_rndx].table_name," go"),1)=0)
     RETURN(0)
    ENDIF
    IF (dm2_push_cmd(concat("drop ddlrecord ",dm2_sch_file->qual[sbr_msf_rndx].table_name,
      " from database ",current_db," WITH DEPS_DELETED go"),1)=0)
     RETURN(0)
    ENDIF
    IF (dm2_push_cmd(concat("drop database ",current_db," with deps_deleted go"),1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET drop_needed = 0
   SELECT INTO "nl:"
    FROM dfile d
    WHERE (d.file_name=dm2_sch_file->qual[sbr_msf_rndx].db_name)
    DETAIL
     drop_needed = 1
    WITH nocounter
   ;end select
   IF (drop_needed=1)
    IF (dm2_push_cmd(concat("drop database ",dm2_sch_file->qual[sbr_msf_rndx].db_name,
      " with deps_deleted go"),1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dm2_push_cmd(concat("create database ",dm2_sch_file->qual[sbr_msf_rndx].db_name,
     " organization(indexed) format(variable) size(",dm2_sch_file->qual[sbr_msf_rndx].size,") ",
     dm2_sch_file->qual[sbr_msf_rndx].db_key," go"),1)=0)
    RETURN(0)
   ENDIF
   CALL dm2_push_cmd(concat("create ddlrecord ",dm2_sch_file->qual[sbr_msf_rndx].table_name,
     " from database ",dm2_sch_file->qual[sbr_msf_rndx].db_name," table ",
     dm2_sch_file->qual[sbr_msf_rndx].table_name),0)
   CALL dm2_push_cmd(" 1 key1 ",0)
   FOR (i = 1 TO dm2_sch_file->qual[sbr_msf_rndx].key_cnt)
     CALL dm2_push_cmd(concat(" 2 ",dm2_sch_file->qual[sbr_msf_rndx].kqual[i].key_col),0)
   ENDFOR
   CALL dm2_push_cmd(" 1 data ",0)
   FOR (i = 1 TO dm2_sch_file->qual[sbr_msf_rndx].data_cnt)
     CALL dm2_push_cmd(concat(" 2 ",dm2_sch_file->qual[sbr_msf_rndx].dqual[i].data_col),0)
   ENDFOR
   IF (dm2_push_cmd(concat("end table ",dm2_sch_file->qual[sbr_msf_rndx].table_name," go"),1)=0)
    RETURN(0)
   ENDIF
   SET msfd_estr = concat("Making def for ",dm2_sch_file->qual[sbr_msf_rndx].table_name)
   SET msfd_ret_val = val_sch_file_ver(sbr_msf_rndx)
   IF (msfd_ret_val=0)
    IF ((dm_err->err_ind=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = msfd_estr
     CALL disp_msg(" ",dm_err->logfile,1)
    ENDIF
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE close_sch_files(null)
   FOR (close_cnt = 1 TO dm2_sch_file->file_cnt)
     IF (dm2_push_cmd(concat("free define ",dm2_sch_file->qual[close_cnt].db_name," go"),1)=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
   ENDFOR
 END ;Subroutine
 SUBROUTINE copy_sch_files(null)
  DECLARE target_name = vc
  FOR (csfi = 1 TO dm2_sch_file->file_cnt)
    SET target_name = build(dm2_sch_file->file_prefix,cnvtlower(dm2_sch_file->qual[csfi].file_suffix)
     )
    IF ( NOT ((dm2_sys_misc->cur_os IN ("AXP"))))
     IF (del_sch_file(build(dm2_sch_file->dest_dir_osfmt,target_name,".dat"))=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
     IF (del_sch_file(build(dm2_sch_file->dest_dir_osfmt,target_name,".idx"))=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
    ENDIF
    IF (copy_sch_file(build(dm2_sch_file->src_dir_osfmt,target_name,".dat"),build(dm2_sch_file->
      dest_dir_osfmt,target_name,".dat"))=0)
     SET dm_err->err_ind = 1
     RETURN(0)
    ENDIF
    IF ( NOT ((dm2_sys_misc->cur_os IN ("AXP"))))
     IF (copy_sch_file(build(dm2_sch_file->src_dir_osfmt,target_name,".idx"),build(dm2_sch_file->
       dest_dir_osfmt,target_name,".idx"))=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
    ENDIF
  ENDFOR
 END ;Subroutine
 SUBROUTINE del_sch_file(sbr_dsf_fname)
  IF ((dm2_sys_misc->cur_os="WIN"))
   IF (findfile(sbr_dsf_fname)=1)
    IF (dm2_push_dcl(concat("del ",sbr_dsf_fname))=0)
     RETURN(0)
    ENDIF
   ENDIF
  ELSEIF ((dm2_sys_misc->cur_os="AXP"))
   IF (findfile(sbr_dsf_fname)=1)
    IF (dm2_push_dcl(concat("del ",sbr_dsf_fname,";\*"))=0)
     RETURN(0)
    ENDIF
   ENDIF
  ELSE
   IF (findfile(sbr_dsf_fname)=1)
    IF (dm2_push_dcl(concat("rm ",sbr_dsf_fname))=0)
     RETURN(0)
    ENDIF
   ENDIF
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE copy_sch_file(sbr_src_fname,sbr_tgt_fname)
  IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "LNX")))
   IF (dm2_push_dcl(concat("cp ",sbr_src_fname," ",sbr_tgt_fname))=0)
    RETURN(0)
   ENDIF
   IF (dm2_push_dcl(concat("chmod 777 ",sbr_tgt_fname))=0)
    RETURN(0)
   ENDIF
  ELSE
   IF (dm2_push_dcl(concat("copy ",sbr_src_fname," ",sbr_tgt_fname))=0)
    RETURN(0)
   ENDIF
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE check_sch_files(null)
   DECLARE csf_file_name = vc WITH noconstant("")
   DECLARE csf_val_ver_ind = i2 WITH noconstant(0)
   FOR (csf_file_cnt = 1 TO dm2_sch_file->file_cnt)
     SET csf_file_name = concat(dm2_install_schema->ccluserdir,dm2_sch_file->qual[csf_file_cnt].
      table_name)
     IF ((dm2_sys_misc->cur_os="AXP"))
      IF ( NOT (findfile(concat(trim(csf_file_name,3),".dat"))))
       RETURN(2)
      ENDIF
     ELSE
      IF ( NOT (findfile(concat(trim(csf_file_name,3),".dat"))))
       RETURN(2)
      ELSEIF ( NOT (findfile(concat(trim(csf_file_name,3),".idx"))))
       RETURN(2)
      ENDIF
     ENDIF
     IF (val_sch_file_ver(csf_file_cnt)=0)
      IF ((dm_err->err_ind=1))
       RETURN(0)
      ELSE
       SET csf_val_ver_ind = 1
      ENDIF
     ENDIF
   ENDFOR
   IF (csf_val_ver_ind=1)
    RETURN(2)
   ELSE
    RETURN(1)
   ENDIF
 END ;Subroutine
 SUBROUTINE prep_sch_file(rec_ndx)
   DECLARE psf_target_name = vc
   DECLARE psf_target_name2 = vc
   DECLARE psf_estr = vc
   DECLARE psf_fext = vc
   IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "LNX")))
    SET psf_fext = ".dat/.idx"
   ELSEIF ((dm2_sys_misc->cur_os="WIN"))
    SET psf_fext = ".dat/.idx"
   ELSE
    SET psf_fext = ".dat"
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("dm2_sch_file->dest_dir_osfmt=",dm2_sch_file->dest_dir_osfmt))
    CALL echo(build("size(dm2_sch_file->dest_dir_osfmt,1)=",size(dm2_sch_file->dest_dir_osfmt,1)))
    CALL echo(concat("dm2_sch_file->file_prefix=",dm2_sch_file->file_prefix))
    CALL echo(concat("dm2_sch_file->qual[rec_ndx]->file_suffix=",dm2_sch_file->qual[rec_ndx].
      file_suffix))
   ENDIF
   SET psf_target_name = build(dm2_sch_file->dest_dir_osfmt,cnvtlower(dm2_sch_file->file_prefix),
    cnvtlower(dm2_sch_file->qual[rec_ndx].file_suffix),".dat")
   IF ((dm_err->debug_flag > 0))
    CALL echo(concat("psf_target_name=",psf_target_name))
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    SET psf_target_name2 = build(dm2_sch_file->dest_dir_osfmt,cnvtlower(dm2_sch_file->file_prefix),
     cnvtlower(dm2_sch_file->qual[rec_ndx].file_suffix),".idx")
   ENDIF
   IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "WIN", "LNX")))
    IF (del_sch_file(psf_target_name)=0)
     RETURN(0)
    ENDIF
    IF (del_sch_file(psf_target_name2)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (copy_sch_file(concat(dm2_install_schema->ccluserdir,cnvtlower(build(dm2_sch_file->qual[rec_ndx
       ].table_name,".dat"))),psf_target_name)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os != "AXP"))
    IF (copy_sch_file(concat(dm2_install_schema->ccluserdir,cnvtlower(build(dm2_sch_file->qual[
        rec_ndx].table_name,".idx"))),psf_target_name2)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF (open_sch_file(1,build(dm2_sch_file->dest_dir_cclfmt,":",cnvtlower(dm2_sch_file->file_prefix),
     cnvtlower(dm2_sch_file->qual[rec_ndx].file_suffix),".dat"),rec_ndx)=0)
    RETURN(0)
   ENDIF
   IF (dm2_push_cmd(concat("delete from ",dm2_sch_file->qual[rec_ndx].table_name," where 1=1 go"),1)=
   0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE gen_sch_files(null)
   DECLARE gsf_fext = vc
   IF ((dm2_sys_misc->cur_os IN ("HPX", "AIX", "LNX")))
    SET gsf_fext = ".dat/.idx"
   ELSEIF ((dm2_sys_misc->cur_os="WIN"))
    SET gsf_fext = ".dat/.idx"
   ELSE
    SET gsf_fext = ".dat"
   ENDIF
   FOR (gsf_cnt = 1 TO dm2_sch_file->file_cnt)
     IF ((dm2_sys_misc->cur_os != "AXP"))
      IF (del_sch_file(concat(dm2_install_schema->ccluserdir,cnvtlower(build(dm2_sch_file->qual[
          gsf_cnt].table_name,".dat"))))=0)
       RETURN(0)
      ENDIF
      IF (del_sch_file(concat(dm2_install_schema->ccluserdir,cnvtlower(build(dm2_sch_file->qual[
          gsf_cnt].table_name,".idx"))))=0)
       RETURN(0)
      ENDIF
     ENDIF
     IF (dm2_push_cmd(concat('select into table "',dm2_sch_file->qual[gsf_cnt].table_name,'"',
       " key1=fillstring(",dm2_sch_file->qual[gsf_cnt].key_size,
       '," "),'," data=fillstring(",dm2_sch_file->qual[gsf_cnt].data_size,'," ") ',
       " from dummyt order key1 with organization=indexed GO"),1)=0)
      RETURN(0)
     ENDIF
     IF (dm2_push_cmd(concat("drop table ",dm2_sch_file->qual[gsf_cnt].table_name," go"),1)=0)
      RETURN(0)
     ENDIF
     IF (dm2_push_cmd(concat("drop ddlrecord ",dm2_sch_file->qual[gsf_cnt].table_name,
       " from database ",dm2_sch_file->qual[gsf_cnt].table_name," with deps_deleted go"),1)=0)
      RETURN(0)
     ENDIF
     IF (dm2_push_cmd(concat("drop database ",dm2_sch_file->qual[gsf_cnt].table_name,
       " with deps_deleted go"),1)=0)
      RETURN(0)
     ENDIF
     IF (make_sch_file_defs(gsf_cnt)=0)
      RETURN(0)
     ENDIF
     IF (prep_sch_file(gsf_cnt)=0)
      RETURN(0)
     ENDIF
   ENDFOR
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsfi_load_schema_file_defs(dsfi_schema_set)
  CASE (cnvtupper(dsfi_schema_set))
   OF "TABLE_INFO":
    SET dm2_sch_file->file_cnt = 11
    SET stat = alterlist(dm2_sch_file->qual,dm2_sch_file->file_cnt)
    CALL dsf_pop_dmheader(1)
    CALL dsf_pop_dmtable(2)
    CALL dsf_pop_dmcolumn(3)
    CALL dsf_pop_dmindex(4)
    CALL dsf_pop_dmindcol(5)
    CALL dsf_pop_dmcons(6)
    CALL dsf_pop_dmconscol(7)
    CALL dsf_pop_dmseq(8)
    CALL dsf_pop_dmtbldoc(9)
    CALL dsf_pop_dmcoldoc(10)
    CALL dsf_pop_dmtsprec(11)
   OF "TSPACE":
    SET dm2_sch_file->file_cnt = 1
    SET stat = alterlist(dm2_sch_file->qual,dm2_sch_file->file_cnt)
    CALL dsf_pop_dmtspace(1)
  ENDCASE
  RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmheader(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_h"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMHEADER"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1058"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1028"
   SET dm2_sch_file->qual[dsfcnt].key_size = "30"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 30)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 1
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "DESCRIPTION = c30 CCL(DESCRIPTION)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 4
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "SOURCE_RDBMS = c20 CCL(SOURCE_RDBMS)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "ADMIN_LOAD_IND = i4 CCL(ADMIN_LOAD_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "SF_VERSION = i4 CCL(SF_VERSION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmtable(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_t"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMTABLE"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1208"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1178"
   SET dm2_sch_file->qual[dsfcnt].key_size = "30"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 30)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 1
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30  CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 21
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "TABLESPACE_NAME = c30 CCL(TABLESPACE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "INDEX_TSPACE = c30 CCL(INDEX_TSPACE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "INDEX_TSPACE_NI = i2 CCL(INDEX_TSPACE_NI)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "LONG_TSPACE = c30 CCL(LONG_TSPACE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "LONG_TSPACE_NI = i2 CCL(LONG_TSPACE_NI)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "INIT_EXT = f8 CCL(INIT_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "NEXT_EXT = f8 CCL(NEXT_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "PCT_INCREASE = f8 CCL(PCT_INCREASE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "PCT_USED = f8 CCL(PCT_USED)"
   SET dm2_sch_file->qual[dsfcnt].dqual[10].data_col = "PCT_FREE = f8 CCL(PCT_FREE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[11].data_col = "BYTES_ALLOCATED = f8 CCL(BYTES_ALLOCATED)"
   SET dm2_sch_file->qual[dsfcnt].dqual[12].data_col = "BYTES_USED = f8 CCL(BYTES_USED)"
   SET dm2_sch_file->qual[dsfcnt].dqual[13].data_col = "SCHEMA_DATE = dq8 CCL(SCHEMA_DATE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[14].data_col =
   "ALPHA_FEATURE_NBR = i4 CCL(ALPHA_FEATURE_NBR)"
   SET dm2_sch_file->qual[dsfcnt].dqual[15].data_col = "FEATURE_NUMBER = i4 CCL(FEATURE_NUMBER)"
   SET dm2_sch_file->qual[dsfcnt].dqual[16].data_col = "UPDT_DT_TM = dq8 CCL(UPDT_DT_TM)"
   SET dm2_sch_file->qual[dsfcnt].dqual[17].data_col = "SCHEMA_INSTANCE = i4 CCL(SCHEMA_INSTANCE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[18].data_col = "TSPACE_TYPE = c1 CCL(TSPACE_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[19].data_col = "LONG_TSPACE_TYPE = c1 CCL(LONG_TSPACE_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[20].data_col = "MAX_EXT = f8 CCL(MAX_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[21].data_col = "FILLER = c990 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmcolumn(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_tc"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMCOLUMN"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1343"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1283"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "COLUMN_NAME = c30 CCL(COLUMN_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 9
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "COLUMN_SEQ = i4 CCL(COLUMN_SEQ)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "DATA_TYPE = c18 CCL(DATA_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "DATA_LENGTH = i4 CCL(DATA_LENGTH)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "NULLABLE = c1 CCL(NULLABLE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "DATA_DEFAULT = c254 CCL(DATA_DEFAULT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "DATA_DEFAULT_NI = i2 CCL(DATA_DEFAULT_NI)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "DATA_DEFAULT2 = c500 CCL(DATA_DEFAULT2)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "VIRTUAL_COLUMN = c3 CCL(VIRTUAL_COLUMN)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "FILLER = c497 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmindex(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_i"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMINDEX"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1140"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1080"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME =  c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "INDEX_NAME = c30 CCL(INDEX_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 13
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "FULL_IND_NAME = c30 CCL(FULL_IND_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "PCT_INCREASE = f8 CCL(PCT_INCREASE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "PCT_FREE = f8 CCL(PCT_FREE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "INIT_EXT = f8 CCL(INIT_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "NEXT_EXT = f8 CCL(NEXT_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "UNIQUE_IND = i2 CCL(UNIQUE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "BYTES_ALLOCATED = f8 CCL(BYTES_ALLOCATED)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "BYTES_USED = f8 CCL(BYTES_USED)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "TSPACE_NAME = c30 CCL(TSPACE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[10].data_col = "TSPACE_TYPE = c1 CCL(TSPACE_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[11].data_col = "INDEX_TYPE = c30 CCL(INDEX_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[12].data_col = "MAX_EXT = f8 CCL(MAX_EXT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[13].data_col = "FILLER = c931 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmindcol(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_ic"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMINDCOL"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1094"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1034"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "INDEX_NAME = c30 CCL(INDEX_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "COLUMN_NAME = c30 CCL(COLUMN_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 3
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "COLUMN_POSITION = i4 CCL(COLUMN_POSITION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmcons(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_c"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMCONS"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1408"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1348"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "CONSTRAINT_NAME = c30 CCL(CONSTRAINT_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 8
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "FULL_CONS_NAME = c30 CCL(FULL_CONS_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "CONSTRAINT_TYPE = c1 CCL(CONSTRAINT_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "STATUS_IND = i2 CCL(STATUS_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col =
   "R_CONSTRAINT_NAME = c30 CCL(R_CONSTRAINT_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col =
   "PARENT_TABLE_NAME = c30 CCL(PARENT_TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col =
   "PARENT_TABLE_COLUMNS = c255 CCL(PARENT_TABLE_COLUMNS)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "DELETE_RULE = c9 CCL(DELETE_RULE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "FILLER = c991 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmconscol(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_cc"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMCONSCOL"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1094"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1034"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "CONSTRAINT_NAME = c30 CCL(CONSTRAINT_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "COLUMN_NAME = c30 CCL(COLUMN_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 3
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "POSITION =  i4 CCL(POSITION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmseq(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_sq"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMSEQ"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1079"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1049"
   SET dm2_sch_file->qual[dsfcnt].key_size = "30"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 30)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 1
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "SEQUENCE_NAME = c30 CCL(SEQUENCE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 9
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "MIN_VALUE = f8  CCL(MIN_VALUE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "MAX_VALUE = f8 CCL(MAX_VALUE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "INCREMENT_BY = f8 CCL(INCREMENT_BY)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "CYCLE_FLAG = c1 CCL(CYCLE_FLAG)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "LAST_NUMBER = f8 CCL(LAST_NUMBER)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "ALPHA_FEATURE_NBR = i4 CCL(ALPHA_FEATURE_NBR)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "FEATURE_NUMBER = i4 CCL(FEATURE_NUMBER)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "UPDT_DT_TM = dq8 CCL(UPDT_DT_TM)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmtbldoc(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_td"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMTBLDOC"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "2041"
   SET dm2_sch_file->qual[dsfcnt].data_size = "2011"
   SET dm2_sch_file->qual[dsfcnt].key_size = "30"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 30)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 1
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 20
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col =
   "DATA_MODEL_SECTION = c80 CCL(DATA_MODEL_SECTION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "DESCRIPTION = c80 CCL(DESCRIPTION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "DEFINITION = c500 CCL(DEFINITION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "STATIC_ROWS = i4 CCL(STATIC_ROWS)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "UPDT_CNT = i4 CCL(UPDT_CNT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "REFERENCE_IND = i2 CCL(REFERENCE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "HUMAN_REQD_IND = i2 CCL(HUMAN_REQD_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "DROP_IND = i2 CCL(DROP_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "TABLE_SUFFIX = c4 CCL(TABLE_SUFFIX)"
   SET dm2_sch_file->qual[dsfcnt].dqual[10].data_col = "FULL_TABLE_NAME = c30 CCL(FULL_TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[11].data_col =
   "SUFFIXED_TABLE_NAME = c18 CCL(SUFFIXED_TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[12].data_col = "DEFAULT_ROW_IND = i2 CCL(DEFAULT_ROW_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[13].data_col =
   "PERSON_CMB_TRIGGER_TYPE = c10 CCL(PERSON_CMB_TRIGGER_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[14].data_col =
   "ENCNTR_CMB_TRIGGER_TYPE = c10 CCL(ENCNTR_CMB_TRIGGER_TYPE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[15].data_col = "MERGE_UI_QUERY = c255 CCL(MERGE_UI_QUERY)"
   SET dm2_sch_file->qual[dsfcnt].dqual[16].data_col = "MERGEABLE_IND  = i2 CCL(MERGEABLE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[17].data_col = "MERGE_DELETE_IND = i2 CCL(MERGE_DELETE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[18].data_col = "MERGE_ACTIVE_IND = i2 CCL(MERGE_ACTIVE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[19].data_col = "DATA_DISP_FLAG = i2 CCL(DATA_DISP_FLAG)"
   SET dm2_sch_file->qual[dsfcnt].dqual[20].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmcoldoc(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_cd"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMCOLDOC"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "2043"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1983"
   SET dm2_sch_file->qual[dsfcnt].key_size = "60"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 60)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "COLUMN_NAME = c30 CCL(COLUMN_NAME)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 19
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "SEQUENCE_NAME = c30 CCL(SEQUENCE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "CODE_SET = i4 CCL(CODE_SET)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "DESCRIPTION = c80 CCL(DESCRIPTION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "DEFINITION = c500 CCL(DEFINITION)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "FLAG_IND = i2 CCL(FLAG_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "UPDT_CNT = i4 CCL(UPDT_CNT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "UNIQUE_IDENT_IND = i2 CCL(UNIQUE_IDENT_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "ROOT_ENTITY_NAME = c30 CCL(ROOT_ENTITY_NAME)"
   SET dm2_sch_file->qual[dsfcnt].dqual[9].data_col = "ROOT_ENTITY_ATTR = c30 CCL(ROOT_ENTITY_ATTR)"
   SET dm2_sch_file->qual[dsfcnt].dqual[10].data_col = "CONSTANT_VALUE = c255 CCL(CONSTANT_VALUE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[11].data_col =
   "PARENT_ENTITY_COL = c30 CCL(PARENT_ENTITY_COL)"
   SET dm2_sch_file->qual[dsfcnt].dqual[12].data_col = "EXCEPTION_FLG = i4 CCL(EXCEPTION_FLG)"
   SET dm2_sch_file->qual[dsfcnt].dqual[13].data_col =
   "DEFINING_ATTRIBUTE_IND = i2 CCL(DEFINING_ATTRIBUTE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[14].data_col =
   "MERGE_UPDATEABLE_IND = i2 CCL(MERGE_UPDATEABLE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[15].data_col = "NLS_COL_IND = i2 CCL(NLS_COL_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[16].data_col =
   "ABSOLUTE_DATE_IND = i2 CCL(ABSOLUTE_DATE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[17].data_col = "MERGE_DELETE_IND = I2 CCL(MERGE_DELETE_IND)"
   SET dm2_sch_file->qual[dsfcnt].dqual[18].data_col = "TZ_RULE_FLAG = I2 CCL(TZ_RULE_FLAG)"
   SET dm2_sch_file->qual[dsfcnt].dqual[19].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmtsprec(dsfcnt)
   SET dm2_sch_file->qual[dsfcnt].file_suffix = "_tp"
   SET dm2_sch_file->qual[dsfcnt].table_name = "DMTSPREC"
   SET dm2_sch_file->qual[dsfcnt].db_name = build(dm2_sch_file->qual[dsfcnt].table_name,dm2_sch_file
    ->sf_ver)
   SET dm2_sch_file->qual[dsfcnt].size = "1152"
   SET dm2_sch_file->qual[dsfcnt].data_size = "1118"
   SET dm2_sch_file->qual[dsfcnt].key_size = "34"
   SET dm2_sch_file->qual[dsfcnt].db_key = "unique key 1 (0, 34)"
   SET dm2_sch_file->qual[dsfcnt].key_cnt = 2
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].kqual,dm2_sch_file->qual[dsfcnt].key_cnt)
   SET dm2_sch_file->qual[dsfcnt].kqual[1].key_col = "TABLE_NAME = c30 CCL(TABLE_NAME)"
   SET dm2_sch_file->qual[dsfcnt].kqual[2].key_col = "PRECEDENCE = i4 CCL(PRECEDENCE)"
   SET dm2_sch_file->qual[dsfcnt].data_cnt = 8
   SET stat = alterlist(dm2_sch_file->qual[dsfcnt].dqual,dm2_sch_file->qual[dsfcnt].data_cnt)
   SET dm2_sch_file->qual[dsfcnt].dqual[1].data_col = "DATA_TABLESPACE = c30 CCL(DATA_TABLESPACE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[2].data_col = "DATA_EXTENT_SIZE = f8 CCL(DATA_EXTENT_SIZE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[3].data_col = "INDEX_TABLESPACE = c30 CCL(INDEX_TABLESPACE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[4].data_col = "INDEX_EXTENT_SIZE = f8 CCL(INDEX_EXTENT_SIZE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[5].data_col = "LONG_TABLESPACE = c30 CCL(LONG_TABLESPACE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[6].data_col = "LONG_EXTENT_SIZE = f8 CCL(LONG_EXTENT_SIZE)"
   SET dm2_sch_file->qual[dsfcnt].dqual[7].data_col = "UPDT_CNT = i4 CCL(UPDT_CNT)"
   SET dm2_sch_file->qual[dsfcnt].dqual[8].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsf_pop_dmtspace(dsfcnt)
   SET dm2_sch_file->qual[1].file_suffix = "_ts"
   SET dm2_sch_file->qual[1].table_name = "DMTSPACE"
   SET dm2_sch_file->qual[1].db_name = build(dm2_sch_file->qual[1].table_name,dm2_sch_file->sf_ver)
   SET dm2_sch_file->qual[1].size = "1056"
   SET dm2_sch_file->qual[1].data_size = "1026"
   SET dm2_sch_file->qual[1].key_size = "30"
   SET dm2_sch_file->qual[1].db_key = "unique key 1 (0, 30)"
   SET dm2_sch_file->qual[1].key_cnt = 1
   SET stat = alterlist(dm2_sch_file->qual[1].kqual,dm2_sch_file->qual[1].key_cnt)
   SET dm2_sch_file->qual[1].kqual[1].key_col = "TSPACE_NAME = c30  CCL(TSPACE_NAME)"
   SET dm2_sch_file->qual[1].data_cnt = 4
   SET stat = alterlist(dm2_sch_file->qual[1].dqual,dm2_sch_file->qual[1].data_cnt)
   SET dm2_sch_file->qual[1].dqual[1].data_col = "BYTES_NEEDED = f8  CCL(BYTES_NEEDED)"
   SET dm2_sch_file->qual[1].dqual[2].data_col = "EXT_MGMT = c10 CCL(EXT_MGMT)"
   SET dm2_sch_file->qual[1].dqual[3].data_col = "UPDT_DT_TM = dq8 CCL(UPDT_DT_TM)"
   SET dm2_sch_file->qual[1].dqual[4].data_col = "FILLER = c1000 CCL(FILLER)"
   RETURN(1)
 END ;Subroutine
 SUBROUTINE dsfi_load_schema_files(dlsf_desc,dlsf_process_option)
   DECLARE dlsf_tbl_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_max_tc_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_max_i_cnt = i2 WITH protect, noconstant(0)
   DECLARE dlsf_max_ic_cnt = i2 WITH protect, noconstant(0)
   DECLARE dlsf_max_c_cnt = i2 WITH protect, noconstant(0)
   DECLARE dlsf_max_cc_cnt = i2 WITH protect, noconstant(0)
   DECLARE dlsf_tc_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_ind_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_icol_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_cons_cnt = i4 WITH protect, noconstant(0)
   DECLARE dlsf_ccol_cnt = i4 WITH protect, noconstant(0)
   IF ((cur_sch->tbl_cnt <= 0))
    SET dm_err->eproc = "NO TABLES IN CURRENT SCHEMA"
    SET dm_err->err_ind = 1
    SET dm_err->emsg = "No tables found for the schema snapshot."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   FOR (dlsf_tbl_cnt = 1 TO value(cur_sch->tbl_cnt))
     SET cur_sch->tbl[dlsf_tbl_cnt].capture_ind = 1
   ENDFOR
   SET dm_err->eproc = "POPULATE DMHEADER SCHEMA FILE WITH HEADER INFO"
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dmheader dh
    SET dh.description = dlsf_desc, dh.admin_load_ind = 0, dh.source_rdbms = currdb,
     dh.sf_version = 1
    WITH nocounter
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "POPULATE DMTABLE SCHEMA FILE WITH TABLE INFO"
   CALL disp_msg(" ",dm_err->logfile,0)
   INSERT  FROM dmtable t,
     (dummyt d  WITH seq = value(cur_sch->tbl_cnt))
    SET t.seq = 1, t.table_name = cur_sch->tbl[d.seq].tbl_name, t.tablespace_name = cur_sch->tbl[d
     .seq].tspace_name,
     t.index_tspace = dm2_dft_clin_itspace, t.index_tspace_ni = 0, t.long_tspace = cur_sch->tbl[d.seq
     ].long_tspace,
     t.long_tspace_ni = cur_sch->tbl[d.seq].long_tspace_ni, t.init_ext = cur_sch->tbl[d.seq].init_ext,
     t.next_ext = cur_sch->tbl[d.seq].next_ext,
     t.pct_increase = cur_sch->tbl[d.seq].pct_increase, t.pct_used = cur_sch->tbl[d.seq].pct_used, t
     .pct_free = cur_sch->tbl[d.seq].pct_free,
     t.bytes_allocated = cur_sch->tbl[d.seq].bytes_allocated, t.bytes_used = cur_sch->tbl[d.seq].
     bytes_used, t.schema_date = cur_sch->tbl[d.seq].schema_date,
     t.schema_instance = cur_sch->tbl[d.seq].schema_instance, t.alpha_feature_nbr = 0, t
     .feature_number = 0,
     t.updt_dt_tm = cnvtdatetime(curdate,curtime3), t.tspace_type = cur_sch->tbl[d.seq].ext_mgmt, t
     .long_tspace_type = cur_sch->tbl[d.seq].lext_mgmt,
     t.max_ext = cur_sch->tbl[d.seq].max_ext
    PLAN (d
     WHERE (cur_sch->tbl[d.seq].capture_ind=1))
     JOIN (t
     WHERE (cur_sch->tbl[d.seq].tbl_name=t.table_name))
    WITH nocounter, outerjoin = d, dontexist
   ;end insert
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "POPULATE DMCOLUMN SCHEMA FILE WITH COLUMN INFO"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    d.seq
    FROM (dummyt d  WITH seq = value(cur_sch->tbl_cnt))
    PLAN (d)
    DETAIL
     IF ((cur_sch->tbl[d.seq].tbl_col_cnt > dlsf_max_tc_cnt))
      dlsf_max_tc_cnt = cur_sch->tbl[d.seq].tbl_col_cnt
     ENDIF
     dlsf_tc_cnt = (dlsf_tc_cnt+ cur_sch->tbl[d.seq].tbl_col_cnt)
    WITH nocounter
   ;end select
   IF (dlsf_max_tc_cnt > 0)
    INSERT  FROM dmcolumn tc,
      (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
      (dummyt d2  WITH seq = value(dlsf_max_tc_cnt))
     SET tc.seq = 1, tc.table_name = cur_sch->tbl[d.seq].tbl_name, tc.column_name = cur_sch->tbl[d
      .seq].tbl_col[d2.seq].col_name,
      tc.column_seq = cur_sch->tbl[d.seq].tbl_col[d2.seq].col_seq, tc.data_type = cur_sch->tbl[d.seq]
      .tbl_col[d2.seq].data_type, tc.data_length = cur_sch->tbl[d.seq].tbl_col[d2.seq].data_length,
      tc.nullable = cur_sch->tbl[d.seq].tbl_col[d2.seq].nullable, tc.data_default = cur_sch->tbl[d
      .seq].tbl_col[d2.seq].data_default, tc.data_default_ni = cur_sch->tbl[d.seq].tbl_col[d2.seq].
      data_default_ni,
      tc.data_default2 = cur_sch->tbl[d.seq].tbl_col[d2.seq].data_default, tc.virtual_column =
      cur_sch->tbl[d.seq].tbl_col[d2.seq].virtual_column
     PLAN (d
      WHERE (cur_sch->tbl[d.seq].capture_ind=1))
      JOIN (d2
      WHERE (d2.seq <= cur_sch->tbl[d.seq].tbl_col_cnt))
      JOIN (tc
      WHERE (cur_sch->tbl[d.seq].tbl_name=tc.table_name)
       AND (cur_sch->tbl[d.seq].tbl_col[d2.seq].col_name=tc.column_name))
     WITH nocounter, outerjoin = d2, dontexist
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->err_ind = 1
    CALL disp_msg("No column information found for tables.",dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "POPULATE DMINDEX SCHEMA FILE WITH INDEX INFO"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    d.seq
    FROM (dummyt d  WITH seq = value(cur_sch->tbl_cnt))
    PLAN (d)
    DETAIL
     IF ((cur_sch->tbl[d.seq].ind_cnt > dlsf_max_i_cnt))
      dlsf_max_i_cnt = cur_sch->tbl[d.seq].ind_cnt
     ENDIF
     dlsf_ind_cnt = (dlsf_ind_cnt+ cur_sch->tbl[d.seq].ind_cnt)
    WITH nocounter
   ;end select
   IF (dlsf_max_i_cnt > 0)
    INSERT  FROM dmindex i,
      (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
      (dummyt d2  WITH seq = value(dlsf_max_i_cnt))
     SET i.seq = 1, i.table_name = cur_sch->tbl[d.seq].tbl_name, i.index_name = cur_sch->tbl[d.seq].
      ind[d2.seq].ind_name,
      i.full_ind_name = cur_sch->tbl[d.seq].ind[d2.seq].full_ind_name, i.pct_increase = cur_sch->tbl[
      d.seq].ind[d2.seq].pct_increase, i.pct_free = cur_sch->tbl[d.seq].ind[d2.seq].pct_free,
      i.init_ext = cur_sch->tbl[d.seq].ind[d2.seq].init_ext, i.next_ext = cur_sch->tbl[d.seq].ind[d2
      .seq].next_ext, i.bytes_allocated = cur_sch->tbl[d.seq].ind[d2.seq].bytes_allocated,
      i.bytes_used = cur_sch->tbl[d.seq].ind[d2.seq].bytes_used, i.unique_ind = cur_sch->tbl[d.seq].
      ind[d2.seq].unique_ind, i.tspace_name = cur_sch->tbl[d.seq].ind[d2.seq].tspace_name,
      i.tspace_type = cur_sch->tbl[d.seq].ind[d2.seq].ext_mgmt, i.index_type = cur_sch->tbl[d.seq].
      ind[d2.seq].index_type, i.max_ext = cur_sch->tbl[d.seq].ind[d2.seq].max_ext
     PLAN (d
      WHERE (cur_sch->tbl[d.seq].capture_ind=1))
      JOIN (d2
      WHERE (d2.seq <= cur_sch->tbl[d.seq].ind_cnt))
      JOIN (i
      WHERE (cur_sch->tbl[d.seq].tbl_name=i.table_name)
       AND (cur_sch->tbl[d.seq].ind[d2.seq].ind_name=i.index_name))
     WITH nocounter, outerjoin = d2, dontexist
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "POPULATE DMINDCOL SCHEMA FILE WITH INDEX COLUMN INFO"
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     d.seq
     FROM (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
      (dummyt d2  WITH seq = value(dlsf_max_i_cnt))
     PLAN (d)
      JOIN (d2
      WHERE (d2.seq <= cur_sch->tbl[d.seq].ind_cnt))
     DETAIL
      IF ((cur_sch->tbl[d.seq].ind[d2.seq].ind_col_cnt > dlsf_max_ic_cnt))
       dlsf_max_ic_cnt = cur_sch->tbl[d.seq].ind[d2.seq].ind_col_cnt
      ENDIF
      dlsf_icol_cnt = (dlsf_icol_cnt+ cur_sch->tbl[d.seq].ind[d2.seq].ind_col_cnt)
     WITH nocounter
    ;end select
    IF (dlsf_max_ic_cnt > 0)
     INSERT  FROM dmindcol ic,
       (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
       (dummyt d2  WITH seq = value(dlsf_max_i_cnt)),
       (dummyt d3  WITH seq = value(dlsf_max_ic_cnt))
      SET ic.seq = 1, ic.table_name = cur_sch->tbl[d.seq].tbl_name, ic.index_name = cur_sch->tbl[d
       .seq].ind[d2.seq].ind_name,
       ic.column_name = cur_sch->tbl[d.seq].ind[d2.seq].ind_col[d3.seq].col_name, ic.column_position
        = cur_sch->tbl[d.seq].ind[d2.seq].ind_col[d3.seq].col_position
      PLAN (d
       WHERE (cur_sch->tbl[d.seq].capture_ind=1))
       JOIN (d2
       WHERE (d2.seq <= cur_sch->tbl[d.seq].ind_cnt))
       JOIN (d3
       WHERE (d3.seq <= cur_sch->tbl[d.seq].ind[d2.seq].ind_col_cnt))
       JOIN (ic
       WHERE (cur_sch->tbl[d.seq].tbl_name=ic.table_name)
        AND (cur_sch->tbl[d.seq].ind[d2.seq].ind_name=ic.index_name)
        AND (cur_sch->tbl[d.seq].ind[d2.seq].ind_col[d3.seq].col_name=ic.column_name))
      WITH nocounter, outerjoin = d3, dontexist
     ;end insert
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
     CALL disp_msg("No column information found for indexes.",dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET dm_err->eproc = "POPULATE DMCONS SCHEMA FILE WITH CONSTRAINT INFO"
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    d.seq
    FROM (dummyt d  WITH seq = value(cur_sch->tbl_cnt))
    PLAN (d)
    DETAIL
     IF ((cur_sch->tbl[d.seq].cons_cnt > dlsf_max_c_cnt))
      dlsf_max_c_cnt = cur_sch->tbl[d.seq].cons_cnt
     ENDIF
     dlsf_cons_cnt = (dlsf_cons_cnt+ cur_sch->tbl[d.seq].cons_cnt)
    WITH nocounter
   ;end select
   IF (dlsf_max_c_cnt > 0)
    INSERT  FROM dmcons c,
      (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
      (dummyt d2  WITH seq = value(dlsf_max_c_cnt))
     SET c.seq = 1, c.table_name = cur_sch->tbl[d.seq].tbl_name, c.constraint_name = cur_sch->tbl[d
      .seq].cons[d2.seq].cons_name,
      c.full_cons_name = cur_sch->tbl[d.seq].cons[d2.seq].full_cons_name, c.constraint_type = cur_sch
      ->tbl[d.seq].cons[d2.seq].cons_type, c.status_ind = cur_sch->tbl[d.seq].cons[d2.seq].status_ind,
      c.r_constraint_name = cur_sch->tbl[d.seq].cons[d2.seq].r_constraint_name, c.parent_table_name
       = cur_sch->tbl[d.seq].cons[d2.seq].parent_table, c.parent_table_columns = cur_sch->tbl[d.seq].
      cons[d2.seq].parent_table_columns,
      c.delete_rule = cur_sch->tbl[d.seq].cons[d2.seq].delete_rule
     PLAN (d
      WHERE (cur_sch->tbl[d.seq].capture_ind=1))
      JOIN (d2
      WHERE (d2.seq <= cur_sch->tbl[d.seq].cons_cnt))
      JOIN (c
      WHERE (cur_sch->tbl[d.seq].tbl_name=c.table_name)
       AND (cur_sch->tbl[d.seq].cons[d2.seq].cons_name=c.constraint_name))
     WITH nocounter, outerjoin = d2, dontexist
    ;end insert
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "POPULATE DMCONSCOL SCHEMA FILE WITH CONSTRAINT COLUMN INFO"
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     d.seq
     FROM (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
      (dummyt d2  WITH seq = value(dlsf_max_c_cnt))
     PLAN (d)
      JOIN (d2
      WHERE (d2.seq <= cur_sch->tbl[d.seq].cons_cnt))
     DETAIL
      IF ((cur_sch->tbl[d.seq].cons[d2.seq].cons_col_cnt > dlsf_max_cc_cnt))
       dlsf_max_cc_cnt = cur_sch->tbl[d.seq].cons[d2.seq].cons_col_cnt
      ENDIF
      dlsf_ccol_cnt = (dlsf_ccol_cnt+ cur_sch->tbl[d.seq].cons[d2.seq].cons_col_cnt)
     WITH nocounter
    ;end select
    IF (dlsf_max_cc_cnt > 0)
     INSERT  FROM dmconscol cc,
       (dummyt d  WITH seq = value(cur_sch->tbl_cnt)),
       (dummyt d2  WITH seq = value(dlsf_max_c_cnt)),
       (dummyt d3  WITH seq = value(dlsf_max_cc_cnt))
      SET cc.seq = 1, cc.table_name = cur_sch->tbl[d.seq].tbl_name, cc.constraint_name = cur_sch->
       tbl[d.seq].cons[d2.seq].cons_name,
       cc.column_name = cur_sch->tbl[d.seq].cons[d2.seq].cons_col[d3.seq].col_name, cc.position =
       cur_sch->tbl[d.seq].cons[d2.seq].cons_col[d3.seq].col_position
      PLAN (d
       WHERE (cur_sch->tbl[d.seq].capture_ind=1))
       JOIN (d2
       WHERE (d2.seq <= cur_sch->tbl[d.seq].cons_cnt))
       JOIN (d3
       WHERE (d3.seq <= cur_sch->tbl[d.seq].cons[d2.seq].cons_col_cnt))
       JOIN (cc
       WHERE (cur_sch->tbl[d.seq].tbl_name=cc.table_name)
        AND (cur_sch->tbl[d.seq].cons[d2.seq].cons_name=cc.constraint_name)
        AND (cur_sch->tbl[d.seq].cons[d2.seq].cons_col[d3.seq].col_name=cc.column_name))
      WITH nocounter, outerjoin = d3, dontexist
     ;end insert
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     SET dm_err->err_ind = 1
     CALL disp_msg("No column information found for constraints.",dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE del_sch_files(null)
   DECLARE dsf_cnt = i4 WITH protect, noconstant(0)
   DECLARE dsf_name = vc WITH protect, noconstant("")
   FOR (dsf_cnt = 1 TO dm2_sch_file->file_cnt)
     SET dsf_name = build(dm2_sch_file->file_prefix,cnvtlower(dm2_sch_file->qual[dsf_cnt].file_suffix
       ))
     IF (del_sch_file(build(dm2_sch_file->dest_dir_osfmt,dsf_name,".dat"))=0)
      SET dm_err->err_ind = 1
      RETURN(0)
     ENDIF
     IF ((dm2_sys_misc->cur_os != "AXP"))
      IF (del_sch_file(build(dm2_sch_file->dest_dir_osfmt,dsf_name,".idx"))=0)
       SET dm_err->err_ind = 1
       RETURN(0)
      ENDIF
     ENDIF
   ENDFOR
 END ;Subroutine
#end_sch_files_inc
 DECLARE ddprr_create_refresh_file(null) = i2
 SUBROUTINE ddprr_create_refresh_file(null)
   DECLARE dcrf_file_name = vc WITH protect, noconstant("")
   DECLARE dcrf_line = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcrf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_refresh.com")
   ELSE
    SET dcrf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_refresh.ksh")
    IF ((ddr_domain_data->tgt_local_group_name="DM2NOTSET"))
     IF (ddr_get_local_group_name(0,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create ",dcrf_file_name)
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO value(dcrf_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!dm2_target_refresh.com "), row + 1,
      CALL print("$!  "),
      row + 1,
      CALL print("$!mod "), row + 1,
      CALL print("$!000 sc4299  initial release "), row + 1,
      CALL print("$!-------------------------------------------"),
      row + 1,
      CALL print("$!                     "), row + 1,
      CALL print("$on ERROR then goto EXIT_ERROR"), row + 1,
      CALL print("$on CONTROL_Y then goto EXIT_ERROR"),
      row + 1,
      CALL print("$!--------------------  "), row + 1,
      CALL print("$!set variables         "), row + 1,
      CALL print("$!--------------------  "),
      row + 1,
      CALL print("$error = 0   "), row + 1,
      CALL print(concat('$tgt_domain_name = "',cnvtupper(ddr_domain_data->tgt_domain_name),'"')), row
       + 1,
      CALL print(concat('$tgt_env = "',cnvtupper(ddr_domain_data->tgt_env),'"')),
      row + 1,
      CALL print("$!  "), row + 1,
      CALL print(concat('$tgt_tmp_dev = "',ddr_domain_data->tgt_tmp_dev,'"')), row + 1,
      CALL print(concat('$tgt_tmp_dir = "',ddr_domain_data->tgt_tmp_dir,'"')),
      row + 1,
      CALL print("$!"), row + 1,
      CALL print(concat('$tgt_tmp_full_dir = "',ddr_domain_data->tgt_tmp_full_dir,'"')), row + 1,
      CALL print(^$if f$search("''tgt_tmp_dev':[''tgt_tmp_dir']''tgt_env'.dir") .eqs. "" ^),
      row + 1,
      CALL print("$then  "), row + 1,
      CALL print(^$   call echo3 "error : directory ''tgt_tmp_full_dir' not found."  ^), row + 1,
      CALL print("$   error = 1"),
      row + 1,
      CALL print("$   goto EXIT_CRITICAL   "), row + 1,
      CALL print("$endif"), row + 1,
      CALL print("$! "),
      row + 1,
      CALL print("$!create log file "), row + 1,
      dcrf_line = concat(^$if f$search("''tgt_tmp_full_dir'dm2_target_refresh.log") .nes. "" then ^,
       " delete 'tgt_tmp_full_dir'dm2_target_refresh.log;* "),
      CALL print(dcrf_line), row + 1,
      CALL print("$open/write logfile 'tgt_tmp_full_dir'dm2_target_refresh.log             "), row +
      1,
      CALL print("$! "),
      row + 1,
      CALL print('$call echo1 "begin dm2_target_refresh.com" '), row + 1,
      CALL print("$!"), row + 1,
      CALL print(concat('$tgt_wh = "',cnvtupper(ddr_domain_data->tgt_wh),'"')),
      row + 1,
      CALL print(concat('$tgt_wh_device = "',ddr_domain_data->tgt_wh_device,'"')), row + 1,
      CALL print(^$if f$search("''tgt_wh_device':[cerner.w_standard]''tgt_wh'.dir") .eqs. "" ^), row
       + 1,
      CALL print("$then    "),
      row + 1,
      CALL print(
      ^$   call echo2 "error : directory ''tgt_wh_device':[cerner.w_standard.''tgt_wh'] not found."  ^
      ), row + 1,
      CALL print("$   error = 1   "), row + 1,
      CALL print("$   goto EXIT_SCRIPT "),
      row + 1,
      CALL print("$endif "), row + 1,
      CALL print("$! "), row + 1,
      CALL print('$tgt_node = f$getsyi("nodename") '),
      row + 1,
      CALL print(^$call echo1 "tgt_node = ''tgt_node'" ^), row + 1,
      CALL print('$common_new_wh = "" '), row + 1,
      CALL print('$common_back_wh = ""'),
      row + 1,
      CALL print("$!                           "), row + 1,
      CALL print(
      "$!----------------------------                                                        "), row
       + 1,
      CALL print(
      "$!verify in Target Environment                                                        "),
      row + 1,
      CALL print(
      "$!----------------------------                                                        "), row
       + 1,
      CALL print(
      '$call echo1 "Verify in Target Environment"                                            '), row
       + 1,
      CALL print(
      "$set noon                                                                             "),
      row + 1,
      CALL print(
      '$if tgt_env .nes. f$edit(f$trnlnm("environment"), "upcase, trim")                     '), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$  call echo2 "Error : Must be in Target environment ''tgt_env'"                      ^),
      row + 1,
      CALL print(
      "$  error = 1                                                                          "), row
       + 1,
      CALL print(
      "$  goto EXIT_SCRIPT                                                                   "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$set on                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      ^$if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. ""                          ^),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '), row
       + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "),
      row + 1,
      CALL print(
      "$   delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*                                        "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!--------------------------                                                          "),
      row + 1,
      CALL print(
      "$!verify user is domain user                                                          "), row
       + 1,
      CALL print(
      "$!--------------------------                                                          "), row
       + 1,
      CALL print(
      '$call echo1 "Verify domain user"                                                      '),
      row + 1,
      CALL print(
      "$set noon                                                                             "), row
       + 1,
      CALL print(
      ^$mcr cer_exe:lreg -getp \environment\'tgt_env' "localusername"                        ^), row
       + 1,
      CALL print(
      "$if $status                                                                           "),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   domain_user = f$edit(lreg_result, "upcase")                                       '), row
       + 1,
      CALL print(
      ^$   call echo1 "domain user : ''domain_user'"                                         ^),
      row + 1,
      CALL print(
      "$else                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "Error : Failed to find domain user."                                  '), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$set on                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$comma_pos = 0                                                                        "), row
       + 1,
      CALL print(
      "$str_length = 0                                                                       "),
      row + 1,
      CALL print(
      "$curuser = f$user()                                                                   "), row
       + 1,
      CALL print(
      '$comma_pos = f$locate(",",curuser)                                                    '), row
       + 1,
      CALL print(
      "$str_length = f$length(curuser)                                                       "),
      row + 1,
      CALL print(
      "$if (comma_pos .gt. 0) .and. (comma_pos .ne. str_length)                              "), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$ curuser = F$EXTRACT(F$LOCATE(",",curuser)+1 ,F$LOCATE("]",curuser)-F$LOCATE(",",curuser)-1,curuser)   '
      ),
      row + 1,
      CALL print(
      "$else                                                                                 "), row
       + 1,
      CALL print(
      '$ curuser = curuser - "[" - "]"                                                       '), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      '$curuser = f$edit(curuser, "upcase")                                                  '), row
       + 1,
      CALL print(
      ^$call echo1 "curuser : ''curuser'"                                                    ^), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$if curuser .nes. domain_user                                                         "), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "error : log on as ''domain_user' and run again."                      ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!-------------------------------                                                     "), row
       + 1,
      CALL print(
      "$!prompt source environment name                                                      "),
      row + 1,
      CALL print(
      "$!-------------------------------                                                     "), row
       + 1,
      CALL print(
      '$call echo1 "Prompt source environment name."                                         '), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$inquire src_env "Enter source environment name"                                      '), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   src_env = f$edit(src_env, "lowercase")                                            '),
      row + 1,
      CALL print(
      '$if src_env .eqs. ""                                                                  '), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "error: Invalid source environment name."                              '),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$else                                                                                 "),
      row + 1,
      CALL print(
      ^$  call echo1 "Source environment name : ''src_env'"                                  ^), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!-------------------------                                                           "), row
       + 1,
      CALL print(
      "$!read source misc_data.dat                                                           "), row
       + 1,
      CALL print(
      "$!-------------------------                                                           "),
      row + 1,
      CALL print(
      '$call echo1 "Read source misc_data.dat"                                               '), row
       + 1,
      CALL print(
      ^$src_tmp_dir = "''tgt_tmp_dev':[''tgt_tmp_dir'.''src_env']"                           ^), row
       + 1,
      CALL print(
      ^$if f$search("''tgt_tmp_dev':[''tgt_tmp_dir']''src_env'.dir") .eqs. ""                ^),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : directory ''src_tmp_dir' not found."                          ^), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      ^$if f$search("''src_tmp_dir'misc_data.dat") .eqs. ""                                  ^), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : file ''src_tmp_dir'misc_data.dat not found."                  ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$node_cnt = 0                                                                         "), row
       + 1,
      CALL print(
      "$open/read/error=CHECK_DATA SRC_DATA 'src_tmp_dir'misc_data.dat                       "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$READ_DATA:                                                                           "), row
       + 1,
      CALL print(
      "$   read/end_of_file=end_READ_DATA SRC_DATA record                                    "),
      row + 1,
      CALL print(
      '$   lable = f$element(0, ",", record)                                                 '), row
       + 1,
      CALL print(
      '$   lable = f$edit(lable, "upcase")                                                   '), row
       + 1,
      CALL print(
      '$   lable_value = f$element(1,",", record)                                            '),
      row + 1,
      CALL print(
      '$   lable_value = lable_value - """" - """"                                           '), row
       + 1,
      CALL print(
      '$   lable_value = f$edit(lable_value, "upcase")                                       '), row
       + 1,
      CALL print(
      "$   goto 'lable'                                                                      "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CER_DATA_DEV:                                                                 "), row
       + 1,
      CALL print(
      "$      src_cer_data_dev_value = lable_value                                           "),
      row + 1,
      CALL print(
      '$      if src_cer_data_dev_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_data_dev not found."                            '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_cer_data_dev = ''src_cer_data_dev_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_WH:                                                                           "), row
       + 1,
      CALL print(
      "$      src_wh_value = lable_value                                                     "), row
       + 1,
      CALL print(
      '$      if src_wh_value .eqs. ""                                                       '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_wh not found."                                      '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_wh = ''src_wh_value'"                                          ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WH_DEVICE:                                                                    "),
      row + 1,
      CALL print(
      "$      src_wh_device_value = lable_value                                              "), row
       + 1,
      CALL print(
      '$      if src_wh_device_value .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_wh_device not found."                               '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_wh_device = ''src_wh_device_value'"                            ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CER_INSTALL_DIR:                                                                    "),
      row + 1,
      CALL print(
      "$      src_cer_install_dir = lable_value                                              "),
      row + 1,
      CALL print(
      '$      if src_cer_install_dir .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_install_dir not found."                         '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_cer_install_dir = ''src_cer_install_dir'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_REVISION_LEVEL:                                                               "), row
       + 1,
      CALL print(
      "$      src_revision_level_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_revision_level_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_revision_level not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_revision_level = ''src_revision_level_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SYSTEM:                                                                       "),
      row + 1,
      CALL print(
      "$      src_system_value = lable_value                                                 "), row
       + 1,
      CALL print(
      '$      if src_system_value .eqs. ""                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_system not found."                                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_system = ''src_system_value'"                                  ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SYSTEM_PWD:                                                                   "), row
       + 1,
      CALL print(
      "$      src_system_pwd_value = lable_value                                             "),
      row + 1,
      CALL print(
      '$      if src_system_pwd_value .eqs. ""                                               '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_system_pwd not found."                              '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_system_pwd = ''src_system_pwd_value'"                          ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   OFFLINE_DICT_IND:                                                                 "), row
       + 1,
      CALL print(
      "$      offline_dict_ind_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if offline_dict_ind_value .eqs. ""                                             '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : offline_dict_ind not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "offline_dict_ind = ''offline_dict_ind_value'"                      ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_DOMAIN_NAME:                                                                  "),
      row + 1,
      CALL print(
      "$      src_domain_name_value = lable_value                                            "), row
       + 1,
      CALL print(
      '$      if src_domain_name_value .eqs. ""                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_domain_name not found."                             '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_domain_name = ''src_domain_name_value'"                        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$   SRC_PRIV:                                                                         "), row
       + 1,
      CALL print(
      "$      src_priv_value = lable_value                                                   "), row
       + 1,
      CALL print(
      '$      if src_priv_value .eqs. ""                                                     '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_priv not found."                                    '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_priv = ''src_priv_value'"                                      ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_PRIV_PWD:                                                                     "),
      row + 1,
      CALL print(
      "$      src_priv_pwd_value = lable_value                                               "), row
       + 1,
      CALL print(
      '$      if src_priv_pwd_value .eqs. ""                                                 '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_priv_pwd not found."                                '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_priv_pwd = ''src_priv_pwd_value'"                              ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_MNG:                                                                          "), row
       + 1,
      CALL print(
      "$      src_mng_value = lable_value                                                    "),
      row + 1,
      CALL print(
      '$      if src_mng_value .eqs. ""                                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_mng not found."                                     '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_mng = ''src_mng_value'"                                        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_MNG_PWD:                                                                      "), row
       + 1,
      CALL print(
      "$      src_mng_pwd_value = lable_value                                                "), row
       + 1,
      CALL print(
      '$      if src_mng_pwd_value .eqs. ""                                                  '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_mng_pwd not found."                                 '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_mng_pwd = ''src_mng_pwd_value'"                                ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_USER_NAME:                                                                "),
      row + 1,
      CALL print(
      "$      src_sec_user_name_value = lable_value                                          "), row
       + 1,
      CALL print(
      '$      if src_sec_user_name_value .eqs. ""                                            '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_user_name not found."                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_user_name = ''src_sec_user_name_value'"                    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_LOCAL_USER_NAME:                                                              "), row
       + 1,
      CALL print(
      "$      src_local_user_name_value = lable_value                                        "),
      row + 1,
      CALL print(
      '$      if src_local_user_name_value .eqs. ""                                          '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_local_user_name not found."                         '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_local_user_name = ''src_local_user_name_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_AUTH_SERVER_ID:                                                               "), row
       + 1,
      CALL print(
      "$      src_auth_server_id_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_auth_server_id_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_auth_server_id not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_auth_server_id = ''src_auth_server_id_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_AUTH_SERVER_DESC:                                                             "),
      row + 1,
      CALL print(
      "$      src_auth_server_desc_value = lable_value                                       "), row
       + 1,
      CALL print(
      '$      if src_auth_server_desc_value .eqs. ""                                         '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_auth_server_desc not found."                        '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_auth_server_desc = ''src_auth_server_desc_value'"              ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_MASTER_ID:                                                         "), row
       + 1,
      CALL print(
      "$      src_tdb_server_master_id_value = lable_value                                   "),
      row + 1,
      CALL print(
      '$      if src_tdb_server_master_id_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_master_id not found."                    '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_master_id = ''src_tdb_server_master_id_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_TDB_SERVER_MASTER_DESC:                                                       "), row
       + 1,
      CALL print(
      "$      src_tdb_server_master_desc_value = lable_value                                 "), row
       + 1,
      CALL print(
      '$      if src_tdb_server_master_desc_value .eqs. ""                                   '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_master_desc not found."                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_master_desc = ''src_tdb_server_master_desc_value'"  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_SLAVE_ID:                                                          "),
      row + 1,
      CALL print(
      "$      src_tdb_server_slave_id_value = lable_value                                    "), row
       + 1,
      CALL print(
      '$      if src_tdb_server_slave_id_value .eqs. ""                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_slave_id not found."                     '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_slave_id = ''src_tdb_server_slave_id_value'"        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_SLAVE_DESC:                                                        "), row
       + 1,
      CALL print(
      "$      src_tdb_server_slave_desc_value = lable_value                                  "),
      row + 1,
      CALL print(
      '$      if src_tdb_server_slave_desc_value .eqs. ""                                    '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_slave_desc not found."                   '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_slave_desc = ''src_tdb_server_slave_desc_value'"    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SCP_SERVER_ID:                                                                "), row
       + 1,
      CALL print(
      "$      src_scp_server_id_value = lable_value                                          "), row
       + 1,
      CALL print(
      '$      if src_scp_server_id_value .eqs. ""                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_scp_server_id not found."                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_scp_server_id = ''src_scp_server_id_value'"                    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SCP_SERVER_DESC:                                                              "),
      row + 1,
      CALL print(
      "$      src_scp_server_desc_value = lable_value                                        "), row
       + 1,
      CALL print(
      '$      if src_scp_server_desc_value .eqs. ""                                          '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_scp_server_desc not found."                         '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_scp_server_desc = ''src_scp_server_desc_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_ID:                                                         "), row
       + 1,
      CALL print(
      "$      src_sec_server_master_id_value = lable_value                                   "),
      row + 1,
      CALL print(
      '$      if src_sec_server_master_id_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_id not found."                    '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_id = ''src_sec_server_master_id_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_LRL:                                                        "), row
       + 1,
      CALL print(
      "$      src_sec_server_master_lrl_value = lable_value                                  "), row
       + 1,
      CALL print(
      '$      if src_sec_server_master_lrl_value .eqs. ""                                    '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_lrl not found."                   '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_lrl = ''src_sec_server_master_lrl_value'"    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_DESC:                                                       "),
      row + 1,
      CALL print(
      "$      src_sec_server_master_desc_value = lable_value                                 "), row
       + 1,
      CALL print(
      '$      if src_sec_server_master_desc_value .eqs. ""                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_desc not found."                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_desc = ''src_sec_server_master_desc_value'"  ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_ID:                                                          "), row
       + 1,
      CALL print(
      "$      src_sec_server_slave_id_value = lable_value                                    "),
      row + 1,
      CALL print(
      '$      if src_sec_server_slave_id_value .eqs. ""                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_id not found."                     '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_id = ''src_sec_server_slave_id_value'"        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_DESC:                                                        "), row
       + 1,
      CALL print(
      "$      src_sec_server_slave_desc_value = lable_value                                  "), row
       + 1,
      CALL print(
      '$      if src_sec_server_slave_desc_value .eqs. ""                                    '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_desc not found."                   '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_desc = ''src_sec_server_slave_desc_value'"    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_LRL:                                                         "),
      row + 1,
      CALL print(
      "$      src_sec_server_slave_lrl_value = lable_value                                   "), row
       + 1,
      CALL print(
      '$      if src_sec_server_slave_lrl_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_lrl not found."                    '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_lrl = ''src_sec_server_slave_lrl_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CCLDIR:                                                                       "), row
       + 1,
      CALL print(
      "$      src_ccldir_value = lable_value                                                 "),
      row + 1,
      CALL print(
      '$      if src_ccldir_value .eqs. ""                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_ccldir not found."                                  '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_ccldir = ''src_ccldir_value'"                                  ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_CCLUSERDIR_DIR:                                                               "), row
       + 1,
      CALL print(
      "$      src_ccluserdir_dir_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_ccluserdir_dir_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_ccluserdir_dir not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_ccluserdir_dir = ''src_ccluserdir_dir_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_OCDTOOLS_DIR:                                                                 "),
      row + 1,
      CALL print(
      "$      src_ocdtools_dir_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_ocdtools_dir_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_ocdtools_dir not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_ocdtools_dir = ''src_ocdtools_dir_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WAREHOUSE_DIR:                                                                "), row
       + 1,
      CALL print(
      "$      src_warehouse_dir_value = lable_value                                          "),
      row + 1,
      CALL print(
      '$      if src_warehouse_dir_value .eqs. ""                                            '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_warehouse_dir not found."                           '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_warehouse_dir = ''src_warehouse_dir_value'"                    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_CER_CONFIG_DIR:                                                               "), row
       + 1,
      CALL print(
      "$      src_cer_config_dir_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_cer_config_dir_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_config_dir not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_cer_config_dir = ''src_cer_config_dir_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SERVER_COUNT:                                                                 "),
      row + 1,
      CALL print(
      "$      src_server_count_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_server_count_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_server_count not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_server_count = ''src_server_count_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_COUNT:                                                                    "), row
       + 1,
      CALL print(
      "$      src_tdb_count_value = lable_value                                              "),
      row + 1,
      CALL print(
      '$      if src_tdb_count_value .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_count not found."                               '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_count = ''src_tdb_count_value'"                            ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_DB_ENV_NAME:                                                                  "), row
       + 1,
      CALL print(
      "$      src_db_env_name_value = lable_value                                            "), row
       + 1,
      CALL print(
      '$      if src_db_env_name_value .eqs. ""                                              '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_db_env_name_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_db_env_name_value = ''src_db_env_name_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WAS_ARCH_IND:                                                                 "),
      row + 1,
      CALL print(
      "$      src_was_arch_ind_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_was_arch_ind_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error :src_was_arch_ind_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_was_arch_ind_value = ''src_was_arch_ind_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   NODE_NAME:                                                                        "), row
       + 1,
      CALL print(
      "$      node_cnt = node_cnt + 1                                                        "),
      row + 1,
      CALL print(
      "$      src_node_name'node_cnt = lable_value                                           "), row
       + 1,
      CALL print(
      ^$      if src_node_name'node_cnt .eqs. ""                                             ^), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      ^$         call echo2 "error : src_node_name ''node_cnt' not found."                   ^), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      tmp_node_name = src_node_name'node_cnt                                         "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_node_name''node_cnt' = ''tmp_node_name'"                       ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_CURPAGES:                                                                 "),
      row + 1,
      CALL print(
      "$      src_tdb_curpages_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_tdb_curpages_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_curpages not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_curpages = ''src_tdb_curpages_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_MAXPAGES:                                                                 "), row
       + 1,
      CALL print(
      "$      src_tdb_maxpages_value = lable_value                                           "),
      row + 1,
      CALL print(
      '$      if src_tdb_maxpages_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_maxpages not found."                            '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_maxpages = ''src_tdb_maxpages_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_TDB_INIT_SIZE:                                                                "), row
       + 1,
      CALL print(
      "$      src_tdb_init_size_value = lable_value                                          "), row
       + 1,
      CALL print(
      '$      if src_tdb_init_size_value .eqs. ""                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_init_size not found."                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_init_size = ''src_tdb_init_size_value'"                    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      "$CHECK_DATA:                                                                          "),
      row + 1,
      CALL print(
      "$   err_msg = f$message($status)                                                      "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error opening file ''src_tmp_dir'misc_data.dat"                       ^), row
       + 1,
      CALL print(
      "$   call echo2 'err_msg'                                                              "),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$END_READ_DATA:                                                                       "),
      row + 1,
      CALL print(
      "$   close SRC_DATA                                                                    "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!---------------------                                                               "),
      row + 1,
      CALL print(
      "$!check src wh sav file                                                               "), row
       + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      ^$call echo1 "Find file ''src_tmp_dir'''src_env'_''src_wh_value'.sav"                  ^),
      row + 1,
      CALL print(
      ^$if f$search("''src_tmp_dir'''src_env'_''src_wh_value'.sav") .eqs. ""                 ^), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : failed to find ''src_tmp_dir'''src_env'_''src_wh_value'.sav"  ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$!check for target wh                                                                 "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "),
      row + 1,
      CALL print(
      '$call echo1 "Check for target warehouse"                                              '), row
       + 1,
      CALL print(
      ^$tgt_wh_exist = f$search("''tgt_wh_device':[cerner.w_standard.''tgt_wh']*.dir")       ^), row
       + 1,
      CALL print(
      '$if tgt_wh_exist .eqs. "" then goto TGT_WH_NOT_FOUND                                  '),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$!target wh found                                                                     "),
      row + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$TGT_WH_FOUND:                                                                        "), row
       + 1,
      CALL print(
      '$   call echo1 "Target wh exists"                                                     '),
      row + 1,
      CALL print(
      "$!  ---------------------------------------------                                     "), row
       + 1,
      CALL print(
      "$!  get warehouse for all environments on the node                                    "), row
       + 1,
      CALL print(
      "$!  ----------------------------------------------                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Get warehouse for all environments"                                   '), row
       + 1,
      dcrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'env_list.dat") .nes. "" then ^,
       " delete 'tgt_tmp_full_dir'env_list.dat;* "),
      CALL print(dcrf_line), row + 1,
      dcrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'wh_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'wh_list.dat;*"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$   define sys$output 'tgt_tmp_full_dir'env_list.dat                                  "), row
       + 1,
      CALL print(
      "$mcr cer_exe:lregview                                                                 "),
      row + 1,
      CALL print(
      "cd \environment                                                                       "), row
       + 1,
      CALL print(
      "dir                                                                                   "), row
       + 1,
      CALL print(
      "exit                                                                                  "),
      row + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   env_cnt = 0                                                                       "), row
       + 1,
      CALL print(
      "$   common_share_wh = 0                                                               "),
      row + 1,
      CALL print(
      "$   wh_ind = 0                                                                        "), row
       + 1,
      CALL print(
      ^$   wh_array'wh_ind = "Warehouse List"                                                ^), row
       + 1,
      CALL print(
      "$   open/read/error=CHECK_ENV_LIST ENV_LIST 'tgt_tmp_full_dir'ENV_LIST.dat            "),
      row + 1,
      CALL print(
      "$   open/write WH_LIST 'tgt_tmp_full_dir'wh_list.dat                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   READ_ENV_LIST:                                                                    "),
      row + 1,
      CALL print(
      "$      read/end_of_file=END_READ_ENV_LIST ENV_LIST record                             "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "),
      row + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            env_cnt = env_cnt + 1                                                    "), row
       + 1,
      CALL print(
      "$            env_name'env_cnt = f$extract(1, end_pos-1, record)                       "),
      row + 1,
      CALL print(
      ^$            tmp_env_name = f$edit(env_name'env_cnt, "upcase")                        ^), row
       + 1,
      CALL print(
      ^$            call echo1 "environment_name : '' tmp_env_name'"                         ^), row
       + 1,
      CALL print(
      "$            set noon                                                                 "),
      row + 1,
      CALL print(
      "$            define/user_mode sys$error nl:                                           "), row
       + 1,
      CALL print(
      ^$            mcr cer_exe:lreg -getp \environment\'tmp_env_name' "warehouse1"          ^), row
       + 1,
      CALL print(
      "$            if $status                                                               "),
      row + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               set on                                                                "), row
       + 1,
      CALL print(
      ^$               env_wh'env_cnt = lreg_result - """" - """"                            ^),
      row + 1,
      CALL print(
      ^$               tmp_env_wh = f$edit(env_wh'env_cnt, "upcase")                         ^), row
       + 1,
      CALL print(
      ^$               call echo1 "warehouse :  ''tmp_env_wh'"                               ^), row
       + 1,
      CALL print(
      "$               i = 0                                                                 "),
      row + 1,
      CALL print(
      '$               found = "F"                                                           '), row
       + 1,
      CALL print(
      "$               FIND_LOOP:                                                            "), row
       + 1,
      CALL print(
      "$                  if (i .le. wh_ind)                                                 "),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     if (tmp_env_wh .eqs. wh_array'i)                                "), row
       + 1,
      CALL print(
      "$                     then                                                            "),
      row + 1,
      CALL print(
      '$                        found = "T"                                                  '), row
       + 1,
      CALL print(
      "$                     endif                                                           "), row
       + 1,
      CALL print(
      "$                     i = i + 1                                                       "),
      row + 1,
      CALL print(
      "$                     goto FIND_LOOP                                                  "), row
       + 1,
      CALL print(
      "$                  endif                                                              "), row
       + 1,
      CALL print(
      "$               wh_ind = wh_ind + 1                                                   "),
      row + 1,
      CALL print(
      "$               wh_array'wh_ind = tmp_env_wh                                          "), row
       + 1,
      CALL print(
      "$               END_FIND_LOOP:                                                        "), row
       + 1,
      CALL print(
      '$                  if (found .eqs. "F")                                               '),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     write WH_LIST "\''tmp_env_wh' "                                 ^), row
       + 1,
      CALL print(
      "$                  endif                                                              "),
      row + 1,
      CALL print(
      "$               if tmp_env_wh .eqs. tgt_wh                                            "), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      '$                  if tmp_env_name .eqs. "COMMON"                                     '),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     call echo2 "common environment warehouse : ''tmp_env_wh'"       ^), row
       + 1,
      CALL print(
      "$                     common_wh = tmp_env_wh                                          "),
      row + 1,
      CALL print(
      "$                     common_share_wh = 1                                             "), row
       + 1,
      CALL print(
      "$                  else                                                               "), row
       + 1,
      CALL print(
      '$                     if (tmp_env_name .nes. "ADMIN") .and. (tmp_env_name .nes. tgt_env)'),
      row + 1,
      CALL print(
      "$                     then                                                            "), row
       + 1,
      CALL print(
      ^$                        call echo2 "warehouse ''tgt_wh'  is used for environment ''tmp_env_name'."^
      ), row + 1,
      CALL print(
      '$                        call echo2 "this process cannot be used to refresh the domain."'),
      row + 1,
      CALL print(
      "$                        error = 1                                                    "), row
       + 1,
      CALL print(
      "$                        goto EXIT_SCRIPT                                             "), row
       + 1,
      CALL print(
      "$                     endif !not admin and tgt_env                                    "),
      row + 1,
      CALL print(
      "$                  endif !common                                                      "), row
       + 1,
      CALL print(
      "$               endif !eqs tgt_wh                                                     "), row
       + 1,
      CALL print(
      "$            endif !$status                                                           "),
      row + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !start with \                                                            "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_ENV_LIST                                                             "), row
       + 1,
      CALL print(
      "$   CHECK_ENV_LIST:                                                                   "),
      row + 1,
      CALL print(
      "$      env_err_msg = f$message($status)                                               "), row
       + 1,
      CALL print(
      ^$      call echo2 "error opening file ''tgt_tmp_full_dir'env_list.dat"                ^), row
       + 1,
      CALL print(
      "$      call echo2 'env_err_msg'                                                       "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_ENV_LIST:                                                                "),
      row + 1,
      CALL print(
      "$      close ENV_LIST                                                                 "), row
       + 1,
      CALL print(
      "$      close WH_LIST                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   wh_cnt = 0                                                                        "), row
       + 1,
      CALL print(
      "$   open/read/error=CHECK_WH_LIST WH_LIST 'tgt_tmp_full_dir'wh_list.dat               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   READ_WH_LIST:                                                                     "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_WH_LIST WH_LIST record                               "),
      row + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '), row
       + 1,
      CALL print(
      "$         length = f$length(record)                                                   "),
      row + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            wh_cnt = wh_cnt + 1                                                      "), row
       + 1,
      CALL print(
      "$            wh_name'wh_cnt = f$extract(1, end_pos-1, record)                         "), row
       + 1,
      CALL print(
      ^$            wh_name'wh_cnt = f$edit(wh_name'wh_cnt, "upcase")                        ^),
      row + 1,
      CALL print(
      "$            tmp_wh_name = wh_name'wh_cnt                                             "), row
       + 1,
      CALL print(
      "$            if tmp_wh_name .nes. tgt_wh                                              "), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               call echo2 'tmp_wh_name'                                              "), row
       + 1,
      CALL print(
      "$            else                                                                     "), row
       + 1,
      CALL print(
      "$               call echo1  'tmp_wh_name'                                             "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !start with \                                                            "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_WH_LIST                                                              "), row
       + 1,
      CALL print(
      "$   CHECK_WH_LIST:                                                                    "),
      row + 1,
      CALL print(
      "$      wh_err_msg = f$message($status)                                                "), row
       + 1,
      CALL print(
      ^$      call echo2 "Error opening file ''tgt_tmp_full_dir'wh_list.dat"                 ^), row
       + 1,
      CALL print(
      "$      call echo2 'wh_err_msg'                                                        "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_WH_LIST:                                                                 "),
      row + 1,
      CALL print(
      "$      close WH_LIST                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if wh_cnt .eq. 1                                                                  "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      tgt_wh_only = 1                                                                "), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      "$      tgt_wh_only = 0                                                                "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   call echo1 "common_share_wh = ''common_share_wh'"                                 ^),
      row + 1,
      CALL print(
      ^$   call echo1 "tgt_wh_only = ''tgt_wh_only'"                                         ^), row
       + 1,
      CALL print(
      "$   if (common_share_wh .eq. 1) .and. (tgt_wh_only .eq. 0)                            "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$!  ----------------------------------                                                "), row
       + 1,
      CALL print(
      "$!  Prompt to change common warehouse                                                 "), row
       + 1,
      CALL print(
      "$!  ---------------------------------                                                 "),
      row + 1,
      CALL print(
      "$   PROMPT_COMMON_WH:                                                                 "), row
       + 1,
      dcrf_line = concat(
       '$      inquire common_new_wh "Please choose a new warehouse for common from ',
       'list above or enter [Q] to Quit" '),
      CALL print(dcrf_line), row + 1,
      CALL print(
      '$      if common_new_wh .eqs. "" then goto PROMPT_COMMON_WH                           '), row
       + 1,
      CALL print(
      '$      if common_new_wh .eqs. "Q"                                                     '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "User choose to quit when selecting a new common warehouse."     '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "common_new_wh = ''common_new_wh'"                                  ^),
      row + 1,
      CALL print(
      "$      wh_count = 0                                                                   "), row
       + 1,
      CALL print(
      "$      new_wh_fnd = 0                                                                 "), row
       + 1,
      CALL print(
      "$      WH_LOOP:                                                                       "),
      row + 1,
      CALL print(
      "$         wh_count = wh_count + 1                                                     "), row
       + 1,
      CALL print(
      "$         if (wh_count .le. wh_cnt) .and. (new_wh_fnd .eq. 0)                         "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$!           write sys$output wh_name'wh_count                                        "), row
       + 1,
      CALL print(
      "$            if (wh_name'wh_count .eqs.common_new_wh) .and. (wh_name'wh_count .nes. tgt_wh)"),
      row + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               new_wh_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$            goto WH_LOOP                                                             "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      ^$      call echo1 "new_wh_fnd = ''new_wh_fnd'"                                        ^), row
       + 1,
      CALL print(
      "$      if new_wh_fnd .eq. 0                                                           "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "''common_new_wh' is not in the warehouse list."                 ^), row
       + 1,
      CALL print(
      "$         goto PROMPT_COMMON_WH                                                       "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      dcrf_line = concat(^$      inquire answer "Change common warehouse from ''common_wh' to ^,
       ^''common_new_wh' [C]ontinue or [Q]uit"^),
      CALL print(dcrf_line), row + 1,
      CALL print(
      ^$      call echo1 "answer = ''answer'"                                                ^), row
       + 1,
      CALL print(
      '$      if answer .eqs. "Q"                                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "User choose to quit when modifying common warehouse."           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -setp \environment\common "wh_changed" "Y"                    '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      common_new_prop = f$edit(lreg_result, "upcase")                                '), row
       + 1,
      CALL print(
      '$      if common_new_prop .nes. "Y"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to add new property wh_changed for common."              '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print("$      set noon                                                                 "),
      row + 1,
      CALL print('$      lreg_result = "NOT_FOUND"                                                '),
      row + 1,
      CALL print('$      mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"        '),
      row + 1,
      CALL print("$      set on                                                                   "),
      row + 1,
      CALL print(^$      call echo1 "lreg_result  = ''lreg_result'"                               ^),
      row + 1,
      CALL print('$      if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                       '),
      row + 1,
      CALL print("$      then                                                                     "),
      row + 1,
      CALL print('$      call echo1 "Note: "unable to get property" is an acceptable error"        '),
      row + 1,
      CALL print("$      endif                                                                    "),
      row + 1,
      CALL print('$      if f$edit(lreg_result, "UPCASE") .nes. "Y"                               '),
      row + 1,
      CALL print("$      then                                                                     "),
      row + 1,
      CALL print("$         set noon                                                              "),
      row + 1,
      CALL print('$         mcr cer_exe:lreg -setp "\environment\common" "common_wh_switched"  "Y"'),
      row + 1,
      CALL print('$         lreg_result = "NOT_FOUND"                                             '),
      row + 1,
      CALL print('$         mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"     '),
      row + 1,
      CALL print("$         set on                                                                "),
      row + 1,
      CALL print(^$         call echo1 "lreg_result  = ''lreg_result'"                            ^),
      row + 1,
      CALL print('$         if f$edit(lreg_result, "upcase") .nes. "Y"                            '),
      row + 1,
      CALL print("$         then                                                                  "),
      row + 1,
      CALL print(
      '$            call echo2 "Failed to add new property common_wh_switched for common." '),
      row + 1,
      CALL print("$            error = 1                                                          "),
      row + 1,
      CALL print("$            goto EXIT_SCRIPT                                                   "),
      row + 1,
      CALL print("$         endif                                                                 "),
      row + 1,
      CALL print("$      endif                                                                    "),
      row + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      ^$      mcr cer_exe:lreg -setp \environment\common "warehouse1" "''common_new_wh'"        ^),
      row + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "warehouse1"                        '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_changed_wh = f$edit(lreg_result, "upcase")                              '),
      row + 1,
      CALL print(
      ^$      call echo1 "common_changed_wh = ''common_changed_wh'"                          ^), row
       + 1,
      CALL print(
      "$      if common_changed_wh .nes. common_new_wh                                       "), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      ^$         call echo2 "Failed to change common warehouse to ''common_new_wh'"          ^), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   endif  !(common_share_wh .eq. 1) .and. (tgt_wh_only .eq. 0)                       "), row
       + 1,
      CALL print(
      "$   if (tgt_wh_only .eq. 0)                                                           "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------                                            "), row
       + 1,
      CALL print("$!  Prompt to change common warehouse                                             "
      ),
      row + 1,
      CALL print(
      "$!  --------------------------------------                                            "), row
       + 1,
      CALL print(
      "$PROMPT_COMMON_AGAIN:                                                                 "), row
       + 1,
      CALL print('$      call echo1 "Prompt to change common warehouse."                           '),
      row + 1, dcrf_line = concat(
       '$      inquire answer "Would you like to change common warehouse after ',
       "target warehouse is rebuilt [Y]es or [N]o"),
      CALL print(dcrf_line),
      row + 1, dcrf_line = concat(
       '$      if (answer .nes. "Y") .and. (answer .nes. "y") .and. (answer .nes. "YES") .and. ',
       '(answer .nes. "yes") .and. (answer .nes. "Yes") .and. (answer .nes. "N").and. (answer .nes. "n") ',
       '.and. (answer .nes. "NO") .and. (answer .nes. "no") .and. (answer .nes. "No")'),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         goto PROMPT_COMMON_AGAIN                                                    "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1, dcrf_line = concat(
       '$      if (answer .eqs. "Y") .or. (answer .eqs. "y") .or. (answer .eqs. "Yes") ',
       '.or. (answer .eqs. "yes") .or. (answer .eqs. "YES")'),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         PROMPT_COMMON_BACK:                                                         "), row
       + 1,
      CALL print(
      "$            wh_count = 0                                                             "),
      row + 1,
      CALL print(
      "$            WH_BACK_LOOP:                                                            "), row
       + 1,
      CALL print(
      "$               wh_count = wh_count + 1                                               "), row
       + 1,
      CALL print(
      "$               if wh_count .le. wh_cnt                                               "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  tmp_wh_name = wh_name'wh_count                                     "), row
       + 1,
      CALL print(
      "$                  if tmp_wh_name .nes.common_new_wh                                  "),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     call echo2 'tmp_wh_name'                                        "), row
       + 1,
      CALL print(
      "$                  endif                                                              "),
      row + 1,
      CALL print(
      "$                  goto WH_BACK_LOOP                                                  "), row
       + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1, dcrf_line = concat(
       '$            inquire common_back_wh "Please choose a warehouse for common ',
       "to change to from list above"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$            wh_count = 0                                                             "),
      row + 1,
      CALL print(
      "$            new_wh_fnd = 0                                                           "), row
       + 1,
      CALL print(
      "$            WH_AGAIN_LOOP:                                                           "), row
       + 1,
      CALL print(
      "$               wh_count = wh_count + 1                                               "),
      row + 1,
      CALL print(
      "$               if (wh_count .le. wh_cnt) .and. (new_wh_fnd .eq. 0)                   "), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$!                 write sys$output wh_name'wh_count                                  "),
      row + 1,
      CALL print(
      "$                  if (wh_name'wh_count .eqs.common_back_wh) .and. (wh_name'wh_count .nes.common_new_wh)"
      ), row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     new_wh_fnd = 1                                                  "),
      row + 1,
      CALL print(
      "$                  endif                                                              "), row
       + 1,
      CALL print(
      "$                  goto WH_AGAIN_LOOP                                                 "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      ^$            call echo1 "new_wh_fnd = ''new_wh_fnd'"                                  ^), row
       + 1,
      CALL print(
      "$            if new_wh_fnd .eq. 0                                                     "), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      ^$               call echo2 "''common_back_wh' is not in the warehouse list."          ^), row
       + 1,
      CALL print(
      "$               goto PROMPT_COMMON_BACK                                               "), row
       + 1,
      CALL print(
      "$            endif                                                                    "),
      row + 1,
      CALL print(
      "$            set noon                                                                 "), row
       + 1,
      CALL print(
      ^$            mcr cer_exe:lreg -setp "\environment\common" "wh_changed_again"  "''common_back_wh'"^
      ), row + 1,
      CALL print(
      '$            lreg_result = "NOT_FOUND"                                                '),
      row + 1,
      CALL print(
      '$            mcr cer_exe:lreg -getp "\environment\common" "wh_changed_again"          '), row
       + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      ^$            call echo1 "lreg_result  = ''lreg_result'"                               ^),
      row + 1,
      CALL print(
      ^$            call echo1 "common_back_wh = ''common_back_wh'"                          ^), row
       + 1,
      CALL print(
      '$            if f$edit(lreg_result, "upcase") .nes. common_back_wh                    '), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      '$               call echo2 "Failed to add new property wh_changed_again for common."  '), row
       + 1,
      CALL print(
      "$               error = 1                                                             "), row
       + 1,
      CALL print(
      "$               goto EXIT_SCRIPT                                                      "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$            set noon                                                                 "), row
       + 1,
      CALL print(
      '$            lreg_result = "NOT_FOUND"                                                '),
      row + 1,
      CALL print(
      '$            mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"        '), row
       + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      ^$            call echo1 "lreg_result  = ''lreg_result'"                               ^),
      row + 1,
      CALL print(
      '$            if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                       '), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      '$               call echo1 "Note: "unable to get property" is an acceptable error"     '),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      '$            if f$edit(lreg_result, "UPCASE") .nes. "Y"                               '), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               set noon                                                              "), row
       + 1,
      CALL print(
      '$               mcr cer_exe:lreg -setp "\environment\common" "common_wh_switched"  "Y"'), row
       + 1,
      CALL print(
      '$               lreg_result = "NOT_FOUND"                                             '),
      row + 1,
      CALL print(
      '$               mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"     '), row
       + 1,
      CALL print(
      "$               set on                                                                "), row
       + 1,
      CALL print(
      ^$               call echo1 "lreg_result  = ''lreg_result'"                            ^),
      row + 1,
      CALL print(
      '$               if f$edit(lreg_result, "upcase") .nes. "Y"                            '), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      '$                  call echo2 "Failed to add new property common_wh_switched for common." '),
      row + 1,
      CALL print(
      "$                  error = 1                                                          "), row
       + 1,
      CALL print(
      "$                  goto EXIT_SCRIPT                                                   "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      '$      endif !(answer .eqs. "Y") .or. (answer .eqs. "y")                              '), row
       + 1,
      CALL print(
      "$   endif !(tgt_wh_only .eq. 0)                                                       "),
      row + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      "$!  -----------------------                                                           "), row
       + 1,
      CALL print(
      "$!  terminate all servers                                                             "),
      row + 1,
      CALL print(
      "$!  -----------------------                                                           "), row
       + 1,
      CALL print(
      '$  call echo2 "Terminate all servers"                                                 '), row
       + 1,
      CALL print(
      "$mcr cer_exe:cmbview -dom 'tgt_domain_name'                                           "),
      row + 1,
      CALL print(
      "kill -all                                                                             "), row
       + 1,
      CALL print(
      "exit                                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   SRV_LOOP:                                                                         "), row
       + 1,
      CALL print(
      "$      if loop .ge. 20 then goto END_SRV_LOOP                                         "),
      row + 1,
      CALL print(
      "$      wait 00:00:15                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^),
      row + 1,
      CALL print(
      "$      gosub find_server                                                              "), row
       + 1,
      CALL print(
      "$      if srv_cnt .eq. 0 then goto END_SRV_LOOP                                       "), row
       + 1,
      CALL print(
      "$      goto SRV_LOOP                                                                  "),
      row + 1,
      CALL print(
      "$   END_SRV_LOOP:                                                                     "), row
       + 1,
      CALL print(
      "$      if srv_cnt .ne. 0                                                              "), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      "$         gosub kill_server                                                           "), row
       + 1,
      CALL print(
      "$      else                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "All servers are terminated by kill all."                        '),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!  ---------------                                                                   "), row
       + 1,
      CALL print(
      "$!  clean up memory                                                                   "),
      row + 1,
      CALL print(
      "$!  ---------------                                                                   "), row
       + 1,
      CALL print(
      '$   call echo1 "Execute terminate_cmb"                                                '), row
       + 1,
      CALL print(
      "$@cer_proc:terminate_cmb 'tgt_domain_name' 0 y n                                      "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Search for server instance"                                           '), row
       + 1,
      CALL print(
      '$   cmb_instance = "not_found"                                                        '),
      row + 1,
      CALL print(
      '$   cmb_instance = f$trnlnm("cmb_instance")                                           '), row
       + 1,
      CALL print(
      '$   if (cmb_instance .eqs. "not_found") .or. (cmb_instance .eqs. "")                  '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "cmb_instance is not defined."                                      '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*_'cmb_instance'/out='tgt_tmp_full_dir'srv_proc.dat         "), row
       + 1,
      CALL print(
      "$   proc_cnt = 0                                                                      "),
      row + 1,
      CALL print(
      "$   open/read/error=CHECK_SRV_PROC SRV_PROC_DAT 'tgt_tmp_full_dir'srv_proc.dat        "), row
       + 1,
      CALL print(
      "$   open/write SRV_PROC_COM 'tgt_tmp_full_dir'srv_proc.com                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   READ_SRV_PROC:                                                                    "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_SRV_PROC SRV_PROC_DAT record                         "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      if char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            proc_cnt = proc_cnt + 1                                                  "), row
       + 1,
      CALL print(
      "$            proc_id'proc_cnt = f$extract(0, end_pos, record)                         "),
      row + 1,
      CALL print(
      "$            tmp_proc_id = proc_id'proc_cnt                                           "), row
       + 1,
      CALL print(
      "$!           write sys$output tmp_proc_id                                             "), row
       + 1,
      CALL print(
      ^$            write SRV_PROC_COM "stop process/id=''tmp_proc_id'"                      ^),
      row + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !char_type                                                               "), row
       + 1,
      CALL print(
      "$!     write sys$output record                                                        "),
      row + 1,
      CALL print(
      "$      goto READ_SRV_PROC                                                             "), row
       + 1,
      CALL print(
      "$   CHECK_SRV_PROC:                                                                   "), row
       + 1,
      CALL print(
      "$      srv_err_msg = f$message($status)                                               "),
      row + 1,
      CALL print(
      ^$      call echo2 "Error opening file ''tgt_tmp_full_dir'srv_proc.dat"                ^), row
       + 1,
      CALL print(
      "$      call echo2 'srv_err_msg'                                                       "), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "),
      row + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_SRV_PROC:                                                                "), row
       + 1,
      CALL print(
      "$      close SRV_PROC_DAT                                                             "),
      row + 1,
      CALL print(
      "$      close SRV_PROC_COM                                                             "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if proc_cnt .gt. 0                                                                "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Stop server proccess."                                             '), row
       + 1,
      CALL print(
      "$@'tgt_tmp_full_dir'srv_proc.com                                                      "),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "No server process found."                                          '), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Execute delete_cmb_gs.com"                                            '), row
       + 1,
      CALL print(
      '$   if f$search("cer_proc:delete_cmb_gs.com") .nes. ""                                '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      @cer_proc:delete_cmb_gs 'tgt_domain_name'                                      "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Delete the audit and code cache"                                      '), row
       + 1,
      CALL print(
      "$mcr cer_exe:auditconf -destroy                                                       "),
      row + 1,
      CALL print(
      "$mcr cer_exe:code -destroy                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   lreg_result = "not_found"                                                         '),
      row + 1,
      CALL print(
      "$   set noon                                                                          "), row
       + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp \environment\common "wh_changed"                           '),
      row + 1,
      CALL print(
      "$   set on                                                                            "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                                '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo1 "Note: "unable to get property" is an acceptable error"              '), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "upcase") .eqs. "Y"                                        '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      common_new_prop_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      "$      common_new_prop_fnd = 0                                                        "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   call echo1 "common_new_prop_fnd = ''common_new_prop_fnd'"                         ^),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if common_new_prop_fnd .eq. 0 then goto WH_CHANGE_NOT_FND                         "), row
       + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "),
      row + 1,
      CALL print(
      "$!  common warehouse changed.  Cycle controller, domain dir and resolver              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "), row
       + 1,
      CALL print(
      "$   WH_CHANGE_FND:                                                                    "),
      row + 1,
      CALL print(
      '$      call echo2 "Common new property found.  Cycle controller,domain directory and resolver"'
      ), row + 1,
      CALL print(
      "$mcr cer_mgr_exe:start_cerner_500 -env common -verbose -noinst                        "), row
       + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "),
      row + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "), row
       + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$      call echo2 "Remove wh_changed property for common"                             '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_new_prop = f$edit(lreg_result, "upcase")                                '),
      row + 1,
      CALL print(
      '$      if common_new_prop .eqs. "Y"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete property wh_changed for common."               '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "), row
       + 1,
      CALL print(
      "$!  target warehouse only.  Shutdown controller, domain dir and resolver              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "),
      row + 1,
      CALL print(
      "$   WH_CHANGE_NOT_FND:                                                                "), row
       + 1,
      CALL print(
      "$   if tgt_wh_only .eq. 1                                                             "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Target warehouse only.  Shutdown controller, domain dir and resolver."'),
      row + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!  ---------------------------------------                                           "), row
       + 1,
      CALL print(
      "$!  de-install target warehouse from memory                                           "), row
       + 1,
      CALL print(
      "$!  ---------------------------------------                                           "),
      row + 1,
      CALL print(
      "$      mcr cer_mgr_exe:shutdown_cerner_500 -deinstall 'tgt_wh'                        "), row
       + 1,
      CALL print(
      "$!  ------------------------                                                          "), row
       + 1,
      CALL print(
      "$!  delete target warehouse                                                           "),
      row + 1,
      CALL print(
      "$!  ------------------------                                                          "), row
       + 1,
      CALL print(
      '$   call echo2 "Delete Target warehouse."                                             '), row
       + 1,
      CALL print(
      "$   loop = 0                                                                          "),
      row + 1,
      CALL print(
      '$   saveMessage = f$environment("message")                                            '), row
       + 1,
      CALL print(
      "$   set message /nofacility /noidentification /noseverity /notext                     "), row
       + 1,
      CALL print(
      "$   DEL_TGT_WH:                                                                       "),
      row + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      "$      delete 'tgt_wh_device':[cerner.w_standard.'tgt_wh'...]*.*;*                    "), row
       + 1,
      CALL print(
      "$      if $STATUS                                                                     "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         set message 'saveMessage'                                                   "), row
       + 1,
      CALL print(
      '$         call echo2 "Target warehouse has been deleted successfully."                '),
      row + 1,
      CALL print(
      "$      else                                                                           "), row
       + 1,
      CALL print(
      "$         if loop .eq. 10                                                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            set message 'saveMessage'                                                "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to delete Target warehouse."                          '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "), row
       + 1,
      CALL print(
      "$            goto DEL_TGT_WH                                                          "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif !$status                                                                 "), row
       + 1,
      CALL print(
      "$!  --------------------------                                                        "),
      row + 1,
      CALL print(
      "$!  Target warehouse not found                                                        "), row
       + 1,
      CALL print(
      "$!  --------------------------                                                        "), row
       + 1,
      CALL print(
      "$TGT_WH_NOT_FOUND:                                                                    "),
      row + 1,
      CALL print(
      "$!  --------------------------                                                        "), row
       + 1,
      CALL print(
      "$!  Copy Target warehouse                                                             "), row
       + 1,
      CALL print(
      "$!  --------------------------                                                        "),
      row + 1,
      CALL print(
      '$   call echo2 "Create Target warehouse from the Source warehouse backup."            '), row
       + 1,
      CALL print(
      ^$   tgt_wh_path = "''tgt_wh_device':[cerner.w_standard.''tgt_wh'...]"                 ^), row
       + 1, dcrf_line = concat("$   backup/log 'src_tmp_dir''src_env'_'src_wh_value'.sav ",
       "/save/select=['src_warehouse_dir_value'...] 'tgt_wh_path'"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$   if $status                                                                        "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Target warehouse was created successfully."                        '), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Failed to create Target warehouse."                                '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$  endif                                                                              "), row
       + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      '$   call echo2 "Securing and Installing the Target warehouse into memory."            '),
      row + 1,
      CALL print(
      "$   mcr cer_exe:secure_cerner_500 -wh 'tgt_wh' -verbose 9                             "), row
       + 1,
      CALL print(
      "$   mcr cer_mgr_exe:start_cerner_500 -env 'tgt_env' -install 'tgt_wh'                 "), row
       + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "),
      row + 1,
      CALL print(
      "$!  target warehouse only.  Startup controller, domain dir and resolver               "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "), row
       + 1,
      CALL print(
      "$   if tgt_wh_only .eq. 1                                                             "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Startup server controller, domain directory and resolver when Target wh only"'
      ), row + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "),
      row + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "),
      row + 1,
      CALL print(
      "$!  check offline dictionary                                                          "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      '$   ccldiraccess = f$trnlnm("CCLDIRACCESS")                                           '),
      row + 1,
      CALL print(
      '$   if ccldiraccess .eqs. ""                                                          '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$     call echo2 "Offline dictionary is not configured."                              '),
      row + 1,
      CALL print(
      '$      tgt_ccldir_value= f$trnlnm("CCLDIR")                                           '), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1, dcrf_line = concat(
       '$      call echo2 "Offline dictionary is used.  Verify CCLDIRACCESS is 1WRITE ',
       'and CCLDIR match CCLDIR1."'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      '$      if ccldiraccess .nes. "1WRITE"                                                 '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Change CCLDIRACCESS to 1WRITE."                                 '), row
       + 1,
      CALL print(
      '$         define /group "CCLDIRACCESS" "1WRITE"                                       '),
      row + 1,
      CALL print(
      '$         ccldiraccess = f$trnlnm("CCLDIRACCESS")                                     '), row
       + 1,
      CALL print(
      '$         if ccldiraccess .nes. "1WRITE"                                              '), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      '$            echo2 "Failed to set logical CCLDIRACCESS to 1WRITE."                    '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      '$      lreg_result = "NOT_FOUND"                                                      '),
      row + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1, dcrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess"'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      if f$edit(lreg_result, "upcase") .nes. "1WRITE"                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         set noon                                                                    "),
      row + 1, dcrf_line = concat(
       ^$      mcr cer_exe:lreg -setp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess" "1WRITE"'),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      '$         lreg_result = "NOT_FOUND"                                                   '), row
       + 1,
      dcrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess"'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$         set on                                                                      "), row
       + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. "1WRITE"                             '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to update registry CCLDIRACCESS to 1WRITE."           '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      '$      endif !ccldiraccess .nes. "1WRITE"                                             '),
      row + 1,
      CALL print(
      '$      ccldir= f$trnlnm("CCLDIR")                                                     '), row
       + 1,
      CALL print(
      '$      ccldir1 = f$trnlnm("CCLDIR1")                                                  '), row
       + 1,
      CALL print(
      "$      if ccldir .nes. ccldir1                                                        "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "Change CCLDIR to match CCLDIR1 value ''ccldir1'."               ^), row
       + 1,
      CALL print(
      ^$         define /group "CCLDIR" 'ccldir1'                                            ^),
      row + 1,
      CALL print(
      '$         ccldir = f$trnlnm("CCLDIR")                                                 '), row
       + 1,
      CALL print(
      "$         if ccldir1 .nes. ccldir                                                     "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      ^$            call echo2 "Failed to set logical CCLDIR to ''ccldir1'."                 ^), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      '$      lreg_result = "NOT_FOUND"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1, dcrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldir"'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      if f$edit(lreg_result, "upcase") .nes. ccldir1                                 '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         set noon                                                                    "),
      row + 1, dcrf_line = concat(
       ^$      mcr cer_exe:lreg -setp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       ^environment" "ccldir" "''ccldir1'"^),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      '$         lreg_result = "NOT_FOUND"                                                   '), row
       + 1,
      dcrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldir"'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. ccldir1                              '), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      ^$            call echo2 "Failed to update registry CCLDIR to ''ccldir1'."             ^), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif !ccldir .nes. ccldir1                                                    "), row
       + 1,
      CALL print(
      "$      tgt_ccldir_value = lreg_result                                                 "),
      row + 1,
      CALL print(
      "$      mcr cer_mgr_exe:start_cerner_500 -env 'tgt_env' -verbose                       "), row
       + 1,
      CALL print(
      '$   endif !ccldiraccess .eqs. ""                                                      '), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "),
      row + 1,
      CALL print(
      "$!  delete ccldir and cer_config                                                      "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      ^$   ccldir_fnd = f$search("''tgt_ccldir_value'*.*;*")                                       ^),
      row + 1,
      CALL print(
      '$   if ccldir_fnd .nes. ""                                                            '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Delete CCLDIR."                                                    '),
      row + 1,
      CALL print(
      "$      delete 'tgt_ccldir_value'*.*;*                                                 "), row
       + 1,
      CALL print(
      ^$      ccldir_fnd = f$search("''tgt_ccldir_value'*.*;*")                              ^), row
       + 1,
      CALL print(
      '$      if ccldir_fnd .nes. ""                                                         '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete CCLDIR."                                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      '$   cer_config = f$trnlnm("CER_CONFIG")                                               '), row
       + 1,
      CALL print(
      '$   if cer_config .eqs. ""                                                            '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "CER_CONFIG is not defined."                                        '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   cer_config_fnd = f$search("''cer_config'*.*;*")                                   ^), row
       + 1,
      CALL print(
      '$   if cer_config_fnd .nes. ""                                                        '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Delete CER_CONFIG."                                                '), row
       + 1,
      CALL print(
      "$      delete 'cer_config'*.*;*                                                       "),
      row + 1,
      CALL print(
      ^$      cer_config_fnd = f$search("''cer_config'*.*;*")                                ^), row
       + 1,
      CALL print(
      '$      if cer_config_fnd .nes. ""                                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to delete CER_CONFIG."                                   '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "),
      row + 1,
      CALL print(
      "$!  Copy ccldir and cer_config                                                        "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      '$   call echo2 "Create CCLDIR from Source backup."                                    '),
      row + 1,
      CALL print(
      '$   tgt_ccldir_path = tgt_ccldir_value - "]" + "...]"                                 '), row
       + 1,
      dcrf_line = concat("$   backup/log 'src_tmp_dir''src_env'_ccldir.sav ",
       "/save/select=['src_ccldir_value'...]  'tgt_ccldir_path'"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$   if $status                                                                        "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Create CCLDIR successfully."                                       '), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Failed to create CCLDIR."                                          '),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Create CER_CONFIG from Source backup."                                '), row
       + 1,
      CALL print(
      '$   tgt_config_path = cer_config - "]" + "...]"                                       '),
      row + 1, dcrf_line = concat("$   backup/log 'src_tmp_dir''src_env'_config.sav ",
       "/save/exclude=*.DIR;*/select=['src_cer_config_dir_value'...] 'tgt_config_path' "),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$   if $status                                                                        "), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Create CER_CONFIG successfully."                                   '),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Failed to create CER_CONFIG."                                      '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "),
      row + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   dic_dat = f$search("''tgt_ccldir_value'dic.*;*")                                  ^),
      row + 1,
      CALL print(
      '$   if dic_dat .nes. ""                                                               '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Delete dic.dat from ccldir."                                       '),
      row + 1,
      CALL print(
      "$      delete 'tgt_ccldir_value'dic.*;*                                               "), row
       + 1,
      CALL print(
      ^$      dic_dat = f$search("''tgt_ccldir_value'dic.*;*")                               ^), row
       + 1,
      CALL print(
      '$      if dic_dat .nes. ""                                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete DIC.DAT."                                      '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      '$   call echo2 "Copy Source dic.dat"                                                  '), row
       + 1,
      CALL print(
      "$   copy cer_install:dic.dat 'tgt_ccldir_value'dic.dat                               "), row
       + 1,
      CALL print(
      ^$   dic_dat = f$search("''tgt_ccldir_value'dic.*;*")                                  ^),
      row + 1,
      CALL print(
      '$   if dic_dat .eqs. ""                                                               '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Failed to copy Source dic.dat."                                    '),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(concat("$   set file/own=",ddr_domain_data->tgt_local_user_name,
       " 'tgt_ccldir_value'dic.dat;*")), row + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      "$!  Clean ccldir and cer_config                                                       "),
      row + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      '$   call echo2 "Clean CCLDIR."                                                        '), row
       + 1,
      CALL print(
      "$   delete 'tgt_ccldir_value'*.*;* /exclude=(*.dat;*,*bcheck*;*)                      "),
      row + 1,
      CALL print(
      '$   call echo2 "Clean CER_CONFIG."                                                    '), row
       + 1,
      dcrf_line = concat("$   delete 'cer_config'*.*;* /exclude=(core.il;*,msg_table.dat;*,",
       "'src_sec_user_name_value'",".dat;*,","'src_sec_user_name_value'",".idx;*,",
       "tdb_system.dat;*,tdb_system.idx;*, jou*.dat;*)"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      ^$   call echo1 "Renaming sec_user files in cer_config from ''src_sec_user_name_value' to match target."^
      ), row + 1, dcrf_line = concat('$   if src_sec_user_name_value .nes. "',trim(ddr_domain_data->
        tgt_sec_user_name),'"'),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1, dcrf_line = concat("$      rename 'cer_config''src_sec_user_name_value'.*;* ",
       "'cer_config'",ddr_domain_data->tgt_sec_user_name,".*;*"),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   set noon                                                                          "),
      row + 1,
      CALL print(
      '$   lreg_result = "NOT_FOUND"                                                         '), row
       + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp "\environment\common" "wh_changed_again"                   '),
      row + 1,
      CALL print(
      "$   set on                                                                            "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                                '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo1 "Note: "unable to get property" is an acceptable error"              '), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   if lreg_result .nes. "NOT_FOUND"                                                  '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print("$!  change common warehouse                                                      "),
      row + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      '$      common_back_wh = f$edit(lreg_result, "upcase")                                 '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp "\environment\common" "warehouse1"                      '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_cur_wh = f$edit(lreg_result, "upcase")                                  '),
      row + 1,
      CALL print(
      "$      if common_cur_wh .nes. common_back_wh                                          "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1, dcrf_line = concat(
       ^$         call echo2 "Change common warehouse from ''common_cur_wh' to ^,^''common_back_wh'"^
       ),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$         set noon                                                                    "),
      row + 1,
      CALL print(
      ^$         mcr cer_exe:lreg -setp "\environment\common" "warehouse1" "''common_back_wh'"  ^),
      row + 1,
      CALL print(
      '$         mcr cer_exe:lreg -getp "\environment\common" "warehouse1"                   '), row
       + 1,
      CALL print(
      "$         set on                                                                      "),
      row + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. common_back_wh                       '), row
       + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      ^$            call echo2 "Failed to change common warehouse to ''common_back_wh'."     ^),
      row + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "),
      row + 1,
      CALL print(
      "$      endif !common_cur_wh .nes. common_back_wh                                      "), row
       + 1,
      CALL print(
      '$      call echo2 "Remove wh_changed_again property for common"                       '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "wh_changed_again"                  '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed_again"                  '), row
       + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      if lreg_result .nes. "not_found"                                               '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete property wh_changed_again for common."         '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$   endif !wh_changed_again found                                                     "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   set noon                                                                          "),
      row + 1,
      CALL print(
      '$   lreg_result = "NOT_FOUND"                                                         '), row
       + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"                 '),
      row + 1,
      CALL print(
      "$   set on                                                                            "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                                '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo1 "Note: "unable to get property" is an acceptable error"              '), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "Y"                                        '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                     "),
      row + 1,
      CALL print(
      "$!     common_wh_switched found                                                          "),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                     "),
      row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*                               Install Cerner                                     *"'
      ),
      row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*Open another session and execute Install_cerner as shown below.                   *"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*Answer the prompts according to the output below.                                 *"'
      ),
      row + 1,
      CALL print(
      '$      call echo2 "*Do not continue until Install_Cerner completes successfully.                      *"'
      ), row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      call echo2 "Using install_cerner to refresh core components.                                    "'
      ),
      row + 1, dcsrf_line = concat(
       ^$      call echo2 "mcr ''tgt_wh_device':[cerner.w_standard.''tgt_wh'.vmsalpha]install_cerner.exe ^,
       '-core -verbose"'),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      '$      call echo2 ""                                                                  '), row
       + 1,
      CALL print(
      '$      call echo2 "*Install_Cerner Prompts and recommended answers:"                  '), row
       + 1,
      CALL print(
      '$      call echo2 ""                                                                  '),
      row + 1,
      CALL print(
      ^$      call echo2 "Core device  > ''tgt_wh_device'"                                   ^), row
       + 1,
      CALL print(
      ^$      call echo2 "CD-ROM Location [] > ''tgt_wh_device'"                             ^), row
       + 1,
      CALL print(
      '$      call echo2 "Is this correct? [y] > Y"                                          '),
      row + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the cer_mgr directory? [N] > Y"             '), row
       + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ), row + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the cer_mgr_exe directory? [N] > Y"         '),
      row + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ), row + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the system registry template? [N] > Y"      '), row
       + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ),
      row + 1,
      CALL print(
      '$      call echo2 "Do you wish to run start_cerner_500 after creation? [Y] > Y"       '), row
       + 1,
      CALL print(
      '$      call echo2 "Hit C to continue; E to exit. > C"                                 '), row
       + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ),
      row + 1,
      CALL print(
      '$      inquire answer "*Has the execution of Install_Cerner as shown above completed successfully?[Y/N]"'
      ), row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      if f$edit(answer, "UPCASE") .nes. "Y"                                          '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to install core."                                        '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "),
      row + 1,
      CALL print(
      "$!     Update Registry                                                                "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      '$      call echo2 "Update registry."                                                  '),
      row + 1, dcsrf_line = concat(
       "$mcr 'tgt_wh_device':[cerner.w_standard.'tgt_wh'.vmsalpha]update_reg -input ",
       "'tgt_wh_device':[cerner.w_standard.'tgt_wh'.install]update_reg_vms.csv"),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      "$!     start_cerner_500                                                               "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "),
      row + 1,
      CALL print(
      '$      call echo2 "Run start_cerner_500."                                             '), row
       + 1,
      CALL print(
      "$mcr cer_mgr_exe:start_cerner_500 -env common -verbose -noinst                        "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "),
      row + 1,
      CALL print(
      "$!     Cycle server controller, ddir and resolver                                     "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1, dcsrf_line = concat(
       '$      call echo2 "common_wh_switched property found.  Cycle server controller,',
       'ddir and resolver"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "),
      row + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "), row
       + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "),
      row + 1,
      CALL print(
      "$!     remove common_wh_switched property                                             "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1,
      CALL print(
      '$      call echo2 "Remove common_wh_switched property for common"                     '),
      row + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "common_wh_switched"                '),
      row + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "common_wh_switched"                '),
      row + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      if lreg_result .nes. "not_found"                                               '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to delete property common_wh_switched property for common."'),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "),
      row + 1,
      CALL print(
      "$!     Update Registry                                                                "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      '$      call echo2 "Update registry."                                                  '),
      row + 1, dcsrf_line = concat(
       "$mcr 'tgt_wh_device':[cerner.w_standard.'tgt_wh'.vmsalpha]update_reg -input ",
       "'tgt_wh_device':[cerner.w_standard.'tgt_wh'.install]update_reg_vms.csv"),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$EXIT_SCRIPT:                                                                         "),
      row + 1,
      CALL print(
      "$   if error .eq. 1                                                                   "), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "dm2_target_refresh.com completed with error."                      '),
      row + 1,
      CALL print(
      "$      close LOGFILE                                                                  "), row
       + 1,
      CALL print(
      "$      exit 2                                                                         "), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "dm2_target_refresh.com completed successfully."                    '), row
       + 1,
      CALL print(
      "$      close LOGFILE                                                                  "), row
       + 1,
      CALL print(
      "$      exit 1                                                                         "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$EXIT_ERROR:                                                                          "), row
       + 1,
      CALL print(
      '$   call echo2 "dm2_target_refresh was terminated."                                   '),
      row + 1,
      CALL print(
      "$   close LOGFILE                                                                     "), row
       + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$EXIT_CRITICAL:                                                                       "),
      row + 1,
      CALL print(
      '$   call echo3 "dm2_target_refresh.com completed with error."                         '), row
       + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!subroutine definition                                                               "),
      row + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!------------------------------------                                                "), row
       + 1,
      CALL print(
      "$! subroutine:                                                                        "),
      row + 1,
      CALL print(
      "$!      echo1 - echo to log file                                                      "), row
       + 1,
      CALL print(
      "$!      echo2 - echo to log file & screen                                             "), row
       + 1,
      CALL print(
      "$!-----------------------------------                                                 "),
      row + 1,
      CALL print(
      "$ECHO1:                                                                               "), row
       + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "),
      row + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO2:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "),
      row + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO3:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$KILL_SERVER:                                                                         "),
      row + 1,
      CALL print(
      "$   count = 0                                                                         "), row
       + 1,
      dcrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'server_cmd.com") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_cmd.com;*"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$   open/write SERVER_CMD 'tgt_tmp_full_dir'server_cmd.com                            "), row
       + 1,
      CALL print(
      ^$   write SERVER_CMD "$mcr cer_exe:cmbview -dom ''tgt_domain_name'"                   ^),
      row + 1,
      CALL print(
      "$   LOOP:                                                                             "), row
       + 1,
      CALL print(
      "$      count = count + 1                                                              "), row
       + 1,
      CALL print(
      "$      if count .le. srv_cnt                                                          "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         tmp_inst = srv_inst'count                                                   "), row
       + 1,
      CALL print(
      ^$         write SERVER_CMD "kill ''tmp_inst'"                                         ^),
      row + 1,
      CALL print(
      "$         delete/symbol srv_inst'count                                                "), row
       + 1,
      CALL print(
      "$         goto LOOP                                                                   "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      '$   write SERVER_CMD "exit"                                                           '), row
       + 1,
      CALL print(
      "$   close SERVER_CMD                                                                  "), row
       + 1,
      CALL print(
      "$   @server_cmd.com                                                                   "),
      row + 1,
      CALL print(
      "$   gosub FIND_SERVER                                                                 "), row
       + 1,
      CALL print(
      "$   if srv_cnt .ne. 0                                                                 "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Failed to terminate all servers."                                  '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "All servers are terminated."                                       '), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$FIND_SERVER:                                                                         "),
      row + 1, dcrf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'server_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_list.dat;*"),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$   define/user_mode sys$output 'tgt_tmp_full_dir'server_list.dat                     "), row
       + 1,
      CALL print(
      "$mcr cer_exe:cmbview -dom 'tgt_domain_name'                                           "), row
       + 1,
      CALL print(
      "server                                                                                "),
      row + 1,
      CALL print(
      "exit                                                                                  "), row
       + 1,
      CALL print(
      "$   srv_cnt = 0                                                                       "), row
       + 1,
      CALL print(
      "$   open/read SERVER_LIST 'tgt_tmp_full_dir'server_list.dat                           "),
      row + 1,
      CALL print(
      "$   READ_SERVER_LIST:                                                                 "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record                       "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      if char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            srv_cnt = srv_cnt + 1                                                    "), row
       + 1,
      CALL print(
      "$            srv_inst'srv_cnt = f$extract(0, end_pos, record)                         "),
      row + 1,
      CALL print(
      "$            write sys$output srv_inst'srv_cnt                                        "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_SERVER_LIST                                                          "), row
       + 1,
      CALL print(
      "$   END_READ_SERVER_LIST:                                                             "),
      row + 1,
      CALL print(
      "$      close SERVER_LIST                                                              "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$CYCLE_REG:                                                                           "), row
       + 1,
      CALL print(
      '$   call echo2 "Stop Registry"                                                        '), row
       + 1,
      CALL print(
      "$   @cer_mgr:stop_registry.com                                                        "),
      row + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      '$   CONTEXT = ""                                                                      '), row
       + 1,
      CALL print(
      "$   kill_reg_proc_loop:                                                               "),
      row + 1,
      CALL print(
      "$   PID = F$PID(CONTEXT)                                                              "), row
       + 1,
      CALL print(
      '$   if PID .eqs. ""                                                                   '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$      goto kill_reg_proc_exit                                                        "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   PNAME = F$GETJPI(PID,"PRCNAM")                                                    '),
      row + 1,
      CALL print(
      '$   if pname .EQS. "REGISTRY_SERVER"                                                  '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$     write sys$output "* Killing process " + pname + "; process_id = " + pid         '),
      row + 1,
      CALL print(
      "$     stop  process/id='pid                                                           "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$   goto kill_reg_proc_loop                                                           "),
      row + 1,
      CALL print(
      "$   kill_reg_proc_exit:                                                               "), row
       + 1,
      CALL print(
      '$      call echo2 "Registry has been stopped"                                         '), row
       + 1, dcrf_line = concat(
       ^$      if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcrf_line), row + 1,
      CALL print("$      open/write REG_IND 'tgt_tmp_full_dir'stop_reg_ind.dat                 "),
      row + 1,
      CALL print(
      '$      write REG_IND "registry stopped"                                            '), row + 1,
      CALL print(
      "$      close REG_IND                                                               "), row + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '),
      row + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "), row
       + 1,
      dcrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcrf_line), row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$STARTUP_CTRL_DDIR_RES:                                                               "), row
       + 1,
      CALL print(
      '$   call echo2 "Startup server controller."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ctrl                                                      "),
      row + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   ctrl_fnd = 0                                                                      "), row
       + 1,
      CALL print(
      "$   CTRL_LOOP:                                                                        "),
      row + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_STARTUP_CTRL                                     "), row
       + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "),
      row + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^), row
       + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'ctrl_proc.dat                  "), row
       + 1,
      CALL print(
      "$      open/read/error=CHECK_CTRL_PROC CTRL_PROC_DAT 'tgt_tmp_full_dir'ctrl_proc.dat  "),
      row + 1,
      CALL print(
      "$      READ_CTRL_PROC:                                                                "), row
       + 1,
      CALL print(
      "$         read/end_of_file=END_READ_CTRL_PROC CTRL_PROC_DAT record                    "), row
       + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "),
      row + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "), row
       + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^), row
       + 1,
      CALL print(
      '$         if char_type .eqs. "INTEGER"                                                '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            ctrl_pos = f$locate("SERVER_CTRL", record)                               '), row
       + 1,
      CALL print(
      "$            length = f$length(record)                                                "),
      row + 1,
      CALL print(
      "$            if (ctrl_pos .gt. 0) .and. (ctrl_pos .ne. length)                        "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               ctrl_fnd = 1                                                          "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         endif !char_type                                                            "), row
       + 1,
      CALL print(
      "$!        write sys$output record                                                     "),
      row + 1,
      CALL print(
      "$         goto READ_CTRL_PROC                                                         "), row
       + 1,
      CALL print(
      "$      CHECK_CTRL_PROC:                                                               "), row
       + 1,
      CALL print(
      "$         ctrl_err_msg = f$message($status)                                           "),
      row + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'ctrl_proc.dat"            ^), row
       + 1,
      CALL print(
      "$         call echo2 'ctrl_err_msg'                                                   "), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      END_READ_CTRL_PROC:                                                            "), row
       + 1,
      CALL print(
      "$         close CTRL_PROC_DAT                                                         "),
      row + 1,
      CALL print(
      "$      if ctrl_fnd .ne. 0 then goto END_STARTUP_CTRL                                  "), row
       + 1,
      CALL print(
      "$      goto CTRL_LOOP                                                                 "), row
       + 1,
      CALL print(
      "$   END_STARTUP_CTRL:                                                                 "),
      row + 1,
      CALL print(
      "$      if ctrl_fnd .eq. 0                                                             "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to startup server controller"                            '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      else                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Startup server controller successfully."                        '), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Startup domain directory."                                            '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ddir                                                      "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Find domain resolver."                                                '), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'startup_res_proc.dat        "), row
       + 1,
      CALL print(
      "$   res_in_use = 0                                                                    "),
      row + 1,
      CALL print(
      "$   OPEN/READ/ERROR=CHECK_FIND_RES_PROC FIND_RES_PROC_DAT 'tgt_tmp_full_dir'startup_res_proc.dat"
      ), row + 1,
      CALL print(
      "$   READ_FIND_RES_PROC:                                                               "), row
       + 1,
      CALL print(
      "$      READ/END_OF_FILE=END_READ_FIND_RES_PROC FIND_RES_PROC_DAT RECORD               "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      IF char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      THEN                                                                           "), row
       + 1,
      CALL print(
      '$         res_pos = f$locate("SRV0000_01", record)                                    '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      "$         if (res_pos .gt. 0) .and. (res_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            res_in_use = 1                                                           "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      ENDIF !char_type                                                               "),
      row + 1,
      CALL print(
      "$!     WRITE SYS$OUTPUT RECORD                                                        "), row
       + 1,
      CALL print(
      "$      GOTO READ_FIND_RES_PROC                                                        "), row
       + 1,
      CALL print(
      "$   CHECK_FIND_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$      find_res_err_msg = F$MESSAGE($STATUS)                                          "), row
       + 1,
      CALL print(
      ^$      CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'startup_res_proc.dat"       ^), row
       + 1,
      CALL print(
      "$      CALL ECHO2 'find_res_err_msg'                                                  "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      GOTO EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_FIND_RES_PROC:                                                           "),
      row + 1,
      CALL print(
      "$      CLOSE FIND_RES_PROC_DAT                                                        "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Startup domain resolver."                                          '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_startup -res                                                    "), row
       + 1,
      CALL print(
      "$      loop=0                                                                         "),
      row + 1,
      CALL print(
      "$      res_fnd = 0                                                                    "), row
       + 1,
      CALL print(
      "$      RES_LOOP:                                                                      "), row
       + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_STARTUP_RES                                   "),
      row + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "), row
       + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^),
      row + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         open/read/error=CHECK_RES_PROC RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat  "), row
       + 1,
      CALL print(
      "$         READ_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$            read/end_of_file=END_READ_RES_PROC RES_PROC_DAT record                   "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "), row
       + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "),
      row + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            if char_type .eqs. "INTEGER"                                             '), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "), row
       + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  res_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      "$            endif !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           write sys$output record                                                  "), row
       + 1,
      CALL print(
      "$            goto READ_RES_PROC                                                       "),
      row + 1,
      CALL print(
      "$         CHECK_RES_PROC:                                                             "), row
       + 1,
      CALL print(
      "$            res_err_msg = f$message($status)                                         "), row
       + 1,
      CALL print(
      ^$            call echo2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^),
      row + 1,
      CALL print(
      "$            call echo2 'res_err_msg'                                                 "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         END_READ_RES_PROC:                                                          "), row
       + 1,
      CALL print(
      "$            close RES_PROC_DAT                                                       "), row
       + 1,
      CALL print(
      "$         if res_fnd .ne. 0 then goto END_STARTUP_RES                                 "),
      row + 1,
      CALL print(
      "$         goto RES_LOOP                                                               "), row
       + 1,
      CALL print(
      "$       END_STARTUP_RES:                                                              "), row
       + 1,
      CALL print(
      "$         if res_fnd .eq. 0                                                           "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to startup resolver"                                  '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Startup resolver successfully."                              '),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   endif !res_in_use                                                                 "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$SHUTDOWN_CTRL_DDIR_RES:                                                              "), row
       + 1,
      CALL print(
      '$   call echo2 "Shutdown server controller."                                          '),
      row + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ctrl                                                     "), row
       + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   shutdown_ctrl_fnd = 0                                                             "),
      row + 1,
      CALL print(
      "$   SHUTDOWN_CTRL_LOOP:                                                               "), row
       + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_SHUTDOWN_CTRL                                    "), row
       + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "),
      row + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^), row
       + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'shutdown_ctrl_proc.dat         "),
      row + 1, dcrf_line = concat(
       "$      OPEN/READ/ERROR=CHECK_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT ",
       "'tgt_tmp_full_dir'shutdown_ctrl_proc.dat"),
      CALL print(dcrf_line),
      row + 1,
      CALL print(
      "$      READ_SHUTDOWN_CTRL_PROC:                                                       "), row
       + 1,
      CALL print(
      "$         READ/END_OF_FILE=END_READ_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT RECORD  "), row
       + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "),
      row + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "), row
       + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^), row
       + 1,
      CALL print(
      '$         IF char_type .eqs. "INTEGER"                                                '),
      row + 1,
      CALL print(
      "$         THEN                                                                        "), row
       + 1,
      CALL print(
      '$            shutdown_ctrl_pos = f$locate("SERVER_CTRL", record)                      '), row
       + 1,
      CALL print(
      "$            length = f$length(record)                                                "),
      row + 1,
      CALL print(
      "$            if (shutdown_ctrl_pos .gt. 0) .and. (shutdown_ctrl_pos .ne. length)      "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               shutdown_ctrl_fnd = 1                                                 "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         ENDIF !char_type                                                            "), row
       + 1,
      CALL print(
      "$!        WRITE SYS$OUTPUT RECORD                                                     "),
      row + 1,
      CALL print(
      "$         GOTO READ_SHUTDOWN_CTRL_PROC                                                "), row
       + 1,
      CALL print(
      "$      CHECK_SHUTDOWN_CTRL_PROC:                                                      "), row
       + 1,
      CALL print(
      "$         shutdown_ctrl_err_msg = F$MESSAGE($STATUS)                                  "),
      row + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'shutdown_ctrl_proc.dat"   ^), row
       + 1,
      CALL print(
      "$         call echo2 'shutdown_ctrl_err_msg'                                          "), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      END_READ_SHUTDOWN_CTRL_PROC:                                                   "), row
       + 1,
      CALL print(
      "$         close SHUTDOWN_CTRL_PROC_DAT                                                "),
      row + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .eq. 0 then goto END_SHUTDOWN_CTRL                        "), row
       + 1,
      CALL print(
      "$      goto SHUTDOWN_CTRL_LOOP                                                        "), row
       + 1,
      CALL print(
      "$   END_SHUTDOWN_CTRL:                                                                "),
      row + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .gt. 0                                                    "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to shutdown server controller"                           '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      else                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Shutdown server controller successfully."                       '), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Shutdown domain directory."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ddir                                                     "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Find domain resolver."                                                '), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'shutdown_res_proc.dat        "), row
       + 1,
      CALL print(
      "$   res_in_use = 0                                                                    "),
      row + 1,
      CALL print(
      "$   OPEN/READ/ERROR=CHECK_FIND_RES_PROC FIND_RES_PROC_DAT 'tgt_tmp_full_dir'shutdown_res_proc.dat"
      ), row + 1,
      CALL print(
      "$   READ_FIND_RES_PROC:                                                               "), row
       + 1,
      CALL print(
      "$      READ/END_OF_FILE=END_READ_FIND_RES_PROC FIND_RES_PROC_DAT RECORD               "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      IF char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      THEN                                                                           "), row
       + 1,
      CALL print(
      '$         res_pos = f$locate("SRV0000_01", record)                                    '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      "$         if (res_pos .gt. 0) .and. (res_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            res_in_use = 1                                                           "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      ENDIF !char_type                                                               "),
      row + 1,
      CALL print(
      "$!     WRITE SYS$OUTPUT RECORD                                                        "), row
       + 1,
      CALL print(
      "$      GOTO READ_FIND_RES_PROC                                                        "), row
       + 1,
      CALL print(
      "$   CHECK_FIND_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$      find_res_err_msg = F$MESSAGE($STATUS)                                          "), row
       + 1,
      CALL print(
      ^$      CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'shutdown_res_proc.dat"       ^), row
       + 1,
      CALL print(
      "$      CALL ECHO2 'find_res_err_msg'                                                  "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      GOTO EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_FIND_RES_PROC:                                                           "),
      row + 1,
      CALL print(
      "$      CLOSE FIND_RES_PROC_DAT                                                        "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Shutdown domain resolver."                                         '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_shutdown -res                                                   "), row
       + 1,
      CALL print(
      "$      loop=0                                                                         "),
      row + 1,
      CALL print(
      "$      shutdown_res_fnd = 0                                                           "), row
       + 1,
      CALL print(
      "$      SHUTDOWN_RES_LOOP:                                                             "), row
       + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_SHUTDOWN_RES                                  "),
      row + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "), row
       + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^),
      row + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         OPEN/READ/ERROR=CHECK_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat"
      ), row + 1,
      CALL print(
      "$         READ_SHUTDOWN_RES_PROC:                                                     "),
      row + 1,
      CALL print(
      "$            READ/END_OF_FILE=END_READ_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT RECORD "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "), row
       + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "),
      row + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            IF char_type .eqs. "INTEGER"                                             '), row
       + 1,
      CALL print(
      "$            THEN                                                                     "),
      row + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "), row
       + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  shutdown_res_fnd = 1                                               "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      "$            ENDIF !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           WRITE SYS$OUTPUT RECORD                                                  "), row
       + 1,
      CALL print(
      "$            GOTO READ_SHUTDOWN_RES_PROC                                              "),
      row + 1,
      CALL print(
      "$         CHECK_SHUTDOWN_RES_PROC:                                                    "), row
       + 1,
      CALL print(
      "$            shutdown_res_err_msg = F$MESSAGE($STATUS)                                "), row
       + 1,
      CALL print(
      ^$            CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^),
      row + 1,
      CALL print(
      "$            CALL ECHO2 'shutdown_res_err_msg'                                        "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            GOTO EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         END_READ_SHUTDOWN_RES_PROC:                                                 "), row
       + 1,
      CALL print(
      "$            CLOSE SHUTDOWN_RES_PROC_DAT                                              "), row
       + 1,
      CALL print(
      "$         IF shutdown_res_fnd .eq. 0 then goto END_SHUTDOWN_RES                       "),
      row + 1,
      CALL print(
      "$         goto SHUTDOWN_RES_LOOP                                                      "), row
       + 1,
      CALL print(
      "$      END_SHUTDOWN_RES:                                                              "), row
       + 1,
      CALL print(
      "$         if shutdown_res_fnd .gt. 0                                                  "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to shutdown resolver"                                 '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Shutdown resolver successfully."                             '),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   else !res_in_use = 0                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Resolver is not running"                                           '),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1
     ELSE
      col 0, "#!/usr/bin/ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# dm2_target_refresh.ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# Note:  Must be run as the root user", row + 1,
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "## Functions:",
      row + 1, col 0, "##	echo1 - Echo to Log File Only",
      row + 1, col 0, "##	echo2 - Echo to Log File & Screen",
      row + 1, col 0, "##	echo3 - Echo to Screen Only",
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "echo1()   #####  Echo to Log File only",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo2()   #####  Echo to Log File & Screen",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1,
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1,
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo3()   #####  Echo to Screen only",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0,
      "##	cycle_common - start common env and cycle controller, domain dir and resolver",
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "cycle_common()",
      row + 1, col 0, "{",
      row + 1, col 0, "$cer_mgr_exe/start_cerner_500 -env common -verbose -noinst",
      row + 1, row + 1, col 0,
      "if (( ${cb_cycle} == 1 ))", row + 1, col 0,
      "then", row + 1, col 0,
      "  $cer_exe/cb_shutdown -ctrl", row + 1, col 0,
      "  loop=0", row + 1, col 0,
      "  while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "    sleep 5", row + 1, col 0,
      "    ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "    if [[ $? -ne 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Terminate server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "  #check if resolver exists", row + 1, col 0,
      "  ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "  if [[ $? -eq 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    resolver_exist=1", row + 1, col 0,
      "  else", row + 1, col 0,
      "    resolver_exist=0", row + 1, col 0,
      "  fi", row + 1, row + 1,
      col 0, "  if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "  then ", row + 1,
      col 0, "    $cer_exe/cb_shutdown -res", row + 1,
      col 0, "    loop=0", row + 1,
      col 0, "    while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "      sleep 5", row + 1,
      col 0, "      ((loop=loop+1))", row + 1,
      col 0, "      ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         loop=100", row + 1,
      col 0, "      elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Terminate resolver failed."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "    done", row + 1,
      col 0, "  fi", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ctrl",
      row + 1, col 0, "  loop=0",
      row + 1, col 0, "  while [[ $loop -lt 12 ]]; do",
      row + 1, col 0, "    sleep 5",
      row + 1, col 0, "    ((loop=loop+1))",
      row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "    if [[ $? -eq 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Start server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ddir",
      row + 1, row + 1, col 0,
      "  if [[ $resolver_exist -eq 1 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    $cer_exe/cb_startup -res", row + 1, col 0,
      "    loop=0", row + 1, col 0,
      "    while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "      sleep 5", row + 1, col 0,
      "      ((loop=loop+1))", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         loop=100", row + 1, col 0,
      "      elif [[ $loop -eq 12 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "Start resolver failed."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "    done", row + 1, col 0,
      "  fi", row + 1, col 0,
      "fi", row + 1, col 0,
      "}", row + 1, row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "## Function:", row + 1,
      col 0, "##	cycle_reg - stop and start registry", row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "cycle_reg()", row + 1,
      col 0, "{", row + 1,
      col 0, "   $cer_mgr_exe/reg_server -stop", row + 1,
      dcrf_line = concat(
       "   ps -ef |grep reg_server |grep cerner |sed 's/\([ ]*[A-Za-z0-9_]*[ ]*\) \([0-9]*\) \([^`]*\)/\2/'",
       " > /tmp/dm2_qpid_dump.txt"), col 0, dcrf_line,
      row + 1, col 0, "   if [[ -s /tmp/dm2_qpid_dump.txt ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "       trgprocid=`head -n 1 /tmp/dm2_qpid_dump.txt`",
      row + 1, col 0, "       rm -f /tmp/dm2_qpid_dump.txt",
      row + 1, col 0, '       echo1 "Initiating a kill -9 $trgprocid"',
      row + 1, col 0, "       kill -9 $trgprocid",
      row + 1, col 0, "      sleep 2",
      row + 1, col 0, "   else",
      row + 1, col 0, '       echo1 "Reg Server has already stopped"',
      row + 1, col 0, "   fi",
      row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, "   slibclean", row + 1
      ENDIF
      col 0, '   echo "registry stopped" >>$tgt_tmp_full_dir/stop_reg_ind.dat', row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, "   ##Start registry          ", row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, '   echo2 "Start registry"', row + 1,
      col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1,
      col 0, "   if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "## Function:", row + 1, col 0,
      "##	version_adjust - Adjust the revision Level to compare.", row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "revision_adjust()", row + 1, col 0,
      "{", row + 1, col 0,
      "   revision=$1", row + 1, col 0,
      "   rev_chk=`echo $revision|tr -d '[0-9]'|tr -d '.'`", row + 1, col 0,
      "   if [[ ${#rev_chk} -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, dcrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. Revision level contains',
       ' unsupported characters [$rev_chk]."'),
      col 0, dcrf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   lvl=`echo $revision|tr -dc '.'|wc -c`", row + 1,
      col 0, "   rev1=0", row + 1,
      col 0, "   rev2=0", row + 1,
      col 0, "   rev3=0", row + 1,
      col 0, "   rev4=0", row + 1,
      col 0, '   rev1=`echo $revision | cut -f1 -d"."`', row + 1,
      col 0, "   if [[ ${#rev1} -ne 4 ]]", row + 1,
      col 0, "   then", row + 1,
      dcrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. First level [${rev1}] should',
       ' be 4 numeric integers (i.e. 2004, 2010, 2012)."'), col 0, dcrf_line,
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   if [[ $lvl -gt 3 ]]",
      row + 1, col 0, "   then",
      row + 1, dcrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision level contains',
       '  more than 4 levels."'), col 0,
      dcrf_line, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev2=`echo $revision | cut -f2 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 1 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev3=`echo $revision | cut -f3 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 2 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev4=`echo $revision | cut -f4 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ ${#rev2} -gt 4 || ${#rev3} -gt 4 || ${#rev4} -gt 4 ]]", row + 1, col 0,
      "   then", row + 1, dcrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision minor levels should',
       ' be less than 5 numeric integers."'),
      col 0, dcrf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   while [[ ${#rev1} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev1="0$rev1"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev2} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev2="0$rev2"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev3} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev3="0$rev3"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev4} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev4="0$rev4"', row + 1,
      col 0, "   done", row + 1,
      col 0, '   rev_lvl="$rev1$rev2$rev3$rev4" ', row + 1,
      col 0, "}", row + 1,
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0, "##	get_server_ctrl - Determine if node level server control exists.",
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "get_server_ctrl() ",
      row + 1, col 0, "{",
      row + 1, col 0, '   echo2 "Get node and domain level server control" ',
      row + 1, col 0, "   tgt_node=`hostname`",
      row + 1, col 0, '   echo2 "tgt_node : $tgt_node" ',
      row + 1, col 0,
      '   node_srvctrl=$($cer_exe/lreg -getp "\node\\${tgt_node}\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "   if (( $? == 0 ))",
      row + 1, col 0, "   then ",
      row + 1, col 0, "     node_srvctrl_fnd=1",
      row + 1, col 0, "   else ",
      row + 1, col 0, "     node_srvctrl_fnd=0 ",
      row + 1, col 0, "     cb_cycle=0 ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, "   if (( ${node_srvctrl_fnd} == 1 ))",
      row + 1, col 0, "   then  ",
      row + 1, col 0, "     #-----------------------------------------------  ",
      row + 1, col 0, "     ##Get ServerCtrl for all domains the node      ",
      row + 1, col 0, "     #----------------------------------------------- ",
      row + 1, col 0, '     echo2 "Get ServerCtrl for all domains the node." ',
      row + 1, col 0, "$cer_exe/lreg -enumk \\\\node\\\\${tgt_node}\\\\domain domain_list.dat  ",
      row + 1, col 0, "     domain_srvctrl_cnt=0 ",
      row + 1, col 0, "     domain_no_srvctrl_cnt=0",
      row + 1, col 0, "     while read domain ; do  ",
      row + 1, col 0, "       echo2 ${domain}",
      row + 1, col 0,
      'dom_srvctrl=$($cer_exe/lreg -getp "\node\\$tgt_node\domain\\$domain\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "       if (( $? == 0 ))",
      row + 1, col 0, "       then ",
      row + 1, col 0, "         (( domain_srvctrl_cnt=domain_srvctrl_cnt+1 ))",
      row + 1, col 0, "       else ",
      row + 1, col 0, "         (( domain_no_srvctrl_cnt=domain_no_srvctrl_cnt+1 ))",
      row + 1, col 0, "       fi ",
      row + 1, col 0, "     done < domain_list.dat ",
      row + 1, col 0, "     if (( ${domain_no_srvctrl_cnt} > 0 )) ",
      row + 1, col 0, "     then   ",
      row + 1, col 0, "       cb_cycle=1  ",
      row + 1, col 0, "     else ",
      row + 1, col 0, "cb_cycle=0 ",
      row + 1, col 0, "     fi ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, '   echo2 "cb_cycle : $cb_cycle" ',
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      "##Make sure the user is root.", row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      'echo3 "Verify user is root."', row + 1, row + 1,
      col 0, 'if [[ `whoami` != "root" ]]', row + 1,
      col 0, "then", row + 1,
      col 0, 'echo " "', row + 1,
      col 0, 'echo3 "ERROR: Logon as root and run again."', row + 1,
      col 0, 'echo " "', row + 1,
      col 0, "exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "#--------------------",
      row + 1, col 0, "#Set Target variables",
      row + 1, col 0, "#--------------------",
      row + 1, row + 1, dcrf_line = concat("tgt_domain_name=",ddr_domain_data->tgt_domain_name),
      col 0, dcrf_line, row + 1,
      dcrf_line = concat("tgt_env=",ddr_domain_data->tgt_env), col 0, dcrf_line,
      row + 1, dcrf_line = concat("tgt_env_lc=",cnvtlower(ddr_domain_data->tgt_env)), col 0,
      dcrf_line, row + 1, dcrf_line = concat("tgt_tmp_dir=",ddr_domain_data->tgt_tmp_dir),
      col 0, dcrf_line, row + 1,
      dcrf_line = concat("tgt_wh=",ddr_domain_data->tgt_wh), col 0, dcrf_line,
      row + 1, dcrf_line = concat("tgt_wh_device=",ddr_domain_data->tgt_wh_device), col 0,
      dcrf_line, row + 1, dcrf_line = concat("tgt_tmp_full_dir=",ddr_domain_data->tgt_tmp_full_dir),
      col 0, dcrf_line, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       dcrf_line = concat("src_env=",cnvtlower(drrr_rf_data->src_env_name)), col 0, dcrf_line,
       row + 1, dcrf_line = concat('cd_rom_loc="/"'), col 0,
       dcrf_line, row + 1, dcrf_line = concat("common_to_tgt=",drrr_rf_data->common_to_tgt),
       col 0, dcrf_line, row + 1,
       dcrf_line = concat("tgt_top_dir=",drrr_rf_data->tgt_top_dir), col 0, dcrf_line,
       row + 1, dcrf_line = concat("tgt_cer_mgr_dir=",drrr_rf_data->tgt_cer_mgr_dir), col 0,
       dcrf_line, row + 1, dcrf_line = concat("tgt_cer_mgr_exe_dir=",drrr_rf_data->
        tgt_cer_mgr_exe_dir),
       col 0, dcrf_line, row + 1,
       dcrf_line = concat("tgt_cer_mgr_log_dir=",drrr_rf_data->tgt_cer_mgr_log_dir), col 0, dcrf_line,
       row + 1, dcrf_line = concat("tgt_cer_reg_dir=",drrr_rf_data->tgt_cer_reg_dir), col 0,
       dcrf_line, row + 1, dcrf_line = concat("tgt_cer_fifo_dir=",drrr_rf_data->tgt_cer_fifo_dir),
       col 0, dcrf_line, row + 1,
       dcrf_line = concat("tgt_cer_usock_dir=",drrr_rf_data->tgt_cer_usock_dir), col 0, dcrf_line,
       row + 1, dcrf_line = concat("tgt_cer_lock_dir=",drrr_rf_data->tgt_cer_lock_dir), col 0,
       dcrf_line, row + 1
      ENDIF
      IF (validate(dm2_skip_date_chk,- (1))=1)
       col 0, "tgt_date_chk=0", row + 1
      ELSE
       col 0, "tgt_date_chk=1", row + 1
      ENDIF
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, "##Verify in Target environment",
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, 'echo3 "Verify in Target environment."',
      row + 1, row + 1, col 0,
      "cur_env=$environment", row + 1, col 0,
      "typeset -l cur_env=$cur_env", row + 1, col 0,
      'if [[ $cur_env = "" ]]', row + 1, col 0,
      "then", row + 1, col 0,
      '  typeset -x environment="${tgt_env_lc}"', row + 1, col 0,
      "  cur_env=$environment", row + 1, col 0,
      "  typeset -l cur_env=$cur_env", row + 1, col 0,
      "fi", row + 1, col 0,
      "if [[ $tgt_env_lc != $cur_env ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      '  echo3 "ERROR: Set to Target environment $tgt_env_lc and run again."', row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      "  exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------", row + 1,
      col 0, "#Validate Target Temp Directory", row + 1,
      col 0, "#------------------------------", row + 1,
      row + 1, col 0, "if [[ ! -d $tgt_tmp_dir ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo3 "$tgt_tmp_dir not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ ! -d $tgt_tmp_full_dir ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo3 "$tgt_tmp_full_dir not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "## Create Target Checkpoint File", row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "CheckPoint=$tgt_tmp_full_dir/target_checkpoint.dat", row + 1,
      col 0, "[[ -f ${CheckPoint} ]] && rm ${CheckPoint}", row + 1,
      col 0, "touch $CheckPoint", row + 1,
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "## Set up the Log File",
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "FilePrefix=$tgt_tmp_full_dir/dm2_target_refresh.log",
      row + 1, col 0, "if [[ -f $FilePrefix ]]",
      row + 1, col 0, "then",
      row + 1, col 0, "   rm -rf $FilePrefix",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "FilePrefix=$tgt_tmp_full_dir/dm2_target_refresh_", row + 1, col 0,
      "LastFile=`ls $FilePrefix[0-9]* 2>/dev/null | tail -1`", row + 1, col 0,
      "LastFile=`echo ${LastFile##*/}`", row + 1, row + 1,
      col 0, "if [[ -z $LastFile ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  ScriptLog=dm2_target_refresh_001.log", row + 1,
      col 0, "else", row + 1,
      col 0, '  Ext=`echo $LastFile | cut -f4 -d"_"`', row + 1,
      col 0, '  Cnt=`echo $Ext | cut -f1 -d"."`', row + 1,
      col 0, "  CntNew=`expr $Cnt + 1`", row + 1,
      col 0, "  while [[ ${#CntNew} -lt 3 ]]", row + 1,
      col 0, "  do", row + 1,
      col 0, "    CntNew=0$CntNew", row + 1,
      col 0, "  done", row + 1,
      col 0, "  ScriptLog=$tgt_tmp_full_dir/dm2_target_refresh_$CntNew.log", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "[[ -f ${ScriptLog} ]] && rm ${ScriptLog}",
      row + 1, row + 1, col 0,
      'echo1 "Begin dm2_target_refresh.ksh"', row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, 'echo1 "This ksh was created using response file"', row + 1
      ENDIF
      row + 1, col 0, "if [[ ! -d $tgt_wh_device ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "$tgt_wh_device not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=0)
       col 0, "#--------------------------------", row + 1,
       col 0, "##Prompt SOURCE Environment name", row + 1,
       col 0, "#--------------------------------", row + 1,
       col 0, 'echo1 "Prompt Source environment name."', row + 1,
       row + 1, col 0, 'echo " "',
       row + 1, col 0, 'echo3 "Enter Source Environment Name: \c"',
       row + 1, col 0, "read src_env",
       row + 1, col 0, "typeset -l src_env=$src_env",
       row + 1, row + 1
      ENDIF
      col 0, "if [[ -z $src_env ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "ERROR: Invalid Source Environment Name."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "else", row + 1,
      col 0, '   echo1 "Source Environment Name : $src_env"', row + 1,
      col 0, "fi", row + 1,
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "##Convert windows line endings to unix line endings", row + 1,
       col 0, "input=$1", row + 1,
       col 0, ^output=$(echo $input| cut -d '.' -f1| awk '{printf("%s%s",$1,"_tmp.txt")}')^, row +
       1,
       col 0, "tr -s '\r\n' '\n' <$input >$output", row + 1,
       col 0, "mv $output $input", row + 1,
       row + 1, col 0, "##Validate response file",
       row + 1, col 0, "response_file=$input",
       row + 1, row + 1, col 0,
       'if [[ ! -f "$response_file" ]]', row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "response file not found!"', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "else", row + 1, col 0,
       '   echo1 "response file found"', row + 1, col 0,
       "fi", row + 1, row + 1,
       col 0, "#------------------------------", row + 1,
       col 0, "#Parse out the connection and process name", row + 1,
       col 0, "#------------------------------", row + 1,
       row + 1, dcrf_line = concat('client_mnemonic=$(grep "s_CLIENT_MNEMONIC" $response_file ',
        ^|awk -F'=' '/s_CLIENT_MNEMONIC /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcrf_line, row + 1, row + 1,
       col 0, "if [[ -z $client_mnemonic ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid client mnemonic."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Client mnemonic : $client_mnemonic"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcrf_line = concat('src_env_name=$(grep "s_SRC_ENV_NAME" $response_file',
        ^|awk -F'=' '/s_SRC_ENV_NAME /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcrf_line, row + 1, row + 1,
       col 0, "if [[ -z $src_env_name ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid source environment name."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Source environment name : $src_env_name"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcrf_line = concat('tgt_env_name=$(grep "s_TGT_ENV_NAME" $response_file ',
        ^|awk -F'=' '/s_TGT_ENV_NAME /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcrf_line, row + 1, row + 1,
       col 0, "if [[ -z $tgt_env_name ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid target environment name."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Target environment name : $tgt_env_name"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcrf_line = concat(
        'tgt_cap_schema_date=$(grep "s_TGT_CAPTURE_SCHEMA_DATE" $response_file ',
        ^|awk -F'=' '/s_TGT_CAPTURE_SCHEMA_DATE /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcrf_line, row + 1, row + 1,
       col 0, "if [[ -z $tgt_cap_schema_date ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid schema date."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Schema date : $tgt_cap_schema_date"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcrf_line = concat('dma_pcs_name=$(echo2 "${client_mnemonic}_${src_env_name}_',
        'to_${tgt_env_name}_${tgt_cap_schema_date}"',
        " | sed 's/-//g'|tr '[:lower:]' '[:upper:]'|tr -d '[:space:]')"), col 0,
       dcrf_line, row + 1, row + 1,
       dcrf_line = concat('adm_user=$(grep "s_ADM_DB_USER" $response_file ',
        ^|awk -F'=' '/ADM_DB_USER /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0, dcrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_user ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin username."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       dcrf_line = concat('adm_password=$(grep "s_ADM_DB_USER_PWD" $response_file ',
        ^|awk -F'=' '/ADM_DB_USER_PWD /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0, dcrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_password ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin password."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       dcrf_line = concat('adm_cnct_str=$(grep "s_ADM_DB_CNCT_STR" $response_file ',
        ^|awk -F'=' '/ADM_DB_CNCT_STR /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0, dcrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_cnct_str ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin connect string."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       col 0,
       ^adm_connection=$(echo "${adm_user}/${adm_password}@${adm_cnct_str}" |tr -d '[:space:]')^, row
        + 1,
       row + 1, col 0, "##Validate ORACLE_HOME directory",
       row + 1, col 0, "if [[ ! -d $ORACLE_HOME ]]",
       row + 1, col 0, "then",
       row + 1, col 0, '   echo2 "Error: ORACLE_HOME value has not been set."',
       row + 1, col 0, "   exit 1",
       row + 1, col 0, "fi",
       row + 1, row + 1, col 0,
       "##TDC COUNT QUERY", row + 1, col 0,
       'tgt_cnt_qry=`echo "select count(*)', row + 1, col 0,
       "from dma_process_event dpe", row + 1, col 0,
       "where dpe.dma_process_id in", row + 1, col 0,
       "  (select x.dma_process_id from dma_process x", row + 1, col 0,
       "   where x.process_name = '$dma_pcs_name'", row + 1, col 0,
       "     and x.process_type = 'REPLICATE_REFRESH'", row + 1, col 0,
       "     and x.action_type = 'EXECUTION')", row + 1, col 0,
       "  and dpe.event_name = 'TARGET DATA COLLECTION'", row + 1, col 0,
       "  and dpe.event_status = 'COMPLETE';`", row + 1, row + 1,
       col 0, "##Get target data collection information", row + 1,
       col 0, "tgt_dc_ind=$(", row + 1,
       col 0, "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1,
       col 0, "whenever sqlerror exit sql.sqlcode;", row + 1,
       col 0, "set echo off", row + 1,
       col 0, "set heading off", row + 1,
       col 0, "set feedback off", row + 1,
       col 0, "$tgt_cnt_qry", row + 1,
       col 0, "END", row + 1,
       col 0, ")", row + 1,
       row + 1, col 0, 'if [[ -z "$tgt_dc_ind" || $tgt_dc_ind -eq 0 ]]',
       row + 1, col 0, "then",
       row + 1, col 0, '   echo2 "Target data not collected"',
       row + 1, col 0, "   exit 1",
       row + 1, col 0, "fi",
       row + 1, row + 1, col 0,
       "####Target refresh ksh update query", row + 1, col 0,
       'tgt_upd_qry=`echo "update dma_process_event dpe', row + 1, col 0,
       "set dpe.event_status = 'COMPLETE-STALE'", row + 1, col 0,
       "where dpe.dma_process_id in", row + 1, col 0,
       " (select x.dma_process_id from dma_process x", row + 1, col 0,
       "   where x.process_name = '$dma_pcs_name'", row + 1, col 0,
       "     and x.process_type = 'REPLICATE_REFRESH'", row + 1, col 0,
       "     and x.action_type = 'EXECUTION')", row + 1, col 0,
       "  and dpe.event_name = 'TARGET REFRESH KSH'", row + 1, col 0,
       "  and dpe.event_status = 'COMPLETE';`", row + 1, row + 1,
       col 0, "####update the complete row to complete stale", row + 1,
       col 0, "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1,
       col 0, "whenever sqlerror exit sql.sqlcode;", row + 1,
       col 0, "set echo off", row + 1,
       col 0, "set heading off", row + 1,
       col 0, "set feedback off", row + 1,
       col 0, "$tgt_upd_qry", row + 1,
       col 0, "commit;", row + 1,
       col 0, "END", row + 1,
       row + 1
      ENDIF
      col 0, "#---------------------------", row + 1,
      col 0, "##Read SOURCE misc_data.dat", row + 1,
      col 0, "#---------------------------", row + 1,
      col 0, 'echo2 "Read Source misc_data.dat."', row + 1,
      row + 1, col 0, 'src_tmp_dir="${tgt_tmp_dir}${src_env}/"',
      row + 1, col 0, 'echo1 "src_temp_dir : $src_tmp_dir"',
      row + 1, col 0, "if [[ ! -d $src_tmp_dir ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "$src_tmp_dir not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ ! -f ${src_tmp_dir}misc_data.dat ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "File ${src_tmp_dir}misc_data.dat not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[ $tgt_date_chk -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  find ${src_tmp_dir}misc_data.dat -mtime +14 |grep misc_data.dat", row + 1,
      col 0, "  if [[ $? -eq 0 ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo2 "misc_data.dat is older than 14 days."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, dcrf_line =
      'src_cer_data_dev=$(grep "^src_cer_data_dev," ${src_tmp_dir}misc_data.dat |', dcrf_line =
      concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^),
      col 0, dcrf_line, row + 1,
      col 0, "if [[ -z $src_cer_data_dev ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "ERROR: Invalid src_cer_data_dev."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "else", row + 1,
      col 0, '   echo1 "src_cer_data_dev : $src_cer_data_dev"', row + 1,
      col 0, "fi", row + 1,
      dcrf_line = 'src_wh=$(grep "^src_wh," ${src_tmp_dir}misc_data.dat |', dcrf_line = concat(
       dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_wh ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_wh."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_wh : $src_wh"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_wh_device=$(grep "^src_wh_device," ${src_tmp_dir}misc_data.dat |', dcrf_line
       = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_wh_device ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_wh_device."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_wh_device : $src_wh_device"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_cer_install_dir=$(grep "^src_cer_install_dir," ${src_tmp_dir}misc_data.dat |',
      dcrf_line = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_cer_install_dir ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_cer_install_dir."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_cer_install_dir : $src_cer_install_dir"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_rev_level=$(grep "^src_revision_level," ${src_tmp_dir}misc_data.dat |',
      dcrf_line = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_rev_level ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_rev_level."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_rev_level : $src_rev_level"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_system_user=$(grep "^src_system," ${src_tmp_dir}misc_data.dat |', dcrf_line =
      concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_system_user ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_system_user."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_system_user : $src_system_user"', row + 1, col 0,
      "fi", row + 1, dcrf_line =
      'src_system_pwd=$(grep "^src_system_pwd," ${src_tmp_dir}misc_data.dat |',
      dcrf_line = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0, dcrf_line,
      row + 1, col 0, "if [[ -z $src_system_pwd ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "ERROR: Invalid src_system_pwd."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "else",
      row + 1, col 0, '   echo1 "src_system_pwd : $src_system_pwd"',
      row + 1, col 0, "fi",
      row + 1, row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       dcrf_line = 'src_sec_user_name=$(grep "^src_sec_user_name," ${src_tmp_dir}misc_data.dat |',
       dcrf_line = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
       dcrf_line, row + 1, col 0,
       "if [[ -z $src_sec_user_name ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid src_sec_user_name."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "else", row + 1, col 0,
       '   echo1 "src_sec_user_name : $src_sec_user_name"', row + 1, col 0,
       "fi", row + 1, row + 1
      ENDIF
      dcrf_line = 'src_local_user_name=$(grep "^src_local_user_name," ${src_tmp_dir}misc_data.dat |',
      dcrf_line = concat(dcrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_local_user_name ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_local_user_name."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_local_user_name : $src_local_user_name"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_offline_dict=$(grep "^offline_dict_ind," ${src_tmp_dir}misc_data.dat |',
      dcrf_line = concat(dcrf_line,"awk -F\, '{print $2}')"), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_offline_dict ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_offline_dict."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_offline_dict : $src_offline_dict"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcrf_line = 'src_node_list=`cat ${src_tmp_dir}misc_data.dat | grep -i "^node_name,"|',
      dcrf_line = concat(dcrf_line,"awk -F\, '{print $2}'`"), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ -z $src_node_list ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_node_list."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_node_list : $src_node_list"', row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "src_node_cnt=0", row + 1,
      col 0, "for src_node in $src_node_list; do", row + 1,
      col 0, "   ((src_node_cnt=src_node_cnt+1))", row + 1,
      col 0, "   if [[ $src_node_cnt -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      src_primary_node=$src_node", row + 1,
      col 0, '      echo1 "src_primary_node = $src_primary_node"', row + 1,
      col 0, "   fi", row + 1,
      col 0, "done", row + 1,
      row + 1, col 0, "#---------------------------",
      row + 1, col 0, "##Check for SOURCE *_wh_.sav",
      row + 1, col 0, "#---------------------------",
      row + 1, col 0, 'echo2 "Check for source *_wh.sav."',
      row + 1, row + 1, col 0,
      "if [[ ! -f ${src_tmp_dir}${src_env}_wh.sav ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "File ${src_tmp_dir}${src_env}_wh.sav not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[ $tgt_date_chk -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  find ${src_tmp_dir}${src_env}_wh.sav -mtime +14 |grep ${src_env}_wh.sav", row + 1,
      col 0, "  if [[ $? -eq 0 ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo2 "${src_env}_wh.sav is older than 14 days."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]",
      row + 1, col 0, "then",
      row + 1, col 0, "   #------------------------",
      row + 1, col 0, "   ##Start registry          ",
      row + 1, col 0, "   #------------------------",
      row + 1, col 0, '   echo2 "Start registry"',
      row + 1, col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg",
      row + 1, col 0, "   rm -f $tgt_tmp_full_dir/stop_reg_ind.dat",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#---------------------------", row + 1, col 0,
      "##check if target wh exists ", row + 1, col 0,
      "#---------------------------", row + 1, col 0,
      ^file_cnt=`LANG=C ls -l $tgt_wh_device| grep total|awk -F" " '{print $2}'`^, row + 1, col 0,
      "if [[ $file_cnt != '0' ]]", row + 1, col 0,
      "then", row + 1, row + 1,
      col 0, "   #-----------------------------------------------", row + 1,
      col 0, "   ##Get warehouse for all environments on the node", row + 1,
      col 0, "   #-----------------------------------------------", row + 1,
      col 0, '   echo2 "Get all environments on the node."', row + 1,
      col 0, "$cer_exe/lregview <<!>env_list.dat", row + 1,
      col 0, "cd \environment", row + 1,
      col 0, "dir", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcrf_line = "   env_list=$(grep '^\\' env_list.dat|", dcrf_line = concat(dcrf_line,
       ^awk -F" " '{print $1}'|sed 's/\\//')^),
      col 0, dcrf_line, row + 1,
      col 0, "   echo1 $env_list", row + 1,
      col 0, '   echo "Warehouse List" > wh_list.dat', row + 1,
      row + 1, col 0, "   ind=0",
      row + 1, col 0, '   wh_array[0]="Warehouse list"',
      row + 1, col 0, "   for env in $env_list ; do",
      row + 1, col 0, "      echo1 $env",
      row + 1, row + 1, col 0,
      '      tmp_wh=$($cer_exe/lreg -getp "\Environment\\\\$env" "Warehouse1" 2>null)', row + 1, col
      0,
      "      echo1 $tmp_wh", row + 1, col 0,
      '      found="F"', row + 1, col 0,
      "      i=0", row + 1, col 0,
      '      echo1 "Array Size = "${#wh_array[@]}', row + 1, col 0,
      "      while [ $i -le ${#wh_array[@]} ]", row + 1, col 0,
      "      do", row + 1, col 0,
      "          if [[ $tmp_wh = ${wh_array[$i]} ]]", row + 1, col 0,
      "          then", row + 1, col 0,
      '             found="T"', row + 1, col 0,
      "          fi", row + 1, col 0,
      "          (( i=i+1 ))", row + 1, col 0,
      "      done", row + 1, col 0,
      "      ind=$ind+1", row + 1, col 0,
      "      wh_array[$ind]=$tmp_wh", row + 1, col 0,
      "      echo1 $found", row + 1, col 0,
      '      if [[ $found = "F" ]]', row + 1, col 0,
      "      then", row + 1, col 0,
      "         echo3 '\\'$tmp_wh' ' >> wh_list.dat", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      if [[ $tmp_wh = $tgt_wh ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         if [[  $env = "common" ]]', row + 1,
      col 0, "         then", row + 1,
      col 0, "            common_wh=${tmp_wh}", row + 1,
      col 0, '            echo1 "common_wh = $common_wh"', row + 1,
      row + 1, col 0, "            common_share_wh=1",
      row + 1, col 0, '            echo1 "common_share_wh = $common_share_wh"',
      row + 1, row + 1, col 0,
      '         elif [[ $env != "admin" && $env != $tgt_env ]]', row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Warehouse $tgt_wh is used for environment $env."', row + 1, col 0,
      '            echo2 "This process can not be used to refresh the domain."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, col 0,
      "      fi ", row + 1, col 0,
      "   done", row + 1, row + 1,
      col 0, "   #------------------------------", row + 1,
      col 0, "   ##Get all warehouse on the node", row + 1,
      col 0, "   #-------------------------------", row + 1,
      col 0, '   echo2 "Get all warehouses on the node."', row + 1,
      row + 1, dcrf_line = "   wh_list=$(grep '^\\' wh_list.dat|", dcrf_line = concat(dcrf_line,
       ^awk -F" " '{print $1}'|sed 's/\\//')^),
      col 0, dcrf_line, row + 1,
      col 0, "   echo1 $wh_list", row + 1,
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   ##check if tgt_wh is the only wh on node",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, '   echo1 "Check if tgt_wh is the only wh on node."',
      row + 1, row + 1, col 0,
      "   wh_cnt=0", row + 1, col 0,
      "   for wh in $wh_list ; do", row + 1, col 0,
      "      ((wh_cnt=wh_cnt+1))", row + 1, col 0,
      "   done", row + 1, col 0,
      "   echo1 wh_cnt=$wh_cnt", row + 1, row + 1,
      col 0, "   if [[ $wh_cnt -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      tgt_wh_only=1", row + 1,
      col 0, "   else", row + 1,
      col 0, "      tgt_wh_only=0", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   echo1 tgt_wh_only=$tgt_wh_only", row + 1,
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   ##Idenfity highest revision level for warehouses",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   if [[ $tgt_wh_only -eq 0 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo1 "Identify the highest warehouse based on revision level."',
      row + 1, col 0, "      cur_highest_rev_lvl=0000",
      row + 1, col 0, '      cur_highest_wh="NONE"',
      row + 1, col 0, "      for wh in $wh_list ; do",
      row + 1, col 0, "         if [[ $wh != $tgt_wh ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '         tmp_rev_lvl=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "Revision Level" 2>null)',
      row + 1, col 0,
      '         tmp_rootpath=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "RootPath" 2>null)',
      row + 1, col 0, '         echo1 "tmp_rev_lvl="$tmp_rev_lvl',
      row + 1, col 0, '         echo1 "tmp_rootpath="$tmp_rootpath',
      row + 1, col 0, "         if [[  -d $tmp_rootpath  ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '            file_cnt=`find $tmp_rootpath -type f -print| grep "cb_server_ctrl"|wc -l`',
      row + 1, col 0, "            if [[ $file_cnt -eq 1 ]]",
      row + 1, col 0, "            then",
      row + 1, col 0, "               revision_adjust $tmp_rev_lvl",
      row + 1, col 0, "               bkp_rev_lvl=$rev_lvl",
      row + 1, col 0, "               revision_adjust $cur_highest_rev_lvl",
      row + 1, col 0, "               bkp_highest_rev_lvl=$rev_lvl",
      row + 1, col 0, "               if [[ $bkp_rev_lvl -gt $bkp_highest_rev_lvl ]]",
      row + 1, col 0, "               then",
      row + 1, col 0, "                  cur_highest_wh=$wh",
      row + 1, col 0, "                  cur_highest_rev_lvl=$tmp_rev_lvl",
      row + 1, col 0, "               fi",
      row + 1, col 0, "            fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "      done",
      row + 1, col 0, '      echo2 "cur_highest_wh="$cur_highest_wh',
      row + 1, col 0, '      echo2 "cur_highest_rev_lvl="$cur_highest_rev_lvl',
      row + 1, col 0, '      if [[ $cur_highest_wh = "NONE" || $cur_highest_rev_lvl = 0 ]]',
      row + 1, col 0, "      then",
      row + 1, col 0,
      '        echo2 "Unable to find a valid warehouse on current node other than target. Setting tgt_wh_only = 1."',
      row + 1, col 0, "        tgt_wh_only=1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "   #------------------------------------------------------------------------", row + 1, col 0,
      "   ##if common use tgt_wh and tgt wh is not the only wh, change wh", row + 1, col 0,
      "   #------------------------------------------------------------------------", row + 1, col 0,
      "   if [[  $common_share_wh -eq 1 && tgt_wh_only -eq 0 ]]", row + 1, col 0,
      "   then", row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "      common_new_wh=$cur_highest_wh", row + 1,
       col 0, '      change_common="c"', row + 1,
       col 0,
       '      echo2 "Temporarily changing common warehouse from $common_wh to $common_new_wh "', row
        + 1
      ELSE
       col 0, "      loop=1", row + 1,
       col 0, "      while [[ $loop -eq 1 ]]; do", row + 1,
       col 0, '         echo2 "Prompt to change common warehouse."', row + 1,
       row + 1, col 0, "         for wh in $wh_list ; do",
       row + 1, col 0, "            if [[ $wh != $tgt_wh ]]",
       row + 1, col 0, "            then",
       row + 1, col 0, "               echo2 $wh",
       row + 1, col 0, "            fi",
       row + 1, col 0, "         done",
       row + 1, row + 1, col 0,
       '         echo2 "Please choose a new warehouse for common from list above: \c"', row + 1, col
       0,
       "         read common_new_wh", row + 1, row + 1,
       col 0, "         for wh in $wh_list ; do", row + 1,
       col 0, "            if [[ $wh != $tgt_wh ]]", row + 1,
       col 0, "            then", row + 1,
       col 0, "               if [[ $wh = $common_new_wh ]]", row + 1,
       col 0, "               then", row + 1,
       col 0, "                  new_wh_fnd=1", row + 1,
       col 0, "               fi", row + 1,
       col 0, "            fi", row + 1,
       col 0, "         done", row + 1,
       row + 1, col 0, "         if [[  $new_wh_fnd -ne 1 ]]",
       row + 1, col 0, "         then",
       row + 1, col 0, '            echo2 "$common_new_wh is not in the warehouse list."',
       row + 1, col 0, "         else",
       row + 1, col 0, "            loop=0",
       row + 1, col 0, "         fi",
       row + 1, col 0, "      done",
       row + 1, row + 1, col 0,
       '      echo2 "Change common warehouse from $common_wh to $common_new_wh [C]ontinue or [Q]uit : \c"',
       row + 1, col 0,
       "      read change_common", row + 1
      ENDIF
      row + 1, col 0, "      if [[ $change_common = 'C' || $change_common = 'c' ]]",
      row + 1, col 0, "      then",
      row + 1, row + 1, col 0,
      '         $cer_exe/lreg -setp "\environment\common" "wh_changed" "Y"', row + 1, col 0,
      '         common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed")', row + 1,
      col 0,
      "         if [[ $common_new_prop != 'Y' ]]", row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Failed to add new property wh_changed for common."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, row + 1,
      col 0, '         $cer_exe/lreg -setp "\environment\common" "common_wh_switched" "Y"', row + 1,
      col 0,
      '         common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "         if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Failed to add new property common_wh_switched for common."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      row + 1, col 0,
      '         $cer_exe/lreg -setp "\environment\common" "warehouse1" "$common_new_wh"',
      row + 1, col 0,
      '         common_changed_wh=$($cer_exe/lreg -getp "\environment\common" "warehouse1")',
      row + 1, row + 1, col 0,
      "         if [[ $common_changed_wh != $common_new_wh ]]", row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Failed to change common warehouse to $common_new_wh."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, col 0,
      "      else", row + 1, col 0,
      '         echo2 "User choose to quit when modifying common warehouse."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "   fi", row + 1,
      col 0, "   if [[  $tgt_wh_only -eq 0 ]]", row + 1,
      col 0, "   then", row + 1,
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "      change_common_again=$common_to_tgt", row + 1,
       col 0, "      prompt_common_again=0", row + 1
      ELSE
       col 0, "      prompt_common_again=1", row + 1,
       col 0, "      while [[ $prompt_common_again -eq 1 ]]; do", row + 1,
       dcrf_line = concat('         echo2 "Would you like to change common warehouse after target',
        ' warehouse is rebuilt [Y]es or [N]o? \c"'), col 0, dcrf_line,
       row + 1, col 0, "         read change_common_again",
       row + 1, dcrf_line = concat(
        "         if [[ $change_common_again = 'Y' || $change_common_again = 'y' || ",
        " $change_common_again = 'YES' ||  $change_common_again = 'yes' ||  $change_common_again = 'Yes' || ",
        "$change_common_again = 'N' || $change_common_again = 'n' || $change_common_again = 'No' || ",
        "$change_common_again = 'no' || $change_common_again = 'NO' ]]"), col 0,
       dcrf_line, row + 1, col 0,
       "         then", row + 1, col 0,
       "            prompt_common_again=0", row + 1, col 0,
       "         fi", row + 1, col 0,
       "      done", row + 1
      ENDIF
      dcrf_line = concat("         if [[ $change_common_again = 'Y' || $change_common_again = 'y' ||",
       "$change_common_again = 'Yes' || $change_common_again = 'yes' || $change_common_again = 'YES' ]]"
       ), col 0, dcrf_line,
      row + 1, col 0, "         then",
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "            common_back_wh=$tgt_wh", row + 1,
       col 0,
       '            echo2 "Changing common warehouse back to $common_back_wh after rebuilding target warehouse"',
       row + 1
      ELSE
       col 0, "            loop=1", row + 1,
       col 0, "            while [[ $loop -eq 1 ]]; do", row + 1,
       col 0, '               echo2 "Prompt to change common warehouse."', row + 1,
       row + 1, col 0, "               for wh in $wh_list ; do",
       row + 1, col 0, "                  if [[ $wh != $common_new_wh ]]",
       row + 1, col 0, "                  then",
       row + 1, col 0, "                     echo2 $wh",
       row + 1, col 0, "                  fi",
       row + 1, col 0, "               done",
       row + 1, row + 1, col 0,
       '               echo2 "Please choose a warehouse for common to change to from list above: \c"',
       row + 1, col 0,
       "               read common_back_wh", row + 1, row + 1,
       col 0, "               for wh in $wh_list ; do", row + 1,
       col 0, "                  if [[ $wh != $common_new_wh ]]", row + 1,
       col 0, "                  then", row + 1,
       col 0, "                     if [[ $wh = $common_back_wh ]]", row + 1,
       col 0, "                     then", row + 1,
       col 0, "                        back_wh_fnd=1", row + 1,
       col 0, "                     fi", row + 1,
       col 0, "                  fi", row + 1,
       col 0, "               done", row + 1,
       row + 1, col 0, "               if [[  $back_wh_fnd -ne 1 ]]",
       row + 1, col 0, "               then",
       row + 1, col 0, '                  echo2 "$common_back_wh is not in the warehouse list."',
       row + 1, col 0, "               else",
       row + 1, col 0, "                  loop=0",
       row + 1, col 0, "               fi",
       row + 1, col 0, "            done",
       row + 1, row + 1
      ENDIF
      col 0,
      '            $cer_exe/lreg -setp "\environment\common" "wh_changed_again" "$common_back_wh"',
      row + 1,
      col 0,
      '            common_again_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again")',
      row + 1,
      col 0, "            if [[ $common_again_prop != $common_back_wh ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Failed to add new property wh_changed_again for common."', row +
      1,
      col 0, "               exit 1", row + 1,
      col 0, "            fi", row + 1,
      col 0,
      '            common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "            if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Note: "unable to get property" is an acceptable error"', row + 1,
      col 0, '               $cer_exe/lreg -setp "\environment\common" "common_wh_switched" "Y"', row
       + 1,
      col 0,
      '               common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "               if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "               then", row + 1,
      col 0, '                  echo2 "Failed to add new property common_wh_switched for common."',
      row + 1,
      col 0, "                  exit 1", row + 1,
      col 0, "               fi", row + 1,
      col 0, "            fi", row + 1,
      row + 1, col 0, "         else",
      row + 1, col 0,
      '            echo2 "User choose not to change common warehouse after target is rebuilt."',
      row + 1, col 0, "         fi",
      row + 1, row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   #-----------------", row + 1,
      col 0, "   ##Stop all servers", row + 1,
      col 0, "   #-----------------", row + 1,
      col 0, '   echo2 "Terminate servers."', row + 1,
      row + 1, col 0, "   test -e $cer_exe/server_ctrl",
      row + 1, col 0, "   if (( $? == 0 ))",
      row + 1, col 0, "   then",
      row + 1, col 0, '     srv_cmd="$cer_exe/scpview -dom"',
      row + 1, col 0, "   else",
      row + 1, col 0, '     srv_cmd="$cer_exe/cmbview -dom"',
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "$srv_cmd $tgt_domain_name <<!", row + 1, col 0,
      "kill -all", row + 1, col 0,
      "exit", row + 1, col 0,
      "!", row + 1, row + 1,
      col 0, "   loop=0", row + 1,
      col 0, "   while [[ $loop -lt 20 ]]; do", row + 1,
      col 0, "      sleep 15", row + 1,
      col 0, "      ((loop=loop+1))", row + 1,
      col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat", row + 1,
      col 0, "server", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcrf_line = "      server_list=$(grep '^[0-9]' server_list.dat|", dcrf_line = concat(
       dcrf_line,^awk -F" " '{print $1}')^),
      col 0, dcrf_line, row + 1,
      row + 1, col 0, "      if [[ -z $server_list ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "All servers are terminated with -all."',
      row + 1, col 0, "         loop=100",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   done",
      row + 1, row + 1, col 0,
      "   if [[ ! -z $server_list ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      "      if [[ -f server_cmd.dat ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         rm server_cmd.dat", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      for server_inst in $server_list ; do", row + 1,
      col 0, '         echo "kill $server_inst" >>server_cmd.dat', row + 1,
      col 0, "      done", row + 1,
      row + 1, col 0, '      echo "exit" >>server_cmd.dat ',
      row + 1, row + 1, col 0,
      "$srv_cmd $tgt_domain_name<server_cmd.dat", row + 1, row + 1,
      col 0, "#must start in the beginning of the line, othewise will error", row + 1,
      col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat", row + 1,
      col 0, "server", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcrf_line = "      server_list=$(grep '^[0-9]' server_list.dat|", dcrf_line = concat(
       dcrf_line,^awk -F" " '{print $1}')^),
      col 0, dcrf_line, row + 1,
      row + 1, col 0, "      if [[ -z $server_list ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "All servers are terminated."',
      row + 1, col 0, "      else",
      row + 1, col 0, '         echo2 "servers can not be terminated."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "   #--------------------------------", row + 1, col 0,
      "   ##Clean-up the CMB Global Section ", row + 1, col 0,
      "   #---------------------------------", row + 1, col 0,
      '   echo2 "Clean up cmb global section."', row + 1, row + 1,
      col 0, "   $cer_proc/terminate_cmb.ksh $tgt_domain_name 0 Y N", row + 1,
      col 0, "   if [[ -f $cer_proc/delete_cmb_gs.ksh ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '         echo "Y" | $cer_proc/delete_cmb_gs.ksh $tgt_domain_name ', row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "   #--------------------------------",
      row + 1, col 0, "   ##Delete the audit and code cache ",
      row + 1, col 0, "   #--------------------------------",
      row + 1, col 0, '   echo2 "Delete audit and code cache."',
      row + 1, row + 1, col 0,
      "   $cer_exe/auditconf -destroy", row + 1, col 0,
      "   code -destroy", row + 1, row + 1,
      col 0, "   #------------------------------------", row + 1,
      col 0, "   ##destroy the que_stat global section ", row + 1,
      col 0,
      '   ##(Note:  "que_stat: unable to destroy memory manager [OS error 2424]" is an ignorable error):',
      row + 1,
      col 0, "   #------------------------------------", row + 1,
      col 0, '   echo2 "Destroy the que_stat global section."', row + 1,
      row + 1, col 0, "   $cer_exe/gmm -destroy que_stat",
      row + 1, row + 1, col 0,
      "   get_server_ctrl", row + 1, row + 1,
      col 0, "   #----------------------------------------", row + 1,
      col 0, "   ##check for wh_changed property on common", row + 1,
      col 0, "   #----------------------------------------", row + 1,
      col 0, '   echo2 "Check for wh_changed property on common."', row + 1,
      row + 1, col 0,
      '   common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed" 2>null)',
      row + 1, row + 1, col 0,
      "   if [[ $common_new_prop = 'Y' ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      "      common_new_prop_fnd=1 ", row + 1, col 0,
      "   else", row + 1, col 0,
      '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1, col 0,
      "      common_new_prop_fnd=0 ", row + 1, col 0,
      "   fi", row + 1, col 0,
      "   echo1 common_new_prop_fnd = $common_new_prop_fnd", row + 1, row + 1,
      col 0, "   #------------------------------------------------------------------------------",
      row + 1,
      col 0, "   ##Cycle server controller, domain directory, resolver if common new prop found ",
      row + 1,
      col 0, "   #------------------------------------------------------------------------------",
      row + 1,
      col 0, "   if [[ $common_new_prop_fnd -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "common new property found."', row + 1,
      row + 1, col 0, "      cycle_common",
      row + 1, col 0, "      cycle_reg",
      row + 1, row + 1, col 0,
      "      #remove common new prop", row + 1, col 0,
      ^      echo1 "Remove common's new property."^, row + 1, col 0,
      '      $cer_exe/lreg -delp "\environment\common" "wh_changed" ', row + 1, row + 1,
      col 0, '      common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed" 2>null)',
      row + 1,
      col 0, "      if [[ $? -eq 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, ^         echo2 "New property 'wh_changed' failed to be removed."^, row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1, col 0,
      "   ##Terminate server controller, domain directory, resolver if target wh is the only warehouse on node",
      row + 1, col 0, "   ##and node level server controller is found and 2012 domain is found.",
      row + 1, col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1, col 0, "   elif (( $tgt_wh_only == 1 && ${cb_cycle} == 1 ))",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "$tgt_wh is the only warehouse on the node."',
      row + 1, col 0, '      echo2 "Terminate server controller, domain directory and resolver."',
      row + 1, row + 1, col 0,
      "      $cer_exe/cb_shutdown -ctrl", row + 1, col 0,
      "      loop=0", row + 1, col 0,
      "      while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "         sleep 5", row + 1, col 0,
      "         ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "         if [[ $? -ne 0 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, "            loop=100", row + 1,
      col 0, "         elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Terminate server controller failed."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      done", row + 1,
      row + 1, col 0, "      $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "      #check if resolver exists", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         resolver_exist=1", row + 1, col 0,
      "      else", row + 1, col 0,
      "         resolver_exist=0", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "      then ", row + 1,
      col 0, "         $cer_exe/cb_shutdown -res", row + 1,
      col 0, "         loop=0", row + 1,
      col 0, "         while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "            sleep 5", row + 1,
      col 0, "            ((loop=loop+1))", row + 1,
      col 0, "            ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "            if [[ $? -ne 0 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, "               loop=100", row + 1,
      col 0, "            elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Terminate resolver failed."', row + 1,
      col 0, "               exit 1", row + 1,
      col 0, "            fi", row + 1,
      col 0, "         done", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       col 0, "     #------------------------", row + 1,
       col 0, "     ##Stop registry          ", row + 1,
       col 0, "     #------------------------", row + 1,
       col 0, '     echo2 "Stop registry"', row + 1,
       col 0, "     $cer_mgr_exe/reg_server -stop", row + 1,
       dcrf_line = concat(
        "      ps -ef |grep reg_server |grep cerner |sed 's/\([ ]*[A-Za-z0-9_]*[ ]*\) \([0-9]*\) \([^`]*\)/\2/'",
        " > /tmp/dm2_qpid_dump.txt"), col 0, dcrf_line,
       row + 1, col 0, "     if [[ -s /tmp/dm2_qpid_dump.txt ]]",
       row + 1, col 0, "     then",
       row + 1, col 0, "         trgprocid=`head -n 1 /tmp/dm2_qpid_dump.txt`",
       row + 1, col 0, "         rm -f /tmp/dm2_qpid_dump.txt",
       row + 1, col 0, '         echo1 "Initiating a kill -9 $trgprocid"',
       row + 1, col 0, "         kill -9 $trgprocid",
       row + 1, col 0, "        sleep 2",
       row + 1, col 0, "     else",
       row + 1, col 0, '         echo1 "Reg Server has already stopped"',
       row + 1, col 0, "     fi",
       row + 1, col 0, '     echo "registry stopped" >>$tgt_tmp_full_dir/stop_reg_ind.dat',
       row + 1
      ENDIF
      col 0, "   #------------------------", row + 1,
      col 0, "   ##Delete target warehouse ", row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, '   echo2 "Delete Target warehouse."', row + 1,
      col 0, "   rm -fR $tgt_wh_device/*", row + 1,
      row + 1, col 0, ^   file_cnt=`LANG=C ls -l $tgt_wh_device| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "   if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "Target warehouse $tgt_wh_device failed to be deleted."',
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#--------------------------------", row + 1, col 0,
      "##Extract source wh backup file  ", row + 1, col 0,
      "#--------------------------------", row + 1, row + 1,
      col 0, 'echo2 "Extract $tgt_wh_device/${src_env}_wh.sav"', row + 1,
      col 0, "cd $tgt_wh_device", row + 1,
      col 0, "tar -xvf ${src_tmp_dir}${src_env}_wh.sav ", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to extract $tgt_wh_device/${src_env}_wh.sav."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       col 0, "   #------------------------", row + 1,
       col 0, "   ##Start registry          ", row + 1,
       col 0, "   #------------------------", row + 1,
       col 0, '   echo2 "Start registry"', row + 1,
       col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1,
       col 0, "   if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, "      rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1,
       col 0, "   fi", row + 1,
       row + 1
      ENDIF
      col 0, "#------------------------", row + 1,
      col 0, "##Recreate symbolic links", row + 1,
      col 0, "#------------------------", row + 1,
      col 0, 'echo2 "Recreating symbolic links"', row + 1,
      col 0, "if [[ -f ${src_tmp_dir}/link_data.dat ]]", row + 1,
      col 0, "then ", row + 1,
      col 0, '  echo2 "Get all Source symbolic links to process..." ', row + 1,
      col 0, "  cat ${src_tmp_dir}/link_data.dat | while read line ", row + 1,
      col 0, "  do  ", row + 1,
      col 0, "     line_eval=`eval echo $line`  ", row + 1,
      col 0, '     full_link_name=`echo $line_eval | cut -f2 -d" "`', row + 1,
      col 0, '     full_file_name=`echo $line_eval | cut -f3 -d" "`', row + 1,
      col 0, "     if [[ -h ${full_link_name} ]] ", row + 1,
      col 0, "     then  ", row + 1,
      col 0, '       echo2 "  Removing symbolic link ${full_link_name}."', row + 1,
      col 0, "       rm -f ${full_link_name}  ", row + 1,
      col 0, "       if [[ $? -ne 0 ]]  ", row + 1,
      col 0, "       then  ", row + 1,
      col 0, '         echo2 "Failed to remove symbolic link ${full_link_name}." ', row + 1,
      col 0, "         exit 1 ", row + 1,
      col 0, "       fi ", row + 1,
      col 0, "     else ", row + 1,
      col 0, '       echo2 "  Symbolic link ${full_link_name} does not exist."', row + 1,
      col 0, "     fi  ", row + 1,
      col 0, "     if [[ ! -z ${full_file_name} ]]", row + 1,
      col 0, "     then                                                    ", row + 1,
      col 0, '       echo2 "  Creating symbolic link ${full_link_name} to file ${full_file_name}." ',
      row + 1,
      col 0, "       ln -sf ${full_file_name} ${full_link_name} ", row + 1,
      col 0, "       if [[ $? -ne 0 ]]   ", row + 1,
      col 0, "       then ", row + 1,
      col 0, '         echo2 "Failed to create symbolic link ${full_link_name} - exit status $?."  ',
      row + 1,
      col 0, "         exit 1 ", row + 1,
      col 0, "       fi", row + 1,
      col 0, "     else ", row + 1,
      col 0, '       echo2 "  Symbolic link ${full_link_name} will not be created." ', row + 1,
      col 0, "     fi ", row + 1,
      col 0, "  done ", row + 1,
      col 0, "fi ", row + 1,
      row + 1, col 0, "#-----------------------------------",
      row + 1, col 0, "#Issue privilege & ownership changes ",
      row + 1, col 0, "#-----------------------------------",
      row + 1, col 0, "chmod -R 775 $tgt_wh_device",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to change mod for $tgt_wh_device."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       dcrf_line = "chown -R b_common:sys $tgt_wh_device"
      ELSE
       dcrf_line = "chown -R b_common:system $tgt_wh_device"
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change owner for $tgt_wh_device."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0,
      "#-----------------------------------------------------------------------------------------------------------",
      row + 1, col 0,
      "#Start the server controller,domain directory and resolver If TARGET's warehouse is the only one on the node",
      row + 1, col 0, "#and node level server controller is found and 2012 domain is found.",
      row + 1, col 0,
      "#------------------------------------------------------------------------------------------------------------",
      row + 1, col 0, "if (( $tgt_wh_only == 1 && ${cb_cycle} == 1 ))",
      row + 1, col 0, "then",
      row + 1, col 0,
      '   echo2 "$tgt_wh is the only warehouse on the node.  Start server controller, domain directory and resolver."',
      row + 1, row + 1, col 0,
      "   $cer_exe/cb_startup -ctrl", row + 1, col 0,
      "   loop=0", row + 1, col 0,
      "   while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "      sleep 5", row + 1, col 0,
      "      ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "      if [[ $? -eq 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         loop=100", row + 1,
      col 0, "      elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Start server controller failed."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   done", row + 1,
      row + 1, col 0, "   $cer_exe/cb_startup -ddir",
      row + 1, row + 1, col 0,
      "   #check if resolver exists", row + 1, col 0,
      "   ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      "      resolver_exist=1", row + 1, col 0,
      "   else", row + 1, col 0,
      "      resolver_exist=0", row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      $cer_exe/cb_startup -res", row + 1,
      col 0, "      loop=0", row + 1,
      col 0, "      while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "         sleep 5", row + 1,
      col 0, "         ((loop=loop+1))", row + 1,
      col 0, "         ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "         if [[ $? -eq 0 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, "            loop=100", row + 1,
      col 0, "         elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Start resolver failed."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      done", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "#-------------------------",
      row + 1, col 0, "#config Offline Dictionary",
      row + 1, col 0, "#-------------------------",
      row + 1, col 0,
      "ccldiraccess=$($cer_exe/getlog CCLDIRACCESS | grep '\[global\]' | sed 's/.*--> //')",
      row + 1, col 0, "if [[ ! -z $ccldiraccess ]]",
      row + 1, col 0, "then",
      row + 1, col 0,
      '   echo2 "Offline dictionary is used.  Verify CCLDIRACCESS is 1WRITE and CCLDIR match CCLDIR1."',
      row + 1, row + 1, col 0,
      "   if [[ $ccldiraccess != '1WRITE' ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      echo2 "Change CCLDIRACCESS to 1WRITE."', row + 1, row + 1,
      col 0, '      $cer_exe/setlog -g "CCLDIRACCESS" "1WRITE"', row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Failed to set logical CCLDIRACCESS to 1WRITE."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "ccldiraccess")'
        )
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "ccldiraccess")'
        )
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "ccldiraccess")'
        )
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "   if [[ $ccldiraccess_reg != '1WRITE' ]]", row + 1,
      col 0, "   then", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "ccldiraccess" "1WRITE"'
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "ccldiraccess" "1WRITE"'
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "ccldiraccess" "1WRITE"'
      ENDIF
      row + 1, col 0, "      if [[ $? -ne 0 ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Failed to update registry CCLDIRACCESS to 1WRITE."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   ccldir=$($cer_exe/getlog CCLDIR | grep '\[global\]' | sed 's/.*--> //')", row + 1,
      col 0, "   ccldir1=$($cer_exe/getlog CCLDIR1 | grep '\[global\]' | sed 's/.*--> //')", row + 1,
      col 0, "   if [[ $ccldir != $ccldir1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Change CCLDIR to match CCLDIR1 value $ccldir1."', row + 1,
      row + 1, col 0, '      $cer_exe/setlog -g "CCLDIR" $ccldir1',
      row + 1, col 0, "      if [[ $? -ne 0 ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Failed to set logical CCLDIR to $ccldir1."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcrf_line = concat(
        'tgt_ccldir_value=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" ',
        '"CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line = concat(
        'tgt_ccldir_value=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" ',
        '"CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcrf_line = concat(
        'tgt_ccldir_value=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\linuxx86-64',
        '\environment" "CCLDIR")')
      ENDIF
      col 4, dcrf_line, row + 1,
      col 0, ^   if [[ $tgt_ccldir_value != "'cer_data'/ccldir" ]]^, row + 1,
      col 0, "   then", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ENDIF
      col 7, dcrf_line, row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, ^         echo2 "Failed to update registry CCLDIR to 'cer_data'/ccldir."^, row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      '   echo2 "Run start_cerner_500 after logical change."', row + 1, col 0,
      "   $cer_mgr_exe/start_cerner_500 -env $tgt_env -verbose", row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "CCLDIR")')
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "   cer_data_value=$($cer_exe/getlog cer_data | grep '\[global\]' | sed 's/.*--> //')",
      row + 1,
      col 0, '   cer_data_value=$(echo ${cer_data_value}|sed "s/\//\\\\\//g")', row + 1
      IF ((dm2_sys_misc->cur_os="LNX"))
       col 0,
       ^   tgt_ccldir_value=$(echo ${tgt_ccldir_value}|sed "s/'//g"|sed "s/cer_data/${cer_data_value}/g")^,
       row + 1
      ELSE
       col 0,
       ^   tgt_ccldir_value=$(echo ${tgt_ccldir_value}|sed "s/\'//g"|sed "s/cer_data/${cer_data_value}/g")^,
       row + 1
      ENDIF
      col 0, "else", row + 1,
      col 0, "   tgt_ccldir_value=$($cer_exe/getlog CCLDIR | grep '\[global\]' | sed 's/.*--> //')",
      row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "if [[  -d $tgt_ccldir_value  ]]",
      row + 1, col 0, "then",
      row + 1, col 0,
      ^   file_cnt=`LANG=C ls -l $tgt_ccldir_value| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "   if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "      #------------------------",
      row + 1, col 0, "      ##Delete target CCLDIR ",
      row + 1, col 0, "      #------------------------",
      row + 1, col 0, '      echo2 "Delete Target CCLDIR."',
      row + 1, col 0, "      rm -R $tgt_ccldir_value/*",
      row + 1, row + 1, col 0,
      ^      file_cnt=`LANG=C ls -l $tgt_ccldir_value| grep total|awk -F" " '{print $2}'`^, row + 1,
      col 0,
      "      if [[ $file_cnt != '0' ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "Target $tgt_ccldir_value was not deleted."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "   fi", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[  -d $cer_config  ]]", row + 1,
      col 0, "then", row + 1,
      col 0, ^   file_cnt=`LANG=C ls -l $cer_config| grep total|awk -F" " '{print $2}'`^, row + 1,
      col 0, "   if [[ $file_cnt != '0' ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      #------------------------", row + 1,
      col 0, "      ##Delete target cer_config ", row + 1,
      col 0, "      #------------------------", row + 1,
      col 0, '      echo2 "Delete Target cer_config."', row + 1,
      col 0, "      rm -R $cer_config/*", row + 1,
      row + 1, col 0, ^      file_cnt=`LANG=C ls -l $cer_config| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "      if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Target $cer_config was not deleted."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#-----------------------------------------------", row + 1, col 0,
      "##Extract backup file from CCLDIR and CER_CONFIG ", row + 1, col 0,
      "#-----------------------------------------------", row + 1, row + 1,
      col 0, 'echo2 "Extract ${src_tmp_dir}${src_env}_ccldir.sav"', row + 1,
      col 0, "cd $tgt_ccldir_value", row + 1,
      col 0, "tar -xvf ${src_tmp_dir}${src_env}_ccldir.sav ", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to extract ${src_tmp_dir}${src_env}_ccldir.sav."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, 'echo2 "Extract ${src_tmp_dir}${src_env}_config.sav"',
      row + 1, col 0, "cd $cer_config",
      row + 1, col 0, "tar -xvf ${src_tmp_dir}${src_env}_config.sav ",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to extract ${src_tmp_dir}${src_env}_config.sav."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#---------------------------------------------------------------", row + 1, col 0,
      "##Delete  dic.dat and dic.idx from CCLDIR and CER_CONFIG ", row + 1, col 0,
      "#---------------------------------------------------------------", row + 1, col 0,
      "ls -l $tgt_ccldir_value/dic.*", row + 1, col 0,
      "if [[ $? -eq 0 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "Delete dic.dat and dic.idx from $tgt_ccldir_value"', row + 1, col 0,
      "   rm $tgt_ccldir_value/dic.*", row + 1, col 0,
      "   if [[ $? -ne 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      echo2 "Failed to delete dic.dat and dic.idx from $tgt_ccldir_value."', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#--------------------------", row + 1,
      col 0, "##Copy DIC.DAT and DIC.IDX", row + 1,
      col 0, "#--------------------------", row + 1,
      col 0, 'echo2 "Copy dic.dat and dic.idx to $tgt_ccldir_value."', row + 1,
      col 0, "cp -p $cer_install/dic.dat $tgt_ccldir_value", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to copy dic.dat to $tgt_ccldir_value."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "cp -p $cer_install/dic.idx $tgt_ccldir_value",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to copy dic.idx to $tgt_ccldir_value."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#------------------------------------------", row + 1, col 0,
      "#Permission change on CCLDIR and CER_CONFIG", row + 1, col 0,
      "#------------------------------------------", row + 1, col 0,
      'echo2 "Change permission and owner on $tgt_ccldir_value and $cer_config."', row + 1, row + 1,
      col 0, "chmod -R 777 $tgt_ccldir_value", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change mod on CCLDIR."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "chmod -R 777 $cer_config",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '  echo2 "Failed to change mod on CER_CONFIG."',
      row + 1, col 0, "  exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, dcrf_line = concat("chown -R ",ddr_domain_data->tgt_local_user_name,":",
       ddr_domain_data->tgt_local_group_name," $tgt_ccldir_value"),
      col 0, dcrf_line, row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change owner on CCLDIR."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, dcrf_line = concat("chown -R ",ddr_domain_data->tgt_local_user_name,":",
       ddr_domain_data->tgt_local_group_name," $cer_config"), col 0,
      dcrf_line, row + 1, col 0,
      "if [[ $? -ne 0 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "Failed to change owner on CER_CONFIG."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#---------------------------------------------------------------", row + 1,
      col 0, "##Remove extraneous components from CCLDIR and CERCONFIG", row + 1,
      col 0, "#---------------------------------------------------------------", row + 1,
      col 0, "for i in `ls $tgt_ccldir_value | awk {'print $1'}`; do ", row + 1,
      col 0, "if [[ $i != *.dat && $i != *.idx && $i != *bcheck* ]]  ", row + 1,
      col 0, "then  ", row + 1,
      col 0, "   rm -rf $tgt_ccldir_value/$i  ", row + 1,
      col 0, "   if [[ $? -ne 0 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Failed to clean CCLDIR."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi    ", row + 1,
      col 0, "done  ", row + 2,
      col 0, "for i in `ls $cer_config | awk {'print $1'}`; do ", row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       dcrf_line = concat("if [[ $i != core.il && $i != msg_table.dat && $i != ","$src_sec_user_name",
        ".dat ","&& $i != ","$src_sec_user_name",
        ".idx ","&& $i != tdb_system.dat && $i != tdb_system.idx && $i != jou*.dat ]] ")
      ELSE
       dcrf_line = concat("if [[ $i != core.il && $i != msg_table.dat ",
        "&& $i != tdb_system.dat && $i != tdb_system.idx && $i != jou*.dat ]] ")
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0, "then ", row + 1,
      col 0, "   rm -rf $cer_config/$i ", row + 1,
      col 0, "   if [[ $? -ne 0 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Failed to clean cer_config."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi   ", row + 1,
      col 0, "done ", row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       col 0,
       'echo1 "Renaming sec_user files in cer_config from "$src_sec_user_name" to match target."',
       row + 1,
       dcrf_line = concat('if [[ $src_sec_user_name != "',trim(cnvtlower(ddr_domain_data->
          tgt_sec_user_name)),'" ]]'), col 0, dcrf_line,
       row + 1, col 0, "then ",
       row + 1, dcrf_line = concat("   mv $cer_config/","${src_sec_user_name}",".dat ","$cer_config/",
        ddr_domain_data->tgt_sec_user_name,
        ".dat"), col 0,
       dcrf_line, row + 1, dcrf_line = concat("   mv $cer_config/","${src_sec_user_name}",".idx ",
        "$cer_config/",ddr_domain_data->tgt_sec_user_name,
        ".idx"),
       col 0, dcrf_line, row + 1,
       col 0, "fi   ", row + 1
      ENDIF
      col 0, "#---------------------", row + 1,
      col 0, "#Change common wh back", row + 1,
      col 0, "#---------------------", row + 1,
      col 0, 'common_back_wh=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again")', row +
      1,
      col 0, "if [[ ! -z $common_back_wh ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Change common warehouse from $common_new_wh to $common_back_wh "', row + 1,
      col 0, '   $cer_exe/lreg -setp "\environment\common" "warehouse1" "$common_back_wh"', row + 1,
      col 0, '   common_changed_again=$($cer_exe/lreg -getp "\environment\common" "warehouse1")', row
       + 1,
      row + 1, col 0, "   if [[ $common_changed_again != $common_back_wh ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "Failed to change common warehouse to $common_back_wh."',
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   #remove common wh_changed_again prop",
      row + 1, col 0, ^   echo1 "Remove common's wh_changed_again property."^,
      row + 1, col 0, '   $cer_exe/lreg -delp "\environment\common" "wh_changed_again" ',
      row + 1, row + 1, col 0,
      '   common_changed_again_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again" 2>null)',
      row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      ^      echo2 "Property 'wh_changed_again' failed to be removed."^, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1, col 0,
      "fi", row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       IF ((dm2_sys_misc->cur_os="AIX"))
        dcrf_line = 'ic_version=`${tgt_wh_device}/aixrs6000/install_cerner -version | cut -f4 -d" "`'
       ELSEIF ((dm2_sys_misc->cur_os="HPX"))
        dcrf_line = 'ic_version=`${tgt_wh_device}/hpuxia64/install_cerner -version | cut -f4 -d" "`'
       ELSEIF ((dm2_sys_misc->cur_os="LNX"))
        dcrf_line =
        'ic_version=`${tgt_wh_device}/linuxx86-64/install_cerner -version | cut -f4 -d" "`'
       ENDIF
       col 0, dcrf_line, row + 1,
       col 0, 'ic_v1=`echo $ic_version | cut -f1 -d"."`', row + 1,
       col 0, 'ic_v2=`echo $ic_version | cut -f2 -d"."`', row + 1,
       col 0, 'ic_v3=`echo $ic_version | cut -f3 -d"."`', row + 1,
       col 0, "ic_version_int=$((ic_v1*10000+ic_v2*100+ic_v3))", row + 1,
       col 0, "if [[ $ic_version_int -eq 60000 ||  $ic_version_int -gt 60000  ]]", row + 1,
       col 0, "then", row + 1,
       col 0, "  ic_input_file_ind=1", row + 1,
       col 0, "fi", row + 1,
       col 0, "if [[ $dm2_bypass_ic_input_file -eq 1  ]]", row + 1,
       col 0, "then", row + 1,
       col 0,
       '  echo2 "Found dm2_bypass_id_input_file variable. Using interactive method for install_cerner."',
       row + 1,
       col 0, "  ic_input_file_ind=0", row + 1,
       col 0, "fi", row + 1
      ENDIF
      col 0, 'common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "if [[ $common_switched_prop = 'Y' || tgt_wh_only -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   common_wh_name=$($cer_exe/lreg -getp "\environment\common" "Warehouse1")', row + 1,
      col 0, '   common_wh_path=$($cer_exe/lreg -getp "\warehouse\\\\${common_wh_name}" "RootPath")',
      row + 1,
      col 0, '   echo2 "Using install_cerner to refresh core components."', row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   ic_cmd="${tgt_wh_device}/aixrs6000/install_cerner -core -verbose"', row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, '   ic_cmd="${tgt_wh_device}/hpuxia64/install_cerner -core -verbose"', row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, '   ic_cmd="${tgt_wh_device}/linuxx86-64/install_cerner -core -verbose"', row + 1
      ENDIF
      col 0, '   echo2 "Launching ${ic_cmd}"', row + 1,
      col 0, '   echo2 ""', row + 1,
      col 0, "   #If ic_input_file_ind is set, then use input file version of install cerner", row +
      1,
      col 0, "   if [[ $ic_input_file_ind -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '     ic_input_file_name="${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}.txt"', row + 1,
      col 0, '     echo1 "Write Install Cerner input file - $ic_input_file_name"', row + 1,
      row + 1, col 0, '     echo "section:core;" >${ic_input_file_name}',
      row + 1, col 0, '     echo "  topdirectory:${tgt_top_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  source:${common_wh_path};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cdrom:${cd_rom_loc};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr:${tgt_cer_mgr_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr_exe:${tgt_cer_mgr_exe_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr_log:${tgt_cer_mgr_log_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_reg:${tgt_cer_reg_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_fifo:${tgt_cer_fifo_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_usock:${tgt_cer_usock_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_lock:${tgt_cer_lock_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "section:end;" >>${ic_input_file_name}',
      row + 1, col 0, '     echo " " >>${ic_input_file_name}',
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcrf_line = concat(
        "   ${tgt_wh_device}/aixrs6000/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcrf_line = concat(
        "   ${tgt_wh_device}/hpuxia64/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcrf_line = concat(
        "   ${tgt_wh_device}/linuxx86-64/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ENDIF
      col 0, dcrf_line, row + 1,
      col 0,
      '     err_cnt=`cat ${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt | grep -i "error: " | wc -l`',
      row + 1,
      col 0, "     if [[ ${err_cnt} -gt 0 ]]", row + 1,
      col 0, "     then", row + 1,
      col 0, "       if [[ ${dm2_ignore_cv_errors} -ne 1 ]]", row + 1,
      col 0, "       then", row + 1,
      col 0,
      '         echo2 "Execution of install_cerner using input file failed during core refresh."',
      row + 1,
      col 0,
      '         echo2 "For error details please view ${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt"',
      row + 1,
      col 0,
      '         echo2 "If errors are ignorable, perform the following before restarting dm2_target_refresh.ksh"',
      row + 1,
      col 0, '         echo2 "export dm2_ignore_cv_errors=1"', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "       fi", row + 1,
      col 0, "     else", row + 1,
      col 0,
      '       echo2 "Execution of install_cerner using input file was successful during ${ic_cmd}."',
      row + 1,
      col 0, "     fi", row + 1,
      col 0, "   else", row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo2 "*                                     Install Cerner                                     *"',
      row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo2 "*Open another session and execute Install_Cerner as shown below.                         *"',
      row + 1,
      col 0,
      '     echo2 "*Answer the prompts according to the output below.                                       *"',
      row + 1,
      col 0,
      '     echo2 "*Do not continue until Install_Cerner completes successfully.                            *"',
      row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0, '     echo2 ""', row + 1,
      col 0, '     echo2 "${ic_cmd}"', row + 1,
      col 0, '     echo2 "" ', row + 1,
      col 0, '     echo2 "Install_Cerner Prompts and recommended answers:"', row + 1,
      col 0, '     echo2 "CD-ROM Location [] > / "', row + 1,
      col 0, '     echo2 "Is this correct? [y] > Y"', row + 1,
      col 0, '     echo2 "Do you wish to refresh the cer_mgr directory? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to refresh the cer_mgr_exe directory? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to refresh the system registry template? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to run start_cerner_500 after creation? [Y] > Y"', row + 1,
      col 0, '     echo2 "Hit C to continue; E to exit. > C" ', row + 1,
      col 0,
      '     echo "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo3 "*Has the execution of Install_Cerner as shown above completed successfully?[Y/N] \c" ',
      row + 1,
      col 0, "     read answer ", row + 1,
      col 0, "     typeset -l answer=$answer", row + 1,
      col 0,
      '     echo "******************************************************************************************"',
      row + 1,
      col 0, '     if [[ $answer != "y" ]]', row + 1,
      col 0, "     then", row + 1,
      col 0, '        echo2 "User choose to quit."', row + 1,
      col 0, "        exit 1 ", row + 1,
      col 0, "     fi", row + 1,
      col 0, "   fi", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   echo2 "Update registry."', row + 1,
       col 0,
       "   $tgt_wh_device/aixrs6000/update_reg -input $tgt_wh_device/install/update_reg_aix.csv ",
       row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_hpux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/hpuxia64/update_reg -input $tgt_wh_device/install/update_reg_hpux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_hpux.csv file not found."', row
        + 1,
       col 0, "   fi", row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_linux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/linuxx86-64/update_reg -input $tgt_wh_device/install/update_reg_linux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_linux.csv file not found."',
       row + 1,
       col 0, "   fi", row + 1
      ENDIF
      col 0, '   echo2 "Run start_cerner_500 for common environment."', row + 1,
      col 0, "   $cer_mgr_exe/start_cerner_500 -env common -verbose -noinst", row + 1,
      col 0,
      "   #-------------------------------------------------------------------------------------------",
      row + 1,
      col 0,
      "   ##Cycle server controller, domain directory, resolver if common_wh_switched prop found ",
      row + 1,
      col 0,
      "   #-------------------------------------------------------------------------------------------",
      row + 1,
      col 0, "   cycle_common", row + 1,
      col 0, "   cycle_reg", row + 1,
      row + 1, col 0, "   #remove common_wh_switched prop",
      row + 1, col 0, '   echo1 "Remove common_wh_switched property."',
      row + 1, col 0, '   $cer_exe/lreg -delp "\environment\common" "common_wh_switched" ',
      row + 1, col 0, '   echo2 "Note: "unable to delete property" is an acceptable error"',
      row + 1, row + 1, col 0,
      '   common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched" 2>null)',
      row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      ^      echo2 "Property 'common_wh_switched' failed to be removed."^, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   echo2 "Update registry."', row + 1,
       col 0,
       "   $tgt_wh_device/aixrs6000/update_reg -input $tgt_wh_device/install/update_reg_aix.csv ",
       row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_hpux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/hpuxia64/update_reg -input $tgt_wh_device/install/update_reg_hpux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_hpux.csv file not found."', row
        + 1,
       col 0, "   fi", row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_linux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/linuxx86-64/update_reg -input $tgt_wh_device/install/update_reg_linux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_linux.csv file not found."',
       row + 1,
       col 0, "   fi", row + 1
      ENDIF
      col 0, "fi", row + 1,
      row + 1, col 0, "src_rev_level=$(echo ${src_rev_level} | awk -F. '{print $1}')",
      row + 1, col 0, "if (( ${src_rev_level} >= 2015 ))",
      row + 1, col 0, "then ",
      row + 1, col 0, '  reg_ksh="${cer_proc}/2015_registry_special_instructions.ksh"',
      row + 1, col 0, "  if [[ -f ${reg_ksh} ]]",
      row + 1, col 0, "  then",
      row + 1, col 0, "    export node=${tgt_node}",
      row + 1, col 0, "    export domain=${tgt_domain_name}",
      row + 1, col 0, "    export environment=${tgt_domain_name}",
      row + 1, col 0, '    echo2 "Execute 2015_registry_special_instructions.ksh."',
      row + 1, col 0, "    ${reg_ksh} ",
      row + 1, dcrf_line = concat(
       '    dom_srvctrl=$($cer_exe/lreg -getp "\node\\${tgt_node}\domain\\${tgt_domain_name}\ServerCtrl" ',
       '"ServerCtrlPath" 2>null)'), col 0,
      dcrf_line, row + 1, col 0,
      "    if (( $? != 0 )) ", row + 1, col 0,
      "    then ", row + 1, col 0,
      '      echo2 "Failed to add domain level server controller." ', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "    fi  ", row + 1, col 0,
      "  fi ", row + 1, col 0,
      "fi ", row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "##Constructing insert statement", row + 1,
       col 0, 'tgt_ins_stmt=`echo "insert into dma_process_event', row + 1,
       col 0, "(dma_process_event_id,dma_process_id,event_name,event_status,", row + 1,
       col 0, "  message,username,begin_dt_tm,end_dt_tm,updt_dt_tm)", row + 1,
       col 0, "select DM_SEQ.nextval,dp.dma_process_id,'TARGET REFRESH KSH',", row + 1,
       col 0, "       'COMPLETE','','',sysdate,sysdate,sysdate", row + 1,
       col 0, "from dma_process dp", row + 1,
       col 0, "where dp.process_name = '$dma_pcs_name'", row + 1,
       col 0, "and dp.process_type = 'REPLICATE_REFRESH'", row + 1,
       col 0, ^and dp.action_type  = 'EXECUTION';"`^, row + 1,
       row + 1, col 0, "##Constructing count statement",
       row + 1, col 0, 'tgt_ins_cnt_qry=`echo "select COUNT(*)',
       row + 1, col 0, "from dma_process_event dpe",
       row + 1, col 0, "where dpe.event_name='TARGET REFRESH KSH'",
       row + 1, col 0, "and   dpe.event_status='COMPLETE'",
       row + 1, col 0, "and   dpe.dma_process_id IN (select dma_process_id",
       row + 1, col 0, "                             from dma_process dp",
       row + 1, col 0, "                             where dp.process_name ='$dma_pcs_name'",
       row + 1, col 0, "                             and dp.process_type = 'REPLICATE_REFRESH'",
       row + 1, col 0, ^                             and dp.action_type  = 'EXECUTION');"`^,
       row + 1, row + 1, col 0,
       '##Insert a "COMPLETE" row after successful script execution', row + 1, col 0,
       "dpe_trk_cnt=$(", row + 1, col 0,
       "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1, col 0,
       "whenever sqlerror exit sql.sqlcode;", row + 1, col 0,
       "set echo off", row + 1, col 0,
       "set heading off", row + 1, col 0,
       "set feedback off", row + 1, col 0,
       "$tgt_ins_stmt", row + 1, col 0,
       "commit;", row + 1, col 0,
       "$tgt_ins_cnt_qry", row + 1, col 0,
       "END", row + 1, col 0,
       ")", row + 1, row + 1,
       col 0, "if [ $dpe_trk_cnt -eq 0 ];", row + 1,
       col 0, "then", row + 1,
       col 0, ^   echo2 "Failed to insert a 'COMPLETE' row on dma_process_event table"^, row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "fi", row + 1,
       row + 1
      ENDIF
      col 0, 'echo2 "dm2_target_refresh.ksh executed successfully."', row + 1,
      col 0, 'echo "TARGET_REFRESH_COMPLETE" >$CheckPoint', row + 1,
      row + 1
     ENDIF
    WITH nocounter, format = variable, formfeed = none,
     maxrow = 1, maxcol = 512
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcrf_line = concat("set file/prot=(s:rwed,o:rwed,g:rwed,w:rwed) ",dcrf_file_name)
   ELSE
    SET dcrf_line = concat("chmod 777 ",dcrf_file_name)
   ENDIF
   IF (dm2_push_dcl(dcrf_line)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE ddsrr_create_sec_refresh_file(null) = i2
 DECLARE ddsrr_create_sec_shutdown_file(null) = i2
 SUBROUTINE ddsrr_create_sec_refresh_file(null)
   DECLARE dcsrf_file_name = vc WITH protect, noconstant("")
   DECLARE dcsrf_line = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcsrf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_refresh.com")
   ELSE
    SET dcsrf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_refresh.ksh")
    IF ((ddr_domain_data->tgt_local_group_name="DM2NOTSET"))
     IF (ddr_get_local_group_name(0,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = concat("Create ",dcsrf_file_name)
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO value(dcsrf_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!dm2_target_refresh.com "), row + 1,
      CALL print("$!  "),
      row + 1,
      CALL print("$!mod "), row + 1,
      CALL print("$!000 sc4299  initial release "), row + 1,
      CALL print("$!-------------------------------------------"),
      row + 1,
      CALL print("$!                     "), row + 1,
      CALL print("$on ERROR then goto EXIT_ERROR"), row + 1,
      CALL print("$on CONTROL_Y then goto EXIT_ERROR"),
      row + 1,
      CALL print("$!--------------------  "), row + 1,
      CALL print("$!set variables         "), row + 1,
      CALL print("$!--------------------  "),
      row + 1,
      CALL print("$error = 0   "), row + 1,
      CALL print(concat('$tgt_domain_name = "',cnvtupper(ddr_domain_data->tgt_domain_name),'"')), row
       + 1,
      CALL print(concat('$tgt_env = "',cnvtupper(ddr_domain_data->tgt_env),'"')),
      row + 1,
      CALL print("$!  "), row + 1,
      CALL print(concat('$tgt_tmp_dev = "',ddr_domain_data->tgt_tmp_dev,'"')), row + 1,
      CALL print(concat('$tgt_tmp_dir = "',ddr_domain_data->tgt_tmp_dir,'"')),
      row + 1,
      CALL print("$!"), row + 1,
      CALL print(concat('$tgt_tmp_full_dir = "',ddr_domain_data->tgt_tmp_full_dir,'"')), row + 1,
      CALL print(^$if f$search("''tgt_tmp_dev':[''tgt_tmp_dir']''tgt_env'.dir") .eqs. "" ^),
      row + 1,
      CALL print("$then  "), row + 1,
      CALL print(^$   call echo3 "error : directory ''tgt_tmp_full_dir' not found."  ^), row + 1,
      CALL print("$   error = 1"),
      row + 1,
      CALL print("$   goto EXIT_CRITICAL   "), row + 1,
      CALL print("$endif"), row + 1,
      CALL print("$! "),
      row + 1,
      CALL print("$!create log file "), row + 1,
      dcsrf_line = concat(^$if f$search("''tgt_tmp_full_dir'dm2_target_refresh.log") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'dm2_target_refresh.log;*"),
      CALL print(dcsrf_line), row + 1,
      CALL print("$open/write logfile 'tgt_tmp_full_dir'dm2_target_refresh.log  "), row + 1,
      CALL print("$! "),
      row + 1,
      CALL print('$call echo1 "begin dm2_target_refresh.com" '), row + 1,
      CALL print("$!"), row + 1,
      CALL print(concat('$tgt_wh = "',cnvtupper(ddr_domain_data->tgt_wh),'"')),
      row + 1,
      CALL print(concat('$tgt_wh_device = "',ddr_domain_data->tgt_wh_device,'"')), row + 1,
      CALL print(^$if f$search("''tgt_wh_device':[cerner.w_standard]''tgt_wh'.dir") .eqs. "" ^), row
       + 1,
      CALL print("$then    "),
      row + 1,
      CALL print(
      ^$   call echo2 "error : directory ''tgt_wh_device':[cerner.w_standard.''tgt_wh'] not found."  ^
      ), row + 1,
      CALL print("$   error = 1   "), row + 1,
      CALL print("$   goto EXIT_SCRIPT "),
      row + 1,
      CALL print("$endif "), row + 1,
      CALL print("$! "), row + 1,
      CALL print('$tgt_node = f$getsyi("nodename") '),
      row + 1,
      CALL print(^$call echo1 "tgt_node = ''tgt_node'" ^), row + 1,
      CALL print('$common_new_wh = "" '), row + 1,
      CALL print('$common_back_wh = ""'),
      row + 1,
      CALL print("$!                           "), row + 1,
      CALL print(
      "$!----------------------------                                                        "), row
       + 1,
      CALL print(
      "$!verify in Target Environment                                                        "),
      row + 1,
      CALL print(
      "$!----------------------------                                                        "), row
       + 1,
      CALL print(
      '$call echo1 "Verify in Target Environment"                                            '), row
       + 1,
      CALL print(
      "$set noon                                                                             "),
      row + 1,
      CALL print(
      '$if tgt_env .nes. f$edit(f$trnlnm("environment"), "upcase, trim")                     '), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : Must be in Target environment ''tgt_env'"                     ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$set on                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      ^$if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. ""                          ^),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '), row
       + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "),
      row + 1,
      CALL print(
      "$   delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*                                        "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!--------------------------                                                          "),
      row + 1,
      CALL print(
      "$!verify user is domain user                                                          "), row
       + 1,
      CALL print(
      "$!--------------------------                                                          "), row
       + 1,
      CALL print(
      '$call echo1 "Verify domain user"                                                      '),
      row + 1,
      CALL print(
      "$set noon                                                                             "), row
       + 1,
      CALL print(
      ^$mcr cer_exe:lreg -getp \environment\'tgt_env' "localusername"                        ^), row
       + 1,
      CALL print(
      "$if $status                                                                           "),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   domain_user = f$edit(lreg_result, "upcase")                                       '), row
       + 1,
      CALL print(
      ^$   call echo1 "domain user : ''domain_user'"                                         ^),
      row + 1,
      CALL print(
      "$else                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "Error : Failed to find domain user."                                  '), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$set on                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$comma_pos = 0                                                                        "), row
       + 1,
      CALL print(
      "$str_length = 0                                                                       "),
      row + 1,
      CALL print(
      "$curuser = f$user()                                                                   "), row
       + 1,
      CALL print(
      '$comma_pos = f$locate(",",curuser)                                                    '), row
       + 1,
      CALL print(
      "$str_length = f$length(curuser)                                                       "),
      row + 1,
      CALL print(
      "$if (comma_pos .gt. 0) .and. (comma_pos .ne. str_length)                              "), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$ curuser = F$EXTRACT(F$LOCATE(",",curuser)+1 ,F$LOCATE("]",curuser)-F$LOCATE(",",curuser)-1,curuser)   '
      ),
      row + 1,
      CALL print(
      "$else                                                                                 "), row
       + 1,
      CALL print(
      '$ curuser = curuser - "[" - "]"                                                       '), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      '$curuser = f$edit(curuser, "upcase")                                                  '), row
       + 1,
      CALL print(
      ^$call echo1 "curuser : ''curuser'"                                                    ^), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$if curuser .nes. domain_user                                                         "), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "error : log on as ''domain_user' and run again."                      ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!-------------------------------                                                     "), row
       + 1,
      CALL print(
      "$!prompt source environment name                                                      "),
      row + 1,
      CALL print(
      "$!-------------------------------                                                     "), row
       + 1,
      CALL print(
      '$call echo1 "Prompt source environment name."                                         '), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$inquire src_env "Enter source environment name"                                      '), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   src_env = f$edit(src_env, "lowercase")                                            '),
      row + 1,
      CALL print(
      '$if src_env .eqs. ""                                                                  '), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$   call echo2 "error: Invalid source environment name."                              '),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$else                                                                                 "),
      row + 1,
      CALL print(
      ^$  call echo1 "Source environment name : ''src_env'"                                  ^), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!-------------------------                                                           "), row
       + 1,
      CALL print(
      "$!read source misc_data.dat                                                           "), row
       + 1,
      CALL print(
      "$!-------------------------                                                           "),
      row + 1,
      CALL print(
      '$call echo1 "Read source misc_data.dat"                                               '), row
       + 1,
      CALL print(
      ^$src_tmp_dir = "''tgt_tmp_dev':[''tgt_tmp_dir'.''src_env']"                           ^), row
       + 1,
      CALL print(
      ^$if f$search("''tgt_tmp_dev':[''tgt_tmp_dir']''src_env'.dir") .eqs. ""                ^),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : directory ''src_tmp_dir' not found."                          ^), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      ^$if f$search("''src_tmp_dir'misc_data.dat") .eqs. ""                                  ^), row
       + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : file ''src_tmp_dir'misc_data.dat not found."                  ^),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$node_cnt = 0                                                                         "), row
       + 1,
      CALL print(
      "$open/read/error=CHECK_DATA SRC_DATA 'src_tmp_dir'misc_data.dat                       "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$READ_DATA:                                                                           "), row
       + 1,
      CALL print(
      "$   read/end_of_file=end_READ_DATA SRC_DATA record                                    "),
      row + 1,
      CALL print(
      '$   lable = f$element(0, ",", record)                                                 '), row
       + 1,
      CALL print(
      '$   lable = f$edit(lable, "upcase")                                                   '), row
       + 1,
      CALL print(
      '$   lable_value = f$element(1,",", record)                                            '),
      row + 1,
      CALL print(
      '$   lable_value = lable_value - """" - """"                                           '), row
       + 1,
      CALL print(
      '$   lable_value = f$edit(lable_value, "upcase")                                       '), row
       + 1,
      CALL print(
      "$   goto 'lable'                                                                      "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CER_DATA_DEV:                                                                 "), row
       + 1,
      CALL print(
      "$      src_cer_data_dev_value = lable_value                                           "),
      row + 1,
      CALL print(
      '$      if src_cer_data_dev_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_data_dev not found."                            '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_cer_data_dev = ''src_cer_data_dev_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_WH:                                                                           "), row
       + 1,
      CALL print(
      "$      src_wh_value = lable_value                                                     "), row
       + 1,
      CALL print(
      '$      if src_wh_value .eqs. ""                                                       '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_wh not found."                                      '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_wh = ''src_wh_value'"                                          ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WH_DEVICE:                                                                    "),
      row + 1,
      CALL print(
      "$      src_wh_device_value = lable_value                                              "), row
       + 1,
      CALL print(
      '$      if src_wh_device_value .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_wh_device not found."                               '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_wh_device = ''src_wh_device_value'"                            ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CER_INSTALL_DIR:                                                                    "),
      row + 1,
      CALL print(
      "$      src_cer_install_dir = lable_value                                              "),
      row + 1,
      CALL print(
      '$      if src_cer_install_dir .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_install_dir not found."                         '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_cer_install_dir = ''src_cer_install_dir'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_REVISION_LEVEL:                                                               "), row
       + 1,
      CALL print(
      "$      src_revision_level_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_revision_level_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_revision_level not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_revision_level = ''src_revision_level_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SYSTEM:                                                                       "),
      row + 1,
      CALL print(
      "$      src_system_value = lable_value                                                 "), row
       + 1,
      CALL print(
      '$      if src_system_value .eqs. ""                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_system not found."                                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_system = ''src_system_value'"                                  ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SYSTEM_PWD:                                                                   "), row
       + 1,
      CALL print(
      "$      src_system_pwd_value = lable_value                                             "),
      row + 1,
      CALL print(
      '$      if src_system_pwd_value .eqs. ""                                               '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_system_pwd not found."                              '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_system_pwd = ''src_system_pwd_value'"                          ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   OFFLINE_DICT_IND:                                                                 "), row
       + 1,
      CALL print(
      "$      offline_dict_ind_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if offline_dict_ind_value .eqs. ""                                             '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : offline_dict_ind not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "offline_dict_ind = ''offline_dict_ind_value'"                      ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_DOMAIN_NAME:                                                                  "),
      row + 1,
      CALL print(
      "$      src_domain_name_value = lable_value                                            "), row
       + 1,
      CALL print(
      '$      if src_domain_name_value .eqs. ""                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_domain_name not found."                             '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_domain_name = ''src_domain_name_value'"                        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$   SRC_PRIV:                                                                         "), row
       + 1,
      CALL print(
      "$      src_priv_value = lable_value                                                   "), row
       + 1,
      CALL print(
      '$      if src_priv_value .eqs. ""                                                     '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_priv not found."                                    '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_priv = ''src_priv_value'"                                      ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_PRIV_PWD:                                                                     "),
      row + 1,
      CALL print(
      "$      src_priv_pwd_value = lable_value                                               "), row
       + 1,
      CALL print(
      '$      if src_priv_pwd_value .eqs. ""                                                 '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_priv_pwd not found."                                '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_priv_pwd = ''src_priv_pwd_value'"                              ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_MNG:                                                                          "), row
       + 1,
      CALL print(
      "$      src_mng_value = lable_value                                                    "),
      row + 1,
      CALL print(
      '$      if src_mng_value .eqs. ""                                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_mng not found."                                     '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_mng = ''src_mng_value'"                                        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_MNG_PWD:                                                                      "), row
       + 1,
      CALL print(
      "$      src_mng_pwd_value = lable_value                                                "), row
       + 1,
      CALL print(
      '$      if src_mng_pwd_value .eqs. ""                                                  '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_mng_pwd not found."                                 '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_mng_pwd = ''src_mng_pwd_value'"                                ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_USER_NAME:                                                                "),
      row + 1,
      CALL print(
      "$      src_sec_user_name_value = lable_value                                          "), row
       + 1,
      CALL print(
      '$      if src_sec_user_name_value .eqs. ""                                            '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_user_name not found."                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_user_name = ''src_sec_user_name_value'"                    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_LOCAL_USER_NAME:                                                              "), row
       + 1,
      CALL print(
      "$      src_local_user_name_value = lable_value                                        "),
      row + 1,
      CALL print(
      '$      if src_local_user_name_value .eqs. ""                                          '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_local_user_name not found."                         '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_local_user_name = ''src_local_user_name_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_AUTH_SERVER_ID:                                                               "), row
       + 1,
      CALL print(
      "$      src_auth_server_id_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_auth_server_id_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_auth_server_id not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_auth_server_id = ''src_auth_server_id_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_AUTH_SERVER_DESC:                                                             "),
      row + 1,
      CALL print(
      "$      src_auth_server_desc_value = lable_value                                       "), row
       + 1,
      CALL print(
      '$      if src_auth_server_desc_value .eqs. ""                                         '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_auth_server_desc not found."                        '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_auth_server_desc = ''src_auth_server_desc_value'"              ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_MASTER_ID:                                                         "), row
       + 1,
      CALL print(
      "$      src_tdb_server_master_id_value = lable_value                                   "),
      row + 1,
      CALL print(
      '$      if src_tdb_server_master_id_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_master_id not found."                    '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_master_id = ''src_tdb_server_master_id_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_TDB_SERVER_MASTER_DESC:                                                       "), row
       + 1,
      CALL print(
      "$      src_tdb_server_master_desc_value = lable_value                                 "), row
       + 1,
      CALL print(
      '$      if src_tdb_server_master_desc_value .eqs. ""                                   '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_master_desc not found."                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_master_desc = ''src_tdb_server_master_desc_value'"  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_SLAVE_ID:                                                          "),
      row + 1,
      CALL print(
      "$      src_tdb_server_slave_id_value = lable_value                                    "), row
       + 1,
      CALL print(
      '$      if src_tdb_server_slave_id_value .eqs. ""                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_slave_id not found."                     '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_slave_id = ''src_tdb_server_slave_id_value'"        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_SERVER_SLAVE_DESC:                                                        "), row
       + 1,
      CALL print(
      "$      src_tdb_server_slave_desc_value = lable_value                                  "),
      row + 1,
      CALL print(
      '$      if src_tdb_server_slave_desc_value .eqs. ""                                    '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_server_slave_desc not found."                   '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_server_slave_desc = ''src_tdb_server_slave_desc_value'"    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SCP_SERVER_ID:                                                                "), row
       + 1,
      CALL print(
      "$      src_scp_server_id_value = lable_value                                          "), row
       + 1,
      CALL print(
      '$      if src_scp_server_id_value .eqs. ""                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_scp_server_id not found."                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_scp_server_id = ''src_scp_server_id_value'"                    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SCP_SERVER_DESC:                                                              "),
      row + 1,
      CALL print(
      "$      src_scp_server_desc_value = lable_value                                        "), row
       + 1,
      CALL print(
      '$      if src_scp_server_desc_value .eqs. ""                                          '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_scp_server_desc not found."                         '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_scp_server_desc = ''src_scp_server_desc_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_ID:                                                         "), row
       + 1,
      CALL print(
      "$      src_sec_server_master_id_value = lable_value                                   "),
      row + 1,
      CALL print(
      '$      if src_sec_server_master_id_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_id not found."                    '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_id = ''src_sec_server_master_id_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_DESC:                                                       "), row
       + 1,
      CALL print(
      "$      src_sec_server_master_desc_value = lable_value                                 "), row
       + 1,
      CALL print(
      '$      if src_sec_server_master_desc_value .eqs. ""                                   '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_desc not found."                  '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_desc = ''src_sec_server_master_desc_value'"  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_MASTER_LRL:                                                        "),
      row + 1,
      CALL print(
      "$      src_sec_server_master_lrl_value = lable_value                                  "), row
       + 1,
      CALL print(
      '$      if src_sec_server_master_lrl_value .eqs. ""                                    '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_master_lrl not found."                   '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_master_lrl = ''src_sec_server_master_lrl_value'"    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_ID:                                                          "), row
       + 1,
      CALL print(
      "$      src_sec_server_slave_id_value = lable_value                                    "),
      row + 1,
      CALL print(
      '$      if src_sec_server_slave_id_value .eqs. ""                                      '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_id not found."                     '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_id = ''src_sec_server_slave_id_value'"        ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_DESC:                                                        "), row
       + 1,
      CALL print(
      "$      src_sec_server_slave_desc_value = lable_value                                  "), row
       + 1,
      CALL print(
      '$      if src_sec_server_slave_desc_value .eqs. ""                                    '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_desc not found."                   '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_desc = ''src_sec_server_slave_desc_value'"    ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SEC_SERVER_SLAVE_LRL:                                                         "),
      row + 1,
      CALL print(
      "$      src_sec_server_slave_lrl_value = lable_value                                   "), row
       + 1,
      CALL print(
      '$      if src_sec_server_slave_lrl_value .eqs. ""                                     '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_sec_server_slave_lrl not found."                    '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_sec_server_slave_lrl = ''src_sec_server_slave_lrl_value'"      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_CCLDIR:                                                                       "), row
       + 1,
      CALL print(
      "$      src_ccldir_value = lable_value                                                 "),
      row + 1,
      CALL print(
      '$      if src_ccldir_value .eqs. ""                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_ccldir not found."                                  '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_ccldir = ''src_ccldir_value'"                                  ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_CCLUSERDIR_DIR:                                                               "), row
       + 1,
      CALL print(
      "$      src_ccluserdir_dir_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_ccluserdir_dir_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_ccluserdir_dir not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_ccluserdir_dir = ''src_ccluserdir_dir_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_OCDTOOLS_DIR:                                                                 "),
      row + 1,
      CALL print(
      "$      src_ocdtools_dir_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_ocdtools_dir_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_ocdtools_dir not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_ocdtools_dir = ''src_ocdtools_dir_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WAREHOUSE_DIR:                                                                "), row
       + 1,
      CALL print(
      "$      src_warehouse_dir_value = lable_value                                          "),
      row + 1,
      CALL print(
      '$      if src_warehouse_dir_value .eqs. ""                                            '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_warehouse_dir not found."                           '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_warehouse_dir = ''src_warehouse_dir_value'"                    ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_CER_CONFIG_DIR:                                                               "), row
       + 1,
      CALL print(
      "$      src_cer_config_dir_value = lable_value                                         "), row
       + 1,
      CALL print(
      '$      if src_cer_config_dir_value .eqs. ""                                           '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_cer_config_dir not found."                          '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_cer_config_dir = ''src_cer_config_dir_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_SERVER_COUNT:                                                                 "),
      row + 1,
      CALL print(
      "$      src_server_count_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_server_count_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error : src_server_count not found."                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_server_count = ''src_server_count_value'"                      ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_COUNT:                                                                    "), row
       + 1,
      CALL print(
      "$      src_tdb_count_value = lable_value                                              "),
      row + 1,
      CALL print(
      '$      if src_tdb_count_value .eqs. ""                                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_tdb_count not found."                               '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_count = ''src_tdb_count_value'"                            ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_DB_ENV_NAME:                                                                  "), row
       + 1,
      CALL print(
      "$      src_db_env_name_value = lable_value                                            "), row
       + 1,
      CALL print(
      '$      if src_db_env_name_value .eqs. ""                                              '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error : src_db_env_name_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_db_env_name_value = ''src_db_env_name_value'"                  ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_WAS_ARCH_IND:                                                                 "),
      row + 1,
      CALL print(
      "$      src_was_arch_ind_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_was_arch_ind_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error :src_was_arch_ind_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_was_arch_ind_value = ''src_was_arch_ind_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   NODE_NAME:                                                                        "), row
       + 1,
      CALL print(
      "$      node_cnt = node_cnt + 1                                                        "),
      row + 1,
      CALL print(
      "$      src_node_name'node_cnt = lable_value                                           "), row
       + 1,
      CALL print(
      ^$      if src_node_name'node_cnt .eqs. ""                                             ^), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      ^$         call echo2 "error : src_node_name ''node_cnt' not found."                   ^), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      tmp_node_name = src_node_name'node_cnt                                         "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_node_name''node_cnt' = ''tmp_node_name'"                       ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_CURPAGES:                                                                 "),
      row + 1,
      CALL print(
      "$      src_tdb_curpages_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_tdb_curpages_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "error :src_tdb_curpages_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_curpages_value = ''src_tdb_curpages_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   SRC_TDB_MAXPAGES:                                                                 "), row
       + 1,
      CALL print(
      "$      src_tdb_maxpages_value = lable_value                                           "),
      row + 1,
      CALL print(
      '$      if src_tdb_maxpages_value .eqs. ""                                             '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error :src_tdb_maxpages_value not found."                       '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      ^$      call echo1 "src_tdb_maxpages_value = ''src_tdb_maxpages_value'"                ^), row
       + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   SRC_TDB_INIT_SIZE:                                                                 "), row
       + 1,
      CALL print(
      "$      src_tdb_init_size_value = lable_value                                           "), row
       + 1,
      CALL print(
      '$      if src_tdb_init_size_value .eqs. ""                                             '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "error :src_tdb_init_size_value not found."                       '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "src_tdb_init_size_value = ''src_tdb_init_size_value'"                ^),
      row + 1,
      CALL print(
      "$      goto READ_DATA                                                                 "), row
       + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      "$CHECK_DATA:                                                                          "),
      row + 1,
      CALL print(
      "$   err_msg = f$message($status)                                                      "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error opening file ''src_tmp_dir'misc_data.dat"                       ^), row
       + 1,
      CALL print(
      "$   call echo2 'err_msg'                                                              "),
      row + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$END_READ_DATA:                                                                       "),
      row + 1,
      CALL print(
      "$   close SRC_DATA                                                                    "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!---------------------                                                               "), row
       + 1,
      CALL print(
      "$!check src wh sav file                                                               "), row
       + 1,
      CALL print(
      "$!----------------------                                                              "),
      row + 1,
      CALL print(
      ^$call echo1 "Find file ''src_tmp_dir'''src_env'_''src_wh_value'.sav"                  ^), row
       + 1,
      CALL print(
      ^$if f$search("''src_tmp_dir'''src_env'_''src_wh_value'.sav") .eqs. ""                 ^), row
       + 1,
      CALL print(
      "$then                                                                                 "),
      row + 1,
      CALL print(
      ^$   call echo2 "Error : failed to find ''src_tmp_dir'''src_env'_''src_wh_value'.sav"  ^), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "),
      row + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$!check for target wh                                                                 "),
      row + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      '$call echo1 "Check for target warehouse"                                              '), row
       + 1,
      CALL print(
      ^$tgt_wh_exist = f$search("''tgt_wh_device':[cerner.w_standard.''tgt_wh']*.dir")       ^),
      row + 1,
      CALL print(
      '$if tgt_wh_exist .eqs. "" then goto TGT_WH_NOT_FOUND                                  '), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "),
      row + 1,
      CALL print(
      "$!target wh found                                                                     "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$TGT_WH_FOUND:                                                                        "),
      row + 1,
      CALL print(
      '$   call echo1 "Target wh exists"                                                     '), row
       + 1,
      CALL print(
      "$!  ---------------------------------------------                                     "), row
       + 1,
      CALL print(
      "$!  get warehouse for all environments on the node                                    "),
      row + 1,
      CALL print(
      "$!  ----------------------------------------------                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Get warehouse for all environments"                                   '), row
       + 1, dcsrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'env_list.dat") .nes. "" then ^,
       " delete 'tgt_tmp_full_dir'env_list.dat;* "),
      CALL print(dcsrf_line), row + 1, dcsrf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'wh_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'wh_list.dat;*"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$   define sys$output 'tgt_tmp_full_dir'env_list.dat                                  "),
      row + 1,
      CALL print(
      "$mcr cer_exe:lregview                                                                 "), row
       + 1,
      CALL print(
      "cd \environment                                                                       "), row
       + 1,
      CALL print(
      "dir                                                                                   "),
      row + 1,
      CALL print(
      "exit                                                                                  "), row
       + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   env_cnt = 0                                                                       "),
      row + 1,
      CALL print(
      "$   common_share_wh = 0                                                               "), row
       + 1,
      CALL print(
      "$   wh_ind = 0                                                                        "), row
       + 1,
      CALL print(
      ^$   wh_array'wh_ind = "Warehouse List"                                                ^),
      row + 1,
      CALL print(
      "$   open/read/error=CHECK_ENV_LIST ENV_LIST 'tgt_tmp_full_dir'ENV_LIST.dat            "), row
       + 1,
      CALL print(
      "$   open/write WH_LIST 'tgt_tmp_full_dir'wh_list.dat                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   READ_ENV_LIST:                                                                    "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_ENV_LIST ENV_LIST record                             "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '), row
       + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^),
      row + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            env_cnt = env_cnt + 1                                                    "),
      row + 1,
      CALL print(
      "$            env_name'env_cnt = f$extract(1, end_pos-1, record)                       "), row
       + 1,
      CALL print(
      ^$            tmp_env_name = f$edit(env_name'env_cnt, "upcase")                        ^), row
       + 1,
      CALL print(
      ^$            call echo1 "environment_name : '' tmp_env_name'"                         ^),
      row + 1,
      CALL print(
      "$            set noon                                                                 "), row
       + 1,
      CALL print(
      "$            define/user_mode sys$error nl:                                           "), row
       + 1,
      CALL print(
      ^$            mcr cer_exe:lreg -getp \environment\'tmp_env_name' "warehouse1"          ^),
      row + 1,
      CALL print(
      "$            if $status                                                               "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               set on                                                                "),
      row + 1,
      CALL print(
      ^$               env_wh'env_cnt = lreg_result - """" - """"                            ^), row
       + 1,
      CALL print(
      ^$               tmp_env_wh = f$edit(env_wh'env_cnt, "upcase")                         ^), row
       + 1,
      CALL print(
      ^$               call echo1 "warehouse :  ''tmp_env_wh'"                               ^),
      row + 1,
      CALL print(
      "$               i = 0                                                                 "), row
       + 1,
      CALL print(
      '$               found = "F"                                                           '), row
       + 1,
      CALL print(
      "$               FIND_LOOP:                                                            "),
      row + 1,
      CALL print(
      "$                  if (i .le. wh_ind)                                                 "), row
       + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     if (tmp_env_wh .eqs. wh_array'i)                                "),
      row + 1,
      CALL print(
      "$                     then                                                            "), row
       + 1,
      CALL print(
      '$                        found = "T"                                                  '), row
       + 1,
      CALL print(
      "$                     endif                                                           "),
      row + 1,
      CALL print(
      "$                     i = i + 1                                                       "), row
       + 1,
      CALL print(
      "$                     goto FIND_LOOP                                                  "), row
       + 1,
      CALL print(
      "$                  endif                                                              "),
      row + 1,
      CALL print(
      "$               wh_ind = wh_ind + 1                                                   "), row
       + 1,
      CALL print(
      "$               wh_array'wh_ind = tmp_env_wh                                          "), row
       + 1,
      CALL print(
      "$               END_FIND_LOOP:                                                        "),
      row + 1,
      CALL print(
      '$                  if (found .eqs. "F")                                               '), row
       + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     write WH_LIST "\''tmp_env_wh' "                                 ^),
      row + 1,
      CALL print(
      "$                  endif                                                              "), row
       + 1,
      CALL print(
      "$               if tmp_env_wh .eqs. tgt_wh                                            "), row
       + 1,
      CALL print(
      "$               then                                                                  "),
      row + 1,
      CALL print(
      '$                  if tmp_env_name .eqs. "COMMON"                                     '), row
       + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     call echo2 "common environment warehouse : ''tmp_env_wh'"       ^),
      row + 1,
      CALL print(
      "$                     common_wh = tmp_env_wh                                          "), row
       + 1,
      CALL print(
      "$                     common_share_wh = 1                                             "), row
       + 1,
      CALL print(
      "$                  else                                                               "),
      row + 1,
      CALL print(
      '$                     if (tmp_env_name .nes. "ADMIN") .and. (tmp_env_name .nes. tgt_env)'),
      row + 1,
      CALL print(
      "$                     then                                                            "), row
       + 1,
      CALL print(
      ^$                        call echo2 "warehouse ''tgt_wh'  is used for environment ''tmp_env_name'."^
      ),
      row + 1,
      CALL print(
      '$                        call echo2 "this process cannot be used to refresh the domain."'),
      row + 1,
      CALL print(
      "$                        error = 1                                                    "), row
       + 1,
      CALL print(
      "$                        goto EXIT_SCRIPT                                             "),
      row + 1,
      CALL print(
      "$                     endif !not admin and tgt_env                                    "), row
       + 1,
      CALL print(
      "$                  endif !common                                                      "), row
       + 1,
      CALL print(
      "$               endif !eqs tgt_wh                                                     "),
      row + 1,
      CALL print(
      "$            endif !$status                                                           "), row
       + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      "$         endif !end_pos                                                              "),
      row + 1,
      CALL print(
      "$      endif !start with \                                                            "), row
       + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_ENV_LIST                                                             "),
      row + 1,
      CALL print(
      "$   CHECK_ENV_LIST:                                                                   "), row
       + 1,
      CALL print(
      "$      env_err_msg = f$message($status)                                               "), row
       + 1,
      CALL print(
      ^$      call echo2 "error opening file ''tgt_tmp_full_dir'env_list.dat"                ^),
      row + 1,
      CALL print(
      "$      call echo2 'env_err_msg'                                                       "), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   END_READ_ENV_LIST:                                                                "), row
       + 1,
      CALL print(
      "$      close ENV_LIST                                                                 "), row
       + 1,
      CALL print(
      "$      close WH_LIST                                                                  "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   wh_cnt = 0                                                                        "),
      row + 1,
      CALL print(
      "$   open/read/error=CHECK_WH_LIST WH_LIST 'tgt_tmp_full_dir'wh_list.dat               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   READ_WH_LIST:                                                                     "),
      row + 1,
      CALL print(
      "$      read/end_of_file=END_READ_WH_LIST WH_LIST record                               "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "),
      row + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            wh_cnt = wh_cnt + 1                                                      "), row
       + 1,
      CALL print(
      "$            wh_name'wh_cnt = f$extract(1, end_pos-1, record)                         "),
      row + 1,
      CALL print(
      ^$            wh_name'wh_cnt = f$edit(wh_name'wh_cnt, "upcase")                        ^), row
       + 1,
      CALL print(
      "$            tmp_wh_name = wh_name'wh_cnt                                             "), row
       + 1,
      CALL print(
      "$            call echo1  'tmp_wh_name'                                                "),
      row + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !start with \                                                            "), row
       + 1,
      CALL print(
      "$!     write sys$output record                                                        "),
      row + 1,
      CALL print(
      "$      goto READ_WH_LIST                                                              "), row
       + 1,
      CALL print(
      "$   CHECK_WH_LIST:                                                                    "), row
       + 1,
      CALL print(
      "$      wh_err_msg = f$message($status)                                                "),
      row + 1,
      CALL print(
      ^$      call echo2 "Error opening file ''tgt_tmp_full_dir'wh_list.dat"                 ^), row
       + 1,
      CALL print(
      "$      call echo2 'wh_err_msg'                                                        "), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "),
      row + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_WH_LIST:                                                                 "), row
       + 1,
      CALL print(
      "$      close WH_LIST                                                                  "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if wh_cnt .eq. 1                                                                  "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$      tgt_wh_only = 1                                                                "), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      "$      tgt_wh_only = 0                                                                "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   call echo1 "common_share_wh = ''common_share_wh'"                                 ^), row
       + 1,
      CALL print(
      ^$   call echo1 "tgt_wh_only = ''tgt_wh_only'"                                         ^),
      row + 1,
      CALL print(
      "$   if (tgt_wh_only .eq. 0)                                                           "), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------                                            "),
      row + 1,
      CALL print(
      "$!  Prompt to change common warehouse                                                 "), row
       + 1,
      CALL print(
      "$!  --------------------------------------                                            "), row
       + 1,
      CALL print(
      '$      call echo1 "Prompt to change common warehouse."                                '),
      row + 1,
      CALL print(
      "$PROMPT_COMMON_AGAIN:                                                                 "), row
       + 1,
      dcsrf_line = concat('$      inquire answer "Would you like to change common warehouse after ',
       "target warehouse is rebuilt [Y]es or [N]o"),
      CALL print(dcsrf_line), row + 1,
      dcsrf_line = concat(
       '$      if (answer .nes. "Y") .and. (answer .nes. "y") .and. (answer .nes. "YES") .and. ',
       '(answer .nes. "yes") .and. (answer .nes. "Yes") .and. (answer .nes. "N").and. (answer .nes. "n") ',
       '(answer .nes. "NO") .and. (answer .nes. "No") .and. (answer .nes. "no")'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         goto PROMPT_COMMON_AGAIN                                                    "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      dcsrf_line = concat(
       '$      if (answer .eqs. "Y") .or. (answer .eqs. "y") .or. (answer .eqs. "Yes") ',
       '.or. (answer .eqs. "yes") .or. (answer .eqs. "YES")'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         mcr cer_exe:lreg -getp \environment\common "warehouse1"                  '),
      row + 1,
      CALL print(
      "$         set on                                                                   "), row + 1,
      CALL print(
      '$         common_new_wh = f$edit(lreg_result, "upcase")                            '), row + 1,
      CALL print(
      ^$         call echo1 "common_new_wh = ''common_new_wh'"                            ^),
      row + 1,
      CALL print(
      "$         if common_new_wh .eqs. ''                                                "), row + 1,
      CALL print(
      "$         then                                                                     "), row + 1,
      CALL print(
      '$            call echo2 "Failed to retrieve common warehouse name"                 '),
      row + 1,
      CALL print(
      "$            error = 1                                                             "), row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                      "), row + 1,
      CALL print(
      "$         endif                                                                    "),
      row + 1,
      CALL print(
      "$         PROMPT_COMMON_BACK:                                                         "), row
       + 1,
      CALL print(
      "$            wh_count = 0                                                             "), row
       + 1,
      CALL print(
      "$            WH_BACK_LOOP:                                                            "),
      row + 1,
      CALL print(
      "$               wh_count = wh_count + 1                                               "), row
       + 1,
      CALL print(
      "$               if wh_count .le. wh_cnt                                               "), row
       + 1,
      CALL print(
      "$               then                                                                  "),
      row + 1,
      CALL print(
      "$                  tmp_wh_name = wh_name'wh_count                                     "), row
       + 1,
      CALL print(
      "$                  if tmp_wh_name .nes.common_new_wh                                  "), row
       + 1,
      CALL print(
      "$                  then                                                               "),
      row + 1,
      CALL print(
      "$                     call echo2 'tmp_wh_name'                                        "), row
       + 1,
      CALL print(
      "$                  endif                                                              "), row
       + 1,
      CALL print(
      "$                  goto WH_BACK_LOOP                                                  "),
      row + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1,
      dcsrf_line = concat(
       '$            inquire common_back_wh "Please choose a warehouse for common ',
       "to change to from list above"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$            wh_count = 0                                                             "), row
       + 1,
      CALL print(
      "$            new_wh_fnd = 0                                                           "),
      row + 1,
      CALL print(
      "$            WH_AGAIN_LOOP:                                                           "), row
       + 1,
      CALL print(
      "$               wh_count = wh_count + 1                                               "), row
       + 1,
      CALL print(
      "$               if (wh_count .le. wh_cnt) .and. (new_wh_fnd .eq. 0)                   "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$!                 write sys$output wh_name'wh_count                                  "), row
       + 1,
      CALL print(
      "$                  if (wh_name'wh_count .eqs.common_back_wh) .and. (wh_name'wh_count .nes.common_new_wh)"
      ),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     new_wh_fnd = 1                                                  "), row
       + 1,
      CALL print(
      "$                  endif                                                              "),
      row + 1,
      CALL print(
      "$                  goto WH_AGAIN_LOOP                                                       "),
      row + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1,
      CALL print(
      ^$            call echo1 "new_wh_fnd = ''new_wh_fnd'"                                  ^),
      row + 1,
      CALL print(
      "$            if new_wh_fnd .eq. 0                                                     "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      ^$               call echo2 "''common_back_wh' is not in the warehouse list."          ^),
      row + 1,
      CALL print(
      "$               goto PROMPT_COMMON_BACK                                               "), row
       + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$            set noon                                                                 "),
      row + 1,
      CALL print(
      ^$            mcr cer_exe:lreg -setp "\environment\common" "wh_changed_again"  "''common_back_wh'"^
      ), row + 1,
      CALL print(
      '$            lreg_result = "NOT_FOUND"                                                '), row
       + 1,
      CALL print(
      '$            mcr cer_exe:lreg -getp "\environment\common" "wh_changed_again"          '),
      row + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      ^$            call echo1 "lreg_result  = ''lreg_result'"                               ^), row
       + 1,
      CALL print(
      ^$            call echo1 "common_back_wh = ''common_back_wh'"                          ^),
      row + 1,
      CALL print(
      '$            if f$edit(lreg_result, "upcase") .nes. common_back_wh                    '), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      '$               call echo2 "Failed to add new property wh_changed_again for common."  '),
      row + 1,
      CALL print(
      "$               error = 1                                                             "), row
       + 1,
      CALL print(
      "$               goto EXIT_SCRIPT                                                      "), row
       + 1,
      CALL print(
      "$            endif                                                                    "),
      row + 1,
      CALL print(
      "$            set noon                                                                 "), row
       + 1,
      CALL print(
      '$            lreg_result = "NOT_FOUND"                                                '), row
       + 1,
      CALL print(
      '$            mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"        '),
      row + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      ^$            call echo1 "lreg_result  = ''lreg_result'"                               ^), row
       + 1,
      CALL print(
      '$            if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                       '),
      row + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      '$               call echo1 "Note: "unable to get property" is an acceptable error"     '), row
       + 1,
      CALL print(
      "$            endif                                                                    "),
      row + 1,
      CALL print(
      '$            if f$edit(lreg_result, "UPCASE") .nes. "Y"                               '), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               set noon                                                              "),
      row + 1,
      CALL print(
      '$               mcr cer_exe:lreg -setp "\environment\common" "common_wh_switched"  "Y"'), row
       + 1,
      CALL print(
      '$               lreg_result = "NOT_FOUND"                                             '), row
       + 1,
      CALL print(
      '$               mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"     '),
      row + 1,
      CALL print(
      "$               set on                                                                "), row
       + 1,
      CALL print(
      ^$               call echo1 "lreg_result  = ''lreg_result'"                            ^), row
       + 1,
      CALL print(
      '$               if f$edit(lreg_result, "upcase") .nes. "Y"                            '),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      '$                  call echo2 "Failed to add new property common_wh_switched for common." '),
      row + 1,
      CALL print(
      "$                  error = 1                                                          "),
      row + 1,
      CALL print(
      "$                  goto EXIT_SCRIPT                                                   "), row
       + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1,
      CALL print(
      "$            endif                                                                    "),
      row + 1,
      CALL print(
      '$      endif !(answer .eqs. "Y") .or. (answer .eqs. "y")                              '), row
       + 1,
      CALL print(
      "$   endif !(tgt_wh_only .eq. 0)                                                       "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!  --------------------------                                                        "), row
       + 1,
      CALL print(
      "$!  Target warehouse not found                                                        "), row
       + 1,
      CALL print(
      "$!  --------------------------                                                        "),
      row + 1,
      CALL print(
      "$TGT_WH_NOT_FOUND:                                                                    "), row
       + 1,
      CALL print('$   call echo2 "Installing the Target warehouse into memory."            '), row +
      1,
      CALL print(
      "$   mcr cer_mgr_exe:start_cerner_500 -env 'tgt_env' -install 'tgt_wh'                 "),
      row + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "), row
       + 1,
      CALL print(
      "$!  target warehouse only.  Startup controller, domain dir and resolver               "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "),
      row + 1,
      CALL print(
      "$   if tgt_wh_only .eq. 1                                                             "), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Startup server controller, domain directory and resolver when Target wh only"'
      ),
      row + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "), row
       + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      "$!  check offline dictionary                                                          "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "),
      row + 1,
      CALL print(
      '$   ccldiraccess = f$trnlnm("CCLDIRACCESS")                                           '), row
       + 1,
      CALL print(
      '$   if ccldiraccess .eqs. ""                                                          '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$     call echo2 "Offline dictionary is not configured."                              '), row
       + 1,
      CALL print(
      '$      tgt_ccldir_value= f$trnlnm("CCLDIR")                                           '), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1, dcsrf_line = concat(
       '$      call echo2 "Offline dictionary is used.  Verify CCLDIRACCESS is 1WRITE ',
       'and CCLDIR match CCLDIR1."'),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      '$      if ccldiraccess .nes. "1WRITE"                                                 '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Change CCLDIRACCESS to 1WRITE."                                 '),
      row + 1,
      CALL print(
      '$         define /group "CCLDIRACCESS" "1WRITE"                                       '), row
       + 1,
      CALL print(
      '$         ccldiraccess = f$trnlnm("CCLDIRACCESS")                                     '), row
       + 1,
      CALL print(
      '$         if ccldiraccess .nes. "1WRITE"                                              '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            echo2 "Failed to set logical CCLDIRACCESS to 1WRITE."                    '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      '$      lreg_result = "NOT_FOUND"                                                      '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1, dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess"'),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      if f$edit(lreg_result, "upcase") .nes. "1WRITE"                                '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      "$         set noon                                                                    "), row
       + 1,
      dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -setp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess" "1WRITE"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      '$         lreg_result = "NOT_FOUND"                                                   '), row
       + 1, dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldiraccess"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$         set on                                                                      "),
      row + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. "1WRITE"                             '), row
       + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to update registry CCLDIRACCESS to 1WRITE."           '),
      row + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "),
      row + 1,
      CALL print(
      '$      endif !ccldiraccess .nes. "1WRITE"                                             '), row
       + 1,
      CALL print(
      '$      ccldir= f$trnlnm("CCLDIR")                                                     '), row
       + 1,
      CALL print(
      '$      ccldir1 = f$trnlnm("CCLDIR1")                                                  '),
      row + 1,
      CALL print(
      "$      if ccldir .nes. ccldir1                                                        "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "Change CCLDIR to match CCLDIR1 value ''ccldir1'."               ^),
      row + 1,
      CALL print(
      ^$         define /group "CCLDIR" 'ccldir1'                                            ^), row
       + 1,
      CALL print(
      '$         ccldir = f$trnlnm("CCLDIR")                                                 '), row
       + 1,
      CALL print(
      "$         if ccldir1 .nes. ccldir                                                     "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      ^$            call echo2 "Failed to set logical CCLDIR to ''ccldir1'."                 ^), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      '$      lreg_result = "NOT_FOUND"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1, dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldir"'),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      if f$edit(lreg_result, "upcase") .nes. ccldir1                                 '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      "$         set noon                                                                    "), row
       + 1,
      dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -setp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       ^environment" "ccldir" "''ccldir1'"^),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      '$         lreg_result = "NOT_FOUND"                                                   '), row
       + 1, dcsrf_line = concat(
       ^$      mcr cer_exe:lreg -getp "\Environment\''tgt_env'\definitions\vmsalpha\^,
       'environment" "ccldir"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. ccldir1                              '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      ^$            call echo2 "Failed to update registry CCLDIR to ''ccldir1'."             ^), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif !ccldir .nes. ccldir1                                                    "),
      row + 1,
      CALL print(
      "$      tgt_ccldir_value = lreg_result                                                 "), row
       + 1,
      CALL print(
      "$      mcr cer_mgr_exe:start_cerner_500 -env 'tgt_env' -verbose                       "), row
       + 1,
      CALL print(
      '$   endif !ccldiraccess .eqs. ""                                                      '),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   set noon                                                                          "), row
       + 1,
      CALL print(
      '$   lreg_result = "NOT_FOUND"                                                         '),
      row + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp "\environment\common" "wh_changed_again"                   '), row
       + 1,
      CALL print(
      "$   set on                                                                            "),
      row + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                                '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo1 "Note: "unable to get property" is an acceptable error"              '),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   if lreg_result .nes. "NOT_FOUND"                                                  '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$!  -----------------------------                                                     "), row
       + 1,
      CALL print(
      "$!  change common warehouse                                                           "), row
       + 1,
      CALL print(
      "$!  -----------------------------                                                     "),
      row + 1,
      CALL print(
      '$      common_back_wh = f$edit(lreg_result, "upcase")                                 '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp "\environment\common" "warehouse1"                      '),
      row + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_cur_wh = f$edit(lreg_result, "upcase")                                  '), row
       + 1,
      CALL print(
      "$      if common_cur_wh .nes. common_back_wh                                          "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      dcsrf_line = concat(^$         call echo2 "Change common warehouse from ''common_cur_wh' to ^,
       ^''common_back_wh'"^),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$         set noon                                                                    "), row
       + 1,
      CALL print(
      ^$         mcr cer_exe:lreg -setp "\environment\common" "warehouse1" "''common_back_wh'"  ^),
      row + 1,
      CALL print(
      '$         mcr cer_exe:lreg -getp "\environment\common" "warehouse1"                   '), row
       + 1,
      CALL print(
      "$         set on                                                                      "), row
       + 1,
      CALL print(
      '$         if f$edit(lreg_result, "upcase") .nes. common_back_wh                       '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      ^$            call echo2 "Failed to change common warehouse to ''common_back_wh'."     ^), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif !common_cur_wh .nes. common_back_wh                                      "),
      row + 1,
      CALL print(
      '$      call echo2 "Remove wh_changed_again property for common"                       '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "wh_changed_again"                  '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed_again"                  '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      if lreg_result .nes. "not_found"                                               '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete property wh_changed_again for common."         '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$   endif !wh_changed_again found                                                     "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   set noon                                                                          "), row
       + 1,
      CALL print(
      '$   lreg_result = "NOT_FOUND"                                                         '),
      row + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp "\environment\common" "common_wh_switched"                 '), row
       + 1,
      CALL print(
      "$   set on                                                                            "),
      row + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "NOT_FOUND"                                '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo1 "Note: "unable to get property" is an acceptable error"              '),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "UPCASE") .eqs. "Y"                                        '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                     "),
      row + 1,
      CALL print(
      "$!     common_wh_switched found                                                          "),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                     "),
      row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*                               Install Cerner                                     *"'
      ), row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ),
      row + 1,
      CALL print(
      '$      call echo2 "*Open another session and execute Install_Cerner as shown below.                   *"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*Answer the prompts according to the output below.                                 *"'
      ), row + 1,
      CALL print(
      '$      call echo2 "*Do not continue until Install_Cerner completes successfully.                      *"'
      ),
      row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      call echo2 "Using Install_Cerner to refresh core components.                                    "'
      ), row + 1, dcsrf_line = concat(
       ^$      call echo2 "mcr ''tgt_wh_device':[cerner.w_standard.''tgt_wh'.vmsalpha]install_cerner.exe ^,
       '-core -verbose"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      '$      call echo2 ""                                                                  '),
      row + 1,
      CALL print(
      '$      call echo2 "*Install_Cerner Prompts and recommended answers:"                  '), row
       + 1,
      CALL print(
      '$      call echo2 ""                                                                  '), row
       + 1,
      CALL print(
      ^$      call echo2 "Core device  > ''tgt_wh_device'"                                   ^),
      row + 1,
      CALL print(
      ^$      call echo2 "CD-ROM Location [] > ''tgt_wh_device'"                             ^), row
       + 1,
      CALL print(
      '$      call echo2 "Is this correct? [y] > Y"                                          '), row
       + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the cer_mgr directory? [N] > Y"             '),
      row + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ), row + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the cer_mgr_exe directory? [N] > Y"         '), row
       + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ),
      row + 1,
      CALL print(
      '$      call echo2 "Do you wish to refresh the system registry template? [N] > Y"      '), row
       + 1,
      CALL print(
      ^$      call echo2 "Select a source directory [] > ''tgt_wh_device':[cerner.w_standard.''tgt_wh']"^
      ), row + 1,
      CALL print(
      '$      call echo2 "Do you wish to run start_cerner_500 after creation? [Y] > Y"       '),
      row + 1,
      CALL print(
      '$      call echo2 "Hit C to continue; E to exit. > C"                                 '), row
       + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      inquire answer "*Has the execution of Install_Cerner as shown above completed successfully?[Y/N]"'
      ),
      row + 1,
      CALL print(
      '$      call echo2 "************************************************************************************"'
      ), row + 1,
      CALL print(
      '$      if f$edit(answer, "UPCASE") .nes. "Y"                                          '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to install core."                                        '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      "$!     Update Registry                                                                "),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      '$      call echo2 "Update registry."                                                  '), row
       + 1, dcsrf_line = concat(
       "$mcr 'tgt_wh_device':[cerner.w_standard.'tgt_wh'.vmsalpha]update_reg -input ",
       "'tgt_wh_device':[cerner.w_standard.'tgt_wh'.install]update_reg_vms.csv"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$!     -----------------------------                                                  "),
      row + 1,
      CALL print(
      "$!     start_cerner_500                                                               "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      '$      call echo2 "Run start_cerner_500."                                             '),
      row + 1,
      CALL print(
      "$mcr cer_mgr_exe:start_cerner_500 -env common -verbose -noinst                        "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1,
      CALL print(
      "$!     Cycle server controller, ddir and resolver                                     "),
      row + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1,
      dcsrf_line = concat(
       '$      call echo2 "common_wh_switched property found.  Cycle server controller,',
       'ddir and resolver"'),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "), row
       + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "),
      row + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1,
      CALL print(
      "$!     remove common_wh_switched property                                             "),
      row + 1,
      CALL print(
      "$!     ------------------------------------------                                     "), row
       + 1,
      CALL print(
      '$      call echo2 "Remove common_wh_switched property for common"                     '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "common_wh_switched"                '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "common_wh_switched"                '), row
       + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      if lreg_result .nes. "not_found"                                               '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete property common_wh_switched property for common."'),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      "$!     Update Registry                                                                "),
      row + 1,
      CALL print(
      "$!     -----------------------------                                                  "), row
       + 1,
      CALL print(
      '$      call echo2 "Update registry."                                                  '), row
       + 1, dcsrf_line = concat(
       "$mcr 'tgt_wh_device':[cerner.w_standard.'tgt_wh'.vmsalpha]update_reg -input ",
       "'tgt_wh_device':[cerner.w_standard.'tgt_wh'.install]update_reg_vms.csv"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$EXIT_SCRIPT:                                                                         "), row
       + 1,
      CALL print(
      "$   if error .eq. 1                                                                   "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "dm2_target_refresh.com completed with error."                      '), row
       + 1,
      CALL print(
      "$      close LOGFILE                                                                  "),
      row + 1,
      CALL print(
      "$      exit 2                                                                         "), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "dm2_target_refresh.com completed successfully."                    '),
      row + 1,
      CALL print(
      "$      close LOGFILE                                                                  "), row
       + 1,
      CALL print(
      "$      exit 1                                                                         "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$EXIT_ERROR:                                                                          "), row
       + 1,
      CALL print(
      '$   call echo2 "dm2_target_refresh was terminated."                                   '), row
       + 1,
      CALL print(
      "$   close LOGFILE                                                                     "),
      row + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$EXIT_CRITICAL:                                                                       "),
      row + 1,
      CALL print(
      '$   call echo3 "dm2_target_refresh.com completed with error."                         '), row
       + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!subroutine definition                                                               "), row
       + 1,
      CALL print(
      "$!----------------------                                                              "),
      row + 1,
      CALL print(
      "$!------------------------------------                                                "), row
       + 1,
      CALL print(
      "$! subroutine:                                                                        "), row
       + 1,
      CALL print(
      "$!      echo1 - echo to log file                                                      "),
      row + 1,
      CALL print(
      "$!      echo2 - echo to log file & screen                                             "), row
       + 1,
      CALL print(
      "$!      echo3 - echo to screen                                                        "), row
       + 1,
      CALL print(
      "$!-----------------------------------                                                 "),
      row + 1,
      CALL print(
      "$ECHO1:                                                                               "), row
       + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "),
      row + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO2:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "),
      row + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO3:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$KILL_SERVER:                                                                         "),
      row + 1,
      CALL print(
      "$   count = 0                                                                         "), row
       + 1,
      dcsrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'server_cmd.com") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_cmd.com;*"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$   open/write SERVER_CMD 'tgt_tmp_full_dir'server_cmd.com                            "), row
       + 1,
      CALL print(
      ^$   write SERVER_CMD "$mcr cer_exe:cmbview -dom ''tgt_domain_name'"                   ^),
      row + 1,
      CALL print(
      "$   LOOP:                                                                             "), row
       + 1,
      CALL print(
      "$      count = count + 1                                                              "), row
       + 1,
      CALL print(
      "$      if count .le. srv_cnt                                                          "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      "$         tmp_inst = srv_inst'count                                                   "), row
       + 1,
      CALL print(
      ^$         write SERVER_CMD "kill ''tmp_inst'"                                         ^),
      row + 1,
      CALL print(
      "$         delete/symbol srv_inst'count                                                "), row
       + 1,
      CALL print(
      "$         goto LOOP                                                                   "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      '$   write SERVER_CMD "exit"                                                           '), row
       + 1,
      CALL print(
      "$   close SERVER_CMD                                                                  "), row
       + 1,
      CALL print(
      "$   @server_cmd.com                                                                   "),
      row + 1,
      CALL print(
      "$   gosub FIND_SERVER                                                                 "), row
       + 1,
      CALL print(
      "$   if srv_cnt .ne. 0                                                                 "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Failed to terminate all servers."                                  '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "All servers are terminated."                                       '), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$FIND_SERVER:                                                                         "),
      row + 1, dcsrf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'server_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_list.dat;*"),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$   define/user_mode sys$output 'tgt_tmp_full_dir'server_list.dat                     "), row
       + 1,
      CALL print(
      "$mcr cer_exe:cmbview -dom 'tgt_domain_name'                                           "), row
       + 1,
      CALL print(
      "server                                                                                "),
      row + 1,
      CALL print(
      "exit                                                                                  "), row
       + 1,
      CALL print(
      "$   srv_cnt = 0                                                                       "), row
       + 1,
      CALL print(
      "$   open/read SERVER_LIST 'tgt_tmp_full_dir'server_list.dat                           "),
      row + 1,
      CALL print(
      "$   READ_SERVER_LIST:                                                                 "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record                       "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      if char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            srv_cnt = srv_cnt + 1                                                    "), row
       + 1,
      CALL print(
      "$            srv_inst'srv_cnt = f$extract(0, end_pos, record)                         "),
      row + 1,
      CALL print(
      "$            write sys$output srv_inst'srv_cnt                                        "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_SERVER_LIST                                                          "), row
       + 1,
      CALL print(
      "$   END_READ_SERVER_LIST:                                                             "),
      row + 1,
      CALL print(
      "$      close SERVER_LIST                                                              "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$CYCLE_REG:                                                                           "), row
       + 1,
      CALL print(
      '$   call echo2 "Stop Registry"                                                        '), row
       + 1,
      CALL print(
      "$   @cer_mgr:stop_registry.com                                                        "),
      row + 1,
      CALL print(
      "$                                                                                     "), row
       + 1,
      CALL print(
      '$   CONTEXT = ""                                                                      '), row
       + 1,
      CALL print(
      "$   kill_reg_proc_loop:                                                               "),
      row + 1,
      CALL print(
      "$   PID = F$PID(CONTEXT)                                                              "), row
       + 1,
      CALL print(
      '$   if PID .eqs. ""                                                                   '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$      goto kill_reg_proc_exit                                                        "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   PNAME = F$GETJPI(PID,"PRCNAM")                                                    '),
      row + 1,
      CALL print(
      '$   if pname .EQS. "REGISTRY_SERVER"                                                  '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$     write sys$output "* Killing process " + pname + "; process_id = " + pid         '),
      row + 1,
      CALL print(
      "$     stop  process/id='pid                                                           "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$   goto kill_reg_proc_loop                                                           "),
      row + 1,
      CALL print(
      "$   kill_reg_proc_exit:                                                               "), row
       + 1,
      CALL print(
      '$      call echo2 "Registry has been stopped"                                         '), row
       + 1, dcsrf_line = concat(
       ^$      if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcsrf_line), row + 1,
      CALL print("$      open/write REG_IND 'tgt_tmp_full_dir'stop_reg_ind.dat                 "),
      row + 1,
      CALL print(
      '$      write REG_IND  "registry stopped"                                            '), row +
      1,
      CALL print(
      "$      close REG_IND                                                               "), row + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '),
      row + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "), row
       + 1,
      dcsrf_line = concat(^$   if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcsrf_line), row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$STARTUP_CTRL_DDIR_RES:                                                               "), row
       + 1,
      CALL print(
      '$   call echo2 "Startup server controller."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ctrl                                                      "),
      row + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   ctrl_fnd = 0                                                                      "), row
       + 1,
      CALL print(
      "$   CTRL_LOOP:                                                                        "),
      row + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_STARTUP_CTRL                                     "), row
       + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "),
      row + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^), row
       + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'ctrl_proc.dat                  "), row
       + 1,
      CALL print(
      "$      open/read/error=CHECK_CTRL_PROC CTRL_PROC_DAT 'tgt_tmp_full_dir'ctrl_proc.dat  "),
      row + 1,
      CALL print(
      "$      READ_CTRL_PROC:                                                                "), row
       + 1,
      CALL print(
      "$         read/end_of_file=END_READ_CTRL_PROC CTRL_PROC_DAT record                    "), row
       + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "),
      row + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "), row
       + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^), row
       + 1,
      CALL print(
      '$         if char_type .eqs. "INTEGER"                                                '),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            ctrl_pos = f$locate("SERVER_CTRL", record)                               '), row
       + 1,
      CALL print(
      "$            length = f$length(record)                                                "),
      row + 1,
      CALL print(
      "$            if (ctrl_pos .gt. 0) .and. (ctrl_pos .ne. length)                        "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               ctrl_fnd = 1                                                          "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         endif !char_type                                                            "), row
       + 1,
      CALL print(
      "$!        write sys$output record                                                     "),
      row + 1,
      CALL print(
      "$         goto READ_CTRL_PROC                                                         "), row
       + 1,
      CALL print(
      "$      CHECK_CTRL_PROC:                                                               "), row
       + 1,
      CALL print(
      "$         ctrl_err_msg = f$message($status)                                           "),
      row + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'ctrl_proc.dat"            ^), row
       + 1,
      CALL print(
      "$         call echo2 'ctrl_err_msg'                                                   "), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      END_READ_CTRL_PROC:                                                            "), row
       + 1,
      CALL print(
      "$         close CTRL_PROC_DAT                                                         "),
      row + 1,
      CALL print(
      "$      if ctrl_fnd .ne. 0 then goto END_STARTUP_CTRL                                  "), row
       + 1,
      CALL print(
      "$      goto CTRL_LOOP                                                                 "), row
       + 1,
      CALL print(
      "$   END_STARTUP_CTRL:                                                                 "),
      row + 1,
      CALL print(
      "$      if ctrl_fnd .eq. 0                                                             "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to startup server controller"                            '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      else                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Startup server controller successfully."                        '), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Startup domain directory."                                            '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ddir                                                      "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Find domain resolver."                                                '), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'startup_res_proc.dat        "), row
       + 1,
      CALL print(
      "$   res_in_use = 0                                                                    "),
      row + 1,
      CALL print(
      "$   OPEN/READ/ERROR=CHECK_FIND_RES_PROC FIND_RES_PROC_DAT 'tgt_tmp_full_dir'startup_res_proc.dat"
      ), row + 1,
      CALL print(
      "$   READ_FIND_RES_PROC:                                                               "), row
       + 1,
      CALL print(
      "$      READ/END_OF_FILE=END_READ_FIND_RES_PROC FIND_RES_PROC_DAT RECORD               "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      IF char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      THEN                                                                           "), row
       + 1,
      CALL print(
      '$         res_pos = f$locate("SRV0000_01", record)                                    '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      "$         if (res_pos .gt. 0) .and. (res_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            res_in_use = 1                                                           "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      ENDIF !char_type                                                               "),
      row + 1,
      CALL print(
      "$!     WRITE SYS$OUTPUT RECORD                                                        "), row
       + 1,
      CALL print(
      "$      GOTO READ_FIND_RES_PROC                                                        "), row
       + 1,
      CALL print(
      "$   CHECK_FIND_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$      find_res_err_msg = F$MESSAGE($STATUS)                                          "), row
       + 1,
      CALL print(
      ^$      CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'startup_res_proc.dat"       ^), row
       + 1,
      CALL print(
      "$      CALL ECHO2 'find_res_err_msg'                                                  "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      GOTO EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_FIND_RES_PROC:                                                           "),
      row + 1,
      CALL print(
      "$      CLOSE FIND_RES_PROC_DAT                                                        "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Startup domain resolver."                                          '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_startup -res                                                    "), row
       + 1,
      CALL print(
      "$      loop=0                                                                         "),
      row + 1,
      CALL print(
      "$      res_fnd = 0                                                                    "), row
       + 1,
      CALL print(
      "$      RES_LOOP:                                                                      "), row
       + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_STARTUP_RES                                   "),
      row + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "), row
       + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^),
      row + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         open/read/error=CHECK_RES_PROC RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat  "), row
       + 1,
      CALL print(
      "$         READ_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$            read/end_of_file=END_READ_RES_PROC RES_PROC_DAT record                   "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "), row
       + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "),
      row + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            if char_type .eqs. "INTEGER"                                             '), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "), row
       + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  res_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      "$            endif !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           write sys$output record                                                  "), row
       + 1,
      CALL print(
      "$            goto READ_RES_PROC                                                       "),
      row + 1,
      CALL print(
      "$         CHECK_RES_PROC:                                                             "), row
       + 1,
      CALL print(
      "$            res_err_msg = f$message($status)                                         "), row
       + 1,
      CALL print(
      ^$            call echo2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^),
      row + 1,
      CALL print(
      "$            call echo2 'res_err_msg'                                                 "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         END_READ_RES_PROC:                                                          "), row
       + 1,
      CALL print(
      "$            close RES_PROC_DAT                                                       "), row
       + 1,
      CALL print(
      "$         if res_fnd .ne. 0 then goto END_STARTUP_RES                                 "),
      row + 1,
      CALL print(
      "$         goto RES_LOOP                                                               "), row
       + 1,
      CALL print(
      "$       END_STARTUP_RES:                                                              "), row
       + 1,
      CALL print(
      "$         if res_fnd .eq. 0                                                           "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to startup resolver"                                  '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Startup resolver successfully."                              '),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   endif !res_in_use                                                                 "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$SHUTDOWN_CTRL_DDIR_RES:                                                              "), row
       + 1,
      CALL print(
      '$   call echo2 "Shutdown server controller."                                          '),
      row + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ctrl                                                     "), row
       + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   shutdown_ctrl_fnd = 0                                                             "),
      row + 1,
      CALL print(
      "$   SHUTDOWN_CTRL_LOOP:                                                               "), row
       + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_SHUTDOWN_CTRL                                    "), row
       + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "),
      row + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^), row
       + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'shutdown_ctrl_proc.dat         "),
      row + 1, dcsrf_line = concat(
       "$      OPEN/READ/ERROR=CHECK_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT ",
       "'tgt_tmp_full_dir'shutdown_ctrl_proc.dat"),
      CALL print(dcsrf_line),
      row + 1,
      CALL print(
      "$      READ_SHUTDOWN_CTRL_PROC:                                                       "), row
       + 1,
      CALL print(
      "$         READ/END_OF_FILE=END_READ_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT RECORD  "), row
       + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "),
      row + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "), row
       + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^), row
       + 1,
      CALL print(
      '$         IF char_type .eqs. "INTEGER"                                                '),
      row + 1,
      CALL print(
      "$         THEN                                                                        "), row
       + 1,
      CALL print(
      '$            shutdown_ctrl_pos = f$locate("SERVER_CTRL", record)                      '), row
       + 1,
      CALL print(
      "$            length = f$length(record)                                                "),
      row + 1,
      CALL print(
      "$            if (shutdown_ctrl_pos .gt. 0) .and. (shutdown_ctrl_pos .ne. length)      "), row
       + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               shutdown_ctrl_fnd = 1                                                 "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         ENDIF !char_type                                                            "), row
       + 1,
      CALL print(
      "$!        WRITE SYS$OUTPUT RECORD                                                     "),
      row + 1,
      CALL print(
      "$         GOTO READ_SHUTDOWN_CTRL_PROC                                                "), row
       + 1,
      CALL print(
      "$      CHECK_SHUTDOWN_CTRL_PROC:                                                      "), row
       + 1,
      CALL print(
      "$         shutdown_ctrl_err_msg = F$MESSAGE($STATUS)                                  "),
      row + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'shutdown_ctrl_proc.dat"   ^), row
       + 1,
      CALL print(
      "$         call echo2 'shutdown_ctrl_err_msg'                                          "), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      END_READ_SHUTDOWN_CTRL_PROC:                                                   "), row
       + 1,
      CALL print(
      "$         close SHUTDOWN_CTRL_PROC_DAT                                                "),
      row + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .eq. 0 then goto END_SHUTDOWN_CTRL                        "), row
       + 1,
      CALL print(
      "$      goto SHUTDOWN_CTRL_LOOP                                                        "), row
       + 1,
      CALL print(
      "$   END_SHUTDOWN_CTRL:                                                                "),
      row + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .gt. 0                                                    "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to shutdown server controller"                           '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      else                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Shutdown server controller successfully."                       '), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Shutdown domain directory."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ddir                                                     "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Find domain resolver."                                                '), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'shutdown_res_proc.dat        "), row
       + 1,
      CALL print(
      "$   res_in_use = 0                                                                    "),
      row + 1,
      CALL print(
      "$   OPEN/READ/ERROR=CHECK_FIND_RES_PROC FIND_RES_PROC_DAT 'tgt_tmp_full_dir'shutdown_res_proc.dat"
      ), row + 1,
      CALL print(
      "$   READ_FIND_RES_PROC:                                                               "), row
       + 1,
      CALL print(
      "$      READ/END_OF_FILE=END_READ_FIND_RES_PROC FIND_RES_PROC_DAT RECORD               "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      IF char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      THEN                                                                           "), row
       + 1,
      CALL print(
      '$         res_pos = f$locate("SRV0000_01", record)                                    '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      "$         if (res_pos .gt. 0) .and. (res_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            res_in_use = 1                                                           "), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      ENDIF !char_type                                                               "),
      row + 1,
      CALL print(
      "$!     WRITE SYS$OUTPUT RECORD                                                        "), row
       + 1,
      CALL print(
      "$      GOTO READ_FIND_RES_PROC                                                        "), row
       + 1,
      CALL print(
      "$   CHECK_FIND_RES_PROC:                                                              "),
      row + 1,
      CALL print(
      "$      find_res_err_msg = F$MESSAGE($STATUS)                                          "), row
       + 1,
      CALL print(
      ^$      CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'shutdown_res_proc.dat"       ^), row
       + 1,
      CALL print(
      "$      CALL ECHO2 'find_res_err_msg'                                                  "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      GOTO EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_FIND_RES_PROC:                                                           "),
      row + 1,
      CALL print(
      "$      CLOSE FIND_RES_PROC_DAT                                                        "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Shutdown domain resolver."                                         '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_shutdown -res                                                   "), row
       + 1,
      CALL print(
      "$      loop=0                                                                         "),
      row + 1,
      CALL print(
      "$      shutdown_res_fnd = 0                                                           "), row
       + 1,
      CALL print(
      "$      SHUTDOWN_RES_LOOP:                                                             "), row
       + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_SHUTDOWN_RES                                  "),
      row + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "), row
       + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^),
      row + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         OPEN/READ/ERROR=CHECK_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat"
      ), row + 1,
      CALL print(
      "$         READ_SHUTDOWN_RES_PROC:                                                     "),
      row + 1,
      CALL print(
      "$            READ/END_OF_FILE=END_READ_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT RECORD "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "), row
       + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "),
      row + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            IF char_type .eqs. "INTEGER"                                             '), row
       + 1,
      CALL print(
      "$            THEN                                                                     "),
      row + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "), row
       + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "),
      row + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  shutdown_res_fnd = 1                                               "), row
       + 1,
      CALL print(
      "$               endif                                                                 "),
      row + 1,
      CALL print(
      "$            ENDIF !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           WRITE SYS$OUTPUT RECORD                                                  "), row
       + 1,
      CALL print(
      "$            GOTO READ_SHUTDOWN_RES_PROC                                              "),
      row + 1,
      CALL print(
      "$         CHECK_SHUTDOWN_RES_PROC:                                                    "), row
       + 1,
      CALL print(
      "$            shutdown_res_err_msg = F$MESSAGE($STATUS)                                "), row
       + 1,
      CALL print(
      ^$            CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^),
      row + 1,
      CALL print(
      "$            CALL ECHO2 'shutdown_res_err_msg'                                        "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            GOTO EXIT_SCRIPT                                                         "),
      row + 1,
      CALL print(
      "$         END_READ_SHUTDOWN_RES_PROC:                                                 "), row
       + 1,
      CALL print(
      "$            CLOSE SHUTDOWN_RES_PROC_DAT                                              "), row
       + 1,
      CALL print(
      "$         IF shutdown_res_fnd .eq. 0 then goto END_SHUTDOWN_RES                       "),
      row + 1,
      CALL print(
      "$         goto SHUTDOWN_RES_LOOP                                                      "), row
       + 1,
      CALL print(
      "$      END_SHUTDOWN_RES:                                                              "), row
       + 1,
      CALL print(
      "$         if shutdown_res_fnd .gt. 0                                                  "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to shutdown resolver"                                 '), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Shutdown resolver successfully."                             '),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   else !res_in_use = 0                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Resolver is not running"                                           '),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1
     ELSE
      col 0, "#!/usr/bin/ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# dm2_target_refresh.ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# Note:  Must be run as the root user", row + 1,
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "## Functions:",
      row + 1, col 0, "##	echo1 - Echo to Log File ",
      row + 1, col 0, "##	echo2 - Echo to Log File & Screen",
      row + 1, col 0, "##	echo3 - Echo to Screen",
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "echo1()   #####  Echo to Log File only",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo2()   #####  Echo to Log File & Screen",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1,
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1,
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo3()   #####  Echo to Screen",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0,
      "##	cycle_common - start common env and cycle controller, domain dir and resolver",
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "cycle_common()",
      row + 1, col 0, "{",
      row + 1, col 0, "$cer_mgr_exe/start_cerner_500 -env common -verbose -noinst",
      row + 1, row + 1, col 0,
      "if (( ${cb_cycle} == 1 ))", row + 1, col 0,
      "then", row + 1, col 0,
      "  $cer_exe/cb_shutdown -ctrl", row + 1, col 0,
      "  loop=0", row + 1, col 0,
      "  while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "    sleep 5", row + 1, col 0,
      "    ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcsrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "    if [[ $? -ne 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Terminate server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "  #check if resolver exists", row + 1, col 0,
      "  ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "  if [[ $? -eq 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    resolver_exist=1", row + 1, col 0,
      "  else", row + 1, col 0,
      "    resolver_exist=0", row + 1, col 0,
      "  fi", row + 1, row + 1,
      col 0, "  if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "  then ", row + 1,
      col 0, "    $cer_exe/cb_shutdown -res", row + 1,
      col 0, "    loop=0", row + 1,
      col 0, "    while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "      sleep 5", row + 1,
      col 0, "      ((loop=loop+1))", row + 1,
      col 0, "      ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         loop=100", row + 1,
      col 0, "      elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Terminate resolver failed."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "    done", row + 1,
      col 0, "  fi", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ctrl",
      row + 1, col 0, "  loop=0",
      row + 1, col 0, "  while [[ $loop -lt 12 ]]; do",
      row + 1, col 0, "    sleep 5",
      row + 1, col 0, "    ((loop=loop+1))",
      row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcsrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "    if [[ $? -eq 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Start server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ddir",
      row + 1, row + 1, col 0,
      "  if [[ $resolver_exist -eq 1 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    $cer_exe/cb_startup -res", row + 1, col 0,
      "    loop=0", row + 1, col 0,
      "    while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "      sleep 5", row + 1, col 0,
      "      ((loop=loop+1))", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         loop=100", row + 1, col 0,
      "      elif [[ $loop -eq 12 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "Start resolver failed."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "    done", row + 1, col 0,
      "  fi", row + 1, col 0,
      "fi", row + 1, col 0,
      "}", row + 1, row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "## Function:", row + 1,
      col 0, "##	cycle_reg - stop and start registry", row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "cycle_reg()", row + 1,
      col 0, "{", row + 1,
      col 0, "   $cer_mgr_exe/reg_server -stop", row + 1,
      dcsrf_line = concat(
       "   ps -ef |grep reg_server |grep cerner |sed 's/\([ ]*[A-Za-z0-9_]*[ ]*\) \([0-9]*\) \([^`]*\)/\2/'",
       " > /tmp/dm2_qpid_dump.txt"), col 0, dcsrf_line,
      row + 1, col 0, "   if [[ -s /tmp/dm2_qpid_dump.txt ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "       trgprocid=`head -n 1 /tmp/dm2_qpid_dump.txt`",
      row + 1, col 0, "       rm -f /tmp/dm2_qpid_dump.txt",
      row + 1, col 0, '       echo1 "Initiating a kill -9 $trgprocid"',
      row + 1, col 0, "       kill -9 $trgprocid",
      row + 1, col 0, "      sleep 2",
      row + 1, col 0, "   else",
      row + 1, col 0, '       echo1 "Reg Server has already stopped"',
      row + 1, col 0, "   fi",
      row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, "   slibclean", row + 1
      ENDIF
      col 0, '   echo "registry stopped" >>$tgt_tmp_full_dir/stop_reg_ind.dat', row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, "   ##Start registry          ", row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, '   echo2 "Start registry"', row + 1,
      col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1,
      col 0, "   if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "## Function:", row + 1, col 0,
      "##	version_adjust - Adjust the revision Level to compare.", row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "revision_adjust()", row + 1, col 0,
      "{", row + 1, col 0,
      "   revision=$1", row + 1, col 0,
      "   rev_chk=`echo $revision|tr -d '[0-9]'|tr -d '.'`", row + 1, col 0,
      "   if [[ ${#rev_chk} -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, dcsrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. Revision level contains',
       ' unsupported characters [$rev_chk]."'),
      col 0, dcsrf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   lvl=`echo $revision|tr -dc '.'|wc -c`", row + 1,
      col 0, "   rev1=0", row + 1,
      col 0, "   rev2=0", row + 1,
      col 0, "   rev3=0", row + 1,
      col 0, "   rev4=0", row + 1,
      col 0, '   rev1=`echo $revision | cut -f1 -d"."`', row + 1,
      col 0, "   if [[ ${#rev1} -ne 4 ]]", row + 1,
      col 0, "   then", row + 1,
      dcsrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. First level [${rev1}] should',
       ' be 4 numeric integers (i.e. 2004, 2010, 2012)."'), col 0, dcsrf_line,
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   if [[ $lvl -gt 3 ]]",
      row + 1, col 0, "   then",
      row + 1, dcsrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision level contains',
       '  more than 4 levels."'), col 0,
      dcsrf_line, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev2=`echo $revision | cut -f2 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 1 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev3=`echo $revision | cut -f3 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 2 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev4=`echo $revision | cut -f4 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ ${#rev2} -gt 4 || ${#rev3} -gt 4 || ${#rev4} -gt 4 ]]", row + 1, col 0,
      "   then", row + 1, dcsrf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision minor levels should',
       ' be less than 5 numeric integers."'),
      col 0, dcsrf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   while [[ ${#rev1} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev1="0$rev1"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev2} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev2="0$rev2"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev3} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev3="0$rev3"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev4} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev4="0$rev4"', row + 1,
      col 0, "   done", row + 1,
      col 0, '   rev_lvl="$rev1$rev2$rev3$rev4" ', row + 1,
      col 0, "}", row + 1,
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0, "##	get_server_ctrl - Determine if node level server control exists.",
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "get_server_ctrl() ",
      row + 1, col 0, "{",
      row + 1, col 0, '   echo2 "Get node and domain level server control" ',
      row + 1, col 0, "   tgt_node=`hostname`",
      row + 1, col 0, '   echo2 "tgt_node : $tgt_node" ',
      row + 1, col 0,
      '   node_srvctrl=$($cer_exe/lreg -getp "\node\\${tgt_node}\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "   if (( $? == 0 ))",
      row + 1, col 0, "   then ",
      row + 1, col 0, "     node_srvctrl_fnd=1",
      row + 1, col 0, "   else ",
      row + 1, col 0, "     node_srvctrl_fnd=0 ",
      row + 1, col 0, "     cb_cycle=0 ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, "   if (( ${node_srvctrl_fnd} == 1 ))",
      row + 1, col 0, "   then  ",
      row + 1, col 0, "     #-----------------------------------------------  ",
      row + 1, col 0, "     ##Get ServerCtrl for all domains the node      ",
      row + 1, col 0, "     #----------------------------------------------- ",
      row + 1, col 0, '     echo2 "Get ServerCtrl for all domains the node." ',
      row + 1, col 0, "$cer_exe/lreg -enumk \\\\node\\\\${tgt_node}\\\\domain domain_list.dat  ",
      row + 1, col 0, "     domain_srvctrl_cnt=0 ",
      row + 1, col 0, "     domain_no_srvctrl_cnt=0",
      row + 1, col 0, "     while read domain ; do ",
      row + 1, col 0, "       echo2 ${domain}",
      row + 1, col 0,
      'dom_srvctrl=$($cer_exe/lreg -getp "\node\\$tgt_node\domain\\$domain\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "       if (( $? == 0 ))",
      row + 1, col 0, "       then ",
      row + 1, col 0, "         (( domain_srvctrl_cnt=domain_srvctrl_cnt+1 ))",
      row + 1, col 0, "       else ",
      row + 1, col 0, "         (( domain_no_srvctrl_cnt=domain_no_srvctrl_cnt+1 ))",
      row + 1, col 0, "       fi ",
      row + 1, col 0, "     done < domain_list.dat",
      row + 1, col 0, "     if (( ${domain_no_srvctrl_cnt} > 0 )) ",
      row + 1, col 0, "     then   ",
      row + 1, col 0, "       cb_cycle=1  ",
      row + 1, col 0, "     else ",
      row + 1, col 0, "cb_cycle=0 ",
      row + 1, col 0, "     fi ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, '   echo2 "cb_cycle : $cb_cycle" ',
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      "##Make sure the user is root.", row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      'echo3 "Verify user is root."', row + 1, row + 1,
      col 0, 'if [[ `whoami` != "root" ]]', row + 1,
      col 0, "then", row + 1,
      col 0, 'echo " "', row + 1,
      col 0, 'echo3 "ERROR: Logon as root and run again."', row + 1,
      col 0, 'echo " "', row + 1,
      col 0, "exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "#--------------------",
      row + 1, col 0, "#Set Target variables",
      row + 1, col 0, "#--------------------",
      row + 1, row + 1, dcsrf_line = concat("tgt_domain_name=",ddr_domain_data->tgt_domain_name),
      col 0, dcsrf_line, row + 1,
      dcsrf_line = concat("tgt_env=",ddr_domain_data->tgt_env), col 0, dcsrf_line,
      row + 1, dcsrf_line = concat("tgt_env_lc=",cnvtlower(ddr_domain_data->tgt_env)), col 0,
      dcsrf_line, row + 1, dcsrf_line = concat("tgt_tmp_dir=",ddr_domain_data->tgt_tmp_dir),
      col 0, dcsrf_line, row + 1,
      dcsrf_line = concat("tgt_tmp_full_dir=",ddr_domain_data->tgt_tmp_full_dir), col 0, dcsrf_line,
      row + 1, dcsrf_line = concat("tgt_wh=",ddr_domain_data->tgt_wh), col 0,
      dcsrf_line, row + 1, dcsrf_line = concat("tgt_wh_device=",ddr_domain_data->tgt_wh_device),
      col 0, dcsrf_line, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       dcsrf_line = concat("src_env=",cnvtlower(drrr_rf_data->src_env_name)), col 0, dcsrf_line,
       row + 1, dcsrf_line = concat('cd_rom_loc="/"'), col 0,
       dcsrf_line, row + 1, dcsrf_line = concat("common_to_tgt=",drrr_rf_data->common_to_tgt),
       col 0, dcsrf_line, row + 1,
       dcsrf_line = concat("tgt_top_dir=",drrr_rf_data->tgt_top_dir), col 0, dcsrf_line,
       row + 1, dcsrf_line = concat("tgt_cer_mgr_dir=",drrr_rf_data->tgt_cer_mgr_dir), col 0,
       dcsrf_line, row + 1, dcsrf_line = concat("tgt_cer_mgr_exe_dir=",drrr_rf_data->
        tgt_cer_mgr_exe_dir),
       col 0, dcsrf_line, row + 1,
       dcsrf_line = concat("tgt_cer_mgr_log_dir=",drrr_rf_data->tgt_cer_mgr_log_dir), col 0,
       dcsrf_line,
       row + 1, dcsrf_line = concat("tgt_cer_reg_dir=",drrr_rf_data->tgt_cer_reg_dir), col 0,
       dcsrf_line, row + 1, dcsrf_line = concat("tgt_cer_fifo_dir=",drrr_rf_data->tgt_cer_fifo_dir),
       col 0, dcsrf_line, row + 1,
       dcsrf_line = concat("tgt_cer_usock_dir=",drrr_rf_data->tgt_cer_usock_dir), col 0, dcsrf_line,
       row + 1, dcsrf_line = concat("tgt_cer_lock_dir=",drrr_rf_data->tgt_cer_lock_dir), col 0,
       dcsrf_line, row + 1
      ENDIF
      IF (validate(dm2_skip_date_chk,- (1))=1)
       col 0, "tgt_date_chk=0", row + 1
      ELSE
       col 0, "tgt_date_chk=1", row + 1
      ENDIF
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, "##Verify in Target environment",
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, 'echo3 "Verify in Target environment."',
      row + 1, row + 1, col 0,
      "cur_env=$environment", row + 1, col 0,
      "typeset -l cur_env=$cur_env", row + 1, col 0,
      'if [[ $cur_env = "" ]]', row + 1, col 0,
      "then", row + 1, col 0,
      '  typeset -x environment="${tgt_env_lc}"', row + 1, col 0,
      "  cur_env=$environment", row + 1, col 0,
      "  typeset -l cur_env=$cur_env", row + 1, col 0,
      "fi", row + 1, col 0,
      "if [[ $tgt_env_lc != $cur_env ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      '  echo3 "ERROR: Set to Target environment $tgt_env_lc and run again."', row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      "  exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------", row + 1,
      col 0, "#Validate Target Temp Directory", row + 1,
      col 0, "#------------------------------", row + 1,
      row + 1, col 0, "if [[ ! -d $tgt_tmp_dir ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo3 "$tgt_tmp_dir not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ ! -d $tgt_tmp_full_dir ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo3 "$tgt_tmp_full_dir not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "## Create Target Checkpoint File", row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "CheckPoint=$tgt_tmp_full_dir/target_checkpoint.dat", row + 1,
      col 0, "[[ -f ${CheckPoint} ]] && rm ${CheckPoint}", row + 1,
      col 0, "touch $CheckPoint", row + 1,
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "## Set up the Log File",
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "FilePrefix=$tgt_tmp_full_dir/dm2_target_refresh.log",
      row + 1, col 0, "if [[ -f $FilePrefix ]]",
      row + 1, col 0, "then",
      row + 1, col 0, "   rm -rf $FilePrefix",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "FilePrefix=$tgt_tmp_full_dir/dm2_target_refresh_", row + 1, col 0,
      "LastFile=`ls $FilePrefix[0-9]* 2>/dev/null | tail -1`", row + 1, col 0,
      "LastFile=`echo ${LastFile##*/}`", row + 1, row + 1,
      col 0, "if [[ -z $LastFile ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  ScriptLog=dm2_target_refresh_001.log", row + 1,
      col 0, "else", row + 1,
      col 0, '  Ext=`echo $LastFile | cut -f4 -d"_"`', row + 1,
      col 0, '  Cnt=`echo $Ext | cut -f1 -d"."`', row + 1,
      col 0, "  CntNew=`expr $Cnt + 1`", row + 1,
      col 0, "  while [[ ${#CntNew} -lt 3 ]]", row + 1,
      col 0, "  do", row + 1,
      col 0, "    CntNew=0$CntNew", row + 1,
      col 0, "  done", row + 1,
      col 0, "  ScriptLog=$tgt_tmp_full_dir/dm2_target_refresh_$CntNew.log", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "[[ -f ${ScriptLog} ]] && rm ${ScriptLog}",
      row + 1, row + 1, col 0,
      'echo1 "Begin dm2_target_refresh.ksh"', row + 1, row + 1,
      col 0, "if [[ ! -d $tgt_wh_device ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "$tgt_wh_device not found."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=0)
       col 0, "#--------------------------------", row + 1,
       col 0, "##Prompt SOURCE Environment name", row + 1,
       col 0, "#--------------------------------", row + 1,
       col 0, 'echo1 "Prompt Source environment name."', row + 1,
       row + 1, col 0, 'echo " "',
       row + 1, col 0, 'echo3 "Enter Source Environment Name: \c"',
       row + 1, col 0, "read src_env",
       row + 1, col 0, "typeset -l src_env=$src_env",
       row + 1, row + 1
      ENDIF
      col 0, "if [[ -z $src_env ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "ERROR: Invalid Source Environment Name."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "else", row + 1,
      col 0, '   echo1 "Source Environment Name : $src_env"', row + 1,
      col 0, "fi", row + 1,
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "##Convert windows line endings to unix line endings", row + 1,
       col 0, "input=$1", row + 1,
       col 0, ^output=$(echo $input| cut -d '.' -f1| awk '{printf("%s%s",$1,"_tmp.txt")}')^, row +
       1,
       col 0, "tr -s '\r\n' '\n' <$input >$output", row + 1,
       col 0, "mv $output $input", row + 1,
       row + 1, col 0, "##Validate response file",
       row + 1, col 0, "response_file=$input",
       row + 1, row + 1, col 0,
       'if [[ ! -f "$response_file" ]]', row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "response file not found!"', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "else", row + 1, col 0,
       '   echo1 "response file found"', row + 1, col 0,
       "fi", row + 1, row + 1,
       col 0, "#------------------------------", row + 1,
       col 0, "#Parse out the connection and process name", row + 1,
       col 0, "#------------------------------", row + 1,
       row + 1, dcsrf_line = concat('client_mnemonic=$(grep "s_CLIENT_MNEMONIC" $response_file ',
        ^|awk -F'=' '/s_CLIENT_MNEMONIC /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line, row + 1, row + 1,
       col 0, "if [[ -z $client_mnemonic ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid client mnemonic."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Client mnemonic : $client_mnemonic"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcsrf_line = concat('src_env_name=$(grep "s_SRC_ENV_NAME" $response_file',
        ^|awk -F'=' '/s_SRC_ENV_NAME /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line, row + 1, row + 1,
       col 0, "if [[ -z $src_env_name ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid source environment name."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Source environment name : $src_env_name"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcsrf_line = concat('tgt_env_name=$(grep "s_TGT_ENV_NAME" $response_file ',
        ^|awk -F'=' '/s_TGT_ENV_NAME /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line, row + 1, row + 1,
       col 0, "if [[ -z $tgt_env_name ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid target environment name."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Target environment name : $tgt_env_name"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcsrf_line = concat(
        'tgt_cap_schema_date=$(grep "s_TGT_CAPTURE_SCHEMA_DATE" $response_file ',
        ^|awk -F'=' '/s_TGT_CAPTURE_SCHEMA_DATE /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line, row + 1, row + 1,
       col 0, "if [[ -z $tgt_cap_schema_date ]]", row + 1,
       col 0, "then", row + 1,
       col 0, '   echo2 "ERROR: Invalid schema date."', row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "else", row + 1,
       col 0, '   echo1 "Schema date : $tgt_cap_schema_date"', row + 1,
       col 0, "fi", row + 1,
       row + 1, dcsrf_line = concat('dma_pcs_name=$(echo2 "${client_mnemonic}_${src_env_name}_',
        'to_${tgt_env_name}_${tgt_cap_schema_date}"',
        " | sed 's/-//g'|tr '[:lower:]' '[:upper:]'|tr -d '[:space:]')"), col 0,
       dcsrf_line, row + 1, row + 1,
       dcsrf_line = concat('adm_user=$(grep "s_ADM_DB_USER" $response_file ',
        ^|awk -F'=' '/ADM_DB_USER /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0, dcsrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_user ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin username."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       dcsrf_line = concat('adm_password=$(grep "s_ADM_DB_USER_PWD" $response_file ',
        ^|awk -F'=' '/ADM_DB_USER_PWD /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_password ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin password."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       dcsrf_line = concat('adm_cnct_str=$(grep "s_ADM_DB_CNCT_STR" $response_file ',
        ^|awk -F'=' '/ADM_DB_CNCT_STR /{print $2}'|sed 's/"//g' |awk '{$1=$1};1')^), col 0,
       dcsrf_line,
       row + 1, row + 1, col 0,
       "if [[ -z $adm_cnct_str ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid admin connect string."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "fi", row + 1, row + 1,
       col 0,
       ^adm_connection=$(echo "${adm_user}/${adm_password}@${adm_cnct_str}" |tr -d '[:space:]')^, row
        + 1,
       row + 1, col 0, "##Validate ORACLE_HOME directory",
       row + 1, col 0, "if [[ ! -d $ORACLE_HOME ]]",
       row + 1, col 0, "then",
       row + 1, col 0, '   echo2 "Error: ORACLE_HOME value has not been set."',
       row + 1, col 0, "   exit 1",
       row + 1, col 0, "fi",
       row + 1, row + 1, col 0,
       "##TDC COUNT QUERY", row + 1, col 0,
       'tgt_cnt_qry=`echo "select count(*)', row + 1, col 0,
       "from dma_process_event dpe", row + 1, col 0,
       "where dpe.dma_process_id in", row + 1, col 0,
       "  (select x.dma_process_id from dma_process x", row + 1, col 0,
       "   where x.process_name = '$dma_pcs_name'", row + 1, col 0,
       "     and x.process_type = 'REPLICATE_REFRESH'", row + 1, col 0,
       "     and x.action_type = 'EXECUTION')", row + 1, col 0,
       "  and dpe.event_name = 'TARGET DATA COLLECTION'", row + 1, col 0,
       "  and dpe.event_status = 'COMPLETE';`", row + 1, row + 1,
       col 0, "##Get target data collection information", row + 1,
       col 0, "tgt_dc_ind=$(", row + 1,
       col 0, "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1,
       col 0, "whenever sqlerror exit sql.sqlcode;", row + 1,
       col 0, "set echo off", row + 1,
       col 0, "set heading off", row + 1,
       col 0, "set feedback off", row + 1,
       col 0, "$tgt_cnt_qry", row + 1,
       col 0, "END", row + 1,
       col 0, ")", row + 1,
       row + 1, col 0, 'if [[ -z "$tgt_dc_ind" || $tgt_dc_ind -eq 0 ]]',
       row + 1, col 0, "then",
       row + 1, col 0, '   echo2 "Target data not collected"',
       row + 1, col 0, "   exit 1",
       row + 1, col 0, "fi",
       row + 1, row + 1, col 0,
       "####Target refresh ksh update query", row + 1, col 0,
       'tgt_upd_qry=`echo "update dma_process_event dpe', row + 1, col 0,
       "set dpe.event_status = 'COMPLETE-STALE'", row + 1, col 0,
       "where dpe.dma_process_id in", row + 1, col 0,
       " (select x.dma_process_id from dma_process x", row + 1, col 0,
       "   where x.process_name = '$dma_pcs_name'", row + 1, col 0,
       "     and x.process_type = 'REPLICATE_REFRESH'", row + 1, col 0,
       "     and x.action_type = 'EXECUTION')", row + 1, col 0,
       "  and dpe.event_name = 'TARGET REFRESH KSH'", row + 1, col 0,
       "  and dpe.event_status = 'COMPLETE';`", row + 1, row + 1,
       col 0, "####update the complete row to complete stale", row + 1,
       col 0, "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1,
       col 0, "whenever sqlerror exit sql.sqlcode;", row + 1,
       col 0, "set echo off", row + 1,
       col 0, "set heading off", row + 1,
       col 0, "set feedback off", row + 1,
       col 0, "$tgt_upd_qry", row + 1,
       col 0, "commit;", row + 1,
       col 0, "END", row + 1,
       row + 1
      ENDIF
      col 0, "#---------------------------", row + 1,
      col 0, "##Read SOURCE misc_data.dat", row + 1,
      col 0, "#---------------------------", row + 1,
      col 0, 'echo2 "Read Source misc_data.dat."', row + 1,
      row + 1, col 0, 'src_tmp_dir="${tgt_tmp_dir}${src_env}/"',
      row + 1, col 0, 'echo1 "src_temp_dir : $src_tmp_dir"',
      row + 1, col 0, "if [[ ! -d $src_tmp_dir ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "$src_tmp_dir not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ ! -f ${src_tmp_dir}misc_data.dat ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "File ${src_tmp_dir}misc_data.dat not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[ $tgt_date_chk -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  find ${src_tmp_dir}misc_data.dat -mtime +14 |grep misc_data.dat", row + 1,
      col 0, "  if [[ $? -eq 0 ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo2 "misc_data.dat is older than 14 days."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, dcsrf_line =
      'src_cer_data_dev=$(grep "^src_cer_data_dev," ${src_tmp_dir}misc_data.dat |', dcsrf_line =
      concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^),
      col 0, dcsrf_line, row + 1,
      col 0, "if [[ -z $src_cer_data_dev ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "ERROR: Invalid src_cer_data_dev."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "else", row + 1,
      col 0, '   echo1 "src_cer_data_dev : $src_cer_data_dev"', row + 1,
      col 0, "fi", row + 1,
      dcsrf_line = 'src_wh=$(grep "^src_wh," ${src_tmp_dir}misc_data.dat |', dcsrf_line = concat(
       dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_wh ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_wh."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_wh : $src_wh"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_wh_device=$(grep "^src_wh_device," ${src_tmp_dir}misc_data.dat |', dcsrf_line
       = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_wh_device ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_wh_device."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_wh_device : $src_wh_device"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_cer_install_dir=$(grep "^src_cer_install_dir," ${src_tmp_dir}misc_data.dat |',
      dcsrf_line = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_cer_install_dir ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_cer_install_dir."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_cer_install_dir : $src_cer_install_dir"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_rev_level=$(grep "^src_revision_level," ${src_tmp_dir}misc_data.dat |',
      dcsrf_line = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_rev_level ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_rev_level."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_rev_level : $src_rev_level"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_system_user=$(grep "^src_system," ${src_tmp_dir}misc_data.dat |', dcsrf_line
       = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_system_user ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_system_user."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_system_user : $src_system_user"', row + 1, col 0,
      "fi", row + 1, dcsrf_line =
      'src_system_pwd=$(grep "^src_system_pwd," ${src_tmp_dir}misc_data.dat |',
      dcsrf_line = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0, dcsrf_line,
      row + 1, col 0, "if [[ -z $src_system_pwd ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "ERROR: Invalid src_system_pwd."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "else",
      row + 1, col 0, '   echo1 "src_system_pwd : $src_system_pwd"',
      row + 1, col 0, "fi",
      row + 1, row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       dcsrf_line = 'src_sec_user_name=$(grep "^src_sec_user_name," ${src_tmp_dir}misc_data.dat |',
       dcsrf_line = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
       dcsrf_line, row + 1, col 0,
       "if [[ -z $src_sec_user_name ]]", row + 1, col 0,
       "then", row + 1, col 0,
       '   echo2 "ERROR: Invalid src_sec_user_name."', row + 1, col 0,
       "   exit 1", row + 1, col 0,
       "else", row + 1, col 0,
       '   echo1 "src_sec_user_name : $src_sec_user_name"', row + 1, col 0,
       "fi", row + 1, row + 1
      ENDIF
      dcsrf_line = 'src_local_user_name=$(grep "^src_local_user_name," ${src_tmp_dir}misc_data.dat |',
      dcsrf_line = concat(dcsrf_line,^awk -F\, '{print $2}'|sed 's/"//g')^), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_local_user_name ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_local_user_name."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_local_user_name : $src_local_user_name"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_offline_dict=$(grep "^offline_dict_ind," ${src_tmp_dir}misc_data.dat |',
      dcsrf_line = concat(dcsrf_line,"awk -F\, '{print $2}')"), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_offline_dict ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_offline_dict."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_offline_dict : $src_offline_dict"', row + 1, col 0,
      "fi", row + 1, row + 1,
      dcsrf_line = 'src_node_list=`cat ${src_tmp_dir}misc_data.dat | grep -i "^node_name,"|',
      dcsrf_line = concat(dcsrf_line,"awk -F\, '{print $2}'`"), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ -z $src_node_list ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "ERROR: Invalid src_node_list."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo1 "src_node_list : $src_node_list"', row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "src_node_cnt=0", row + 1,
      col 0, "for src_node in $src_node_list; do", row + 1,
      col 0, "   ((src_node_cnt=src_node_cnt+1))", row + 1,
      col 0, "   if [[ $src_node_cnt -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      src_primary_node=$src_node", row + 1,
      col 0, '      echo1 "src_primary_node = $src_primary_node"', row + 1,
      col 0, "   fi", row + 1,
      col 0, "done", row + 1,
      row + 1, col 0, "#---------------------------",
      row + 1, col 0, "##Check for SOURCE *_wh_.sav",
      row + 1, col 0, "#---------------------------",
      row + 1, col 0, 'echo2 "Check for source *_wh.sav."',
      row + 1, row + 1, col 0,
      "if [[ ! -f ${src_tmp_dir}${src_env}_wh.sav ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "File ${src_tmp_dir}${src_env}_wh.sav not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[ $tgt_date_chk -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, "  find ${src_tmp_dir}${src_env}_wh.sav -mtime +14 |grep ${src_env}_wh.sav", row + 1,
      col 0, "  if [[ $? -eq 0 ]]", row + 1,
      col 0, "  then", row + 1,
      col 0, '    echo2 "${src_env}_wh.sav is older than 14 days."', row + 1,
      col 0, "    exit 1", row + 1,
      col 0, "  fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]",
      row + 1, col 0, "then",
      row + 1, col 0, "   rm -f $tgt_tmp_full_dir/stop_reg_ind.dat",
      row + 1, col 0, "   #------------------------",
      row + 1, col 0, "   ##Start registry          ",
      row + 1, col 0, "   #------------------------",
      row + 1, col 0, '   echo2 "Start registry"',
      row + 1, col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#---------------------------", row + 1, col 0,
      "##check if target wh exists ", row + 1, col 0,
      "#---------------------------", row + 1, col 0,
      ^file_cnt=`LANG=C ls -l $tgt_wh_device| grep total|awk -F" " '{print $2}'`^, row + 1, col 0,
      "if [[ $file_cnt != '0' ]]", row + 1, col 0,
      "then", row + 1, row + 1,
      col 0, "   #-----------------------------------------------", row + 1,
      col 0, "   ##Get warehouse for all environments on the node", row + 1,
      col 0, "   #-----------------------------------------------", row + 1,
      col 0, '   echo2 "Get all environments on the node."', row + 1,
      col 0, "$cer_exe/lregview <<!>env_list.dat", row + 1,
      col 0, "cd \environment", row + 1,
      col 0, "dir", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcsrf_line = "   env_list=$(grep '^\\' env_list.dat|", dcsrf_line = concat(dcsrf_line,
       ^awk -F" " '{print $1}'|sed 's/\\//')^),
      col 0, dcsrf_line, row + 1,
      col 0, "   echo1 $env_list", row + 1,
      col 0, '   echo "Warehouse List" > wh_list.dat', row + 1,
      row + 1, col 0, "   ind=0",
      row + 1, col 0, '   wh_array[0]="Warehouse list"',
      row + 1, col 0, "   for env in $env_list ; do",
      row + 1, col 0, "      echo1 $env",
      row + 1, row + 1, col 0,
      '      tmp_wh=$($cer_exe/lreg -getp "\Environment\\\\$env" "Warehouse1" 2>null)', row + 1, col
      0,
      "      echo1 $tmp_wh", row + 1, col 0,
      '      found="F"', row + 1, col 0,
      "      i=0", row + 1, col 0,
      '      echo1 "Array Size = "${#wh_array[@]}', row + 1, col 0,
      "      while [ $i -le ${#wh_array[@]} ]", row + 1, col 0,
      "      do", row + 1, col 0,
      "          if [[ $tmp_wh = ${wh_array[$i]} ]]", row + 1, col 0,
      "          then", row + 1, col 0,
      '             found="T"', row + 1, col 0,
      "          fi", row + 1, col 0,
      "          (( i=i+1 ))", row + 1, col 0,
      "      done", row + 1, col 0,
      "      ind=$ind+1", row + 1, col 0,
      "      wh_array[$ind]=$tmp_wh", row + 1, col 0,
      "      echo1 $found", row + 1, col 0,
      '      if [[ $found = "F" ]]', row + 1, col 0,
      "      then", row + 1, col 0,
      "         echo3 '\\'$tmp_wh' ' >> wh_list.dat", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      if [[ $tmp_wh = $tgt_wh ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         if [[  $env = "common" ]]', row + 1,
      col 0, "         then", row + 1,
      col 0, "            common_wh=${tmp_wh}", row + 1,
      col 0, '            echo1 "common_wh = $common_wh"', row + 1,
      row + 1, col 0, "            common_share_wh=1",
      row + 1, col 0, '            echo1 "common_share_wh = $common_share_wh"',
      row + 1, row + 1, col 0,
      '         elif [[ $env != "admin" && $env != $tgt_env ]]', row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Warehouse $tgt_wh is used for environment $env."', row + 1, col 0,
      '            echo2 "This process can not be used to refresh the domain."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, col 0,
      "      fi ", row + 1, col 0,
      "   done", row + 1, row + 1,
      col 0, "   #------------------------------", row + 1,
      col 0, "   ##Get all warehouse on the node", row + 1,
      col 0, "   #-------------------------------", row + 1,
      col 0, '   echo2 "Get all warehouses on the node."', row + 1,
      row + 1, dcsrf_line = "   wh_list=$(grep '^\\' wh_list.dat|", dcsrf_line = concat(dcsrf_line,
       ^awk -F" " '{print $1}'|sed 's/\\//')^),
      col 0, dcsrf_line, row + 1,
      col 0, "   echo1 $wh_list", row + 1,
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   ##check if tgt_wh is the only wh on node",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, '   echo1 "Check if tgt_wh is the only wh on node."',
      row + 1, row + 1, col 0,
      "   wh_cnt=0", row + 1, col 0,
      "   for wh in $wh_list ; do", row + 1, col 0,
      "      ((wh_cnt=wh_cnt+1))", row + 1, col 0,
      "   done", row + 1, col 0,
      "   echo1 wh_cnt=$wh_cnt", row + 1, row + 1,
      col 0, "   if [[ $wh_cnt -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      tgt_wh_only=1", row + 1,
      col 0, "   else", row + 1,
      col 0, "      tgt_wh_only=0", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   echo1 tgt_wh_only=$tgt_wh_only", row + 1,
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   ##Idenfity highest revision level for warehouses",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   if [[ $tgt_wh_only -eq 0 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo1 "Identify the highest warehouse based on revision level."',
      row + 1, col 0, "      cur_highest_rev_lvl=0000",
      row + 1, col 0, '      cur_highest_wh="NONE"',
      row + 1, col 0, "      for wh in $wh_list ; do",
      row + 1, col 0, "         if [[ $wh != $tgt_wh ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '         tmp_rev_lvl=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "Revision Level" 2>null)',
      row + 1, col 0,
      '         tmp_rootpath=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "RootPath" 2>null)',
      row + 1, col 0, '         echo1 "tmp_rev_lvl="$tmp_rev_lvl',
      row + 1, col 0, '         echo1 "tmp_rootpath="$tmp_rootpath',
      row + 1, col 0, "         if [[  -d $tmp_rootpath  ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '            file_cnt=`find $tmp_rootpath -type f -print| grep "cb_server_ctrl"|wc -l`',
      row + 1, col 0, "            if [[ $file_cnt -eq 1 ]]",
      row + 1, col 0, "            then",
      row + 1, col 0, "               revision_adjust $tmp_rev_lvl",
      row + 1, col 0, "               bkp_rev_lvl=$rev_lvl",
      row + 1, col 0, "               revision_adjust $cur_highest_rev_lvl",
      row + 1, col 0, "               bkp_highest_rev_lvl=$rev_lvl",
      row + 1, col 0, "               if [[ $bkp_rev_lvl -gt $bkp_highest_rev_lvl ]]",
      row + 1, col 0, "               then",
      row + 1, col 0, "                  cur_highest_wh=$wh",
      row + 1, col 0, "                  cur_highest_rev_lvl=$tmp_rev_lvl",
      row + 1, col 0, "               fi",
      row + 1, col 0, "            fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "      done",
      row + 1, col 0, '      echo2 "cur_highest_wh="$cur_highest_wh',
      row + 1, col 0, '      echo2 "cur_highest_rev_lvl="$cur_highest_rev_lvl',
      row + 1, col 0, '      if [[ $cur_highest_wh = "NONE" || $cur_highest_rev_lvl = 0 ]]',
      row + 1, col 0, "      then",
      row + 1, col 0,
      '        echo2 "Unable to find a valid warehouse on current node other than target. Setting tgt_wh_only = 1."',
      row + 1, col 0, "        tgt_wh_only=1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   if [[  $tgt_wh_only -eq 0 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      common_new_wh=$($cer_exe/lreg -getp "\environment\common" "warehouse1")',
      row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "      change_common_again=$common_to_tgt", row + 1,
       col 0, "      prompt_common_again=0", row + 1
      ELSE
       col 0, "      prompt_common_again=1", row + 1
      ENDIF
      col 0, "      while [[ $prompt_common_again -eq 1 ]]; do", row + 1,
      dcsrf_line = concat('         echo2 "Would you like to change common warehouse after target',
       ' warehouse is rebuilt [Y]es or [N]o? \c"'), col 0, dcsrf_line,
      row + 1, col 0, "         read change_common_again",
      row + 1, dcsrf_line = concat(
       "         if [[ $change_common_again = 'Y' || $change_common_again = 'y' || ",
       " $change_common_again = 'YES' ||  $change_common_again = 'yes' ||  $change_common_again = 'Yes' || ",
       "$change_common_again = 'N' || $change_common_again = 'n' ||  $change_common_again = 'NO' || ",
       "$change_common_again = 'No' || $change_common_again = 'no' ]]"), col 0,
      dcsrf_line, row + 1, col 0,
      "         then", row + 1, col 0,
      "            prompt_common_again=0", row + 1, col 0,
      "         fi", row + 1, col 0,
      "      done", row + 1, dcsrf_line = concat(
       "      if [[ $change_common_again = 'Y' || $change_common_again = 'y' ||",
       "$change_common_again = 'Yes' || $change_common_again = 'yes' || $change_common_again = 'YES' ]]"
       ),
      col 0, dcsrf_line, row + 1,
      col 0, "      then", row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "            common_back_wh=$tgt_wh", row + 1,
       col 0,
       '            echo2 "Changing common warehouse back to $common_back_wh after rebuilding target warehouse"',
       row + 1
      ELSE
       col 0, "         loop=1", row + 1,
       col 0, "         while [[ $loop -eq 1 ]]; do", row + 1,
       col 0, '            echo2 "Prompt to change common warehouse."', row + 1,
       row + 1, col 0, "            for wh in $wh_list ; do",
       row + 1, col 0, "               if [[ $wh != $common_new_wh ]]",
       row + 1, col 0, "               then",
       row + 1, col 0, "                  echo2 $wh",
       row + 1, col 0, "               fi",
       row + 1, col 0, "            done",
       row + 1, row + 1, col 0,
       '            echo2 "Please choose a warehouse for common to change to from list above: \c"',
       row + 1, col 0,
       "            read common_back_wh", row + 1, row + 1,
       col 0, "            for wh in $wh_list ; do", row + 1,
       col 0, "               if [[ $wh != $common_new_wh ]]", row + 1,
       col 0, "               then", row + 1,
       col 0, "                  if [[ $wh = $common_back_wh ]]", row + 1,
       col 0, "                  then", row + 1,
       col 0, "                     back_wh_fnd=1", row + 1,
       col 0, "                  fi", row + 1,
       col 0, "               fi", row + 1,
       col 0, "            done", row + 1,
       row + 1, col 0, "            if [[  $back_wh_fnd -ne 1 ]]",
       row + 1, col 0, "            then",
       row + 1, col 0, '               echo2 "$common_back_wh is not in the warehouse list."',
       row + 1, col 0, "            else",
       row + 1, col 0, "               loop=0",
       row + 1, col 0, "            fi",
       row + 1, col 0, "         done",
       row + 1, row + 1
      ENDIF
      col 0,
      '         $cer_exe/lreg -setp "\environment\common" "wh_changed_again" "$common_back_wh"', row
       + 1,
      col 0,
      '         common_again_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again")',
      row + 1,
      col 0, "         if [[ $common_again_prop != $common_back_wh ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Failed to add new property wh_changed_again for common."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0,
      '         common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "         if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            $cer_exe/lreg -setp "\environment\common" "common_wh_switched" "Y"', row +
      1,
      col 0,
      '            common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "            if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Failed to add new property common_wh_switched for common."', row
       + 1,
      col 0, "               exit 1", row + 1,
      col 0, "            fi", row + 1,
      col 0, "         fi", row + 1,
      row + 1, col 0, "      else",
      row + 1, col 0,
      '         echo2 "User choose not to change common warehouse after target is rebuilt."',
      row + 1, col 0, "      fi",
      row + 1, row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   #-----------------", row + 1,
      col 0, "   ##Stop all servers", row + 1,
      col 0, "   #-----------------", row + 1,
      col 0, '   echo2 "Terminate servers."', row + 1,
      row + 1, col 0, "   test -e $cer_exe/server_ctrl",
      row + 1, col 0, "   if (( $? == 0 ))",
      row + 1, col 0, "   then",
      row + 1, col 0, '     srv_cmd="$cer_exe/scpview -dom"',
      row + 1, col 0, "   else",
      row + 1, col 0, '     srv_cmd="$cer_exe/cmbview -dom"',
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "$srv_cmd $tgt_domain_name <<!", row + 1, col 0,
      "kill -all", row + 1, col 0,
      "exit", row + 1, col 0,
      "!", row + 1, row + 1,
      col 0, "   loop=0", row + 1,
      col 0, "   while [[ $loop -lt 20 ]]; do", row + 1,
      col 0, "      sleep 15", row + 1,
      col 0, "      ((loop=loop+1))", row + 1,
      col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat", row + 1,
      col 0, "server", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcsrf_line = "      server_list=$(grep '^[0-9]' server_list.dat|", dcsrf_line = concat
      (dcsrf_line,^awk -F" " '{print $1}')^),
      col 0, dcsrf_line, row + 1,
      row + 1, col 0, "      if [[ -z $server_list ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "All servers are terminated with -all."',
      row + 1, col 0, "         loop=100",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   done",
      row + 1, row + 1, col 0,
      "   if [[ ! -z $server_list ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      "      if [[ -f server_cmd.dat ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         rm server_cmd.dat", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      for server_inst in $server_list ; do", row + 1,
      col 0, '         echo "kill $server_inst" >>server_cmd.dat', row + 1,
      col 0, "      done", row + 1,
      row + 1, col 0, '      echo "exit" >>server_cmd.dat ',
      row + 1, row + 1, col 0,
      "$srv_cmd $tgt_domain_name<server_cmd.dat", row + 1, row + 1,
      col 0, "#must start in the beginning of the line, othewise will error", row + 1,
      col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat", row + 1,
      col 0, "server", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, dcsrf_line = "      server_list=$(grep '^[0-9]' server_list.dat|", dcsrf_line = concat
      (dcsrf_line,^awk -F" " '{print $1}')^),
      col 0, dcsrf_line, row + 1,
      row + 1, col 0, "      if [[ -z $server_list ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "All servers are terminated."',
      row + 1, col 0, "      else",
      row + 1, col 0, '         echo2 "servers can not be terminated."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "   #--------------------------------", row + 1, col 0,
      "   ##Clean-up the CMB Global Section ", row + 1, col 0,
      "   #---------------------------------", row + 1, col 0,
      '   echo2 "Clean up cmb global section."', row + 1, row + 1,
      col 0, "   $cer_proc/terminate_cmb.ksh $tgt_domain_name 0 Y N", row + 1,
      col 0, "   if [[ -f $cer_proc/delete_cmb_gs.ksh ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '         echo "Y" | $cer_proc/delete_cmb_gs.ksh $tgt_domain_name ', row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "   #--------------------------------",
      row + 1, col 0, "   ##Delete the audit and code cache ",
      row + 1, col 0, "   #--------------------------------",
      row + 1, col 0, '   echo2 "Delete audit and code cache."',
      row + 1, row + 1, col 0,
      "   $cer_exe/auditconf -destroy", row + 1, col 0,
      "   code -destroy", row + 1, row + 1,
      col 0, "   #------------------------------------", row + 1,
      col 0, "   ##destroy the que_stat global section ", row + 1,
      col 0,
      '   ##(Note:  "que_stat: unable to destroy memory manager [OS error 2424]" is an ignorable error):',
      row + 1,
      col 0, "   #------------------------------------", row + 1,
      col 0, '   echo2 "Destroy the que_stat global section."', row + 1,
      row + 1, col 0, "   $cer_exe/gmm -destroy que_stat",
      row + 1, row + 1, col 0,
      "   get_server_ctrl", row + 1, row + 1,
      col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1,
      col 0,
      "   ##Terminate server controller, domain directory, resolver if target wh is the only warehouse on node",
      row + 1,
      col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1,
      col 0, "   if (( $tgt_wh_only == 1 && ${cb_cycle} == 1 ))", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "$tgt_wh is the only warehouse on the node."', row + 1,
      col 0, '      echo2 "Terminate server controller, domain directory and resolver."', row + 1,
      row + 1, col 0, "      $cer_exe/cb_shutdown -ctrl",
      row + 1, col 0, "      loop=0",
      row + 1, col 0, "      while [[ $loop -lt 12 ]]; do",
      row + 1, col 0, "         sleep 5",
      row + 1, col 0, "         ((loop=loop+1))",
      row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcsrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "         if [[ $? -ne 0 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, "            loop=100", row + 1,
      col 0, "         elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Terminate server controller failed."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      done", row + 1,
      row + 1, col 0, "      $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "      #check if resolver exists", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         resolver_exist=1", row + 1, col 0,
      "      else", row + 1, col 0,
      "         resolver_exist=0", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "      then ", row + 1,
      col 0, "         $cer_exe/cb_shutdown -res", row + 1,
      col 0, "         loop=0", row + 1,
      col 0, "         while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "            sleep 5", row + 1,
      col 0, "            ((loop=loop+1))", row + 1,
      col 0, "            ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "            if [[ $? -ne 0 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, "               loop=100", row + 1,
      col 0, "            elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Terminate resolver failed."', row + 1,
      col 0, "               exit 1", row + 1,
      col 0, "            fi", row + 1,
      col 0, "         done", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       col 0, "      #------------------------", row + 1,
       col 0, "      ##Stop registry          ", row + 1,
       col 0, "      #------------------------", row + 1,
       col 0, '      echo2 "Stop registry"', row + 1,
       col 0, "      $cer_mgr_exe/reg_server -stop", row + 1,
       dcsrf_line = concat(
        "      ps -ef |grep reg_server |grep cerner |sed 's/\([ ]*[A-Za-z0-9_]*[ ]*\) \([0-9]*\) \([^`]*\)/\2/'",
        " > /tmp/dm2_qpid_dump.txt"), col 0, dcsrf_line,
       row + 1, col 0, "      if [[ -s /tmp/dm2_qpid_dump.txt ]]",
       row + 1, col 0, "      then",
       row + 1, col 0, "          trgprocid=`head -n 1 /tmp/dm2_qpid_dump.txt`",
       row + 1, col 0, "          rm -f /tmp/dm2_qpid_dump.txt",
       row + 1, col 0, '          echo1 "Initiating a kill -9 $trgprocid"',
       row + 1, col 0, "          kill -9 $trgprocid",
       row + 1, col 0, "          sleep 2",
       row + 1, col 0, "      else",
       row + 1, col 0, '          echo1 "Reg Server has already stopped"',
       row + 1, col 0, "      fi",
       row + 1, col 0, '     echo "registry stopped" >>$tgt_tmp_full_dir/stop_reg_ind.dat',
       row + 1
      ENDIF
      col 0, "   #------------------------", row + 1,
      col 0, "   ##Delete target warehouse ", row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, '   echo2 "Delete Target warehouse."', row + 1,
      col 0, "   rm -fR $tgt_wh_device/*", row + 1,
      row + 1, col 0, ^   file_cnt=`LANG=C ls -l $tgt_wh_device| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "   if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "Target warehouse $tgt_wh_device failed to be deleted."',
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#--------------------------------", row + 1, col 0,
      "##Extract source wh backup file  ", row + 1, col 0,
      "#--------------------------------", row + 1, row + 1,
      col 0, 'echo2 "Extract $tgt_wh_device/${src_env}_wh.sav"', row + 1,
      col 0, "cd $tgt_wh_device", row + 1,
      col 0, "tar -xvf ${src_tmp_dir}${src_env}_wh.sav ", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to extract $tgt_wh_device/${src_env}_wh.sav."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       col 0, "   #------------------------", row + 1,
       col 0, "   ##Start registry          ", row + 1,
       col 0, "   #------------------------", row + 1,
       col 0, '   echo2 "Start registry"', row + 1,
       col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1,
       col 0, "   if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, "      rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1,
       col 0, "   fi", row + 1,
       row + 1
      ENDIF
      col 0, "#------------------------", row + 1,
      col 0, "##Recreate symbolic links", row + 1,
      col 0, "#------------------------", row + 1,
      col 0, 'echo2 "Recreating symbolic links"', row + 1,
      col 0, "if [[ -f ${src_tmp_dir}/link_data.dat ]]", row + 1,
      col 0, "then ", row + 1,
      col 0, '  echo2 "Get all Source symbolic links to process..." ', row + 1,
      col 0, "  cat ${src_tmp_dir}/link_data.dat | while read line ", row + 1,
      col 0, "  do  ", row + 1,
      col 0, "     line_eval=`eval echo $line`  ", row + 1,
      col 0, '     full_link_name=`echo $line_eval | cut -f2 -d" "`', row + 1,
      col 0, '     full_file_name=`echo $line_eval | cut -f3 -d" "`', row + 1,
      col 0, "     if [[ -h ${full_link_name} ]] ", row + 1,
      col 0, "     then  ", row + 1,
      col 0, '       echo2 "  Removing symbolic link ${full_link_name}."', row + 1,
      col 0, "       rm -f ${full_link_name}  ", row + 1,
      col 0, "       if [[ $? -ne 0 ]]  ", row + 1,
      col 0, "       then  ", row + 1,
      col 0, '         echo2 "Failed to remove symbolic link ${full_link_name}." ', row + 1,
      col 0, "         exit 1 ", row + 1,
      col 0, "       fi ", row + 1,
      col 0, "     else ", row + 1,
      col 0, '       echo2 "  Symbolic link ${full_link_name} does not exist."', row + 1,
      col 0, "     fi  ", row + 1,
      col 0, "     if [[ ! -z ${full_file_name} ]]", row + 1,
      col 0, "     then                                                    ", row + 1,
      col 0, '       echo2 "  Creating symbolic link ${full_link_name} to file ${full_file_name}." ',
      row + 1,
      col 0, "       ln -sf ${full_file_name} ${full_link_name} ", row + 1,
      col 0, "       if [[ $? -ne 0 ]]   ", row + 1,
      col 0, "       then ", row + 1,
      col 0, '         echo2 "Failed to create symbolic link ${full_link_name} - exit status $?."  ',
      row + 1,
      col 0, "         exit 1 ", row + 1,
      col 0, "       fi", row + 1,
      col 0, "     else ", row + 1,
      col 0, '       echo2 "  Symbolic link ${full_link_name} will not be created." ', row + 1,
      col 0, "     fi ", row + 1,
      col 0, "  done ", row + 1,
      col 0, "fi ", row + 1,
      row + 1, col 0, "#-----------------------------------",
      row + 1, col 0, "#Issue privilege & ownership changes ",
      row + 1, col 0, "#-----------------------------------",
      row + 1, col 0, "chmod -R 775 $tgt_wh_device",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to change mod for $tgt_wh_device."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os IN ("HPX", "LNX")))
       dcsrf_line = "chown -R b_common:sys $tgt_wh_device"
      ELSE
       dcsrf_line = "chown -R b_common:system $tgt_wh_device"
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change owner for $tgt_wh_device."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0,
      "#-----------------------------------------------------------------------------------------------------------",
      row + 1, col 0,
      "#Start the server controller,domain directory and resolver If TARGET's warehouse is the only one on the node",
      row + 1, col 0,
      "#------------------------------------------------------------------------------------------------------------",
      row + 1, col 0, "if (( $tgt_wh_only == 1 && ${cb_cycle} == 1 ))",
      row + 1, col 0, "then",
      row + 1, col 0,
      '   echo2 "$tgt_wh is the only warehouse on the node.  Start server controller, domain directory and resolver."',
      row + 1, row + 1, col 0,
      "   $cer_exe/cb_startup -ctrl", row + 1, col 0,
      "   loop=0", row + 1, col 0,
      "   while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "      sleep 5", row + 1, col 0,
      "      ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcsrf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "      if [[ $? -eq 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         loop=100", row + 1,
      col 0, "      elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Start server controller failed."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   done", row + 1,
      row + 1, col 0, "   $cer_exe/cb_startup -ddir",
      row + 1, row + 1, col 0,
      "   #check if resolver exists", row + 1, col 0,
      "   ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      "      resolver_exist=1", row + 1, col 0,
      "   else", row + 1, col 0,
      "      resolver_exist=0", row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      $cer_exe/cb_startup -res", row + 1,
      col 0, "      loop=0", row + 1,
      col 0, "      while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "         sleep 5", row + 1,
      col 0, "         ((loop=loop+1))", row + 1,
      col 0, "         ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "         if [[ $? -eq 0 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, "            loop=100", row + 1,
      col 0, "         elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Start resolver failed."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      done", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "#-------------------------",
      row + 1, col 0, "#config Offline Dictionary",
      row + 1, col 0, "#-------------------------",
      row + 1, col 0,
      "ccldiraccess=$($cer_exe/getlog CCLDIRACCESS | grep '\[global\]' | sed 's/.*--> //')",
      row + 1, col 0, "if [[ ! -z $ccldiraccess ]]",
      row + 1, col 0, "then",
      row + 1, col 0,
      '   echo2 "Offline dictionary is used.  Verify CCLDIRACCESS is 1WRITE and CCLDIR match CCLDIR1."',
      row + 1, row + 1, col 0,
      "   if [[ $ccldiraccess != '1WRITE' ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      echo2 "Change CCLDIRACCESS to 1WRITE."', row + 1, row + 1,
      col 0, '      $cer_exe/setlog -g "CCLDIRACCESS" "1WRITE"', row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Failed to set logical CCLDIRACCESS to 1WRITE."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   fi", row + 1,
      row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcsrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "ccldiraccess")'
        )
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "ccldiraccess")'
        )
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcsrf_line = concat("   ccldiraccess_reg=$(",
        '$cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "ccldiraccess")'
        )
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "   if [[ $ccldiraccess_reg != '1WRITE' ]]", row + 1,
      col 0, "   then", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "ccldiraccess" "1WRITE"'
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "ccldiraccess" "1WRITE"'
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0,
       '      $cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "ccldiraccess" "1WRITE"'
      ENDIF
      row + 1, col 0, "      if [[ $? -ne 0 ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Failed to update registry CCLDIRACCESS to 1WRITE."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   ccldir=$($cer_exe/getlog CCLDIR | grep '\[global\]' | sed 's/.*--> //')", row + 1,
      col 0, "   ccldir1=$($cer_exe/getlog CCLDIR1 | grep '\[global\]' | sed 's/.*--> //')", row + 1,
      col 0, "   if [[ $ccldir != $ccldir1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Change CCLDIR to match CCLDIR1 value $ccldir1."', row + 1,
      row + 1, col 0, '      $cer_exe/setlog -g "CCLDIR" $ccldir1',
      row + 1, col 0, "      if [[ $? -ne 0 ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Failed to set logical CCLDIR to $ccldir1."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcsrf_line = concat(
        'ccldir_reg=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" ',
        '"CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line = concat(
        'ccldir_reg=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" ',
        '"CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcsrf_line = concat(
        'ccldir_reg=$($cer_exe/lreg -getp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" ',
        '"CCLDIR")')
      ENDIF
      col 4, dcsrf_line, row + 1,
      col 0, ^   if [[ $ccldir_reg != "'cer_data'/ccldir" ]]^, row + 1,
      col 0, "   then", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcsrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcsrf_line = concat(
        '$cer_exe/lreg -setp "\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" ',
        ^"CCLDIR" "'cer_data'/ccldir"^)
      ENDIF
      col 7, dcsrf_line, row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, ^         echo2 "Failed to update registry CCLDIR to 'cer_data'/ccldir."^, row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      '   echo2 "Run start_cerner_500 after logical change."', row + 1, col 0,
      "   $cer_mgr_exe/start_cerner_500 -env $tgt_env -verbose", row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcsrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\aixrs6000\environment" "CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\hpuxia64\environment" "CCLDIR")')
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcsrf_line = concat("   tgt_ccldir_value=$($cer_exe/lreg -getp ",
        '"\Environment\\\\${tgt_env}\definitions\linuxx86-64\environment" "CCLDIR")')
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "   cer_data_value=$($cer_exe/getlog cer_data | grep '\[global\]' | sed 's/.*--> //')",
      row + 1,
      col 0, '   cer_data_value=$(echo ${cer_data_value}|sed "s/\//\\\\\//g")', row + 1
      IF ((dm2_sys_misc->cur_os="LNX"))
       col 0,
       ^   tgt_ccldir_value=$(echo ${tgt_ccldir_value}|sed "s/'//g"|sed "s/cer_data/${cer_data_value}/g")^,
       row + 1
      ELSE
       col 0,
       ^   tgt_ccldir_value=$(echo ${tgt_ccldir_value}|sed "s/\'//g"|sed "s/cer_data/${cer_data_value}/g")^,
       row + 1
      ENDIF
      col 0, "else", row + 1,
      col 0, "   tgt_ccldir_value=$($cer_exe/getlog CCLDIR | grep '\[global\]' | sed 's/.*--> //')",
      row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "if [[  -d $tgt_ccldir_value  ]]",
      row + 1, col 0, "then",
      row + 1, col 0,
      ^   file_cnt=`LANG=C ls -l $tgt_ccldir_value| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "   if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "      #------------------------",
      row + 1, col 0, "      ##Delete target CCLDIR ",
      row + 1, col 0, "      #------------------------",
      row + 1, col 0, '      echo2 "Delete Target CCLDIR."',
      row + 1, col 0, "      rm -R $tgt_ccldir_value/*",
      row + 1, row + 1, col 0,
      ^      file_cnt=`LANG=C ls -l $tgt_ccldir_value| grep total|awk -F" " '{print $2}'`^, row + 1,
      col 0,
      "      if [[ $file_cnt != '0' ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "Target $tgt_ccldir_value was not deleted."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "   fi", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "if [[  -d $cer_config  ]]", row + 1,
      col 0, "then", row + 1,
      col 0, ^   file_cnt=`LANG=C ls -l $cer_config| grep total|awk -F" " '{print $2}'`^, row + 1,
      col 0, "   if [[ $file_cnt != '0' ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      #------------------------", row + 1,
      col 0, "      ##Delete target cer_config ", row + 1,
      col 0, "      #------------------------", row + 1,
      col 0, '      echo2 "Delete Target cer_config."', row + 1,
      col 0, "      rm -R $cer_config/*", row + 1,
      row + 1, col 0, ^      file_cnt=`LANG=C ls -l $cer_config| grep total|awk -F" " '{print $2}'`^,
      row + 1, col 0, "      if [[ $file_cnt != '0' ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         echo2 "Target $cer_config was not deleted."',
      row + 1, col 0, "         exit 1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#-----------------------------------------------", row + 1, col 0,
      "##Extract backup file from CCLDIR and CER_CONFIG ", row + 1, col 0,
      "#-----------------------------------------------", row + 1, row + 1,
      col 0, 'echo2 "Extract ${src_tmp_dir}${src_env}_ccldir.sav"', row + 1,
      col 0, "cd $tgt_ccldir_value", row + 1,
      col 0, "tar -xvf ${src_tmp_dir}${src_env}_ccldir.sav ", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to extract ${src_tmp_dir}${src_env}_ccldir.sav."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, 'echo2 "Extract ${src_tmp_dir}${src_env}_config.sav"',
      row + 1, col 0, "cd $cer_config",
      row + 1, col 0, "tar -xvf ${src_tmp_dir}${src_env}_config.sav ",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to extract ${src_tmp_dir}${src_env}_config.sav."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#---------------------------------------------------------------", row + 1, col 0,
      "##Delete  dic.dat and dic.idx from CCLDIR and CER_CONFIG ", row + 1, col 0,
      "#---------------------------------------------------------------", row + 1, col 0,
      "ls -l $tgt_ccldir_value/dic.*", row + 1, col 0,
      "if [[ $? -eq 0 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "Delete dic.dat and dic.idx from $tgt_ccldir_value"', row + 1, col 0,
      "   rm $tgt_ccldir_value/dic.*", row + 1, col 0,
      "   if [[ $? -ne 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      echo2 "Failed to delete dic.dat and dic.idx from $tgt_ccldir_value."', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#--------------------------", row + 1,
      col 0, "##Copy DIC.DAT and DIC.IDX", row + 1,
      col 0, "#--------------------------", row + 1,
      col 0, 'echo2 "Copy dic.dat and dic.idx to $tgt_ccldir_value."', row + 1,
      col 0, "cp -p $cer_install/dic.dat $tgt_ccldir_value", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to copy dic.dat to $tgt_ccldir_value."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "cp -p $cer_install/dic.idx $tgt_ccldir_value",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "Failed to copy dic.idx to $tgt_ccldir_value."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "#------------------------------------------", row + 1, col 0,
      "#Permission change on CCLDIR and CER_CONFIG", row + 1, col 0,
      "#------------------------------------------", row + 1, col 0,
      'echo2 "Change permission and owner on $tgt_ccldir_value and $cer_config."', row + 1, row + 1,
      col 0, "chmod -R 777 $tgt_ccldir_value", row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change mod on CCLDIR."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "chmod -R 777 $cer_config",
      row + 1, col 0, "if [[ $? -ne 0 ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '  echo2 "Failed to change mod on CER_CONFIG."',
      row + 1, col 0, "  exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, dcsrf_line = concat("chown -R ",ddr_domain_data->tgt_local_user_name,":",
       ddr_domain_data->tgt_local_group_name," $tgt_ccldir_value"),
      col 0, dcsrf_line, row + 1,
      col 0, "if [[ $? -ne 0 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Failed to change owner on CCLDIR."', row + 1,
      col 0, "   exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, dcsrf_line = concat("chown -R ",ddr_domain_data->tgt_local_user_name,":",
       ddr_domain_data->tgt_local_group_name," $cer_config"), col 0,
      dcsrf_line, row + 1, col 0,
      "if [[ $? -ne 0 ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo2 "Failed to change owner on CER_CONFIG."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#---------------------------------------------------------------", row + 1,
      col 0, "##Remove extraneous components from CCLDIR and CERCONFIG", row + 1,
      col 0, "#---------------------------------------------------------------", row + 1,
      col 0, "for i in `ls $tgt_ccldir_value | awk {'print $1'}`; do ", row + 1,
      col 0, "if [[ $i != *.dat && $i != *.idx && $i != *bcheck* ]]  ", row + 1,
      col 0, "then  ", row + 1,
      col 0, "   rm -rf $tgt_ccldir_value/$i  ", row + 1,
      col 0, "   if [[ $? -ne 0 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Failed to clean CCLDIR."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi    ", row + 1,
      col 0, "done  ", row + 2,
      col 0, "for i in `ls $cer_config | awk {'print $1'}`; do ", row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       dcsrf_line = concat("if [[ $i != core.il && $i != msg_table.dat && $i != ",
        "$src_sec_user_name",".dat ","&& $i != ","$src_sec_user_name",
        ".idx ","&& $i != tdb_system.dat && $i != tdb_system.idx && $i != jou*.dat ]] ")
      ELSE
       dcsrf_line = concat("if [[ $i != core.il && $i != msg_table.dat ",
        "&& $i != tdb_system.dat && $i != tdb_system.idx && $i != jou*.dat ]] ")
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0, "then ", row + 1,
      col 0, "   rm -rf $cer_config/$i ", row + 1,
      col 0, "   if [[ $? -ne 0 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '      echo2 "Failed to clean cer_config."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "fi   ", row + 1,
      col 0, "done ", row + 1
      IF ((ddr_domain_data->src_was_arch_ind=0))
       col 0,
       'echo1 "Renaming sec_user files in cer_config from "$src_sec_user_name" to match target."',
       row + 1,
       dcsrf_line = concat('if [[ $src_sec_user_name != "',trim(cnvtlower(ddr_domain_data->
          tgt_sec_user_name)),'" ]]'), col 0, dcsrf_line,
       row + 1, col 0, "then ",
       row + 1, dcsrf_line = concat("   mv $cer_config/","${src_sec_user_name}",".dat ",
        "$cer_config/",ddr_domain_data->tgt_sec_user_name,
        ".dat"), col 0,
       dcsrf_line, row + 1, dcsrf_line = concat("   mv $cer_config/","${src_sec_user_name}",".idx ",
        "$cer_config/",ddr_domain_data->tgt_sec_user_name,
        ".idx"),
       col 0, dcsrf_line, row + 1,
       col 0, "fi   ", row + 1
      ENDIF
      col 0, "#---------------------", row + 1,
      col 0, "#Change common wh", row + 1,
      col 0, "#---------------------", row + 1,
      col 0, 'common_back_wh=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again")', row +
      1,
      col 0, "if [[ ! -z $common_back_wh ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   echo2 "Change common warehouse from $common_new_wh to $common_back_wh "', row + 1,
      col 0, '   $cer_exe/lreg -setp "\environment\common" "warehouse1" "$common_back_wh"', row + 1,
      col 0, '   common_changed_again=$($cer_exe/lreg -getp "\environment\common" "warehouse1")', row
       + 1,
      row + 1, col 0, "   if [[ $common_changed_again != $common_back_wh ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "Failed to change common warehouse to $common_back_wh."',
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   #remove common wh_changed_again prop",
      row + 1, col 0, ^   echo1 "Remove common's wh_changed_again property."^,
      row + 1, col 0, '   $cer_exe/lreg -delp "\environment\common" "wh_changed_again" ',
      row + 1, row + 1, col 0,
      '   common_changed_again_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed_again" 2>null)',
      row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      ^      echo2 "Property 'wh_changed_again' failed to be removed."^, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1, col 0,
      "fi", row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       IF ((dm2_sys_misc->cur_os="AIX"))
        dcsrf_line =
        'ic_version=`${tgt_wh_device}/aixrs6000/install_cerner -version | cut -f4 -d" "`'
       ELSEIF ((dm2_sys_misc->cur_os="HPX"))
        dcsrf_line = 'ic_version=`${tgt_wh_device}/hpuxia64/install_cerner -version | cut -f4 -d" "`'
       ELSEIF ((dm2_sys_misc->cur_os="LNX"))
        dcsrf_line =
        'ic_version=`${tgt_wh_device}/linuxx86-64/install_cerner -version | cut -f4 -d" "`'
       ENDIF
       col 0, dcsrf_line, row + 1,
       col 0, 'ic_v1=`echo $ic_version | cut -f1 -d"."`', row + 1,
       col 0, 'ic_v2=`echo $ic_version | cut -f2 -d"."`', row + 1,
       col 0, 'ic_v3=`echo $ic_version | cut -f3 -d"."`', row + 1,
       col 0, "ic_version_int=$((ic_v1*10000+ic_v2*100+ic_v3))", row + 1,
       col 0, "if [[ $ic_version_int -eq 60000 ||  $ic_version_int -gt 60000  ]]", row + 1,
       col 0, "then", row + 1,
       col 0, "  ic_input_file_ind=1", row + 1,
       col 0, "fi", row + 1,
       col 0, "if [[ $dm2_bypass_ic_input_file -eq 1  ]]", row + 1,
       col 0, "then", row + 1,
       col 0,
       '  echo2 "Found dm2_bypass_id_input_file variable. Using interactive method for install_cerner."',
       row + 1,
       col 0, "  ic_input_file_ind=0", row + 1,
       col 0, "fi", row + 1
      ENDIF
      col 0, 'common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "if [[ $common_switched_prop = 'Y' || tgt_wh_only -eq 1 ]]", row + 1,
      col 0, "then", row + 1,
      col 0, '   common_wh_name=$($cer_exe/lreg -getp "\environment\common" "warehouse1")', row + 1,
      col 0, '   common_wh_path=$($cer_exe/lreg -getp "\warehouse\\\\${common_wh_name}" "RootPath")',
      row + 1,
      col 0, '   echo2 "Using install_cerner to refresh core components."', row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   ic_cmd="${tgt_wh_device}/aixrs6000/install_cerner -core -verbose"', row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, '   ic_cmd="${tgt_wh_device}/hpuxia64/install_cerner -core -verbose"', row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, '   ic_cmd="${tgt_wh_device}/linuxx86-64/install_cerner -core -verbose"', row + 1
      ENDIF
      col 0, '   echo2 "Launching ${ic_cmd}"', row + 1,
      col 0, '   echo2 ""', row + 1,
      col 0, "   #If ic_input_file_ind is set, then use input file version of install cerner", row +
      1,
      col 0, "   if [[ $ic_input_file_ind -eq 1 ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, '     ic_input_file_name="${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}.txt"', row + 1,
      col 0, '     echo1 "Write Install Cerner input file - $ic_input_file_name"', row + 1,
      row + 1, col 0, '     echo "section:core;" >${ic_input_file_name}',
      row + 1, col 0, '     echo "  topdirectory:${tgt_top_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  source:${common_wh_path};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cdrom:${cd_rom_loc};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr:${tgt_cer_mgr_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr_exe:${tgt_cer_mgr_exe_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_mgr_log:${tgt_cer_mgr_log_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_reg:${tgt_cer_reg_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_fifo:${tgt_cer_fifo_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_usock:${tgt_cer_usock_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "  cer_lock:${tgt_cer_lock_dir};" >>${ic_input_file_name}',
      row + 1, col 0, '     echo "section:end;" >>${ic_input_file_name}',
      row + 1, col 0, '     echo " " >>${ic_input_file_name}',
      row + 1, row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       dcsrf_line = concat(
        "   ${tgt_wh_device}/aixrs6000/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       dcsrf_line = concat(
        "   ${tgt_wh_device}/hpuxia64/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       dcsrf_line = concat(
        "   ${tgt_wh_device}/linuxx86-64/install_cerner -input ${ic_input_file_name} > ",
        "${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt")
      ENDIF
      col 0, dcsrf_line, row + 1,
      col 0,
      '     err_cnt=`cat ${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt | grep -i "error: " | wc -l`',
      row + 1,
      col 0, "     if [[ ${err_cnt} -gt 0 ]]", row + 1,
      col 0, "     then", row + 1,
      col 0, "       if [[ ${dm2_ignore_cv_errors} -ne 1 ]]", row + 1,
      col 0, "       then", row + 1,
      col 0,
      '         echo2 "Execution of install_cerner using input file failed during core refresh."',
      row + 1,
      col 0,
      '         echo2 "For error details please view ${tgt_tmp_full_dir}/ic_cv_${tgt_domain_name}_log.txt"',
      row + 1,
      col 0,
      '         echo2 "If errors are ignorable, perform the following before restarting dm2_target_refresh.ksh"',
      row + 1,
      col 0, '         echo2 "export dm2_ignore_cv_errors=1"', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "       fi", row + 1,
      col 0, "     else", row + 1,
      col 0,
      '       echo2 "Execution of install_cerner using input file was successful during ${ic_cmd}."',
      row + 1,
      col 0, "     fi", row + 1,
      col 0, "   else", row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo2 "*                                     Install Cerner                                     *"',
      row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo2 "*Open another session and execute Install_Cerner as shown below.                         *"',
      row + 1,
      col 0,
      '     echo2 "*Answer the prompts according to the output below.                                       *"',
      row + 1,
      col 0,
      '     echo2 "*Do not continue until Install_Cerner completes successfully.                            *"',
      row + 1,
      col 0,
      '     echo2 "******************************************************************************************"',
      row + 1,
      col 0, '     echo2 "Using Install_Cerner to refresh core components."', row + 1,
      col 0, '     echo2 ""', row + 1,
      col 0, '     echo2 "${ic_cmd}"', row + 1,
      col 0, '     echo2 "" ', row + 1,
      col 0, '     echo2 "Install_Cerner Prompts and recommended answers:"', row + 1,
      col 0, '     echo2 "CD-ROM Location [] > / "', row + 1,
      col 0, '     echo2 "Is this correct? [y] > Y"', row + 1,
      col 0, '     echo2 "Do you wish to refresh the cer_mgr directory? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to refresh the cer_mgr_exe directory? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to refresh the system registry template? [N] > Y"', row + 1,
      col 0, '     echo2 "Select a source directory [] > $tgt_wh_device "', row + 1,
      col 0, '     echo2 "Do you wish to run start_cerner_500 after creation? [Y] > Y"', row + 1,
      col 0, '     echo2 "Hit C to continue; E to exit. > C" ', row + 1,
      col 0,
      '     echo "******************************************************************************************"',
      row + 1,
      col 0,
      '     echo3 "*Has the execution of Install_Cerner as shown above completed successfully?[Y/N] \c" ',
      row + 1,
      col 0, "     read answer ", row + 1,
      col 0, "     typeset -l answer=$answer", row + 1,
      col 0,
      '     echo "******************************************************************************************"',
      row + 1,
      col 0, '     if [[ $answer != "y" ]]', row + 1,
      col 0, "     then", row + 1,
      col 0, '        echo2 "User choose to quit."', row + 1,
      col 0, "        exit 1 ", row + 1,
      col 0, "     fi", row + 1,
      col 0, "   fi", row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   echo2 "Update registry."', row + 1,
       col 0,
       "   $tgt_wh_device/aixrs6000/update_reg -input $tgt_wh_device/install/update_reg_aix.csv ",
       row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_hpux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/hpuxia64/update_reg -input $tgt_wh_device/install/update_reg_hpux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_hpux.csv file not found."', row
        + 1,
       col 0, "   fi", row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_linux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/linuxx86-64/update_reg -input $tgt_wh_device/install/update_reg_linux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_linux.csv file not found."',
       row + 1,
       col 0, "   fi", row + 1
      ENDIF
      col 0, '   echo2 "Run start_cerner_500 for common environment."', row + 1,
      col 0, "   $cer_mgr_exe/start_cerner_500 -env common -verbose -noinst", row + 1,
      col 0,
      "   #-------------------------------------------------------------------------------------------",
      row + 1,
      col 0,
      "   ##Cycle server controller, domain directory, resolver if common_wh_switched prop found ",
      row + 1,
      col 0,
      "   #-------------------------------------------------------------------------------------------",
      row + 1,
      col 0, "   cycle_common", row + 1,
      col 0, "   cycle_reg", row + 1,
      row + 1, col 0, "   #remove common_wh_switched prop",
      row + 1, col 0, '   echo1 "Remove common_wh_switched property."',
      row + 1, col 0, '   $cer_exe/lreg -delp "\environment\common" "common_wh_switched" ',
      row + 1, col 0, '   echo2 "Note: "unable to delete property" is an acceptable error"',
      row + 1, row + 1, col 0,
      '   common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched" 2>null)',
      row + 1, col 0,
      "   if [[ $? -eq 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      ^      echo2 "Property 'common_wh_switched' failed to be removed."^, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "else", row + 1, col 0,
      '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, '   echo2 "Update registry."', row + 1,
       col 0,
       "   $tgt_wh_device/aixrs6000/update_reg -input $tgt_wh_device/install/update_reg_aix.csv ",
       row + 1
      ELSEIF ((dm2_sys_misc->cur_os="HPX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_hpux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/hpuxia64/update_reg -input $tgt_wh_device/install/update_reg_hpux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_hpux.csv file not found."', row
        + 1,
       col 0, "   fi", row + 1
      ELSEIF ((dm2_sys_misc->cur_os="LNX"))
       col 0, "   if [[ -s $tgt_wh_device/install/update_reg_linux.csv ]]", row + 1,
       col 0, "   then", row + 1,
       col 0, '     echo2 "Update registry."', row + 1,
       col 0,
       "     $tgt_wh_device/linuxx86-64/update_reg -input $tgt_wh_device/install/update_reg_linux.csv ",
       row + 1,
       col 0, "   else", row + 1,
       col 0, '     echo2 "Skipping update registry work - update_reg_linux.csv file not found."',
       row + 1,
       col 0, "   fi", row + 1
      ENDIF
      col 0, "fi", row + 1,
      row + 1, col 0, "src_rev_level=$(echo ${src_rev_level} | awk -F. '{print $1}')",
      row + 1, col 0, "if (( ${src_rev_level} >= 2015 ))",
      row + 1, col 0, "then ",
      row + 1, col 0, '  reg_ksh="${cer_proc}/2015_registry_special_instructions.ksh"',
      row + 1, col 0, "  if [[ -f ${reg_ksh} ]]",
      row + 1, col 0, "  then",
      row + 1, col 0, "    export node=${tgt_node}",
      row + 1, col 0, "    export domain=${tgt_domain_name}",
      row + 1, col 0, "    export environment=${tgt_domain_name}",
      row + 1, col 0, '    echo2 "Execute 2015_registry_special_instructions.ksh."',
      row + 1, col 0, "    ${reg_ksh} ",
      row + 1, dcrf_line = concat(
       '    dom_srvctrl=$($cer_exe/lreg -getp "\node\\${tgt_node}\domain\\${tgt_domain_name}\ServerCtrl" ',
       '"ServerCtrlPath" 2>null)'), col 0,
      dcrf_line, row + 1, col 0,
      "    if (( $? != 0 )) ", row + 1, col 0,
      "    then ", row + 1, col 0,
      '      echo2 "Failed to add domain level server controller." ', row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "    fi  ", row + 1, col 0,
      "  fi  ", row + 1, col 0,
      "fi ", row + 1, row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "##Construct insert statement", row + 1,
       col 0, 'tgt_ins_stmt=`echo "insert into dma_process_event', row + 1,
       col 0, "(dma_process_event_id,dma_process_id,event_name,event_status,", row + 1,
       col 0, "  message,username,begin_dt_tm,end_dt_tm,updt_dt_tm)", row + 1,
       col 0, "select DM_SEQ.nextval,dp.dma_process_id,'TARGET REFRESH KSH',", row + 1,
       col 0, "       'COMPLETE','','',sysdate,sysdate,sysdate", row + 1,
       col 0, "from dma_process dp", row + 1,
       col 0, "where dp.process_name = '$dma_pcs_name'", row + 1,
       col 0, "and dp.process_type = 'REPLICATE_REFRESH'", row + 1,
       col 0, ^and dp.action_type  = 'EXECUTION';"`^, row + 1,
       row + 1, col 0, "##Construct count statement",
       row + 1, col 0, 'tgt_ins_cnt_qry=`echo "select COUNT(*)',
       row + 1, col 0, "from dma_process_event dpe",
       row + 1, col 0, "where dpe.event_name='TARGET REFRESH KSH'",
       row + 1, col 0, "and   dpe.event_status='COMPLETE'",
       row + 1, col 0, "and   dpe.dma_process_id IN (select dma_process_id",
       row + 1, col 0, "                             from dma_process dp",
       row + 1, col 0, "                             where dp.process_name ='$dma_pcs_name'",
       row + 1, col 0, "                             and dp.process_type = 'REPLICATE_REFRESH'",
       row + 1, col 0, ^                             and dp.action_type  = 'EXECUTION');"`^,
       row + 1, row + 1, col 0,
       '##Insert a "COMPLETE" row after successful script execution', row + 1, col 0,
       "dpe_trk_cnt=$(", row + 1, col 0,
       "$ORACLE_HOME/bin/sqlplus -s $adm_connection << END", row + 1, col 0,
       "whenever sqlerror exit sql.sqlcode;", row + 1, col 0,
       "set echo off", row + 1, col 0,
       "set heading off", row + 1, col 0,
       "set feedback off", row + 1, col 0,
       "$tgt_ins_stmt", row + 1, col 0,
       "commit;", row + 1, col 0,
       "$tgt_ins_cnt_qry", row + 1, col 0,
       "END", row + 1, col 0,
       ")", row + 1, row + 1,
       col 0, "if [ $dpe_trk_cnt -eq 0 ];", row + 1,
       col 0, "then", row + 1,
       col 0, ^   echo2 "Failed to insert a 'COMPLETE' row on dma_process_event table"^, row + 1,
       col 0, "   exit 1", row + 1,
       col 0, "fi", row + 1,
       row + 1
      ENDIF
      col 0, 'echo2 "dm2_target_refresh.ksh executed successfully."', row + 1,
      col 0, 'echo "TARGET_REFRESH_COMPLETE" >$CheckPoint', row + 1,
      row + 1
     ENDIF
    WITH nocounter, format = variable, formfeed = none,
     maxrow = 1, maxcol = 512
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcsrf_line = concat("set file/prot=(s:rwed,o:rwed,g:rwed,w:rwed) ",dcsrf_file_name)
   ELSE
    SET dcsrf_line = concat("chmod 777 ",dcsrf_file_name)
   ENDIF
   IF (dm2_push_dcl(dcsrf_line)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE ddsrr_create_sec_shutdown_file(null)
   DECLARE dcssf_file_name = vc WITH protect, noconstant("")
   DECLARE dcssf_line = vc WITH protect, noconstant("")
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcssf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_shutdown.com")
   ELSE
    SET dcssf_file_name = concat(ddr_domain_data->tgt_tmp_full_dir,"dm2_target_shutdown.ksh")
   ENDIF
   SET dm_err->eproc = concat("Create ",dcssf_file_name)
   CALL disp_msg("",dm_err->logfile,0)
   SELECT INTO value(dcssf_file_name)
    FROM (dummyt t  WITH seq = 1)
    DETAIL
     IF ((dm2_sys_misc->cur_os="AXP"))
      CALL print("$!dm2_target_shutdown.com "), row + 1,
      CALL print("$!  "),
      row + 1,
      CALL print("$!mod "), row + 1,
      CALL print("$!000 sc4299  initial release "), row + 1,
      CALL print("$!-------------------------------------------"),
      row + 1,
      CALL print("$!                     "), row + 1,
      CALL print("$on ERROR then goto EXIT_ERROR"), row + 1,
      CALL print("$on CONTROL_Y then goto EXIT_ERROR"),
      row + 1,
      CALL print("$!--------------------  "), row + 1,
      CALL print("$!set variables         "), row + 1,
      CALL print("$!--------------------  "),
      row + 1,
      CALL print("$error = 0   "), row + 1,
      CALL print(concat('$tgt_domain_name = "',cnvtupper(ddr_domain_data->tgt_domain_name),'"')), row
       + 1,
      CALL print(concat('$tgt_env = "',cnvtupper(ddr_domain_data->tgt_env),'"')),
      row + 1,
      CALL print(concat('$tgt_tmp_dev = "',ddr_domain_data->tgt_tmp_dev,'"')), row + 1,
      CALL print(concat('$tgt_tmp_dir = "',ddr_domain_data->tgt_tmp_dir,'"')), row + 1,
      CALL print(concat('$tgt_tmp_full_dir = "',ddr_domain_data->tgt_tmp_full_dir,'"')),
      row + 1,
      CALL print(concat('$tgt_wh = "',cnvtupper(ddr_domain_data->tgt_wh),'"')), row + 1,
      CALL print(concat('$tgt_wh_device = "',ddr_domain_data->tgt_wh_device,'"')), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print(^$if f$search("''tgt_tmp_dev':[''tgt_tmp_dir']''tgt_env'.dir") .eqs. "" ^), row + 1,
      CALL print("$then  "), row + 1,
      CALL print(^$   call echo3 "error : directory ''tgt_tmp_full_dir' not found."  ^),
      row + 1,
      CALL print("$   error = 1"), row + 1,
      CALL print("$   goto EXIT_CRITICAL   "), row + 1,
      CALL print("$endif"),
      row + 1,
      CALL print("$! "), row + 1,
      CALL print("$!create log file "), row + 1, dcssf_line = concat(
       ^$if f$search("''tgt_tmp_full_dir'dm2_target_shutdown.log") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'dm2_target_shutdown.log;*"),
      CALL print(dcssf_line), row + 1,
      CALL print("$open/write logfile 'tgt_tmp_full_dir'dm2_target_shutdown.log             "),
      row + 1,
      CALL print("$! "), row + 1,
      CALL print('$call echo1 "begin dm2_target_shutdown.com" '), row + 1,
      CALL print("$!"),
      row + 1,
      CALL print(^$if f$search("''tgt_wh_device':[cerner.w_standard]''tgt_wh'.dir") .eqs. "" ^), row
       + 1,
      CALL print("$then    "), row + 1,
      CALL print(
      ^$   call echo2 "error : directory ''tgt_wh_device':[cerner.w_standard.''tgt_wh'] not found."  ^
      ),
      row + 1,
      CALL print("$   error = 1   "), row + 1,
      CALL print("$   goto EXIT_SCRIPT "), row + 1,
      CALL print("$endif "),
      row + 1,
      CALL print("$! "), row + 1,
      CALL print('$tgt_node = f$getsyi("nodename") '), row + 1,
      CALL print(^$call echo1 "tgt_node = ''tgt_node'" ^),
      row + 1,
      CALL print('$common_new_wh = "" '), row + 1,
      CALL print('$common_back_wh = ""'), row + 1,
      CALL print("$!                           "),
      row + 1,
      CALL print(
      "$!----------------------------                                                        "), row
       + 1,
      CALL print(
      "$!verify in Target Environment                                                        "), row
       + 1,
      CALL print(
      "$!----------------------------                                                        "),
      row + 1,
      CALL print(
      '$call echo1 "Verify in Target Environment"                                            '), row
       + 1,
      CALL print(
      "$set noon                                                                             "), row
       + 1,
      CALL print(
      '$if tgt_env .nes. f$edit(f$trnlnm("environment"), "upcase, trim")                     '),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "Error : Must be in Target environment ''tgt_env'"                     ^), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$set on                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      ^$if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. ""                          ^), row
       + 1,
      CALL print(
      "$then                                                                                 "),
      row + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '), row
       + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "), row
       + 1,
      CALL print(
      "$   delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*                                        "),
      row + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!--------------------------                                                          "), row
       + 1,
      CALL print(
      "$!verify user is domain user                                                          "),
      row + 1,
      CALL print(
      "$!--------------------------                                                          "), row
       + 1,
      CALL print(
      '$call echo1 "Verify domain user"                                                      '), row
       + 1,
      CALL print(
      "$set noon                                                                             "),
      row + 1,
      CALL print(
      ^$mcr cer_exe:lreg -getp \environment\'tgt_env' "localusername"                        ^), row
       + 1,
      CALL print(
      "$if $status                                                                           "), row
       + 1,
      CALL print(
      "$then                                                                                 "),
      row + 1,
      CALL print(
      '$   domain_user = f$edit(lreg_result, "upcase")                                       '), row
       + 1,
      CALL print(
      ^$   call echo1 "domain user : ''domain_user'"                                         ^), row
       + 1,
      CALL print(
      "$else                                                                                 "),
      row + 1,
      CALL print(
      '$   call echo2 "Error : Failed to find domain user."                                  '), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "), row
       + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "),
      row + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$set on                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$comma_pos = 0                                                                        "), row
       + 1,
      CALL print(
      "$str_length = 0                                                                       "), row
       + 1,
      CALL print(
      "$curuser = f$user()                                                                   "),
      row + 1,
      CALL print(
      '$comma_pos = f$locate(",",curuser)                                                    '), row
       + 1,
      CALL print(
      "$str_length = f$length(curuser)                                                       "), row
       + 1,
      CALL print(
      "$if (comma_pos .gt. 0) .and. (comma_pos .ne. str_length)                              "),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      '$ curuser = F$EXTRACT(F$LOCATE(",",curuser)+1 ,F$LOCATE("]",curuser)-F$LOCATE(",",curuser)-1,curuser)   '
      ), row + 1,
      CALL print(
      "$else                                                                                 "),
      row + 1,
      CALL print(
      '$ curuser = curuser - "[" - "]"                                                       '), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      '$curuser = f$edit(curuser, "upcase")                                                  '),
      row + 1,
      CALL print(
      ^$call echo1 "curuser : ''curuser'"                                                    ^), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$if curuser .nes. domain_user                                                         "),
      row + 1,
      CALL print(
      "$then                                                                                 "), row
       + 1,
      CALL print(
      ^$   call echo2 "error : log on as ''domain_user' and run again."                      ^), row
       + 1,
      CALL print(
      "$   error = 1                                                                         "),
      row + 1,
      CALL print(
      "$   goto EXIT_SCRIPT                                                                  "), row
       + 1,
      CALL print(
      "$endif                                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$!check for target wh                                                                 "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "),
      row + 1,
      CALL print(
      '$call echo1 "Check for target warehouse"                                              '), row
       + 1,
      CALL print(
      ^$tgt_wh_exist = f$search("''tgt_wh_device':[cerner.w_standard.''tgt_wh']*.dir")       ^), row
       + 1,
      CALL print(
      '$if tgt_wh_exist .eqs. "" then goto EXIT_SCRIPT                                       '),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$!target wh found                                                                     "),
      row + 1,
      CALL print(
      "$!-------------------                                                                 "), row
       + 1,
      CALL print(
      "$TGT_WH_FOUND:                                                                        "), row
       + 1,
      CALL print(
      '$   call echo1 "Target wh exists"                                                     '),
      row + 1,
      CALL print(
      "$!  ---------------------------------------------                                     "), row
       + 1,
      CALL print(
      "$!  get warehouse for all environments on the node                                    "), row
       + 1,
      CALL print(
      "$!  ----------------------------------------------                                    "),
      row + 1,
      CALL print(
      '$   call echo2 "Get warehouse for all environments"                                   '), row
       + 1,
      dcssf_line = concat(^$   if f$search("''tgt_tmp_full_dir'env_list.dat") .nes. "" then ^,
       " delete 'tgt_tmp_full_dir'env_list.dat;* "),
      CALL print(dcssf_line), row + 1,
      dcssf_line = concat(^$   if f$search("''tgt_tmp_full_dir'wh_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'wh_list.dat;*"),
      CALL print(dcssf_line), row + 1,
      CALL print(
      "$   define sys$output 'tgt_tmp_full_dir'env_list.dat                                  "), row
       + 1,
      CALL print(
      "$mcr cer_exe:lregview                                                                 "),
      row + 1,
      CALL print(
      "cd \environment                                                                       "), row
       + 1,
      CALL print(
      "dir                                                                                   "), row
       + 1,
      CALL print(
      "exit                                                                                  "),
      row + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   env_cnt = 0                                                                       "), row
       + 1,
      CALL print(
      "$   common_share_wh = 0                                                               "),
      row + 1,
      CALL print(
      "$   wh_ind = 0                                                                        "), row
       + 1,
      CALL print(
      ^$   wh_array'wh_ind = "Warehouse List"                                                ^), row
       + 1,
      CALL print(
      "$   open/read/error=CHECK_ENV_LIST ENV_LIST 'tgt_tmp_full_dir'ENV_LIST.dat            "),
      row + 1,
      CALL print(
      "$   open/write WH_LIST 'tgt_tmp_full_dir'wh_list.dat                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   READ_ENV_LIST:                                                                    "),
      row + 1,
      CALL print(
      "$      read/end_of_file=END_READ_ENV_LIST ENV_LIST record                             "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "),
      row + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            env_cnt = env_cnt + 1                                                    "), row
       + 1,
      CALL print(
      "$            env_name'env_cnt = f$extract(1, end_pos-1, record)                       "),
      row + 1,
      CALL print(
      ^$            tmp_env_name = f$edit(env_name'env_cnt, "upcase")                        ^), row
       + 1,
      CALL print(
      ^$            call echo1 "environment_name : '' tmp_env_name'"                         ^), row
       + 1,
      CALL print(
      "$            set noon                                                                 "),
      row + 1,
      CALL print(
      "$            define/user_mode sys$error nl:                                           "), row
       + 1,
      CALL print(
      ^$            mcr cer_exe:lreg -getp \environment\'tmp_env_name' "warehouse1"          ^), row
       + 1,
      CALL print(
      "$            if $status                                                               "),
      row + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               set on                                                                "), row
       + 1,
      CALL print(
      ^$               env_wh'env_cnt = lreg_result - """" - """"                            ^),
      row + 1,
      CALL print(
      ^$               tmp_env_wh = f$edit(env_wh'env_cnt, "upcase")                         ^), row
       + 1,
      CALL print(
      ^$               call echo1 "warehouse :  ''tmp_env_wh'"                               ^), row
       + 1,
      CALL print(
      "$               i = 0                                                                 "),
      row + 1,
      CALL print(
      '$               found = "F"                                                           '), row
       + 1,
      CALL print(
      "$               FIND_LOOP:                                                            "), row
       + 1,
      CALL print(
      "$                  if (i .le. wh_ind)                                                 "),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      "$                     if (tmp_env_wh .eqs. wh_array'i)                                "), row
       + 1,
      CALL print(
      "$                     then                                                            "),
      row + 1,
      CALL print(
      '$                        found = "T"                                                  '), row
       + 1,
      CALL print(
      "$                     endif                                                           "), row
       + 1,
      CALL print(
      "$                     i = i + 1                                                       "),
      row + 1,
      CALL print(
      "$                     goto FIND_LOOP                                                  "), row
       + 1,
      CALL print(
      "$                  endif                                                              "), row
       + 1,
      CALL print(
      "$               wh_ind = wh_ind + 1                                                   "),
      row + 1,
      CALL print(
      "$               wh_array'wh_ind = tmp_env_wh                                          "), row
       + 1,
      CALL print(
      "$               END_FIND_LOOP:                                                        "), row
       + 1,
      CALL print(
      '$                  if (found .eqs. "F")                                               '),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     write WH_LIST "\''tmp_env_wh' "                                 ^), row
       + 1,
      CALL print(
      "$                  endif                                                              "),
      row + 1,
      CALL print(
      "$               if tmp_env_wh .eqs. tgt_wh                                            "), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      '$                  if tmp_env_name .eqs. "COMMON"                                     '),
      row + 1,
      CALL print(
      "$                  then                                                               "), row
       + 1,
      CALL print(
      ^$                     call echo2 "common environment warehouse : ''tmp_env_wh'"       ^), row
       + 1,
      CALL print(
      "$                     common_wh = tmp_env_wh                                          "),
      row + 1,
      CALL print(
      "$                     common_share_wh = 1                                             "), row
       + 1,
      CALL print(
      "$                  else                                                               "), row
       + 1,
      CALL print(
      '$                     if (tmp_env_name .nes. "ADMIN") .and. (tmp_env_name .nes. tgt_env)'),
      row + 1,
      CALL print(
      "$                     then                                                            "), row
       + 1,
      CALL print(
      ^$                        call echo2 "warehouse ''tgt_wh'  is used for environment ''tmp_env_name'."^
      ), row + 1,
      CALL print(
      '$                        call echo2 "this process cannot be used to refresh the domain."'),
      row + 1,
      CALL print(
      "$                        error = 1                                                    "), row
       + 1,
      CALL print(
      "$                        goto EXIT_SCRIPT                                             "), row
       + 1,
      CALL print(
      "$                     endif !not admin and tgt_env                                    "),
      row + 1,
      CALL print(
      "$                  endif !common                                                      "), row
       + 1,
      CALL print(
      "$               endif !eqs tgt_wh                                                     "), row
       + 1,
      CALL print(
      "$            endif !$status                                                           "),
      row + 1,
      CALL print(
      "$            set on                                                                   "), row
       + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !start with \                                                            "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_ENV_LIST                                                             "), row
       + 1,
      CALL print(
      "$   CHECK_ENV_LIST:                                                                   "),
      row + 1,
      CALL print(
      "$      env_err_msg = f$message($status)                                               "), row
       + 1,
      CALL print(
      ^$      call echo2 "error opening file ''tgt_tmp_full_dir'env_list.dat"                ^), row
       + 1,
      CALL print(
      "$      call echo2 'env_err_msg'                                                       "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_ENV_LIST:                                                                "),
      row + 1,
      CALL print(
      "$      close ENV_LIST                                                                 "), row
       + 1,
      CALL print(
      "$      close WH_LIST                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   deassign sys$output                                                               "), row
       + 1,
      CALL print(
      "$   wh_cnt = 0                                                                        "), row
       + 1,
      CALL print(
      "$   open/read/error=CHECK_WH_LIST WH_LIST 'tgt_tmp_full_dir'wh_list.dat               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   READ_WH_LIST:                                                                     "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_WH_LIST WH_LIST record                               "),
      row + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      '$      if char .eqs. "\"                                                              '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '), row
       + 1,
      CALL print(
      "$         length = f$length(record)                                                   "),
      row + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            wh_cnt = wh_cnt + 1                                                      "), row
       + 1,
      CALL print(
      "$            wh_name'wh_cnt = f$extract(1, end_pos-1, record)                         "), row
       + 1,
      CALL print(
      ^$            wh_name'wh_cnt = f$edit(wh_name'wh_cnt, "upcase")                        ^),
      row + 1,
      CALL print(
      "$            tmp_wh_name = wh_name'wh_cnt                                             "), row
       + 1,
      CALL print(
      "$            if tmp_wh_name .nes. tgt_wh                                              "), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               call echo2 'tmp_wh_name'                                              "), row
       + 1,
      CALL print(
      "$            else                                                                     "), row
       + 1,
      CALL print(
      "$               call echo1  'tmp_wh_name'                                             "),
      row + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !start with \                                                            "),
      row + 1,
      CALL print(
      "$!     write sys$output record                                                        "), row
       + 1,
      CALL print(
      "$      goto READ_WH_LIST                                                              "), row
       + 1,
      CALL print(
      "$   CHECK_WH_LIST:                                                                    "),
      row + 1,
      CALL print(
      "$      wh_err_msg = f$message($status)                                                "), row
       + 1,
      CALL print(
      ^$      call echo2 "Error opening file ''tgt_tmp_full_dir'wh_list.dat"                 ^), row
       + 1,
      CALL print(
      "$      call echo2 'wh_err_msg'                                                        "),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_WH_LIST:                                                                 "),
      row + 1,
      CALL print(
      "$      close WH_LIST                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if wh_cnt .eq. 1                                                                  "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      tgt_wh_only = 1                                                                "), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      "$      tgt_wh_only = 0                                                                "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   call echo1 "common_share_wh = ''common_share_wh'"                                 ^),
      row + 1,
      CALL print(
      ^$   call echo1 "tgt_wh_only = ''tgt_wh_only'"                                         ^), row
       + 1,
      CALL print(
      "$   if (common_share_wh .eq. 1) .and. (tgt_wh_only .eq. 0)                            "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$!  ----------------------------------                                                "), row
       + 1,
      CALL print(
      "$!  Prompt to change common warehouse                                                 "), row
       + 1,
      CALL print(
      "$!  ---------------------------------                                                 "),
      row + 1,
      CALL print(
      "$   PROMPT_COMMON_WH:                                                                 "), row
       + 1,
      dcssf_line = concat(
       '$      inquire common_new_wh "Please choose a new warehouse for common from ',
       'list above or enter [Q] to Quit" '),
      CALL print(dcssf_line), row + 1,
      CALL print(
      '$      if common_new_wh .eqs. "" then goto PROMPT_COMMON_WH                           '), row
       + 1,
      CALL print(
      '$      if common_new_wh .eqs. "Q"                                                     '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "User choose to quit when selecting a new common warehouse."     '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      ^$      call echo1 "common_new_wh = ''common_new_wh'"                                  ^),
      row + 1,
      CALL print(
      "$      wh_count = 0                                                                   "), row
       + 1,
      CALL print(
      "$      new_wh_fnd = 0                                                                 "), row
       + 1,
      CALL print(
      "$      WH_LOOP:                                                                       "),
      row + 1,
      CALL print(
      "$         wh_count = wh_count + 1                                                     "), row
       + 1,
      CALL print(
      "$         if (wh_count .le. wh_cnt) .and. (new_wh_fnd .eq. 0)                         "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$!           write sys$output wh_name'wh_count                                        "), row
       + 1,
      CALL print(
      "$            if (wh_name'wh_count .eqs.common_new_wh) .and. (wh_name'wh_count .nes. tgt_wh)"),
      row + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               new_wh_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$            goto WH_LOOP                                                             "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      ^$      call echo1 "new_wh_fnd = ''new_wh_fnd'"                                        ^), row
       + 1,
      CALL print(
      "$      if new_wh_fnd .eq. 0                                                           "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "''common_new_wh' is not in the warehouse list."                 ^), row
       + 1,
      CALL print(
      "$         goto PROMPT_COMMON_WH                                                       "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      dcssf_line = concat(^$      inquire answer "Change common warehouse from ''common_wh' to ^,
       ^''common_new_wh' [C]ontinue or [Q]uit"^),
      CALL print(dcssf_line), row + 1,
      CALL print(
      ^$      call echo1 "answer = ''answer'"                                                ^), row
       + 1,
      CALL print(
      '$      if answer .eqs. "Q"                                                            '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "User choose to quit when modifying common warehouse."           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      set noon                                                                       "),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -setp \environment\common "wh_changed" "Y"                    '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '),
      row + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      "$      set on                                                                         "),
      row + 1,
      CALL print(
      '$      common_new_prop = f$edit(lreg_result, "upcase")                                '), row
       + 1,
      CALL print(
      '$      if common_new_prop .nes. "Y"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to add new property wh_changed for common."              '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -setp \environment\common "common_wh_switched" "Y"            '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "common_wh_switched"                '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_wh_switched_prop = f$edit(lreg_result, "upcase")                        '),
      row + 1,
      CALL print(
      '$      if common_wh_switched_prop .nes. "Y"                                           '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to add new property common_wh_switched for common."      '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      ^$      mcr cer_exe:lreg -setp \environment\common "warehouse1" "''common_new_wh'"        ^),
      row + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "), row
       + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "warehouse1"                        '),
      row + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_changed_wh = f$edit(lreg_result, "upcase")                              '), row
       + 1,
      CALL print(
      ^$      call echo1 "common_changed_wh = ''common_changed_wh'"                          ^),
      row + 1,
      CALL print(
      "$      if common_changed_wh .nes. common_new_wh                                       "), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "Failed to change common warehouse to ''common_new_wh'"          ^),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$   endif  !(common_share_wh .eq. 1) .and. (tgt_wh_only .eq. 0)                       "), row
       + 1,
      CALL print(
      "$!  -----------------------                                                           "), row
       + 1,
      CALL print(
      "$!  terminate all servers                                                             "),
      row + 1,
      CALL print(
      "$!  -----------------------                                                           "), row
       + 1,
      CALL print(
      '$  call echo2 "Terminate all servers"                                                 '), row
       + 1,
      CALL print(
      "$mcr cer_exe:cmbview -dom 'tgt_domain_name'                                           "),
      row + 1,
      CALL print(
      "kill -all                                                                             "), row
       + 1,
      CALL print(
      "exit                                                                                  "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   loop=0                                                                            "), row
       + 1,
      CALL print(
      "$   SRV_LOOP:                                                                         "), row
       + 1,
      CALL print(
      "$      if loop .ge. 20 then goto END_SRV_LOOP                                         "),
      row + 1,
      CALL print(
      "$      wait 00:00:15                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^),
      row + 1,
      CALL print(
      "$      gosub find_server                                                              "), row
       + 1,
      CALL print(
      "$      if srv_cnt .eq. 0 then goto END_SRV_LOOP                                       "), row
       + 1,
      CALL print(
      "$      goto SRV_LOOP                                                                  "),
      row + 1,
      CALL print(
      "$   END_SRV_LOOP:                                                                     "), row
       + 1,
      CALL print(
      "$      if srv_cnt .ne. 0                                                              "), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      "$         gosub kill_server                                                           "), row
       + 1,
      CALL print(
      "$      else                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "All servers are terminated by kill all."                        '),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!  ---------------                                                                   "), row
       + 1,
      CALL print(
      "$!  clean up memory                                                                   "),
      row + 1,
      CALL print(
      "$!  ---------------                                                                   "), row
       + 1,
      CALL print(
      '$   call echo1 "Execute terminate_cmb"                                                '), row
       + 1,
      CALL print(
      "$@cer_proc:terminate_cmb 'tgt_domain_name' 0 y n                                      "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Search for server instance"                                           '), row
       + 1,
      CALL print(
      '$   cmb_instance = "not_found"                                                        '),
      row + 1,
      CALL print(
      '$   cmb_instance = f$trnlnm("cmb_instance")                                           '), row
       + 1,
      CALL print(
      '$   if (cmb_instance .eqs. "not_found") .or. (cmb_instance .eqs. "")                  '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "cmb_instance is not defined."                                      '), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*_'cmb_instance'/out='tgt_tmp_full_dir'srv_proc.dat         "), row
       + 1,
      CALL print(
      "$   proc_cnt = 0                                                                      "),
      row + 1,
      CALL print(
      "$   open/read/error=CHECK_SRV_PROC SRV_PROC_DAT 'tgt_tmp_full_dir'srv_proc.dat        "), row
       + 1,
      CALL print(
      "$   open/write SRV_PROC_COM 'tgt_tmp_full_dir'srv_proc.com                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$   READ_SRV_PROC:                                                                    "), row
       + 1,
      CALL print(
      "$      read/end_of_file=END_READ_SRV_PROC SRV_PROC_DAT record                         "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "),
      row + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^),
      row + 1,
      CALL print(
      '$      if char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '),
      row + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            proc_cnt = proc_cnt + 1                                                  "), row
       + 1,
      CALL print(
      "$            proc_id'proc_cnt = f$extract(0, end_pos, record)                         "),
      row + 1,
      CALL print(
      "$            tmp_proc_id = proc_id'proc_cnt                                           "), row
       + 1,
      CALL print(
      "$!           write sys$output tmp_proc_id                                             "), row
       + 1,
      CALL print(
      ^$            write SRV_PROC_COM "stop process/id=''tmp_proc_id'"                      ^),
      row + 1,
      CALL print(
      "$         endif !end_pos                                                              "), row
       + 1,
      CALL print(
      "$      endif !char_type                                                               "), row
       + 1,
      CALL print(
      "$!     write sys$output record                                                        "),
      row + 1,
      CALL print(
      "$      goto READ_SRV_PROC                                                             "), row
       + 1,
      CALL print(
      "$   CHECK_SRV_PROC:                                                                   "), row
       + 1,
      CALL print(
      "$      srv_err_msg = f$message($status)                                               "),
      row + 1,
      CALL print(
      ^$      call echo2 "Error opening file ''tgt_tmp_full_dir'srv_proc.dat"                ^), row
       + 1,
      CALL print(
      "$      call echo2 'srv_err_msg'                                                       "), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "),
      row + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   END_READ_SRV_PROC:                                                                "), row
       + 1,
      CALL print(
      "$      close SRV_PROC_DAT                                                             "),
      row + 1,
      CALL print(
      "$      close SRV_PROC_COM                                                             "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if proc_cnt .gt. 0                                                                "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Stop server proccess."                                             '), row
       + 1,
      CALL print(
      "$@'tgt_tmp_full_dir'srv_proc.com                                                      "),
      row + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "No server process found."                                          '), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Execute delete_cmb_gs.com"                                            '), row
       + 1,
      CALL print(
      '$   if f$search("cer_proc:delete_cmb_gs.com") .nes. ""                                '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      @cer_proc:delete_cmb_gs 'tgt_domain_name'                                      "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Delete the audit and code cache"                                      '), row
       + 1,
      CALL print(
      "$mcr cer_exe:auditconf -destroy                                                       "),
      row + 1,
      CALL print(
      "$mcr cer_exe:code -destroy                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   lreg_result = "not_found"                                                         '),
      row + 1,
      CALL print(
      "$   set noon                                                                          "), row
       + 1,
      CALL print(
      "$   define/user_mode sys$error nl:                                                    "), row
       + 1,
      CALL print(
      '$   mcr cer_exe:lreg -getp \environment\common "wh_changed"                           '),
      row + 1,
      CALL print(
      "$   set on                                                                            "), row
       + 1,
      CALL print(
      '$   if f$edit(lreg_result, "upcase") .eqs. "Y"                                        '), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      "$      common_new_prop_fnd = 1                                                        "), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Note: "unable to get property" is an acceptable error"              '),
      row + 1,
      CALL print(
      "$      common_new_prop_fnd = 0                                                        "), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      ^$   call echo1 "common_new_prop_fnd = ''common_new_prop_fnd'"                         ^),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if common_new_prop_fnd .eq. 0 then goto WH_CHANGE_NOT_FND                         "), row
       + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "),
      row + 1,
      CALL print(
      "$!  common warehouse changed.  Cycle controller, domain dir and resolver              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "), row
       + 1,
      CALL print(
      "$   WH_CHANGE_FND:                                                                    "),
      row + 1,
      CALL print(
      '$      call echo2 "Common new property found.  Cycle controller,domain directory and resolver"'
      ), row + 1,
      CALL print(
      "$mcr cer_mgr_exe:start_cerner_500 -env common -verbose -noinst                        "), row
       + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "),
      row + 1,
      CALL print(
      "$      gosub STARTUP_CTRL_DDIR_RES                                                    "), row
       + 1,
      CALL print(
      "$      gosub CYCLE_REG                                                                "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      '$      call echo2 "Remove wh_changed property for common"                             '), row
       + 1,
      CALL print(
      "$      set noon                                                                       "), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -delp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      '$      lreg_result = "not_found"                                                      '), row
       + 1,
      CALL print(
      "$      define/user_mode sys$error nl:                                                 "),
      row + 1,
      CALL print(
      '$      mcr cer_exe:lreg -getp \environment\common "wh_changed"                        '), row
       + 1,
      CALL print(
      "$      set on                                                                         "), row
       + 1,
      CALL print(
      '$      common_new_prop = f$edit(lreg_result, "upcase")                                '),
      row + 1,
      CALL print(
      '$      if common_new_prop .eqs. "Y"                                                   '), row
       + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to delete property wh_changed for common."               '),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$!  ---------------------------------------------------------------------             "), row
       + 1,
      CALL print(
      "$!  target warehouse only.  Shutdown controller, domain dir and resolver              "), row
       + 1,
      CALL print(
      "$!  --------------------------------------------------------------------              "),
      row + 1,
      CALL print(
      "$   WH_CHANGE_NOT_FND:                                                                "), row
       + 1,
      CALL print(
      "$   if tgt_wh_only .eq. 1                                                             "), row
       + 1,
      CALL print(
      "$   then                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Target warehouse only.  Shutdown controller, domain dir and resolver."'),
      row + 1,
      CALL print(
      "$      gosub SHUTDOWN_CTRL_DDIR_RES                                                   "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$!  ---------------------------------------                                           "), row
       + 1,
      CALL print(
      "$!  de-install target warehouse from memory                                           "), row
       + 1,
      CALL print(
      "$!  ---------------------------------------                                           "),
      row + 1,
      CALL print(
      "$      mcr cer_mgr_exe:shutdown_cerner_500 -deinstall 'tgt_wh'                        "), row
       + 1,
      CALL print(
      "$EXIT_SCRIPT:                                                                         "), row
       + 1,
      CALL print(
      "$   if error .eq. 1                                                                   "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "dm2_target_shutdown.com completed with error."                      '), row
       + 1,
      CALL print(
      "$      close LOGFILE                                                                  "),
      row + 1,
      CALL print(
      "$      exit 2                                                                         "), row
       + 1,
      CALL print(
      "$   else                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "dm2_target_shutdown.com completed successfully."                    '),
      row + 1,
      CALL print(
      "$      close LOGFILE                                                                  "), row
       + 1,
      CALL print(
      "$      exit 1                                                                         "), row
       + 1,
      CALL print(
      "$   endif                                                                             "),
      row + 1,
      CALL print(
      "$EXIT_ERROR:                                                                          "), row
       + 1,
      CALL print(
      '$   call echo2 "dm2_target_shutdown was terminated."                                   '), row
       + 1,
      CALL print(
      "$   close LOGFILE                                                                     "),
      row + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$EXIT_CRITICAL:                                                                       "),
      row + 1,
      CALL print(
      '$   call echo3 "dm2_target_shutdown.com completed with error."                        '), row
       + 1,
      CALL print(
      "$   exit 2                                                                            "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!----------------------                                                              "), row
       + 1,
      CALL print(
      "$!subroutine definition                                                               "), row
       + 1,
      CALL print(
      "$!----------------------                                                              "),
      row + 1,
      CALL print(
      "$!------------------------------------                                                "), row
       + 1,
      CALL print(
      "$! subroutine:                                                                        "), row
       + 1,
      CALL print(
      "$!      echo1 - echo to log file                                                      "),
      row + 1,
      CALL print(
      "$!      echo2 - echo to log file & screen                                             "), row
       + 1,
      CALL print(
      "$!-----------------------------------                                                 "), row
       + 1,
      CALL print(
      "$ECHO1:                                                                               "),
      row + 1,
      CALL print(
      "$SUBROUTINE                                                                           "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "), row
       + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO2:                                                                               "), row
       + 1,
      CALL print(
      "$SUBROUTINE                                                                           "),
      row + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$   write logfile p1                                                                  "), row
       + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$ECHO3:                                                                               "), row
       + 1,
      CALL print(
      "$SUBROUTINE                                                                           "),
      row + 1,
      CALL print(
      "$   write sys$output p1                                                               "), row
       + 1,
      CALL print(
      "$ENDSUBROUTINE                                                                        "), row
       + 1,
      CALL print(
      "$!                                                                                    "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$KILL_SERVER:                                                                         "), row
       + 1,
      CALL print(
      "$   count = 0                                                                         "),
      row + 1, dcssf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'server_cmd.com") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_cmd.com;*"),
      CALL print(dcssf_line),
      row + 1,
      CALL print(
      "$   open/write SERVER_CMD 'tgt_tmp_full_dir'server_cmd.com                            "), row
       + 1,
      CALL print(
      ^$   write SERVER_CMD "$mcr cer_exe:cmbview -dom ''tgt_domain_name'"                   ^), row
       + 1,
      CALL print(
      "$   LOOP:                                                                             "),
      row + 1,
      CALL print(
      "$      count = count + 1                                                              "), row
       + 1,
      CALL print(
      "$      if count .le. srv_cnt                                                          "), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      "$         tmp_inst = srv_inst'count                                                   "), row
       + 1,
      CALL print(
      ^$         write SERVER_CMD "kill ''tmp_inst'"                                         ^), row
       + 1,
      CALL print(
      "$         delete/symbol srv_inst'count                                                "),
      row + 1,
      CALL print(
      "$         goto LOOP                                                                   "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      '$   write SERVER_CMD "exit"                                                           '),
      row + 1,
      CALL print(
      "$   close SERVER_CMD                                                                  "), row
       + 1,
      CALL print(
      "$   @server_cmd.com                                                                   "), row
       + 1,
      CALL print(
      "$   gosub FIND_SERVER                                                                 "),
      row + 1,
      CALL print(
      "$   if srv_cnt .ne. 0                                                                 "), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Failed to terminate all servers."                                  '),
      row + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      goto EXIT_SCRIPT                                                               "), row
       + 1,
      CALL print(
      "$   else                                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "All servers are terminated."                                       '), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$FIND_SERVER:                                                                         "), row
       + 1, dcssf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'server_list.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'server_list.dat;*"),
      CALL print(dcssf_line), row + 1,
      CALL print(
      "$   define/user_mode sys$output 'tgt_tmp_full_dir'server_list.dat                     "),
      row + 1,
      CALL print(
      "$mcr cer_exe:cmbview -dom 'tgt_domain_name'                                           "), row
       + 1,
      CALL print(
      "server                                                                                "), row
       + 1,
      CALL print(
      "exit                                                                                  "),
      row + 1,
      CALL print(
      "$   srv_cnt = 0                                                                       "), row
       + 1,
      CALL print(
      "$   open/read SERVER_LIST 'tgt_tmp_full_dir'server_list.dat                           "), row
       + 1,
      CALL print(
      "$   READ_SERVER_LIST:                                                                 "),
      row + 1,
      CALL print(
      "$      read/end_of_file=END_READ_SERVER_LIST SERVER_LIST record                       "), row
       + 1,
      CALL print(
      "$      end_pos = 0                                                                    "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "),
      row + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "), row
       + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^), row
       + 1,
      CALL print(
      '$      if char_type .eqs. "INTEGER"                                                   '),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         end_pos = f$locate(" ", record)                                             '), row
       + 1,
      CALL print(
      "$         length = f$length(record)                                                   "),
      row + 1,
      CALL print(
      ^$!        write sys$output "end_pos = ''end_pos'"                                     ^), row
       + 1,
      CALL print(
      "$         if (end_pos .gt. 0) .and. (end_pos .ne. length)                             "), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      "$            srv_cnt = srv_cnt + 1                                                    "), row
       + 1,
      CALL print(
      "$            srv_inst'srv_cnt = f$extract(0, end_pos, record)                         "), row
       + 1,
      CALL print(
      "$            write sys$output srv_inst'srv_cnt                                        "),
      row + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!     write sys$output record                                                        "),
      row + 1,
      CALL print(
      "$      goto READ_SERVER_LIST                                                          "), row
       + 1,
      CALL print(
      "$   END_READ_SERVER_LIST:                                                             "), row
       + 1,
      CALL print(
      "$      close SERVER_LIST                                                              "),
      row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$CYCLE_REG:                                                                           "),
      row + 1,
      CALL print(
      '$   call echo2 "Stop Registry"                                                        '), row
       + 1,
      CALL print(
      "$   @cer_mgr:stop_registry.com                                                        "), row
       + 1,
      CALL print(
      "$                                                                                     "),
      row + 1,
      CALL print(
      '$   CONTEXT = ""                                                                      '), row
       + 1,
      CALL print(
      "$   kill_reg_proc_loop:                                                               "), row
       + 1,
      CALL print(
      "$   PID = F$PID(CONTEXT)                                                              "),
      row + 1,
      CALL print(
      '$   if PID .eqs. ""                                                                   '), row
       + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      "$      goto kill_reg_proc_exit                                                        "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      '$   PNAME = F$GETJPI(PID,"PRCNAM")                                                    '), row
       + 1,
      CALL print(
      '$   if pname .EQS. "REGISTRY_SERVER"                                                  '),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$     write sys$output "* Killing process " + pname + "; process_id = " + pid         '), row
       + 1,
      CALL print(
      "$     stop  process/id='pid                                                           "),
      row + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$   goto kill_reg_proc_loop                                                           "), row
       + 1,
      CALL print(
      "$   kill_reg_proc_exit:                                                               "),
      row + 1,
      CALL print(
      '$      call echo2 "Registry has been stopped"                                         '), row
       + 1,
      dcssf_line = concat(^$      if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcssf_line), row + 1,
      CALL print("$      open/write REG_IND 'tgt_tmp_full_dir'stop_reg_ind.dat                 "),
      row + 1,
      CALL print(
      '$      write REG_IND "registry stopped"                                            '),
      row + 1,
      CALL print(
      "$      close REG_IND                                                               "), row + 1,
      CALL print(
      '$   call echo2 "Re-starting Registry"                                                 '), row
       + 1,
      CALL print(
      "$   @cer_mgr:start_registry.com                                                       "),
      row + 1, dcssf_line = concat(
       ^$   if f$search("''tgt_tmp_full_dir'stop_reg_ind.dat") .nes. "" then ^,
       "delete 'tgt_tmp_full_dir'stop_reg_ind.dat;*"),
      CALL print(dcssf_line),
      row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$STARTUP_CTRL_DDIR_RES:                                                               "),
      row + 1,
      CALL print(
      '$   call echo2 "Startup server controller."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ctrl                                                      "), row
       + 1,
      CALL print(
      "$   loop=0                                                                            "),
      row + 1,
      CALL print(
      "$   ctrl_fnd = 0                                                                      "), row
       + 1,
      CALL print(
      "$   CTRL_LOOP:                                                                        "), row
       + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_STARTUP_CTRL                                     "),
      row + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^),
      row + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'ctrl_proc.dat                  "), row
       + 1,
      CALL print(
      "$      open/read/error=CHECK_CTRL_PROC CTRL_PROC_DAT 'tgt_tmp_full_dir'ctrl_proc.dat  "), row
       + 1,
      CALL print(
      "$      READ_CTRL_PROC:                                                                "),
      row + 1,
      CALL print(
      "$         read/end_of_file=END_READ_CTRL_PROC CTRL_PROC_DAT record                    "), row
       + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "), row
       + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "),
      row + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^), row
       + 1,
      CALL print(
      '$         if char_type .eqs. "INTEGER"                                                '), row
       + 1,
      CALL print(
      "$         then                                                                        "),
      row + 1,
      CALL print(
      '$            ctrl_pos = f$locate("SERVER_CTRL", record)                               '), row
       + 1,
      CALL print(
      "$            length = f$length(record)                                                "), row
       + 1,
      CALL print(
      "$            if (ctrl_pos .gt. 0) .and. (ctrl_pos .ne. length)                        "),
      row + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      "$               ctrl_fnd = 1                                                          "), row
       + 1,
      CALL print(
      "$            endif                                                                    "),
      row + 1,
      CALL print(
      "$         endif !char_type                                                            "), row
       + 1,
      CALL print(
      "$!        write sys$output record                                                     "), row
       + 1,
      CALL print(
      "$         goto READ_CTRL_PROC                                                         "),
      row + 1,
      CALL print(
      "$      CHECK_CTRL_PROC:                                                               "), row
       + 1,
      CALL print(
      "$         ctrl_err_msg = f$message($status)                                           "), row
       + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'ctrl_proc.dat"            ^),
      row + 1,
      CALL print(
      "$         call echo2 'ctrl_err_msg'                                                   "), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      END_READ_CTRL_PROC:                                                            "), row
       + 1,
      CALL print(
      "$         close CTRL_PROC_DAT                                                         "), row
       + 1,
      CALL print(
      "$      if ctrl_fnd .ne. 0 then goto END_STARTUP_CTRL                                  "),
      row + 1,
      CALL print(
      "$      goto CTRL_LOOP                                                                 "), row
       + 1,
      CALL print(
      "$   END_STARTUP_CTRL:                                                                 "), row
       + 1,
      CALL print(
      "$      if ctrl_fnd .eq. 0                                                             "),
      row + 1,
      CALL print(
      "$      then                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Failed to startup server controller"                            '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "),
      row + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      else                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Startup server controller successfully."                        '),
      row + 1,
      CALL print(
      "$      endif                                                                          "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Startup domain directory."                                            '),
      row + 1,
      CALL print(
      "$   mcr cer_exe:cb_startup -ddir                                                      "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Startup domain resolver."                                          '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_startup -res                                                    "),
      row + 1,
      CALL print(
      "$      loop=0                                                                         "), row
       + 1,
      CALL print(
      "$      res_fnd = 0                                                                    "), row
       + 1,
      CALL print(
      "$      RES_LOOP:                                                                      "),
      row + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_STARTUP_RES                                   "), row
       + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "),
      row + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^), row
       + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         open/read/error=CHECK_RES_PROC RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat  "),
      row + 1,
      CALL print(
      "$         READ_RES_PROC:                                                              "), row
       + 1,
      CALL print(
      "$            read/end_of_file=END_READ_RES_PROC RES_PROC_DAT record                   "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "),
      row + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "), row
       + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            if char_type .eqs. "INTEGER"                                             '),
      row + 1,
      CALL print(
      "$            then                                                                     "), row
       + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "),
      row + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  res_fnd = 1                                                        "),
      row + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1,
      CALL print(
      "$            endif !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           write sys$output record                                                  "),
      row + 1,
      CALL print(
      "$            goto READ_RES_PROC                                                       "), row
       + 1,
      CALL print(
      "$         CHECK_RES_PROC:                                                             "), row
       + 1,
      CALL print(
      "$            res_err_msg = f$message($status)                                         "),
      row + 1,
      CALL print(
      ^$            call echo2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^), row
       + 1,
      CALL print(
      "$            call echo2 'res_err_msg'                                                 "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         END_READ_RES_PROC:                                                          "), row
       + 1,
      CALL print(
      "$            close RES_PROC_DAT                                                       "),
      row + 1,
      CALL print(
      "$         if res_fnd .ne. 0 then goto END_STARTUP_RES                                 "), row
       + 1,
      CALL print(
      "$         goto RES_LOOP                                                               "), row
       + 1,
      CALL print(
      "$       END_STARTUP_RES:                                                              "),
      row + 1,
      CALL print(
      "$         if res_fnd .eq. 0                                                           "), row
       + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to startup resolver"                                  '),
      row + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "),
      row + 1,
      CALL print(
      '$            call echo2 "Startup resolver successfully."                              '), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   endif !res_in_use                                                                 "),
      row + 1,
      CALL print(
      "$RETURN                                                                               "), row
       + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      "$SHUTDOWN_CTRL_DDIR_RES:                                                              "),
      row + 1,
      CALL print(
      '$   call echo2 "Shutdown server controller."                                          '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ctrl                                                     "), row
       + 1,
      CALL print(
      "$   loop=0                                                                            "),
      row + 1,
      CALL print(
      "$   shutdown_ctrl_fnd = 0                                                             "), row
       + 1,
      CALL print(
      "$   SHUTDOWN_CTRL_LOOP:                                                               "), row
       + 1,
      CALL print(
      "$      if loop .ge. 12 then goto END_SHUTDOWN_CTRL                                    "),
      row + 1,
      CALL print(
      "$      wait 00:00:05                                                                  "), row
       + 1,
      CALL print(
      "$      loop = loop + 1                                                                "), row
       + 1,
      CALL print(
      ^$      call echo1 "loop = ''loop'"                                                    ^),
      row + 1,
      CALL print(
      "$      pipe show sys/proc=*ctrl*/out='tgt_tmp_full_dir'shutdown_ctrl_proc.dat         "), row
       + 1,
      dcssf_line = concat("$      OPEN/READ/ERROR=CHECK_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT ",
       "'tgt_tmp_full_dir'shutdown_ctrl_proc.dat"),
      CALL print(dcssf_line), row + 1,
      CALL print(
      "$      READ_SHUTDOWN_CTRL_PROC:                                                       "), row
       + 1,
      CALL print(
      "$         READ/END_OF_FILE=END_READ_SHUTDOWN_CTRL_PROC SHUTDOWN_CTRL_PROC_DAT RECORD  "),
      row + 1,
      CALL print(
      "$         char = f$extract(0, 1, record)                                              "), row
       + 1,
      CALL print(
      "$         char_type = f$type(char)                                                    "), row
       + 1,
      CALL print(
      ^$!        write sys$output "char = ''char' type = ''char_type'"                       ^),
      row + 1,
      CALL print(
      '$         IF char_type .eqs. "INTEGER"                                                '), row
       + 1,
      CALL print(
      "$         THEN                                                                        "), row
       + 1,
      CALL print(
      '$            shutdown_ctrl_pos = f$locate("SERVER_CTRL", record)                      '),
      row + 1,
      CALL print(
      "$            length = f$length(record)                                                "), row
       + 1,
      CALL print(
      "$            if (shutdown_ctrl_pos .gt. 0) .and. (shutdown_ctrl_pos .ne. length)      "), row
       + 1,
      CALL print(
      "$            then                                                                     "),
      row + 1,
      CALL print(
      "$               shutdown_ctrl_fnd = 1                                                 "), row
       + 1,
      CALL print(
      "$            endif                                                                    "), row
       + 1,
      CALL print(
      "$         ENDIF !char_type                                                            "),
      row + 1,
      CALL print(
      "$!        WRITE SYS$OUTPUT RECORD                                                     "), row
       + 1,
      CALL print(
      "$         GOTO READ_SHUTDOWN_CTRL_PROC                                                "), row
       + 1,
      CALL print(
      "$      CHECK_SHUTDOWN_CTRL_PROC:                                                      "),
      row + 1,
      CALL print(
      "$         shutdown_ctrl_err_msg = F$MESSAGE($STATUS)                                  "), row
       + 1,
      CALL print(
      ^$         call echo2 "Error opening file ''tgt_tmp_full_dir'shutdown_ctrl_proc.dat"   ^), row
       + 1,
      CALL print(
      "$         call echo2 'shutdown_ctrl_err_msg'                                          "),
      row + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "), row
       + 1,
      CALL print(
      "$      END_READ_SHUTDOWN_CTRL_PROC:                                                   "),
      row + 1,
      CALL print(
      "$         close SHUTDOWN_CTRL_PROC_DAT                                                "), row
       + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .eq. 0 then goto END_SHUTDOWN_CTRL                        "), row
       + 1,
      CALL print(
      "$      goto SHUTDOWN_CTRL_LOOP                                                        "),
      row + 1,
      CALL print(
      "$   END_SHUTDOWN_CTRL:                                                                "), row
       + 1,
      CALL print(
      "$      if shutdown_ctrl_fnd .gt. 0                                                    "), row
       + 1,
      CALL print(
      "$      then                                                                           "),
      row + 1,
      CALL print(
      '$         call echo2 "Failed to shutdown server controller"                           '), row
       + 1,
      CALL print(
      "$         error = 1                                                                   "), row
       + 1,
      CALL print(
      "$         goto EXIT_SCRIPT                                                            "),
      row + 1,
      CALL print(
      "$      else                                                                           "), row
       + 1,
      CALL print(
      '$         call echo2 "Shutdown server controller successfully."                       '), row
       + 1,
      CALL print(
      "$      endif                                                                          "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Shutdown domain directory."                                           '), row
       + 1,
      CALL print(
      "$   mcr cer_exe:cb_shutdown -ddir                                                     "),
      row + 1,
      CALL print(
      "$!                                                                                    "), row
       + 1,
      CALL print(
      '$   call echo2 "Find domain resolver."                                                '), row
       + 1,
      CALL print(
      "$   pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'shutdown_res_proc.dat        "),
      row + 1,
      CALL print(
      "$   res_in_use = 0                                                                    "), row
       + 1,
      CALL print(
      "$   OPEN/READ/ERROR=CHECK_FIND_RES_PROC FIND_RES_PROC_DAT 'tgt_tmp_full_dir'shutdown_res_proc.dat"
      ), row + 1,
      CALL print(
      "$   READ_FIND_RES_PROC:                                                               "),
      row + 1,
      CALL print(
      "$      READ/END_OF_FILE=END_READ_FIND_RES_PROC FIND_RES_PROC_DAT RECORD               "), row
       + 1,
      CALL print(
      "$      char = f$extract(0, 1, record)                                                 "), row
       + 1,
      CALL print(
      "$      char_type = f$type(char)                                                       "),
      row + 1,
      CALL print(
      ^$!     write sys$output "char = ''char' type = ''char_type'"                          ^), row
       + 1,
      CALL print(
      '$      IF char_type .eqs. "INTEGER"                                                   '), row
       + 1,
      CALL print(
      "$      THEN                                                                           "),
      row + 1,
      CALL print(
      '$         res_pos = f$locate("SRV0000_01", record)                                    '), row
       + 1,
      CALL print(
      "$         length = f$length(record)                                                   "), row
       + 1,
      CALL print(
      "$         if (res_pos .gt. 0) .and. (res_pos .ne. length)                             "),
      row + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      "$            res_in_use = 1                                                           "), row
       + 1,
      CALL print(
      "$         endif                                                                       "),
      row + 1,
      CALL print(
      "$      ENDIF !char_type                                                               "), row
       + 1,
      CALL print(
      "$!     WRITE SYS$OUTPUT RECORD                                                        "), row
       + 1,
      CALL print(
      "$      GOTO READ_FIND_RES_PROC                                                        "),
      row + 1,
      CALL print(
      "$   CHECK_FIND_RES_PROC:                                                              "), row
       + 1,
      CALL print(
      "$      find_res_err_msg = F$MESSAGE($STATUS)                                          "), row
       + 1,
      CALL print(
      ^$      CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'shutdown_res_proc.dat"       ^),
      row + 1,
      CALL print(
      "$      CALL ECHO2 'find_res_err_msg'                                                  "), row
       + 1,
      CALL print(
      "$      error = 1                                                                      "), row
       + 1,
      CALL print(
      "$      GOTO EXIT_SCRIPT                                                               "),
      row + 1,
      CALL print(
      "$   END_READ_FIND_RES_PROC:                                                           "), row
       + 1,
      CALL print(
      "$      CLOSE FIND_RES_PROC_DAT                                                        "), row
       + 1,
      CALL print(
      "$   if res_in_use .gt. 0                                                              "),
      row + 1,
      CALL print(
      "$   then                                                                              "), row
       + 1,
      CALL print(
      '$      call echo2 "Shutdown domain resolver."                                         '), row
       + 1,
      CALL print(
      "$      mcr cer_exe:cb_shutdown -res                                                   "),
      row + 1,
      CALL print(
      "$      loop=0                                                                         "), row
       + 1,
      CALL print(
      "$      shutdown_res_fnd = 0                                                           "), row
       + 1,
      CALL print(
      "$      SHUTDOWN_RES_LOOP:                                                             "),
      row + 1,
      CALL print(
      "$         if loop .ge. 12 then goto END_SHUTDOWN_RES                                  "), row
       + 1,
      CALL print(
      "$         wait 00:00:05                                                               "), row
       + 1,
      CALL print(
      "$         loop = loop + 1                                                             "),
      row + 1,
      CALL print(
      ^$         call echo1 "loop = ''loop'"                                                 ^), row
       + 1,
      CALL print(
      "$         pipe show sys/proc=srv*0000_01/out='tgt_tmp_full_dir'res_proc.dat           "), row
       + 1,
      CALL print(
      "$         OPEN/READ/ERROR=CHECK_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT 'tgt_tmp_full_dir'res_proc.dat"
      ),
      row + 1,
      CALL print(
      "$         READ_SHUTDOWN_RES_PROC:                                                     "), row
       + 1,
      CALL print(
      "$            READ/END_OF_FILE=END_READ_SHUTDOWN_RES_PROC SHUTDOWN_RES_PROC_DAT RECORD "), row
       + 1,
      CALL print(
      "$            char = f$extract(0, 1, record)                                           "),
      row + 1,
      CALL print(
      "$            char_type = f$type(char)                                                 "), row
       + 1,
      CALL print(
      ^$!           write sys$output "char = ''char' type = ''char_type'"                    ^), row
       + 1,
      CALL print(
      '$            IF char_type .eqs. "INTEGER"                                             '),
      row + 1,
      CALL print(
      "$            THEN                                                                     "), row
       + 1,
      CALL print(
      '$               res_pos = f$locate("SRV0000_01", record)                              '), row
       + 1,
      CALL print(
      "$               length = f$length(record)                                             "),
      row + 1,
      CALL print(
      "$               if (res_pos .gt. 0) .and. (res_pos .ne. length)                       "), row
       + 1,
      CALL print(
      "$               then                                                                  "), row
       + 1,
      CALL print(
      "$                  shutdown_res_fnd = 1                                               "),
      row + 1,
      CALL print(
      "$               endif                                                                 "), row
       + 1,
      CALL print(
      "$            ENDIF !char_type                                                         "), row
       + 1,
      CALL print(
      "$!           WRITE SYS$OUTPUT RECORD                                                  "),
      row + 1,
      CALL print(
      "$            GOTO READ_SHUTDOWN_RES_PROC                                              "), row
       + 1,
      CALL print(
      "$         CHECK_SHUTDOWN_RES_PROC:                                                    "), row
       + 1,
      CALL print(
      "$            shutdown_res_err_msg = F$MESSAGE($STATUS)                                "),
      row + 1,
      CALL print(
      ^$            CALL ECHO2 "Error opening file ''tgt_tmp_full_dir'res_proc.dat"          ^), row
       + 1,
      CALL print(
      "$            CALL ECHO2 'shutdown_res_err_msg'                                        "), row
       + 1,
      CALL print(
      "$            error = 1                                                                "),
      row + 1,
      CALL print(
      "$            GOTO EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         END_READ_SHUTDOWN_RES_PROC:                                                 "), row
       + 1,
      CALL print(
      "$            CLOSE SHUTDOWN_RES_PROC_DAT                                              "),
      row + 1,
      CALL print(
      "$         IF shutdown_res_fnd .eq. 0 then goto END_SHUTDOWN_RES                       "), row
       + 1,
      CALL print(
      "$         goto SHUTDOWN_RES_LOOP                                                      "), row
       + 1,
      CALL print(
      "$      END_SHUTDOWN_RES:                                                              "),
      row + 1,
      CALL print(
      "$         if shutdown_res_fnd .gt. 0                                                  "), row
       + 1,
      CALL print(
      "$         then                                                                        "), row
       + 1,
      CALL print(
      '$            call echo2 "Failed to shutdown resolver"                                 '),
      row + 1,
      CALL print(
      "$            error = 1                                                                "), row
       + 1,
      CALL print(
      "$            goto EXIT_SCRIPT                                                         "), row
       + 1,
      CALL print(
      "$         else                                                                        "),
      row + 1,
      CALL print(
      '$            call echo2 "Shutdown resolver successfully."                             '), row
       + 1,
      CALL print(
      "$         endif                                                                       "), row
       + 1,
      CALL print(
      "$   else !res_in_use = 0                                                              "),
      row + 1,
      CALL print(
      '$      call echo2 "Resolver is not running"                                           '), row
       + 1,
      CALL print(
      "$   endif                                                                             "), row
       + 1,
      CALL print(
      "$RETURN                                                                               "),
      row + 1
     ELSE
      col 0, "#!/usr/bin/ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# dm2_target_shutdown.ksh", row + 1,
      col 0, "#", row + 1,
      col 0, "# Note:  Must be run as the root user", row + 1,
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "## Functions:",
      row + 1, col 0, "##	echo1 - Echo to Log File ",
      row + 1, col 0, "##	echo2 - Echo to Log File & Screen",
      row + 1, col 0, "##	echo3 - Echo to Screen",
      row + 1, col 0, "#------------------------------------",
      row + 1, col 0, "echo1()   #####  Echo to Log File only",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo2()   #####  Echo to Log File & Screen",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1,
       col 0, '   echo "$*" >> ${ScriptLog}', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1,
       col 0, '   echo -e "$*" >> ${ScriptLog}', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0, "echo3()   #####  Echo to Screen only",
      row + 1, col 0, "{",
      row + 1
      IF ((dm2_sys_misc->cur_os != "LNX"))
       col 0, '   echo "$*"', row + 1
      ELSE
       col 0, '   echo -e "$*"', row + 1
      ENDIF
      col 0, "}", row + 1,
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0,
      "##	cycle_common - start common env and cycle controller, domain dir and resolver",
      row + 1, col 0,
      "#--------------------------------------------------------------------------------",
      row + 1, col 0, "cycle_common()",
      row + 1, col 0, "{",
      row + 1, col 0, "$cer_mgr_exe/start_cerner_500 -env common -verbose -noinst",
      row + 1, row + 1, col 0,
      "if (( ${cb_cycle} == 1 ))", row + 1, col 0,
      "then", row + 1, col 0,
      "  $cer_exe/cb_shutdown -ctrl", row + 1, col 0,
      "  loop=0", row + 1, col 0,
      "  while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "    sleep 5", row + 1, col 0,
      "    ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcssf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcssf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcssf_line, row + 1,
      col 0, "    if [[ $? -ne 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Terminate server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "  #check if resolver exists", row + 1, col 0,
      "  ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "  if [[ $? -eq 0 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    resolver_exist=1", row + 1, col 0,
      "  else", row + 1, col 0,
      "    resolver_exist=0", row + 1, col 0,
      "  fi", row + 1, row + 1,
      col 0, "  if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "  then ", row + 1,
      col 0, "    $cer_exe/cb_shutdown -res", row + 1,
      col 0, "    loop=0", row + 1,
      col 0, "    while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "      sleep 5", row + 1,
      col 0, "      ((loop=loop+1))", row + 1,
      col 0, "      ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "      if [[ $? -ne 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         loop=100", row + 1,
      col 0, "      elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, '         echo2 "Terminate resolver failed."', row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      col 0, "    done", row + 1,
      col 0, "  fi", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ctrl",
      row + 1, col 0, "  loop=0",
      row + 1, col 0, "  while [[ $loop -lt 12 ]]; do",
      row + 1, col 0, "    sleep 5",
      row + 1, col 0, "    ((loop=loop+1))",
      row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcssf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcssf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcssf_line, row + 1,
      col 0, "    if [[ $? -eq 0 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, "      loop=100", row + 1,
      col 0, "    elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "    then", row + 1,
      col 0, '      echo2 "Start server controller failed."', row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "    fi", row + 1,
      col 0, "  done", row + 1,
      row + 1, col 0, "  $cer_exe/cb_startup -ddir",
      row + 1, row + 1, col 0,
      "  if [[ $resolver_exist -eq 1 ]]", row + 1, col 0,
      "  then", row + 1, col 0,
      "    $cer_exe/cb_startup -res", row + 1, col 0,
      "    loop=0", row + 1, col 0,
      "    while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "      sleep 5", row + 1, col 0,
      "      ((loop=loop+1))", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         loop=100", row + 1, col 0,
      "      elif [[ $loop -eq 12 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "Start resolver failed."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "    done", row + 1, col 0,
      "  fi", row + 1, col 0,
      "fi", row + 1, col 0,
      "}", row + 1, row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "## Function:", row + 1,
      col 0, "##	cycle_reg - stop and start registry", row + 1,
      col 0, "#--------------------------------------------------------------------------------", row
       + 1,
      col 0, "cycle_reg()", row + 1,
      col 0, "{", row + 1,
      col 0, "   $cer_mgr_exe/reg_server -stop", row + 1,
      dcssf_line = concat(
       "   ps -ef |grep reg_server |grep cerner |sed 's/\([ ]*[A-Za-z0-9_]*[ ]*\) \([0-9]*\) \([^`]*\)/\2/'",
       " > /tmp/dm2_qpid_dump.txt"), col 0, dcssf_line,
      row + 1, col 0, "   if [[ -s /tmp/dm2_qpid_dump.txt ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "       trgprocid=`head -n 1 /tmp/dm2_qpid_dump.txt`",
      row + 1, col 0, "       rm -f /tmp/dm2_qpid_dump.txt",
      row + 1, col 0, '       echo1 "Initiating a kill -9 $trgprocid"',
      row + 1, col 0, "       kill -9 $trgprocid",
      row + 1, col 0, "      sleep 2",
      row + 1, col 0, "   else",
      row + 1, col 0, '       echo1 "Reg Server has already stopped"',
      row + 1, col 0, "   fi",
      row + 1
      IF ((dm2_sys_misc->cur_os="AIX"))
       col 0, "   slibclean", row + 1
      ENDIF
      col 0, '   echo "registry stopped" >>$tgt_tmp_full_dir/stop_reg_ind.dat', row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, "   ##Start registry          ", row + 1,
      col 0, "   #------------------------", row + 1,
      col 0, '   echo2 "Start registry"', row + 1,
      col 0, "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1,
      col 0, "   if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "## Function:", row + 1, col 0,
      "##	version_adjust - Adjust the revision Level to compare.", row + 1, col 0,
      "#--------------------------------------------------------", row + 1, col 0,
      "revision_adjust()", row + 1, col 0,
      "{", row + 1, col 0,
      "   revision=$1", row + 1, col 0,
      "   rev_chk=`echo $revision|tr -d '[0-9]'|tr -d '.'`", row + 1, col 0,
      "   if [[ ${#rev_chk} -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, dcssf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. Revision level contains',
       ' unsupported characters [$rev_chk]."'),
      col 0, dcssf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   lvl=`echo $revision|tr -dc '.'|wc -c`", row + 1,
      col 0, "   rev1=0", row + 1,
      col 0, "   rev2=0", row + 1,
      col 0, "   rev3=0", row + 1,
      col 0, "   rev4=0", row + 1,
      col 0, '   rev1=`echo $revision | cut -f1 -d"."`', row + 1,
      col 0, "   if [[ ${#rev1} -ne 4 ]]", row + 1,
      col 0, "   then", row + 1,
      dcssf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported. First level [${rev1}] should',
       ' be 4 numeric integers (i.e. 2004, 2010, 2012)."'), col 0, dcssf_line,
      row + 1, col 0, "      exit 1",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   if [[ $lvl -gt 3 ]]",
      row + 1, col 0, "   then",
      row + 1, dcssf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision level contains',
       '  more than 4 levels."'), col 0,
      dcssf_line, row + 1, col 0,
      "      exit 1", row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 0 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev2=`echo $revision | cut -f2 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 1 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev3=`echo $revision | cut -f3 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ $lvl -gt 2 ]]", row + 1, col 0,
      "   then", row + 1, col 0,
      '      rev4=`echo $revision | cut -f4 -d"."`', row + 1, col 0,
      "   fi", row + 1, col 0,
      "   if [[ ${#rev2} -gt 4 || ${#rev3} -gt 4 || ${#rev4} -gt 4 ]]", row + 1, col 0,
      "   then", row + 1, dcssf_line = concat(
       '      echo2 "Revision level $revision for $wh is invalid/unsupported.  Revision minor levels should',
       ' be less than 5 numeric integers."'),
      col 0, dcssf_line, row + 1,
      col 0, "      exit 1", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   while [[ ${#rev1} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev1="0$rev1"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev2} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev2="0$rev2"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev3} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev3="0$rev3"', row + 1,
      col 0, "   done", row + 1,
      col 0, "   while [[ ${#rev4} -lt 4 ]]", row + 1,
      col 0, "   do", row + 1,
      col 0, '      rev4="0$rev4"', row + 1,
      col 0, "   done", row + 1,
      col 0, '   rev_lvl="$rev1$rev2$rev3$rev4" ', row + 1,
      col 0, "}", row + 1,
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "## Function:",
      row + 1, col 0, "##	get_server_ctrl - Determine if node level server control exists.",
      row + 1, col 0, "#--------------------------------------------------------",
      row + 1, col 0, "get_server_ctrl() ",
      row + 1, col 0, "{",
      row + 1, col 0, '   echo2 "Get node and domain level server control" ',
      row + 1, col 0, "   tgt_node=`hostname`",
      row + 1, col 0, '   echo2 "tgt_node : $tgt_node" ',
      row + 1, col 0,
      '   node_srvctrl=$($cer_exe/lreg -getp "\node\\${tgt_node}\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "   if (( $? == 0 ))",
      row + 1, col 0, "   then ",
      row + 1, col 0, "     node_srvctrl_fnd=1",
      row + 1, col 0, "   else ",
      row + 1, col 0, "     node_srvctrl_fnd=0 ",
      row + 1, col 0, "     cb_cycle=0 ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, "   if (( ${node_srvctrl_fnd} == 1 ))",
      row + 1, col 0, "   then  ",
      row + 1, col 0, "     #-----------------------------------------------  ",
      row + 1, col 0, "     ##Get ServerCtrl for all domains the node      ",
      row + 1, col 0, "     #----------------------------------------------- ",
      row + 1, col 0, '     echo2 "Get ServerCtrl for all domains the node." ',
      row + 1, col 0, "$cer_exe/lreg -enumk \\\\node\\\\${tgt_node}\\\\domain domain_list.dat  ",
      row + 1, col 0, "     domain_srvctrl_cnt=0 ",
      row + 1, col 0, "     domain_no_srvctrl_cnt=0",
      row + 1, col 0, "     while read domain ; do ",
      row + 1, col 0, "       echo2 ${domain}",
      row + 1, col 0,
      'dom_srvctrl=$($cer_exe/lreg -getp "\node\\$tgt_node\domain\\$domain\ServerCtrl" "ServerCtrlPath" 2>null)',
      row + 1, col 0, "       if (( $? == 0 ))",
      row + 1, col 0, "       then ",
      row + 1, col 0, "         (( domain_srvctrl_cnt=domain_srvctrl_cnt+1 ))",
      row + 1, col 0, "       else ",
      row + 1, col 0, "         (( domain_no_srvctrl_cnt=domain_no_srvctrl_cnt+1 ))",
      row + 1, col 0, "       fi ",
      row + 1, col 0, "     done < domain_list.dat ",
      row + 1, col 0, "     if (( ${domain_no_srvctrl_cnt} > 0 )) ",
      row + 1, col 0, "     then   ",
      row + 1, col 0, "       cb_cycle=1  ",
      row + 1, col 0, "     else ",
      row + 1, col 0, "cb_cycle=0 ",
      row + 1, col 0, "     fi ",
      row + 1, col 0, "   fi ",
      row + 1, col 0, '   echo2 "cb_cycle : $cb_cycle" ',
      row + 1, col 0, "}",
      row + 1, row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      "##Make sure the user is root.", row + 1, col 0,
      "#----------------------------", row + 1, col 0,
      'echo3 "Verify user is root."', row + 1, row + 1,
      col 0, 'if [[ `whoami` != "root" ]]', row + 1,
      col 0, "then", row + 1,
      col 0, 'echo " "', row + 1,
      col 0, 'echo3 "ERROR: Logon as root and run again."', row + 1,
      col 0, 'echo " "', row + 1,
      col 0, "exit 1", row + 1,
      col 0, "fi", row + 1,
      row + 1, col 0, "#--------------------",
      row + 1, col 0, "#Set Target variables",
      row + 1, col 0, "#--------------------",
      row + 1, col 0, 'echo3 "Set target variables."',
      row + 1, row + 1, dcssf_line = concat("tgt_domain_name=",ddr_domain_data->tgt_domain_name),
      col 0, dcssf_line, row + 1,
      dcssf_line = concat("tgt_env=",ddr_domain_data->tgt_env), col 0, dcssf_line,
      row + 1, dcssf_line = concat("tgt_env_lc=",cnvtlower(ddr_domain_data->tgt_env)), col 0,
      dcssf_line, row + 1, dcssf_line = concat("tgt_tmp_dir=",ddr_domain_data->tgt_tmp_dir),
      col 0, dcssf_line, row + 1,
      dcssf_line = concat("tgt_tmp_full_dir=",ddr_domain_data->tgt_tmp_full_dir), col 0, dcssf_line,
      row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       dcssf_line = concat("src_env=",cnvtlower(drrr_rf_data->src_env_name)), col 0, dcssf_line,
       row + 1, dcssf_line = concat('cd_rom_loc="/"'), col 0,
       dcssf_line, row + 1, dcssf_line = concat("common_to_tgt=",drrr_rf_data->common_to_tgt),
       col 0, dcssf_line, row + 1,
       dcssf_line = concat("tgt_top_dir=",drrr_rf_data->tgt_top_dir), col 0, dcssf_line,
       row + 1, dcssf_line = concat("tgt_cer_mgr_dir=",drrr_rf_data->tgt_cer_mgr_dir), col 0,
       dcssf_line, row + 1, dcssf_line = concat("tgt_cer_mgr_exe_dir=",drrr_rf_data->
        tgt_cer_mgr_exe_dir),
       col 0, dcssf_line, row + 1,
       dcssf_line = concat("tgt_cer_mgr_log_dir=",drrr_rf_data->tgt_cer_mgr_log_dir), col 0,
       dcssf_line,
       row + 1, dcssf_line = concat("tgt_cer_reg_dir=",drrr_rf_data->tgt_cer_reg_dir), col 0,
       dcssf_line, row + 1, dcssf_line = concat("tgt_cer_fifo_dir=",drrr_rf_data->tgt_cer_fifo_dir),
       col 0, dcssf_line, row + 1,
       dcssf_line = concat("tgt_cer_usock_dir=",drrr_rf_data->tgt_cer_usock_dir), col 0, dcssf_line,
       row + 1, dcssf_line = concat("tgt_cer_lock_dir=",drrr_rf_data->tgt_cer_lock_dir), col 0,
       dcssf_line, row + 1
      ENDIF
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, "##Verify in Target environment",
      row + 1, col 0, "#-----------------------------",
      row + 1, col 0, 'echo3 "Verify in Target environment."',
      row + 1, row + 1, col 0,
      "cur_env=$environment", row + 1, col 0,
      "typeset -l cur_env=$cur_env", row + 1, col 0,
      'if [[ $cur_env = "" ]]', row + 1, col 0,
      "then", row + 1, col 0,
      '  typeset -x environment="${tgt_env_lc}"', row + 1, col 0,
      "  cur_env=$environment", row + 1, col 0,
      "  typeset -l cur_env=$cur_env", row + 1, col 0,
      "fi", row + 1, col 0,
      "if [[ $tgt_env_lc != $cur_env ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      '  echo3 "ERROR: Set to Target environment $tgt_env_lc and run again."', row + 1, col 0,
      '  echo3 " "', row + 1, col 0,
      "  exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------", row + 1,
      col 0, "#Validate Target Temp Directory", row + 1,
      col 0, "#------------------------------", row + 1,
      row + 1, col 0, "if [[ ! -d $tgt_tmp_dir ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo3 "$tgt_tmp_dir not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ ! -d $tgt_tmp_full_dir ]]", row + 1, col 0,
      "then", row + 1, col 0,
      '   echo3 "$tgt_tmp_full_dir not found."', row + 1, col 0,
      "   exit 1", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "## Set up the Log File", row + 1,
      col 0, "#------------------------------------", row + 1,
      col 0, "ScriptLog=$tgt_tmp_full_dir/dm2_target_shutdown.log", row + 1,
      col 0, "[[ -f ${ScriptLog} ]] && rm ${ScriptLog}", row + 1,
      row + 1, col 0, 'echo1 "Begin dm2_target_shutdown.ksh"',
      row + 1, row + 1, dcssf_line = concat("tgt_wh=",ddr_domain_data->tgt_wh),
      col 0, dcssf_line, row + 1,
      dcssf_line = concat("tgt_wh_device=",ddr_domain_data->tgt_wh_device), col 0, dcssf_line,
      row + 1, col 0, "if [[ ! -d $tgt_wh_device ]]",
      row + 1, col 0, "then",
      row + 1, col 0, '   echo2 "$tgt_wh_device not found."',
      row + 1, col 0, "   exit 1",
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      "if [[ -s $tgt_tmp_full_dir/stop_reg_ind.dat ]]", row + 1, col 0,
      "then", row + 1, col 0,
      "   #------------------------", row + 1, col 0,
      "   ##Start registry          ", row + 1, col 0,
      "   #------------------------", row + 1, col 0,
      '   echo2 "Start registry"', row + 1, col 0,
      "   $cer_mgr_exe/reg_server -start $cer_reg/registry.cfg", row + 1, col 0,
      "   rm -f $tgt_tmp_full_dir/stop_reg_ind.dat", row + 1, col 0,
      "fi", row + 1, row + 1,
      col 0, "#---------------------------", row + 1,
      col 0, "##check if target wh exists ", row + 1,
      col 0, "#---------------------------", row + 1,
      col 0, ^file_cnt=`LANG=C ls -l $tgt_wh_device| grep total|awk -F" " '{print $2}'`^, row + 1,
      col 0, "if [[ $file_cnt != '0' ]]", row + 1,
      col 0, "then", row + 1,
      row + 1, col 0, "   #-----------------------------------------------",
      row + 1, col 0, "   ##Get warehouse for all environments on the node",
      row + 1, col 0, "   #-----------------------------------------------",
      row + 1, col 0, '   echo2 "Get all environments on the node."',
      row + 1, col 0, "$cer_exe/lregview <<!>env_list.dat",
      row + 1, col 0, "cd \environment",
      row + 1, col 0, "dir",
      row + 1, col 0, "exit",
      row + 1, col 0, "!",
      row + 1, row + 1, dcssf_line = "   env_list=$(grep '^\\' env_list.dat|",
      dcssf_line = concat(dcssf_line,^awk -F" " '{print $1}'|sed 's/\\//')^), col 0, dcssf_line,
      row + 1, col 0, "   echo1 $env_list",
      row + 1, col 0, '   echo "Warehouse List" > wh_list.dat',
      row + 1, row + 1, col 0,
      "   ind=0", row + 1, col 0,
      '   wh_array[0]="Warehouse list"', row + 1, col 0,
      "   for env in $env_list ; do", row + 1, col 0,
      "      echo1 $env", row + 1, row + 1,
      col 0, '      tmp_wh=$($cer_exe/lreg -getp "\Environment\\\\$env" "Warehouse1" 2>null)', row +
      1,
      col 0, "      echo1 $tmp_wh", row + 1,
      col 0, '      found="F"', row + 1,
      col 0, "      i=0", row + 1,
      col 0, '      echo1 "Array Size = "${#wh_array[@]}', row + 1,
      col 0, "      while [ $i -le ${#wh_array[@]} ]", row + 1,
      col 0, "      do", row + 1,
      col 0, "          if [[ $tmp_wh = ${wh_array[$i]} ]]", row + 1,
      col 0, "          then", row + 1,
      col 0, '             found="T"', row + 1,
      col 0, "          fi", row + 1,
      col 0, "          (( i=i+1 ))", row + 1,
      col 0, "      done", row + 1,
      col 0, "      ind=$ind+1", row + 1,
      col 0, "      wh_array[$ind]=$tmp_wh", row + 1,
      col 0, "      echo1 $found", row + 1,
      col 0, '      if [[ $found = "F" ]]', row + 1,
      col 0, "      then", row + 1,
      col 0, "         echo3 '\\'$tmp_wh' ' >> wh_list.dat", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0, "      if [[ $tmp_wh = $tgt_wh ]]",
      row + 1, col 0, "      then",
      row + 1, col 0, '         if [[  $env = "common" ]]',
      row + 1, col 0, "         then",
      row + 1, col 0, "            common_wh=${tmp_wh}",
      row + 1, col 0, '            echo1 "common_wh = $common_wh"',
      row + 1, row + 1, col 0,
      "            common_share_wh=1", row + 1, col 0,
      '            echo1 "common_share_wh = $common_share_wh"', row + 1, row + 1,
      col 0, '         elif [[ $env != "admin" && $env != $tgt_env ]]', row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Warehouse $tgt_wh is used for environment $env."', row + 1,
      col 0, '            echo2 "This process can not be used to refresh the domain."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      fi ", row + 1,
      col 0, "   done", row + 1,
      row + 1, col 0, "   #------------------------------",
      row + 1, col 0, "   ##Get all warehouse on the node",
      row + 1, col 0, "   #-------------------------------",
      row + 1, col 0, '   echo2 "Get all warehouses on the node."',
      row + 1, row + 1, dcssf_line = "   wh_list=$(grep '^\\' wh_list.dat|",
      dcssf_line = concat(dcssf_line,^awk -F" " '{print $1}'|sed 's/\\//')^), col 0, dcssf_line,
      row + 1, col 0, "   echo1 $wh_list",
      row + 1, row + 1, col 0,
      "   #------------------------------------------", row + 1, col 0,
      "   ##check if tgt_wh is the only wh on node", row + 1, col 0,
      "   #------------------------------------------", row + 1, col 0,
      '   echo1 "Check if tgt_wh is the only wh on node."', row + 1, row + 1,
      col 0, "   wh_cnt=0", row + 1,
      col 0, "   for wh in $wh_list ; do", row + 1,
      col 0, "      ((wh_cnt=wh_cnt+1))", row + 1,
      col 0, "   done", row + 1,
      col 0, "   echo1 wh_cnt=$wh_cnt", row + 1,
      row + 1, col 0, "   if [[ $wh_cnt -eq 1 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, "      tgt_wh_only=1",
      row + 1, col 0, "   else",
      row + 1, col 0, "      tgt_wh_only=0",
      row + 1, col 0, "   fi",
      row + 1, col 0, "   echo1 tgt_wh_only=$tgt_wh_only",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   ##Idenfity highest revision level for warehouses",
      row + 1, col 0, "   #------------------------------------------",
      row + 1, col 0, "   if [[ $tgt_wh_only -eq 0 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo1 "Identify the highest warehouse based on revision level."',
      row + 1, col 0, "      cur_highest_rev_lvl=0000",
      row + 1, col 0, '      cur_highest_wh="NONE"',
      row + 1, col 0, "      for wh in $wh_list ; do",
      row + 1, col 0, "         if [[ $wh != $tgt_wh ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '         tmp_rev_lvl=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "Revision Level" 2>null)',
      row + 1, col 0,
      '         tmp_rootpath=$($cer_exe/lreg -getp "\Warehouse\\\\$wh" "RootPath" 2>null)',
      row + 1, col 0, '         echo1 "tmp_rev_lvl="$tmp_rev_lvl',
      row + 1, col 0, '         echo1 "tmp_rootpath="$tmp_rootpath',
      row + 1, col 0, "         if [[  -d $tmp_rootpath  ]]",
      row + 1, col 0, "         then",
      row + 1, col 0,
      '            file_cnt=`find $tmp_rootpath -type f -print| grep "cb_server_ctrl"|wc -l`',
      row + 1, col 0, "            if [[ $file_cnt -eq 1 ]]",
      row + 1, col 0, "            then",
      row + 1, col 0, "               revision_adjust $tmp_rev_lvl",
      row + 1, col 0, "               bkp_rev_lvl=$rev_lvl",
      row + 1, col 0, "               revision_adjust $cur_highest_rev_lvl",
      row + 1, col 0, "               bkp_highest_rev_lvl=$rev_lvl",
      row + 1, col 0, "               if [[ $bkp_rev_lvl -gt $bkp_highest_rev_lvl ]]",
      row + 1, col 0, "               then",
      row + 1, col 0, "                  cur_highest_wh=$wh",
      row + 1, col 0, "                  cur_highest_rev_lvl=$tmp_rev_lvl",
      row + 1, col 0, "               fi",
      row + 1, col 0, "            fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "         fi",
      row + 1, col 0, "      done",
      row + 1, col 0, '      echo2 "cur_highest_wh="$cur_highest_wh',
      row + 1, col 0, '      echo2 "cur_highest_rev_lvl="$cur_highest_rev_lvl',
      row + 1, col 0, '      if [[ $cur_highest_wh = "NONE" || $cur_highest_rev_lvl = 0 ]]',
      row + 1, col 0, "      then",
      row + 1, col 0,
      '        echo2 "Unable to find a valid warehouse on current node other than target. Setting tgt_wh_only = 1."',
      row + 1, col 0, "        tgt_wh_only=1",
      row + 1, col 0, "      fi",
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "   #------------------------------------------------------------------------", row + 1, col 0,
      "   ##if common use tgt_wh and tgt wh is not the only wh, prompt to change wh", row + 1, col 0,
      "   #------------------------------------------------------------------------", row + 1, col 0,
      "   if [[  $common_share_wh -eq 1 && tgt_wh_only -eq 0 ]]", row + 1, col 0,
      "   then", row + 1
      IF (validate(drrr_responsefile_in_use,0)=1)
       col 0, "      common_new_wh=$cur_highest_wh", row + 1,
       col 0, '      change_common="c"', row + 1
      ELSE
       col 0, "      loop=1", row + 1,
       col 0, "      while [[ $loop -eq 1 ]]; do", row + 1,
       col 0, '         echo2 "Prompt to change common warehouse."', row + 1,
       row + 1, col 0, "         for wh in $wh_list ; do",
       row + 1, col 0, "            if [[ $wh != $tgt_wh ]]",
       row + 1, col 0, "            then",
       row + 1, col 0, "               echo2 $wh",
       row + 1, col 0, "            fi",
       row + 1, col 0, "         done",
       row + 1, row + 1, col 0,
       '         echo2 "Please choose a new warehouse for common from list above: \c"', row + 1, col
       0,
       "         read common_new_wh", row + 1, row + 1,
       col 0, "         for wh in $wh_list ; do", row + 1,
       col 0, "            if [[ $wh != $tgt_wh ]]", row + 1,
       col 0, "            then", row + 1,
       col 0, "               if [[ $wh = $common_new_wh ]]", row + 1,
       col 0, "               then", row + 1,
       col 0, "                  new_wh_fnd=1", row + 1,
       col 0, "               fi", row + 1,
       col 0, "            fi", row + 1,
       col 0, "         done", row + 1,
       row + 1, col 0, "         if [[  $new_wh_fnd -ne 1 ]]",
       row + 1, col 0, "         then",
       row + 1, col 0, '            echo2 "$common_new_wh is not in the warehouse list."',
       row + 1, col 0, "         else",
       row + 1, col 0, "            loop=0",
       row + 1, col 0, "         fi",
       row + 1, col 0, "      done",
       row + 1, row + 1, col 0,
       '      echo2 "Change common warehouse from $common_wh to $common_new_wh [C]ontinue or [Q]uit : \c"',
       row + 1, col 0,
       "      read change_common", row + 1
      ENDIF
      row + 1, col 0, "      if [[ $change_common = 'C' || $change_common = 'c' ]]",
      row + 1, col 0, "      then",
      row + 1, row + 1, col 0,
      '         $cer_exe/lreg -setp "\environment\common" "wh_changed" "Y"', row + 1, col 0,
      '         common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed")', row + 1,
      col 0,
      "         if [[ $common_new_prop != 'Y' ]]", row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Failed to add new property wh_changed for common."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, row + 1,
      col 0, '         $cer_exe/lreg -setp "\environment\common" "common_wh_switched" "Y"', row + 1,
      col 0,
      '         common_switched_prop=$($cer_exe/lreg -getp "\environment\common" "common_wh_switched")',
      row + 1,
      col 0, "         if [[ $common_switched_prop != 'Y' ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Failed to add new property common_wh_switched for common."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      row + 1, col 0,
      '         $cer_exe/lreg -setp "\environment\common" "warehouse1" "$common_new_wh"',
      row + 1, col 0,
      '         common_changed_wh=$($cer_exe/lreg -getp "\environment\common" "warehouse1")',
      row + 1, row + 1, col 0,
      "         if [[ $common_changed_wh != $common_new_wh ]]", row + 1, col 0,
      "         then", row + 1, col 0,
      '            echo2 "Failed to change common warehouse to $common_new_wh."', row + 1, col 0,
      "            exit 1", row + 1, col 0,
      "         fi", row + 1, col 0,
      "      else", row + 1, col 0,
      '         echo2 "User choose to quit when modifying common warehouse."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "   #-----------------",
      row + 1, col 0, "   ##Stop all servers",
      row + 1, col 0, "   #-----------------",
      row + 1, col 0, '   echo2 "Terminate servers."',
      row + 1, row + 1, col 0,
      "   test -e $cer_exe/server_ctrl", row + 1, col 0,
      "   if (( $? == 0 ))", row + 1, col 0,
      "   then", row + 1, col 0,
      '     srv_cmd="$cer_exe/scpview -dom"', row + 1, col 0,
      "   else", row + 1, col 0,
      '     srv_cmd="$cer_exe/cmbview -dom"', row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "$srv_cmd $tgt_domain_name <<!", row + 1,
      col 0, "kill -all", row + 1,
      col 0, "exit", row + 1,
      col 0, "!", row + 1,
      row + 1, col 0, "   loop=0",
      row + 1, col 0, "   while [[ $loop -lt 20 ]]; do",
      row + 1, col 0, "      sleep 15",
      row + 1, col 0, "      ((loop=loop+1))",
      row + 1, col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat",
      row + 1, col 0, "server",
      row + 1, col 0, "exit",
      row + 1, col 0, "!",
      row + 1, row + 1, dcssf_line = "      server_list=$(grep '^[0-9]' server_list.dat|",
      dcssf_line = concat(dcssf_line,^awk -F" " '{print $1}')^), col 0, dcssf_line,
      row + 1, row + 1, col 0,
      "      if [[ -z $server_list ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "All servers are terminated with -all."', row + 1, col 0,
      "         loop=100", row + 1, col 0,
      "      fi", row + 1, col 0,
      "   done", row + 1, row + 1,
      col 0, "   if [[ ! -z $server_list ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      if [[ -f server_cmd.dat ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, "         rm server_cmd.dat", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0, "      for server_inst in $server_list ; do",
      row + 1, col 0, '         echo "kill $server_inst" >>server_cmd.dat',
      row + 1, col 0, "      done",
      row + 1, row + 1, col 0,
      '      echo "exit" >>server_cmd.dat ', row + 1, row + 1,
      col 0, "$srv_cmd $tgt_domain_name<server_cmd.dat", row + 1,
      row + 1, col 0, "#must start in the beginning of the line, othewise will error",
      row + 1, col 0, "$srv_cmd $tgt_domain_name <<!>server_list.dat",
      row + 1, col 0, "server",
      row + 1, col 0, "exit",
      row + 1, col 0, "!",
      row + 1, row + 1, dcssf_line = "      server_list=$(grep '^[0-9]' server_list.dat|",
      dcssf_line = concat(dcssf_line,^awk -F" " '{print $1}')^), col 0, dcssf_line,
      row + 1, row + 1, col 0,
      "      if [[ -z $server_list ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      '         echo2 "All servers are terminated."', row + 1, col 0,
      "      else", row + 1, col 0,
      '         echo2 "servers can not be terminated."', row + 1, col 0,
      "         exit 1", row + 1, col 0,
      "      fi", row + 1, col 0,
      "   fi", row + 1, row + 1,
      col 0, "   #--------------------------------", row + 1,
      col 0, "   ##Clean-up the CMB Global Section ", row + 1,
      col 0, "   #---------------------------------", row + 1,
      col 0, '   echo2 "Clean up cmb global section."', row + 1,
      row + 1, col 0, "   $cer_proc/terminate_cmb.ksh $tgt_domain_name 0 Y N",
      row + 1, col 0, "   if [[ -f $cer_proc/delete_cmb_gs.ksh ]]",
      row + 1, col 0, "   then",
      row + 1, col 0, '         echo "Y" | $cer_proc/delete_cmb_gs.ksh $tgt_domain_name ',
      row + 1, col 0, "   fi",
      row + 1, row + 1, col 0,
      "   #--------------------------------", row + 1, col 0,
      "   ##Delete the audit and code cache ", row + 1, col 0,
      "   #--------------------------------", row + 1, col 0,
      '   echo2 "Delete audit and code cache."', row + 1, row + 1,
      col 0, "   $cer_exe/auditconf -destroy", row + 1,
      col 0, "   code -destroy", row + 1,
      row + 1, col 0, "   #------------------------------------",
      row + 1, col 0, "   ##destroy the que_stat global section ",
      row + 1, col 0,
      '   ##(Note:  "que_stat: unable to destroy memory manager [OS error 2424]" is an ignorable error):',
      row + 1, col 0, "   #------------------------------------",
      row + 1, col 0, '   echo2 "Destroy the que_stat global section."',
      row + 1, row + 1, col 0,
      "   $cer_exe/gmm -destroy que_stat", row + 1, row + 1,
      col 0, "   get_server_ctrl", row + 1,
      row + 1, col 0, "   #----------------------------------------",
      row + 1, col 0, "   ##check for wh_changed property on common",
      row + 1, col 0, "   #----------------------------------------",
      row + 1, col 0, '   echo2 "Check for wh_changed property on common."',
      row + 1, row + 1, col 0,
      '   common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed" 2>null)', row + 1,
      row + 1,
      col 0, "   if [[ $common_new_prop = 'Y' ]]", row + 1,
      col 0, "   then", row + 1,
      col 0, "      common_new_prop_fnd=1 ", row + 1,
      col 0, "   else", row + 1,
      col 0, '   echo2 "Note: "unable to get property" is an acceptable error"', row + 1,
      col 0, "      common_new_prop_fnd=0 ", row + 1,
      col 0, "   fi", row + 1,
      col 0, "   echo1 common_new_prop_fnd = $common_new_prop_fnd", row + 1,
      row + 1, col 0,
      "   #------------------------------------------------------------------------------",
      row + 1, col 0,
      "   ##Cycle server controller, domain directory, resolver if common new prop found ",
      row + 1, col 0,
      "   #------------------------------------------------------------------------------",
      row + 1, col 0, "   if [[ $common_new_prop_fnd -eq 1 ]]",
      row + 1, col 0, "   then",
      row + 1, col 0,
      '      echo2 "common new property found.  Cycle server controller, domain directory and resolver."',
      row + 1, row + 1, col 0,
      "      cycle_common", row + 1, col 0,
      "      cycle_reg", row + 1, col 0,
      "      #remove common new prop", row + 1, col 0,
      ^      echo1 "Remove common's new property."^, row + 1, col 0,
      '      $cer_exe/lreg -delp "\environment\common" "wh_changed" ', row + 1, row + 1,
      col 0, '      common_new_prop=$($cer_exe/lreg -getp "\environment\common" "wh_changed" 2>null)',
      row + 1,
      col 0, "      if [[ $? -eq 0 ]]", row + 1,
      col 0, "      then", row + 1,
      col 0, ^         echo2 "New property 'wh_changed' failed to be removed."^, row + 1,
      col 0, "         exit 1", row + 1,
      col 0, "      fi", row + 1,
      row + 1, col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1, col 0,
      "   ##Terminate server controller, domain directory, resolver if target wh is the only warehouse on node",
      row + 1, col 0,
      "   #---------------------------------------------------------------------------------------------------",
      row + 1, col 0, "   elif (( $tgt_wh_only == 1 && ${cb_cycle} == 1 ))",
      row + 1, col 0, "   then",
      row + 1, col 0, '      echo2 "$tgt_wh is the only warehouse on the node."',
      row + 1, col 0, '      echo2 "Terminate server controller, domain directory and resolver."',
      row + 1, row + 1, col 0,
      "      $cer_exe/cb_shutdown -ctrl", row + 1, col 0,
      "      loop=0", row + 1, col 0,
      "      while [[ $loop -lt 12 ]]; do", row + 1, col 0,
      "         sleep 5", row + 1, col 0,
      "         ((loop=loop+1))", row + 1
      IF ((dm2_sys_misc->cur_os="HPX"))
       dcssf_line =
       "      UNIX95= ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ELSE
       dcssf_line = "      ps -Ao vsz,pid,user,group,args | grep cb_server_ctrl | grep -v grep"
      ENDIF
      col 0, dcssf_line, row + 1,
      col 0, "         if [[ $? -ne 0 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, "            loop=100", row + 1,
      col 0, "         elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "         then", row + 1,
      col 0, '            echo2 "Terminate server controller failed."', row + 1,
      col 0, "            exit 1", row + 1,
      col 0, "         fi", row + 1,
      col 0, "      done", row + 1,
      row + 1, col 0, "      $cer_exe/cb_shutdown -ddir",
      row + 1, row + 1, col 0,
      "      #check if resolver exists", row + 1, col 0,
      "      ps -ef | grep cb_resolver | grep -v grep", row + 1, col 0,
      "      if [[ $? -eq 0 ]]", row + 1, col 0,
      "      then", row + 1, col 0,
      "         resolver_exist=1", row + 1, col 0,
      "      else", row + 1, col 0,
      "         resolver_exist=0", row + 1, col 0,
      "      fi", row + 1, row + 1,
      col 0, "      if [[ $resolver_exist -eq 1 ]]", row + 1,
      col 0, "      then ", row + 1,
      col 0, "         $cer_exe/cb_shutdown -res", row + 1,
      col 0, "         loop=0", row + 1,
      col 0, "         while [[ $loop -lt 12 ]]; do", row + 1,
      col 0, "            sleep 5", row + 1,
      col 0, "            ((loop=loop+1))", row + 1,
      col 0, "            ps -ef | grep cb_resolver | grep -v grep", row + 1,
      col 0, "            if [[ $? -ne 0 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, "               loop=100", row + 1,
      col 0, "            elif [[ $loop -eq 12 ]]", row + 1,
      col 0, "            then", row + 1,
      col 0, '               echo2 "Terminate resolver failed."', row + 1,
      col 0, "               exit 1", row + 1,
      col 0, "            fi", row + 1,
      col 0, "         done", row + 1,
      col 0, "      fi", row + 1,
      col 0, "   fi", row + 1,
      row + 1, col 0, "fi",
      row + 1, row + 1, col 0,
      'echo2 "dm2_target_shutdown.ksh executed successfully."', row + 1, row + 1
     ENDIF
    WITH nocounter, format = variable, formfeed = none,
     maxrow = 1, maxcol = 512
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm2_sys_misc->cur_os="AXP"))
    SET dcssf_line = concat("set file/prot=(s:rwed,o:rwed,g:rwed,w:rwed) ",dcssf_file_name)
   ELSE
    SET dcssf_line = concat("chmod 777 ",dcssf_file_name)
   ENDIF
   IF (dm2_push_dcl(dcssf_line)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 IF (validate(der_expimp_data->tgt_oracle_home,"x")="x"
  AND validate(der_expimp_data->tgt_oracle_home,"y")="y")
  FREE RECORD der_expimp_data
  RECORD der_expimp_data(
    1 src_ftp_user = vc
    1 src_ftp_pass = vc
    1 src_sys_pass = vc
    1 tgt_sys_pass = vc
    1 tgt_ftp_user = vc
    1 tgt_ftp_pass = vc
    1 tgt_db_os = vc
    1 src_db_os = vc
    1 tgt_dbname = vc
    1 tgt_oracle_home = vc
    1 tgt_temp_dir = vc
    1 src_temp_dir = vc
    1 src_ftp_tested_ind = i2
    1 tgt_ftp_tested_ind = i2
    1 src_db_node = vc
    1 tgt_db_node = vc
    1 max_runners = f8
    1 max_runners_fnd = i2
    1 setup_complete_ind = f8
    1 cleanup_complete_ind = f8
    1 op_type = vc
    1 run_id = i4
    1 priority = f8
    1 schema_date = vc
    1 total_cnt = i4
    1 complete_cnt = i4
    1 left_cnt = i4
    1 running_cnt = i4
    1 failed_cnt = i4
    1 suspended_cnt = i4
    1 preserve_from_begin = i2
    1 ignorable_error_ind = i2
    1 temp_timestamp = dq8
    1 temp_cnt = i4
    1 dp_node_type = vc
    1 tgt_app_temp_dir = vc
  )
  SET der_expimp_data->tgt_dbname = "DM2NOTSET"
  SET der_expimp_data->tgt_oracle_home = ""
  SET der_expimp_data->tgt_temp_dir = ""
  SET der_expimp_data->max_runners = 0
  SET der_expimp_data->max_runners_fnd = 0
  SET der_expimp_data->setup_complete_ind = 0
  SET der_expimp_data->cleanup_complete_ind = 0
  SET der_expimp_data->op_type = "DM2NOTSET"
  SET der_expimp_data->run_id = 0
  SET der_expimp_data->priority = 0
  SET der_expimp_data->schema_date = "DM2NOTSET"
  SET der_expimp_data->total_cnt = 0
  SET der_expimp_data->complete_cnt = 0
  SET der_expimp_data->left_cnt = 0
  SET der_expimp_data->running_cnt = 0
  SET der_expimp_data->failed_cnt = 0
  SET der_expimp_data->suspended_cnt = 0
  SET der_expimp_data->preserve_from_begin = 0
  SET der_expimp_data->ignorable_error_ind = 0
  SET der_expimp_data->temp_timestamp = cnvtdatetime("01-JAN-1900 00:00:00")
  SET der_expimp_data->temp_cnt = 0
  SET der_expimp_data->dp_node_type = "DM2NOTSET"
  SET der_expimp_data->tgt_app_temp_dir = ""
 ENDIF
 DECLARE der_determine_expimp_mode(ddem_mode=i2(ref)) = i2
 DECLARE der_dir_prompt(null) = i2
 DECLARE der_get_cnts(dgc_priority=i4) = i2
 DECLARE der_process_expimp_screen(dpes_display_only=i2,dpes_priority=i4) = i2
 DECLARE der_manage_admin_data(dmad_dbname=vc,dmad_admin_tbl=vc,dmad_mode=vc,dmad_data_name=vc,
  dmad_data_value=vc) = i2
 DECLARE der_sync_dir_obj(null) = i2
 DECLARE der_create_dirs(null) = i2
 DECLARE der_drop_dirs(null) = i2
 DECLARE der_val_dbms_cloud(dvdc_src_ind=i2) = i2
 DECLARE der_compile_oos_pkg(dcop_src_ind=i2) = i2
 SUBROUTINE der_determine_expimp_mode(ddem_mode)
  IF ((((dm2_sys_misc->cur_db_os="AXP")) OR ((validate(dm2_force_old_expimp_method,- (1)) != - (1))
  )) )
   SET ddem_mode = 0
  ELSE
   SET ddem_mode = 1
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE der_dir_prompt(null)
   DECLARE depd_str = vc WITH protect, noconstant("")
   DECLARE depd_ftp_tested_ind = i2 WITH protect, noconstant(0)
   DECLARE depd_temp_dir_found_ind = i2 WITH protect, noconstant(0)
   DECLARE depd_row = i2 WITH protect, noconstant(0)
   DECLARE depd_sys_cnct_valid_ind = i2 WITH protect, noconstant(0)
   DECLARE depd_cclversion = i4 WITH protect, noconstant(0)
   SET depd_cclversion = (((cnvtint(currev) * 1000000)+ (cnvtint(currevminor) * 1000))+ cnvtint(
    currevminor2))
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Getting target host_name from v$instance."
   SELECT INTO "nl:"
    FROM v$instance vi
    DETAIL
     der_expimp_data->tgt_db_node = vi.host_name
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) > 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   SET dm_err->eproc = "Display Export/Import Files Prompts."
   CALL disp_msg("",dm_err->logfile,0)
   SET width = 132
   IF ((dm_err->debug_flag != 722))
    SET message = window
   ENDIF
   CALL clear(1,1)
   CALL box(1,1,24,131)
   SET depd_row = 1
   CALL text(1,2,"Directory Location Prompts")
   SET dm2ftpr->user_name = "oracle"
   SET dm2ftpr->user_pwd = "oracle"
   SET der_expimp_data->tgt_ftp_user = dm2ftpr->user_name
   SET der_expimp_data->tgt_ftp_pass = dm2ftpr->user_pwd
   SET der_expimp_data->src_ftp_user = dm2ftpr->user_name
   SET der_expimp_data->src_ftp_pass = dm2ftpr->user_pwd
   SET depd_row = (depd_row+ 2)
   IF (cnvtupper(curnode) != cnvtupper(der_expimp_data->tgt_db_node)
    AND (dm2_sys_misc->cur_os != "AXP"))
    WHILE ((der_expimp_data->tgt_ftp_tested_ind=0))
      IF ((der_expimp_data->tgt_ftp_tested_ind=0))
       SET dm2ftpr->remote_host = der_expimp_data->tgt_db_node
       SET dm2ftpr->options = "-b"
       IF (dfr_test_connect(null)=0)
        SET dm_err->err_ind = 0
        CALL text((depd_row+ 2),2,concat("Failed FTP connection. Error Message:",substring(1,50,
           dm2ftpr->errline_full)))
        CALL text((depd_row+ 3),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
        CALL accept((depd_row+ 3),50,"P;CU"," "
         WHERE curaccept IN ("C", "Q"))
        IF (curaccept="C")
         CALL clear((depd_row+ 2),2,129)
         CALL clear((depd_row+ 3),2,129)
        ELSE
         RETURN(0)
        ENDIF
       ELSE
        CALL clear((depd_row+ 2),2,129)
        CALL clear((depd_row+ 3),2,129)
        SET der_expimp_data->tgt_ftp_tested_ind = 1
       ENDIF
      ENDIF
    ENDWHILE
    SET depd_row = (depd_row+ 3)
   ENDIF
   IF (cnvtupper(curnode) != cnvtupper(der_expimp_data->src_db_node)
    AND (dm2_sys_misc->cur_os != "AXP")
    AND (dm2_rdbms_version->level1 >= 11))
    WHILE ((der_expimp_data->src_ftp_tested_ind=0))
      IF ((der_expimp_data->src_ftp_tested_ind=0))
       SET dm2ftpr->remote_host = der_expimp_data->src_db_node
       SET dm2ftpr->options = "-b"
       IF (dfr_test_connect(null)=0)
        SET dm_err->err_ind = 0
        CALL text((depd_row+ 2),2,concat("Failed FTP connection. Error Message:",substring(1,50,
           dm2ftpr->errline_full)))
        CALL text((depd_row+ 3),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
        CALL accept((depd_row+ 3),50,"P;CU"," "
         WHERE curaccept IN ("C", "Q"))
        IF (curaccept="C")
         CALL clear((depd_row+ 2),2,129)
         CALL clear((depd_row+ 3),2,129)
        ELSE
         RETURN(0)
        ENDIF
       ELSE
        CALL clear((depd_row+ 2),2,129)
        CALL clear((depd_row+ 3),2,129)
        SET der_expimp_data->src_ftp_tested_ind = 1
       ENDIF
      ENDIF
    ENDWHILE
    SET depd_row = (depd_row+ 3)
   ENDIF
   IF ((dm2_rdbms_version->level1 >= 11)
    AND (dm2_sys_misc->cur_os != "AXP"))
    WHILE (depd_sys_cnct_valid_ind=0)
      SET depd_str = concat("Password for SYS user on Target database ",der_expimp_data->tgt_dbname,
       ":")
      CALL text(depd_row,2,depd_str)
      CALL accept(depd_row,(size(depd_str)+ 3),"P(30);c"," "
       WHERE curaccept > " ")
      SET der_expimp_data->tgt_sys_pass = curaccept
      SET dm_err->eproc = "Verify Target SYS password."
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      CALL dm2_push_cmd("free define oraclesystem go",1)
      IF (depd_cclversion < 8012003)
       SET depd_str = concat("define oraclesystem 'SYS/",der_expimp_data->tgt_sys_pass,"@",
        dm2_install_schema->v500_connect_str,"' go")
      ELSE
       SET depd_str = concat("define oraclesystem 'SYS/",der_expimp_data->tgt_sys_pass,"@",
        dm2_install_schema->v500_connect_str,"' with sysdba go")
      ENDIF
      IF (dm2_push_cmd(depd_str,1)=0)
       SET dm_err->err_ind = 0
       CALL box(1,1,24,131)
       CALL text(1,2,"Directory Location Prompts")
       IF (findstring("ORA-",dm_err->emsg,1,1) > 0)
        CALL text((depd_row+ 1),2,concat("Failed SYS login. Error Message:",substring(findstring(
            "ORA-",dm_err->emsg,1,1),50,dm_err->emsg)))
       ELSE
        CALL text((depd_row+ 1),2,concat("Failed SYS login. Error Message:",substring(1,50,dm_err->
           emsg)))
       ENDIF
       CALL text((depd_row+ 2),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
       CALL accept((depd_row+ 2),50,"P;CU"," "
        WHERE curaccept IN ("C", "Q"))
       IF (curaccept="C")
        CALL clear((depd_row+ 1),2,129)
        CALL clear((depd_row+ 2),2,129)
       ELSE
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->eproc =
       "Re-Connect to Target after successful Source SYS user validation and directory creation."
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg("",dm_err->logfile,0)
       ENDIF
       CALL dm2_push_cmd("free define oraclesystem go",1)
       SET depd_str = concat("define oraclesystem 'V500/",dm2_install_schema->v500_p_word,"@",
        dm2_install_schema->v500_connect_str,"' go")
       IF (dm2_push_cmd(depd_str,1)=0)
        RETURN(0)
       ENDIF
       SET depd_sys_cnct_valid_ind = 1
      ENDIF
    ENDWHILE
    SET depd_row = (depd_row+ 1)
    SET depd_sys_cnct_valid_ind = 0
    SET depd_sys_cnct_valid_ind = 0
    WHILE (depd_sys_cnct_valid_ind=0)
      SET depd_str = concat("Password for SYS user on Source database ",dm2_install_schema->
       src_dbase_name,":")
      CALL text(depd_row,2,depd_str)
      CALL accept(depd_row,(size(depd_str)+ 3),"P(30);c"," "
       WHERE curaccept > " ")
      SET der_expimp_data->src_sys_pass = curaccept
      SET dm_err->eproc = "Verify Source SYS password."
      IF ((dm_err->debug_flag > 0))
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
      CALL dm2_push_cmd("free define oraclesystem go",1)
      IF (depd_cclversion < 8012003)
       SET depd_str = concat("define oraclesystem 'SYS/",der_expimp_data->src_sys_pass,"@",
        dm2_install_schema->src_v500_connect_str,"' go")
      ELSE
       SET depd_str = concat("define oraclesystem 'SYS/",der_expimp_data->src_sys_pass,"@",
        dm2_install_schema->src_v500_connect_str,"' with sysdba go")
      ENDIF
      IF (dm2_push_cmd(depd_str,1)=0)
       SET dm_err->err_ind = 0
       CALL box(1,1,24,131)
       CALL text(1,2,"Directory Location Prompts")
       IF (findstring("ORA-",dm_err->emsg,1,1) > 0)
        CALL text((depd_row+ 1),2,concat("Failed SYS login. Error Message:",substring(findstring(
            "ORA-",dm_err->emsg,1,1),50,dm_err->emsg)))
       ELSE
        CALL text((depd_row+ 1),2,concat("Failed SYS login. Error Message:",substring(1,50,dm_err->
           emsg)))
       ENDIF
       CALL text((depd_row+ 2),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
       CALL accept((depd_row+ 2),50,"P;CU"," "
        WHERE curaccept IN ("C", "Q"))
       IF (curaccept="C")
        CALL clear((depd_row+ 1),2,129)
        CALL clear((depd_row+ 2),2,129)
       ELSE
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->eproc =
       "Re-Connect to Target after successful Source SYS user validation and directory creation."
       IF ((dm_err->debug_flag > 0))
        CALL disp_msg("",dm_err->logfile,0)
       ENDIF
       CALL dm2_push_cmd("free define oraclesystem go",1)
       SET depd_str = concat("define oraclesystem 'V500/",dm2_install_schema->v500_p_word,"@",
        dm2_install_schema->v500_connect_str,"' go")
       IF (dm2_push_cmd(depd_str,1)=0)
        RETURN(0)
       ENDIF
       SET depd_sys_cnct_valid_ind = 1
      ENDIF
    ENDWHILE
    SET depd_row = (depd_row+ 2)
   ENDIF
   SET depd_temp_dir_found_ind = 0
   SET dm2ftpr->remote_host = der_expimp_data->tgt_db_node
   SET dm2ftpr->options = "-b"
   WHILE (depd_temp_dir_found_ind=0)
     CALL text(depd_row,2,concat("Target Database Node ",cnvtupper(der_expimp_data->tgt_db_node),
       " Temporary Directory Location"))
     CALL text((depd_row+ 1),4,"(Export/Import commands will execute from this directory.)")
     CALL text((depd_row+ 2),10,": ")
     CALL accept((depd_row+ 2),12,"P(70);C",der_expimp_data->tgt_temp_dir
      WHERE  NOT (curaccept=" "))
     SET der_expimp_data->tgt_temp_dir = trim(curaccept)
     IF (substring(size(der_expimp_data->tgt_temp_dir),1,der_expimp_data->tgt_temp_dir)="/")
      SET der_expimp_data->tgt_temp_dir = replace(der_expimp_data->tgt_temp_dir,"/","",2)
     ENDIF
     IF ((dm_err->debug_flag > 721))
      CALL echorecord(der_expimp_data)
     ENDIF
     IF ((der_expimp_data->tgt_ftp_tested_ind=1))
      SET dm2ftpr->dir_name = der_expimp_data->tgt_temp_dir
      IF (dfr_find_directory(null)=0)
       RETURN(0)
      ENDIF
      IF ((dm2ftpr->exists_ind=0))
       CALL text((depd_row+ 3),2,concat(
         "Failed to find Target Temporary Directory. Please verify directory exists before continuing."
         ))
       CALL text((depd_row+ 4),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
       CALL accept((depd_row+ 4),50,"P;CU"," "
        WHERE curaccept IN ("C", "Q"))
       IF (curaccept="C")
        CALL clear((depd_row+ 3),2,129)
        CALL clear((depd_row+ 4),2,129)
       ELSE
        RETURN(0)
       ENDIF
      ELSE
       SET depd_temp_dir_found_ind = 1
      ENDIF
      IF (depd_temp_dir_found_ind=1)
       SET dm2ftpr->dir_name = concat(der_expimp_data->tgt_temp_dir,"/",cnvtlower(der_expimp_data->
         tgt_dbname),"_exp")
       IF (dfr_find_directory(null)=0)
        RETURN(0)
       ENDIF
       IF ((dm2ftpr->exists_ind=0))
        IF (dfr_create_directory(null)=0)
         SET message = nowindow
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ENDIF
      ENDIF
     ELSE
      IF ((dm2_sys_misc->cur_os="AXP"))
       SET depd_temp_dir_found_ind = 1
      ELSEIF (cnvtupper(curnode)=cnvtupper(der_expimp_data->tgt_db_node))
       SET depd_temp_dir_found_ind = dm2_find_dir(der_expimp_data->tgt_temp_dir)
       IF ((dm_err->err_ind > 0))
        RETURN(0)
       ENDIF
       IF (depd_temp_dir_found_ind=0)
        CALL text((depd_row+ 3),2,concat(
          "Failed to find Target Temporary Directory. Please verify directory exists before continuing."
          ))
        CALL text((depd_row+ 4),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
        CALL accept((depd_row+ 4),50,"P;CU"," "
         WHERE curaccept IN ("C", "Q"))
        IF (curaccept="C")
         CALL clear((depd_row+ 3),2,129)
         CALL clear((depd_row+ 4),2,129)
        ELSE
         RETURN(0)
        ENDIF
       ELSE
        SET depd_temp_dir_found_ind = dm2_find_dir(concat(der_expimp_data->tgt_temp_dir,"/",cnvtlower
          (der_expimp_data->tgt_dbname),"_exp"))
        IF ((dm_err->err_ind > 0))
         RETURN(0)
        ENDIF
        IF (depd_temp_dir_found_ind=0)
         IF (dm2_push_dcl(concat("mkdir ",concat(der_expimp_data->tgt_temp_dir,"/",cnvtlower(
             der_expimp_data->tgt_dbname),"_exp")))=0)
          RETURN(0)
         ELSE
          IF (dm2_push_dcl(concat("chmod 777 ",concat(der_expimp_data->tgt_temp_dir,"/",cnvtlower(
              der_expimp_data->tgt_dbname),"_exp")))=0)
           RETURN(0)
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
   ENDWHILE
   SET depd_row = (depd_row+ 4)
   IF ((dm2_rdbms_version->level1 >= 11)
    AND (dm2_sys_misc->cur_os != "AXP"))
    SET dm2ftpr->remote_host = der_expimp_data->src_db_node
    SET dm2ftpr->options = "-b"
    SET depd_temp_dir_found_ind = 0
    WHILE (depd_temp_dir_found_ind=0)
      CALL text(depd_row,2,concat("Source Database Node ",cnvtupper(der_expimp_data->src_db_node),
        " Temporary Directory Location"))
      CALL text((depd_row+ 1),4,"(Export/Import commands will execute from this directory.)")
      CALL text((depd_row+ 2),10,": ")
      CALL accept((depd_row+ 2),12,"P(70);C",der_expimp_data->src_temp_dir
       WHERE  NOT (curaccept=" "))
      SET der_expimp_data->src_temp_dir = trim(curaccept)
      IF (substring(size(der_expimp_data->src_temp_dir),1,der_expimp_data->src_temp_dir)="/")
       SET der_expimp_data->src_temp_dir = replace(der_expimp_data->src_temp_dir,"/","",2)
      ENDIF
      IF ((dm_err->debug_flag > 721))
       CALL echorecord(der_expimp_data)
      ENDIF
      IF ((der_expimp_data->src_ftp_tested_ind=1))
       SET dm2ftpr->dir_name = der_expimp_data->src_temp_dir
       IF (dfr_find_directory(null)=0)
        RETURN(0)
       ENDIF
       IF ((dm2ftpr->exists_ind=0))
        CALL text((depd_row+ 3),2,concat(
          "Failed to find Source Temporary Directory. Please verify directory exists before continuing."
          ))
        CALL text((depd_row+ 4),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
        CALL accept((depd_row+ 4),50,"P;CU"," "
         WHERE curaccept IN ("C", "Q"))
        IF (curaccept="C")
         CALL clear((depd_row+ 3),2,129)
         CALL clear((depd_row+ 4),2,129)
        ELSE
         RETURN(0)
        ENDIF
       ELSE
        SET depd_temp_dir_found_ind = 1
       ENDIF
       IF (depd_temp_dir_found_ind=1)
        SET dm2ftpr->dir_name = concat(der_expimp_data->src_temp_dir,"/",cnvtlower(der_expimp_data->
          tgt_dbname),"_exp")
        IF (dfr_find_directory(null)=0)
         RETURN(0)
        ENDIF
        IF ((dm2ftpr->exists_ind=0))
         IF (dfr_create_directory(null)=0)
          SET message = nowindow
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
        ENDIF
       ENDIF
      ELSE
       IF ((dm2_sys_misc->cur_os="AXP"))
        SET depd_temp_dir_found_ind = 1
       ELSEIF (cnvtupper(curnode)=cnvtupper(der_expimp_data->src_db_node))
        SET depd_temp_dir_found_ind = dm2_find_dir(der_expimp_data->src_temp_dir)
        IF ((dm_err->err_ind > 0))
         RETURN(0)
        ENDIF
        IF (depd_temp_dir_found_ind=0)
         CALL text((depd_row+ 3),2,concat(
           "Failed to find Source Temporary Directory. Please verify directory exists before continuing."
           ))
         CALL text((depd_row+ 4),2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
         CALL accept((depd_row+ 4),50,"P;CU"," "
          WHERE curaccept IN ("C", "Q"))
         IF (curaccept="C")
          CALL clear((depd_row+ 3),2,129)
          CALL clear((depd_row+ 4),2,129)
         ELSE
          RETURN(0)
         ENDIF
        ELSE
         SET depd_temp_dir_found_ind = dm2_find_dir(concat(der_expimp_data->src_temp_dir,"/",
           cnvtlower(der_expimp_data->tgt_dbname),"_exp"))
         IF ((dm_err->err_ind > 0))
          RETURN(0)
         ENDIF
         IF (depd_temp_dir_found_ind=0)
          IF (dm2_push_dcl(concat("mkdir ",concat(der_expimp_data->src_temp_dir,"/",cnvtlower(
              der_expimp_data->tgt_dbname),"_exp")))=0)
           RETURN(0)
          ELSE
           IF (dm2_push_dcl(concat("chmod 777 ",concat(der_expimp_data->src_temp_dir,"/",cnvtlower(
               der_expimp_data->tgt_dbname),"_exp")))=0)
            RETURN(0)
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
    ENDWHILE
    SET depd_row = (depd_row+ 4)
   ENDIF
   IF (der_create_dirs(null)=0)
    RETURN(0)
   ENDIF
   CALL text(depd_row,2,concat("Oracle Home for Oracle ",dm2_rdbms_version->version,
     " Target Database on node ",cnvtupper(der_expimp_data->tgt_db_node)))
   CALL text((depd_row+ 1),10,": ")
   CALL accept((depd_row+ 1),12,"P(70);C",der_expimp_data->tgt_oracle_home
    WHERE  NOT (curaccept=" "))
   SET der_expimp_data->tgt_oracle_home = trim(curaccept)
   IF (substring(size(der_expimp_data->tgt_oracle_home),1,der_expimp_data->tgt_oracle_home)="/")
    SET der_expimp_data->tgt_oracle_home = replace(der_expimp_data->tgt_oracle_home,"/","",2)
   ENDIF
   SET depd_row = (depd_row+ 3)
   SET depd_row = (depd_row+ 1)
   IF ((dm2_rdbms_version->level1 >= 11))
    CALL echo("Oracle 11 specific routines")
   ENDIF
   CALL text(23,2,"Enter 'C' to continue or 'Q' to quit (C or Q): ")
   CALL accept(23,50,"P;CU"," "
    WHERE curaccept IN ("C", "Q"))
   SET message = nowindow
   IF (curaccept="Q")
    RETURN(0)
   ELSE
    CALL clear(1,1)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_create_dirs(null)
   DECLARE dcd_tmp_str = vc WITH protect, noconstant("")
   DECLARE dcd_cclversion = i4 WITH protect, noconstant(0)
   DECLARE dcd_src_dir_setup = i2 WITH protect, noconstant(1)
   DECLARE dcd_src_v500_priv_cnt = i2 WITH protect, noconstant(0)
   DECLARE dcd_src_cloud_priv_cnt = i2 WITH protect, noconstant(0)
   SET dcd_cclversion = (((cnvtint(currev) * 1000000)+ (cnvtint(currevminor) * 1000))+ cnvtint(
    currevminor2))
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_rdbms_version->level1 >= 11)
    AND (dm2_sys_misc->cur_os != "AXP"))
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm_err->eproc = "Connect to Source as V500 to check for Oracle directory."
     CALL disp_msg("",dm_err->logfile,0)
     CALL dm2_push_cmd("free define oraclesystem go",1)
     SET dcd_tmp_str = concat("define oraclesystem 'V500/",drrr_rf_data->src_db_user_pwd,"@",
      dm2_install_schema->src_v500_connect_str,"' go")
     IF (dm2_push_cmd(dcd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Query from dba_directories to check if Oracle directory is created."
     CALL disp_msg(" ",dm_err->logfile,0)
     SELECT
      IF ((drrr_rf_data->src_db_deploy_config IN ("OP", "OCI")))
       WHERE (cnvtupper(directory_name)=drrr_rf_data->src_dp_dir_name)
        AND (directory_path=drrr_rf_data->src_dp_dir_path)
      ELSEIF ((drrr_rf_data->src_db_deploy_config="ADB"))
       WHERE (cnvtupper(directory_name)=drrr_rf_data->src_dp_dir_name)
        AND parser(concat("directory_path = '*/data/",drrr_rf_data->src_dp_dir_path,"'"))
      ELSE
      ENDIF
      INTO "nl:"
      FROM dba_directories
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc) > 0)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (curqual > 0)
      SET dm_err->eproc = "Query dba_tab_privs to check V500 privilege on Source directory."
      CALL disp_msg(" ",dm_err->logfile,0)
      SELECT INTO "nl:"
       FROM dba_tab_privs t
       WHERE t.owner="SYS"
        AND (cnvtupper(t.table_name)=drrr_rf_data->src_dp_dir_name)
        AND t.grantee="V500"
        AND t.privilege IN ("READ", "WRITE")
       DETAIL
        dcd_src_v500_priv_cnt = (dcd_src_v500_priv_cnt+ 1)
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc) > 0)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
      IF ((drrr_rf_data->src_db_deploy_config IN ("OCI", "ADB")))
       SET dm_err->eproc =
       "Query dba_tab_privs to check C##CLOUD$SERVICE privilege on Source directory."
       CALL disp_msg(" ",dm_err->logfile,0)
       SELECT INTO "nl:"
        FROM dba_tab_privs t
        WHERE t.owner="SYS"
         AND (cnvtupper(t.table_name)=drrr_rf_data->src_dp_dir_name)
         AND t.grantee="C##CLOUD$SERVICE"
         AND t.privilege IN ("READ", "WRITE")
        DETAIL
         dcd_src_cloud_priv_cnt = (dcd_src_cloud_priv_cnt+ 1)
        WITH nocounter
       ;end select
       IF (check_error(dm_err->eproc) > 0)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
      IF ((((drrr_rf_data->src_db_deploy_config="OP")
       AND dcd_src_v500_priv_cnt=2) OR ((drrr_rf_data->src_db_deploy_config IN ("OCI", "ADB"))
       AND dcd_src_v500_priv_cnt=2
       AND dcd_src_cloud_priv_cnt=2)) )
       SET dm_err->eproc = concat("Oracle directory ",drrr_rf_data->src_dp_dir_name,
        " does exist under required directory path.")
       CALL disp_msg(" ",dm_err->logfile,0)
       SET dcd_src_dir_setup = 0
      ENDIF
     ENDIF
     IF ((drrr_rf_data->src_dp_dir_setup="NO"))
      IF (dcd_src_dir_setup=1)
       SET dm_err->err_ind = 1
       SET dm_err->eproc = "Verify Oracle directory used by Datapump export/import utilities."
       SET dm_err->emsg = concat("Oracle directory does not exist or permissions not set.",
        "  Response file preventing setup so need to configure manually.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
    IF (dcd_src_dir_setup=1)
     CALL dm2_push_cmd("free define oraclesystem go",1)
     IF (dcd_cclversion < 8012003)
      SET dcd_tmp_str = concat("define oraclesystem 'SYS/",der_expimp_data->src_sys_pass,"@",
       dm2_install_schema->src_v500_connect_str,"' go")
     ELSEIF (validate(drrr_responsefile_in_use,0)=1)
      IF ((drrr_rf_data->src_db_deploy_config="ADB"))
       SET dcd_tmp_str = concat("define oraclesystem '",drrr_rf_data->src_sys_user,"/",
        der_expimp_data->src_sys_pass,"@",
        dm2_install_schema->src_v500_connect_str,"' go")
      ELSE
       SET dcd_tmp_str = concat("define oraclesystem '",drrr_rf_data->src_sys_user,"/",
        der_expimp_data->src_sys_pass,"@",
        dm2_install_schema->src_v500_connect_str,"' with sysdba go")
      ENDIF
     ELSE
      SET dcd_tmp_str = concat("define oraclesystem 'SYS/",der_expimp_data->src_sys_pass,"@",
       dm2_install_schema->src_v500_connect_str,"' with sysdba go")
     ENDIF
     IF (dm2_push_cmd(dcd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
     SET dm_err->eproc = "Create Source Oracle directory."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SET dcd_tmp_str = concat("rdb create or replace directory ",der_expimp_data->tgt_dbname,
      "_EXPORT_IMPORT as '",der_expimp_data->src_temp_dir,"/",
      cnvtlower(der_expimp_data->tgt_dbname),"_exp' go")
     IF (dm2_push_cmd(dcd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
     SET dcd_tmp_str = concat("rdb grant read,write on directory ",cnvtlower(der_expimp_data->
       tgt_dbname),"_EXPORT_IMPORT to V500 go")
     IF (dm2_push_cmd(dcd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
     IF (validate(drrr_responsefile_in_use,0)=1)
      IF ((drrr_rf_data->src_db_deploy_config IN ("ADB", "OCI")))
       SET dm_err->eproc = "GRANT READ, WRITE ON DIRECTORY TO C##CLOUD$SERVICE"
       CALL disp_msg("",dm_err->logfile,0)
       SET dcd_tmp_str = concat("rdb grant read, write on directory ",cnvtlower(der_expimp_data->
         tgt_dbname),"_EXPORT_IMPORT to C##CLOUD$SERVICE go")
       IF (dm2_push_cmd(dcd_tmp_str,1)=0)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
    SET dm_err->eproc = "Connect to Target to create oracle directory."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    CALL dm2_push_cmd("free define oraclesystem go",1)
    IF (dcd_cclversion < 8012003)
     SET dcd_tmp_str = concat("define oraclesystem 'SYS/",der_expimp_data->tgt_sys_pass,"@",
      dm2_install_schema->v500_connect_str,"' go")
    ELSEIF (validate(drrr_responsefile_in_use,0)=1)
     IF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
      SET dcd_tmp_str = concat("define oraclesystem '",drrr_rf_data->tgt_sys_user,"/",der_expimp_data
       ->tgt_sys_pass,"@",
       dm2_install_schema->v500_connect_str,"' go")
     ELSE
      SET dcd_tmp_str = concat("define oraclesystem '",drrr_rf_data->tgt_sys_user,"/",der_expimp_data
       ->tgt_sys_pass,"@",
       dm2_install_schema->v500_connect_str,"' with sysdba go")
     ENDIF
    ELSE
     SET dcd_tmp_str = concat("define oraclesystem 'SYS/",der_expimp_data->tgt_sys_pass,"@",
      dm2_install_schema->v500_connect_str,"' with sysdba go")
    ENDIF
    IF (dm2_push_cmd(dcd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Create Target Oracle directory."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SET dcd_tmp_str = concat("rdb create or replace directory ",der_expimp_data->tgt_dbname,
     "_EXPORT_IMPORT as '",der_expimp_data->tgt_temp_dir,"/",
     cnvtlower(der_expimp_data->tgt_dbname),"_exp' go")
    IF (dm2_push_cmd(dcd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "GRANT READ, WRITE ON Target DIRECTORY TO V500"
    CALL disp_msg("",dm_err->logfile,0)
    SET dcd_tmp_str = concat("rdb grant read,write on directory ",der_expimp_data->tgt_dbname,
     "_EXPORT_IMPORT to V500 go")
    IF (dm2_push_cmd(dcd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    IF (validate(drrr_responsefile_in_use,0)=1)
     IF ((drrr_rf_data->tgt_db_deploy_config IN ("ADB", "OCI")))
      SET dm_err->eproc = "GRANT READ, WRITE ON Target DIRECTORY TO C##CLOUD$SERVICE"
      CALL disp_msg("",dm_err->logfile,0)
      SET dcd_tmp_str = concat("rdb grant read, write on directory ",cnvtlower(der_expimp_data->
        tgt_dbname),"_EXPORT_IMPORT to C##CLOUD$SERVICE go")
      IF (dm2_push_cmd(dcd_tmp_str,1)=0)
       RETURN(0)
      ENDIF
     ENDIF
    ENDIF
    SET dm_err->eproc =
    "Re-Connect to Target after successful Source SYS user validation and directory creation."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    CALL dm2_push_cmd("free define oraclesystem go",1)
    SET dcd_tmp_str = concat("define oraclesystem 'V500/",dm2_install_schema->v500_p_word,"@",
     dm2_install_schema->v500_connect_str,"' go")
    IF (dm2_push_cmd(dcd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_drop_dirs(null)
   DECLARE ddd_tmp_str = vc WITH protect, noconstant("")
   IF ((drrr_rf_data->src_drop_expimp_dir="YES"))
    SET dm_err->eproc = "Connect to Source as V500 to check for Oracle directory."
    CALL disp_msg("",dm_err->logfile,0)
    CALL dm2_push_cmd("free define oraclesystem go",1)
    SET ddd_tmp_str = concat("define oraclesystem 'V500/",drrr_rf_data->src_db_user_pwd,"@",
     drrr_rf_data->src_db_cnct_str,"' go")
    IF (dm2_push_cmd(ddd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Query from Source dba_directories to check if Oracle directory ",
     drrr_rf_data->src_dp_dir_name," exists.")
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dba_directories
     WHERE (cnvtupper(directory_name)=drrr_rf_data->src_dp_dir_name)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc) > 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual > 0)
     SET dm_err->eproc = concat("Drop Source Oracle directory ",drrr_rf_data->src_dp_dir_name)
     CALL disp_msg(" ",dm_err->logfile,0)
     SET ddd_tmp_str = concat("rdb drop directory ",drrr_rf_data->src_dp_dir_name," go")
     IF (dm2_push_cmd(ddd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF ((drrr_rf_data->tgt_drop_expimp_dir="YES"))
    SET dm_err->eproc = "Connect to Target as V500 to check for Oracle directory."
    CALL disp_msg("",dm_err->logfile,0)
    CALL dm2_push_cmd("free define oraclesystem go",1)
    SET ddd_tmp_str = concat("define oraclesystem 'V500/",drrr_rf_data->tgt_db_user_pwd,"@",
     drrr_rf_data->tgt_db_cnct_str,"' go")
    IF (dm2_push_cmd(ddd_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Query from Target dba_directories to check if Oracle directory ",
     drrr_rf_data->tgt_dp_dir_name," exists.")
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dba_directories
     WHERE (cnvtupper(directory_name)=drrr_rf_data->tgt_dp_dir_name)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc) > 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (curqual > 0)
     SET dm_err->eproc = concat("Drop Target Oracle directory ",drrr_rf_data->tgt_dp_dir_name)
     CALL disp_msg(" ",dm_err->logfile,0)
     SET ddd_tmp_str = concat("rdb drop directory ",drrr_rf_data->tgt_dp_dir_name," go")
     IF (dm2_push_cmd(ddd_tmp_str,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_get_cnts(dgc_priority)
   DECLARE dgc_table = vc WITH protect, noconstant(" ")
   DECLARE dgc_run_id = f8 WITH protect, noconstant(0.0)
   IF (dgc_priority=0)
    SET dm_err->eproc = "Checking that DM2_DDL_OPS_LOG table exists."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    SELECT INTO "nl:"
     FROM user_tab_cols utc
     WHERE utc.table_name="DM2_DDL_OPS_LOG1"
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSEIF (((curqual=0) OR (checkdic("DM2_DDL_OPS_LOG1","T",0)=0)) )
     SET dm_err->eproc = "DM2_DDL_OPS_LOG table does not exist."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     RETURN(1)
    ENDIF
   ENDIF
   IF ((dm2_install_schema->run_id=0))
    SET dm_err->eproc = "Get RUN_ID for latest CLIN COPY operation that completed."
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dm2_ddl_ops d
     WHERE d.run_id IN (
     (SELECT
      max(r.run_id)
      FROM dm2_ddl_ops r
      WHERE r.process_option=patstring("CLIN COPY*")))
     DETAIL
      dgc_run_id = d.run_id
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET dgc_run_id = dm2_install_schema->run_id
   ENDIF
   SET dm_err->eproc = "Retrieving run id and op type being executed."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT
    IF (dgc_priority > 0)
     FROM dm2_ddl_ops_log ddol,
      dm2_ddl_ops ddo
     WHERE ddol.priority=dgc_priority
      AND ddo.run_id=dgc_run_id
      AND ddol.run_id=ddo.run_id
    ELSE
     FROM dm2_ddl_ops_log ddol,
      dm2_ddl_ops ddo
     WHERE ddo.run_id=dgc_run_id
      AND ddol.run_id=ddo.run_id
      AND ddol.op_type IN ("IMPORT*", "EXPORT*")
      AND ddol.ready_to_run_ind=1
    ENDIF
    INTO "nl:"
    ORDER BY ddol.priority DESC
    HEAD ddol.priority
     der_expimp_data->op_type = ddol.op_type, der_expimp_data->priority = ddol.priority,
     der_expimp_data->run_id = ddo.run_id,
     der_expimp_data->schema_date = format(ddo.schema_date,"DD-MMM-YYYY;;D"), dm2_install_schema->
     run_id = ddo.run_id,
     CALL cancel(1)
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((der_expimp_data->op_type="IMPORT*"))
    SET der_expimp_data->op_type = "IMPORT"
   ELSE
    SET der_expimp_data->op_type = "EXPORT"
   ENDIF
   SET dm_err->eproc = "Retrieving DDL operation statuses."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    ddol.status, dgc_count = count(*)
    FROM dm2_ddl_ops_log ddol
    WHERE (ddol.run_id=der_expimp_data->run_id)
     AND (ddol.priority=der_expimp_data->priority)
    GROUP BY ddol.status
    DETAIL
     CASE (ddol.status)
      OF "COMPLETE":
       der_expimp_data->complete_cnt = dgc_count
      OF "ERROR":
       der_expimp_data->failed_cnt = dgc_count
      OF "RUNNING":
       der_expimp_data->running_cnt = dgc_count
      ELSE
       der_expimp_data->left_cnt = dgc_count
     ENDCASE
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    IF ((dm_err->emsg="*ORA-01013*"))
     SET dm_err->err_ind = 0
     SET der_expimp_data->ignorable_error_ind = 1
     CALL echo("ABOVE ERROR IS IGNORABLE")
    ELSE
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET der_expimp_data->total_cnt = (((der_expimp_data->complete_cnt+ der_expimp_data->failed_cnt)+
   der_expimp_data->running_cnt)+ der_expimp_data->left_cnt)
   IF ((der_expimp_data->running_cnt > 0))
    IF ( NOT ((dm2_rdbms_version->level1 > 0)))
     IF (dm2_get_rdbms_version(null)=0)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((dm2_rdbms_version->level1 >= 9))
     SET dm_err->eproc = "Querying for resumable sessions that are suspended from DBA_RESUMABLE."
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     SELECT INTO "nl:"
      cnt = count(*)
      FROM dba_resumable gvr
      WHERE gvr.status="SUSPENDED"
      DETAIL
       der_expimp_data->suspended_cnt = cnt
      WITH nocounter
     ;end select
     IF (check_error(dm_err->eproc))
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   IF ((der_expimp_data->tgt_dbname="DM2NOTSET"))
    SET der_expimp_data->tgt_dbname = currdbname
   ENDIF
   IF (der_manage_admin_data(der_expimp_data->tgt_dbname,"DM2_ADMIN_DM_INFO","S","ALL","")=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_process_expimp_screen(dpes_display_only,dpes_priority)
   DECLARE dpes_event_type = vc WITH protect, noconstant("DM2_NOTSET")
   DECLARE dpes_action = vc WITH protect, noconstant(" ")
   DECLARE dpes_pre_eproc = vc WITH protect, noconstant(" ")
   DECLARE dpes_pre_err_ind = i2 WITH protect, noconstant(0)
   DECLARE dpes_pre_emsg = vc WITH protect, noconstant(" ")
   DECLARE dpes_pre_user_action = vc WITH protect, noconstant(" ")
   DECLARE dpes_notify = i2 WITH protect, noconstant(0)
   DECLARE dpes_wait_timestamp = f8 WITH protect, noconstant(0)
   SET dpes_wait_timestamp = cnvtdatetime(curdate,curtime3)
   WHILE (true)
     SET der_expimp_data->total_cnt = 0
     SET der_expimp_data->complete_cnt = 0
     SET der_expimp_data->left_cnt = 0
     SET der_expimp_data->running_cnt = 0
     SET der_expimp_data->failed_cnt = 0
     SET der_expimp_data->suspended_cnt = 0
     SET der_expimp_data->max_runners = 0
     SET der_expimp_data->op_type = " "
     IF (der_get_cnts(dpes_priority)=0)
      RETURN(0)
     ENDIF
     IF ((der_expimp_data->op_type="DM2NOTSET"))
      SET der_expimp_data->op_type = "[EXPORT/IMPORT]"
     ENDIF
     IF ( NOT ((((drr_clin_copy_data->process="DM2NOTSET")) OR ((drr_clin_copy_data->process=""))) ))
      SET dpes_event_type = cnvtupper(concat(drr_clin_copy_data->process," ",der_expimp_data->op_type,
        " PROCESS..."))
     ELSE
      SET dpes_event_type = cnvtupper(concat("REPLICATE/REFRESH ",der_expimp_data->op_type,
        " PROCESS..."))
     ENDIF
     IF (dpes_display_only=1
      AND (der_expimp_data->total_cnt > 0))
      IF ((der_expimp_data->total_cnt=der_expimp_data->complete_cnt))
       SET message = nowindow
       RETURN(1)
      ELSEIF ((der_expimp_data->total_cnt=(der_expimp_data->complete_cnt+ der_expimp_data->failed_cnt
      )))
       IF ((dm2_install_schema->process_option="CLIN COPY")
        AND (drr_clin_copy_data->process != "MIGRATION")
        AND (drer_email_list->email_cnt > 0)
        AND dpes_notify=0)
        SET dpes_pre_eproc = dm_err->eproc
        SET dpes_pre_err_ind = dm_err->err_ind
        SET dpes_pre_emsg = dm_err->emsg
        SET dpes_pre_user_action = dm_err->user_action
        SET drer_email_det->status = "FAILED"
        SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
        SET drer_email_det->step = concat("REPLICATE/REFRESH ",der_expimp_data->op_type," PROCESS")
        SET drer_email_det->email_level = 1
        SET drer_email_det->logfile = dm_err->logfile
        SET drer_email_det->err_ind = dm_err->err_ind
        SET drer_email_det->eproc = dpes_event_type
        SET drer_email_det->emsg = concat(trim(cnvtstring(der_expimp_data->failed_cnt))," failed ",
         der_expimp_data->op_type," operations are found.")
        SET drer_email_det->user_action =
        "Launch dm2_replicate_expimp_menu to view failed operations."
        SET drer_email_det->component_name = curprog
        IF (drer_compose_email(null)=1)
         CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
          email_level)
        ENDIF
        SET dm_err->eproc = dpes_pre_eproc
        SET dm_err->err_ind = dpes_pre_err_ind
        SET dm_err->emsg = dpes_pre_emsg
        SET dm_err->user_action = dpes_pre_user_action
        SET dpes_notify = 1
       ENDIF
      ELSE
       IF ((dm2_install_schema->process_option="CLIN COPY")
        AND (drr_clin_copy_data->process != "MIGRATION")
        AND (drer_email_list->email_cnt > 0))
        IF (datetimediff(cnvtdatetime(curdate,curtime),cnvtdatetime(dpes_wait_timestamp),4) > 30)
         SET dpes_wait_timestamp = cnvtdatetime(curdate,curtime3)
         SET dpes_pre_eproc = dm_err->eproc
         SET dpes_pre_err_ind = dm_err->err_ind
         SET dpes_pre_emsg = dm_err->emsg
         SET dpes_pre_user_action = dm_err->user_action
         SET drer_email_det->status = "MONITOR"
         SET drer_email_det->status_dt_tm = cnvtdatetime(curdate,curtime3)
         SET drer_email_det->step = concat("REPLICATE/REFRESH ",der_expimp_data->op_type," PROCESS")
         SET drer_email_det->email_level = 2
         SET drer_email_det->logfile = dm_err->logfile
         SET drer_email_det->component_name = curprog
         CALL drer_add_body_text(concat("Total Operations: ",trim(cnvtstring(der_expimp_data->
             total_cnt))),1)
         CALL drer_add_body_text(concat("Total Completed: ",trim(cnvtstring(der_expimp_data->
             complete_cnt))),0)
         CALL drer_add_body_text(concat("Total Remaining: ",trim(cnvtstring(der_expimp_data->left_cnt
             ))),0)
         CALL drer_add_body_text(concat("Total Running: ",trim(cnvtstring(der_expimp_data->
             running_cnt))),0)
         CALL drer_add_body_text(concat("Total Failed: ",trim(cnvtstring(der_expimp_data->failed_cnt)
            )),0)
         CALL drer_add_body_text(concat("Total Suspended: ",trim(cnvtstring(der_expimp_data->
             suspended_cnt))),0)
         CALL drer_add_body_text(concat("Log files are located at ",der_expimp_data->tgt_temp_dir,
           "/log/"),0)
         IF ((der_expimp_data->failed_cnt > 0))
          SET drer_email_det->msgtype = "ACTIONREQ"
          SET drer_email_det->user_action =
          "Launch dm2_replicate_expimp_menu to view failed operations."
         ELSE
          SET drer_email_det->msgtype = "PROGRESS"
         ENDIF
         IF (drer_compose_email(null)=1)
          CALL drer_send_email(drer_email_det->subject,drer_email_det->file_name,drer_email_det->
           email_level)
         ENDIF
         SET dm_err->eproc = dpes_pre_eproc
         SET dm_err->err_ind = dpes_pre_err_ind
         SET dm_err->emsg = dpes_pre_emsg
         SET dm_err->user_action = dpes_pre_user_action
        ENDIF
       ENDIF
      ENDIF
     ENDIF
     SET width = 132
     IF ((dm_err->debug_flag != 722))
      SET message = window
     ENDIF
     CALL clear(1,1)
     CALL box(1,1,24,131)
     CALL text(2,2,dpes_event_type)
     CALL text(5,2,"Total Operations:")
     CALL text(5,25,build(der_expimp_data->total_cnt))
     CALL text(6,2,"Total Completed:")
     CALL text(6,25,build(der_expimp_data->complete_cnt))
     CALL text(7,2,"Total Remaining:")
     CALL text(7,25,build(der_expimp_data->left_cnt))
     CALL text(8,2,"Total Running:")
     CALL text(8,25,build(der_expimp_data->running_cnt))
     IF ((der_expimp_data->failed_cnt > 0))
      CALL video(b)
     ENDIF
     CALL text(9,2,"Total Failed:")
     CALL text(9,25,build(der_expimp_data->failed_cnt))
     CALL video(n)
     CALL text(10,2,"Total Suspended:")
     CALL text(10,25,build(der_expimp_data->suspended_cnt))
     CALL text(12,2,"Max number of parallel runners to execute:")
     CALL text(12,45,build(cnvtstring(der_expimp_data->max_runners)))
     SET accept = time(30)
     CALL clear(16,2,130)
     CALL clear(18,2,130)
     IF ((der_expimp_data->ignorable_error_ind=1))
      SET der_expimp_data->ignorable_error_ind = 0
      CALL text(16,2,"(R)efresh Screen, (E)xit:")
      CALL text(18,2,"Unable to retrieve total counts - will be available shortly.")
      CALL accept(16,28,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("R", "E"))
     ELSEIF (dpes_display_only=1
      AND (der_expimp_data->total_cnt > 0))
      CALL text(16,2,"(R)efresh Screen, (E)xit:")
      CALL text(18,2,concat("Launch dm2_replicate_expimp_menu to manage the ",der_expimp_data->
        op_type," operations."))
      CALL accept(16,28,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("R", "E"))
     ELSEIF ((der_expimp_data->total_cnt=0))
      CALL text(16,2,"(R)efresh Screen, (E)xit:")
      CALL text(18,2,"No [export/import] operations found to process!")
      CALL accept(16,28,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("R", "E"))
     ELSEIF ((der_expimp_data->failed_cnt > 0)
      AND (der_expimp_data->suspended_cnt > 0))
      CALL text(16,2,
       "(V)iew Operations, (F)ailed Operations Retry, (S)uspended Operations, (R)efresh Screen, (E)xit:"
       )
      CALL accept(16,98,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("V", "F", "S", "R", "E"))
     ELSEIF ((der_expimp_data->failed_cnt > 0))
      CALL text(16,2,"(V)iew Operations, (F)ailed Operations Retry, (R)efresh Screen, (E)xit:")
      CALL accept(16,74,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("V", "F", "R", "E"))
     ELSEIF ((der_expimp_data->suspended_cnt > 0))
      CALL text(16,2,"(V)iew Operations, (S)uspended Operations, (R)efresh Screen, (E)xit:")
      CALL accept(16,72,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("V", "S", "R", "E"))
     ELSE
      CALL text(16,2,"(V)iew Operations, (R)efresh Screen, (E)xit:")
      IF ((der_expimp_data->total_cnt=der_expimp_data->complete_cnt))
       CALL text(18,2,concat("All ",der_expimp_data->op_type," operations completed."))
      ELSEIF ((der_expimp_data->running_cnt=0))
       IF ((der_expimp_data->temp_timestamp=cnvtdatetime("01-JAN-1900 00:00:00")))
        SET der_expimp_data->temp_timestamp = cnvtdatetime(curdate,curtime3)
        SET der_expimp_data->temp_cnt = der_expimp_data->complete_cnt
       ELSE
        IF (datetimediff(cnvtdatetime(curdate,curtime3),cnvtdatetime(der_expimp_data->temp_timestamp),
         4) > 5)
         IF ((der_expimp_data->temp_cnt=der_expimp_data->complete_cnt))
          CALL text(18,2,
           "Operations are not being processed. Ensure cron job is running and that max runners is greater than 0"
           )
         ELSE
          SET der_expimp_data->temp_timestamp = cnvtdatetime(curdate,curtime3)
          SET der_expimp_data->temp_cnt = der_expimp_data->complete_cnt
         ENDIF
        ENDIF
       ENDIF
      ENDIF
      CALL accept(16,47,"A;CU","R"
       WHERE cnvtupper(curaccept) IN ("V", "R", "E"))
     ENDIF
     SET accept = notime
     SET dpes_action = cnvtupper(curaccept)
     CASE (dpes_action)
      OF "E":
       RETURN(1)
      OF "F":
       EXECUTE dm2_retry_imp_exp "ALL DDL"
       IF ((dm_err->err_ind=1))
        RETURN(0)
       ENDIF
      OF "S":
       EXECUTE dm2_resumable_session_menu
       IF ((dm_err->err_ind > 0))
        RETURN(0)
       ENDIF
      OF "V":
       CALL clear(16,2,130)
       CALL text(16,2,"(R)unning, (F)ailed, (C)ompleted, (A)ll, (E)xit:")
       CALL clear(18,2,130)
       CALL accept(16,51,"A;CU"," "
        WHERE cnvtupper(curaccept) IN ("R", "F", "C", "A", "E"))
       CASE (cnvtupper(curaccept))
        OF "R":
         SET dm2rpting->status_criteria =
         "ddol.status = 'RUNNING' and ddol.op_type in ('IMPORT*','EXPORT*')"
         SET dm2rpting->report_option = "Running Operations"
        OF "F":
         SET dm2rpting->status_criteria =
         "ddol.status = 'ERROR' and ddol.op_type in ('IMPORT*','EXPORT*') "
         SET dm2rpting->report_option = "Failed Operations"
        OF "C":
         SET dm2rpting->status_criteria =
         "ddol.status = 'COMPLETE' and ddol.op_type in ('IMPORT*','EXPORT*') "
         SET dm2rpting->report_option = "Completed Operations"
        OF "A":
         SET dm2rpting->status_criteria = concat(
          "(ddol.status in ('COMPLETE','RUNNING','ERROR') or ddol.status is null)",
          " and ddol.op_type in ('IMPORT*','EXPORT*')")
         SET dm2rpting->report_option = "All Operations"
       ENDCASE
       IF (cnvtupper(curaccept) != "E")
        SET message = nowindow
        SET dm2rpting->prompt_mode = "NOPROMPT"
        SET dm2rpting->run_id = der_expimp_data->run_id
        SET dm2rpting->install_mode = "SCHEMA_DATE"
        SET dm2rpting->schema_date = der_expimp_data->schema_date
        EXECUTE dm2_ddl_reports
        IF ((dm_err->err_ind=1))
         RETURN(0)
        ENDIF
       ENDIF
     ENDCASE
   ENDWHILE
 END ;Subroutine
 SUBROUTINE der_manage_admin_data(dmad_dbname,dmad_admin_tbl,dmad_mode,dmad_data_name,dmad_data_value
  )
   DECLARE dmad_fnd = i2 WITH protect, noconstant(0)
   DECLARE dmad_db_name_str = vc WITH protect, noconstant("")
   DECLARE dmad_info_domain = vc WITH protect, constant("DM2_REPLICATE_EXPIMP_DATA")
   DECLARE dmad_info_name = vc WITH protect, noconstant(" ")
   DECLARE dmad_info_char = vc WITH protect, noconstant(" ")
   IF (((trim(dmad_dbname,3) IN ("DM2NOTSET", "")) OR (((trim(dmad_admin_tbl,3) IN ("DM2NOTSET", ""))
    OR (((trim(dmad_mode,3) IN ("DM2NOTSET", "")) OR (trim(dmad_data_name,3) IN ("DM2NOTSET", "")))
   )) )) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validate input into subroutine der_manage_admin_data."
    SET dm_err->emsg = "Invalid input."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ( NOT (dmad_mode IN ("S", "U", "D")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validate input mode into subroutine der_manage_admin_data."
    SET dm_err->emsg = "Incorrect mode. Needs to be S, U or D."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dmad_mode IN ("S", "D")
    AND  NOT (dmad_data_name IN ("ALL", "ORACLE_HOME", "TEMP_DIRECTORY", "SRC_TEMP_DIRECTORY",
   "MAX_RUNNERS",
   "SETUP_COMPLETE_IND", "CLEANUP_COMPLETE_IND", "TGT_SYS_PASS", "DP_NODE_TYPE",
   "TGT_APP_TEMP_DIRECTORY")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validate input data_name into subroutine der_manage_admin_data."
    SET dm_err->emsg = "Incorrect data name for input using mode of S/D."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dmad_mode="U"
    AND  NOT (dmad_data_name IN ("ORACLE_HOME", "TEMP_DIRECTORY", "SRC_TEMP_DIRECTORY", "MAX_RUNNERS",
   "SETUP_COMPLETE_IND",
   "CLEANUP_COMPLETE_IND", "TGT_SYS_PASS", "DP_NODE_TYPE", "TGT_APP_TEMP_DIRECTORY")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validate input data_name into subroutine der_manage_admin_data."
    SET dm_err->emsg = "Incorrect data name for input using mode of U."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dmad_db_name_str = cnvtupper(build(dmad_dbname,"_"))
   SET dmad_info_name = cnvtupper(build(dmad_db_name_str,dmad_data_name))
   SET dmad_info_char = dmad_data_value
   IF (dmad_mode IN ("S", "D")
    AND dmad_data_name="ALL")
    SET dmad_info_name = build(dmad_db_name_str,"*")
    SET der_expimp_data->tgt_oracle_home = ""
    SET der_expimp_data->tgt_temp_dir = ""
    SET der_expimp_data->src_temp_dir = ""
    SET der_expimp_data->max_runners = 0
    SET der_expimp_data->max_runners_fnd = 0
    SET der_expimp_data->setup_complete_ind = 0
    SET der_expimp_data->cleanup_complete_ind = 0
    SET der_expimp_data->tgt_sys_pass = ""
    SET der_expimp_data->dp_node_type = ""
    SET der_expimp_data->tgt_app_temp_dir = ""
   ENDIF
   SET dm_err->eproc = "Select Export/Import Data from Admin DM_INFO."
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SELECT INTO "nl:"
    FROM (value(dmad_admin_tbl) d)
    WHERE d.info_domain=dmad_info_domain
     AND d.info_name=patstring(dmad_info_name)
    DETAIL
     dmad_fnd = 1
     IF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="ORACLE_HOME")
      IF ((der_expimp_data->tgt_oracle_home=""))
       der_expimp_data->tgt_oracle_home = d.info_char
      ENDIF
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="TEMP_DIRECTORY")
      IF ((der_expimp_data->tgt_temp_dir=""))
       der_expimp_data->tgt_temp_dir = d.info_char
      ENDIF
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="SRC_TEMP_DIRECTORY")
      IF ((der_expimp_data->src_temp_dir=""))
       der_expimp_data->src_temp_dir = d.info_char
      ENDIF
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="TGT_SYS_PASS")
      IF ((der_expimp_data->tgt_sys_pass=""))
       der_expimp_data->tgt_sys_pass = d.info_char
      ENDIF
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="MAX_RUNNERS")
      der_expimp_data->max_runners_fnd = 1, der_expimp_data->max_runners = cnvtreal(d.info_char)
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="SETUP_COMPLETE_IND")
      der_expimp_data->setup_complete_ind = 1
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="CLEANUP_COMPLETE_IND")
      der_expimp_data->cleanup_complete_ind = 1
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="DP_NODE_TYPE")
      IF ((der_expimp_data->dp_node_type=""))
       der_expimp_data->dp_node_type = d.info_char
      ENDIF
     ELSEIF (cnvtupper(trim(replace(d.info_name,dmad_db_name_str,"",0)))="TGT_APP_TEMP_DIRECTORY")
      IF ((der_expimp_data->tgt_app_temp_dir=""))
       der_expimp_data->tgt_app_temp_dir = d.info_char
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 721))
    CALL echorecord(der_expimp_data)
   ENDIF
   IF (dmad_mode="S")
    RETURN(1)
   ENDIF
   IF (dmad_mode="U")
    IF (dmad_fnd=0)
     SET dm_err->eproc = "Insert Export/Import Data into Admin"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     INSERT  FROM (value(dmad_admin_tbl) d)
      SET d.info_domain = dmad_info_domain, d.info_name = dmad_info_name, d.info_char =
       dmad_info_char,
       d.updt_dt_tm = cnvtdatetime(curdate,curtime3)
      WITH nocounter
     ;end insert
     IF (check_error(dm_err->eproc)=1)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
      ROLLBACK
      RETURN(0)
     ENDIF
     COMMIT
    ELSEIF (dmad_fnd=1)
     SET dm_err->eproc = "Update Export/Import Data into Admin"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     UPDATE  FROM (value(dmad_admin_tbl) d)
      SET d.info_char = dmad_info_char, d.updt_dt_tm = cnvtdatetime(curdate,curtime3)
      WHERE d.info_domain=dmad_info_domain
       AND d.info_name=dmad_info_name
      WITH nocounter
     ;end update
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     COMMIT
    ENDIF
   ELSEIF (dmad_mode="D")
    IF (dmad_fnd=0)
     SET dm_err->eproc = "No Export/Import Data row(s) in Admin to Delete"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
    ELSEIF (dmad_fnd=1)
     SET dm_err->eproc = "Delete Export/Import data row(s) from Admin"
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     DELETE  FROM (value(dmad_admin_tbl) d)
      WHERE d.info_domain=dmad_info_domain
       AND d.info_name=patstring(dmad_info_name)
      WITH nocounter
     ;end delete
     IF (check_error(dm_err->eproc)=1)
      ROLLBACK
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     COMMIT
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_sync_dir_obj(null)
   IF (validate(dm2_bypass_sync_dir_obj,- (1))=1)
    SET dm_err->eproc = "bypassing the subroutine der_sync_dir_obj - external flag set"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   DECLARE dsdo_str = vc WITH protect, noconstant("")
   IF ((der_expimp_data->tgt_dbname="DM2NOTSET"))
    SET der_expimp_data->tgt_dbname = currdbname
   ENDIF
   IF (dm2_get_rdbms_version(null)=0)
    RETURN(0)
   ENDIF
   IF ((dm2_rdbms_version->level1 >= 11)
    AND (dm2_sys_misc->cur_os != "AXP"))
    SET dm_err->eproc =
    "Re-create Target Oracle directory directory used during export/import process."
    CALL disp_msg("",dm_err->logfile,0)
   ELSE
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Query from dba_directories to check if Oracle directory is created."
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO "nl:"
    FROM dba_directories
    WHERE cnvtupper(directory_name)=concat(cnvtupper(der_expimp_data->tgt_dbname),"_EXPORT_IMPORT")
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc) > 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (curqual=0)
    SET dm_err->eproc = concat("Oracle directory ",cnvtupper(der_expimp_data->tgt_dbname),
     "_EXPORT_IMPORT does not exist. Exiting subroutine.")
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   IF (der_manage_admin_data(der_expimp_data->tgt_dbname,"DM2_ADMIN_DM_INFO","S","ALL","")=0)
    RETURN(0)
   ENDIF
   IF ((der_expimp_data->tgt_sys_pass=""))
    SET dm_err->eproc = "Bypassing directory cleanup"
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ELSE
    SET dm_err->eproc = "Connecting to TARGET database as SYS user."
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dm2_install_schema->dbase_name = der_expimp_data->tgt_dbname
    IF (validate(drrr_responsefile_in_use,0)=1)
     SET dm2_install_schema->u_name = drrr_rf_data->tgt_sys_user
    ELSE
     SET dm2_install_schema->u_name = "SYS"
    ENDIF
    SET dm2_install_schema->p_word = der_expimp_data->tgt_sys_pass
    SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   SET dsdo_str = concat("rdb create or replace directory ",der_expimp_data->tgt_dbname,
    "_EXPORT_IMPORT as '",der_expimp_data->tgt_temp_dir,"/",
    cnvtlower(der_expimp_data->tgt_dbname),"_exp' go")
   IF (dm2_push_cmd(dsdo_str,1)=0)
    RETURN(0)
   ENDIF
   SET dsdo_str = concat("rdb grant read,write on directory ",der_expimp_data->tgt_dbname,
    "_EXPORT_IMPORT to V500 go")
   IF (dm2_push_cmd(dsdo_str,1)=0)
    RETURN(0)
   ENDIF
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OCI", "ADB")))
     SET dsdo_str = concat("rdb grant read, write on directory ",der_expimp_data->tgt_dbname,
      "_EXPORT_IMPORT to C##CLOUD$SERVICE go")
     IF (dm2_push_cmd(dsdo_str,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET dm_err->eproc = "Connecting back to TARGET database as V500 user."
   CALL disp_msg(" ",dm_err->logfile,0)
   SET dm2_install_schema->dbase_name = der_expimp_data->tgt_dbname
   SET dm2_install_schema->u_name = "V500"
   SET dm2_install_schema->p_word = dm2_install_schema->v500_p_word
   SET dm2_install_schema->connect_str = dm2_install_schema->v500_connect_str
   EXECUTE dm2_connect_to_dbase "CO"
   IF ((dm_err->err_ind=1))
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_val_dbms_cloud(dvdc_src_ind)
   DECLARE dvdc_syn_pub_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvdc_syn_priv_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvdc_pkg_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvdc_pkg_body_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvdc_tmp_str = vc WITH protect, noconstant("")
   DECLARE dvdc_priv_fnd = i2 WITH protect, noconstant(0)
   DECLARE dvdc_adb_ind = i2 WITH protect, noconstant(0)
   IF (validate(drrr_responsefile_in_use,0)=1)
    CALL dm2_push_cmd("free define oraclesystem go",1)
    IF (dvdc_src_ind=1)
     IF ((drrr_rf_data->src_db_deploy_config="ADB"))
      SET dvdc_adb_ind = 1
      SET dvdc_tmp_str = concat("define oraclesystem '",drrr_rf_data->src_sys_user,"/",drrr_rf_data->
       src_sys_pwd,"@",
       dm2_install_schema->src_v500_connect_str,"' go")
     ELSE
      SET dvdc_tmp_str = concat("define oraclesystem '",drrr_rf_data->src_sys_user,"/",drrr_rf_data->
       src_sys_pwd,"@",
       dm2_install_schema->src_v500_connect_str,"' with sysdba go")
     ENDIF
    ELSE
     IF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
      SET dvdc_adb_ind = 1
      SET dvdc_tmp_str = concat("define oraclesystem '",drrr_rf_data->tgt_sys_user,"/",drrr_rf_data->
       tgt_sys_pwd,"@",
       dm2_install_schema->v500_connect_str,"' go")
     ELSE
      SET dvdc_tmp_str = concat("define oraclesystem '",drrr_rf_data->tgt_sys_user,"/",drrr_rf_data->
       tgt_sys_pwd,"@",
       dm2_install_schema->v500_connect_str,"' with sysdba go")
     ENDIF
    ENDIF
    IF (dm2_push_cmd(dvdc_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Validate DBMS_CLOUD for database ",currdbname)
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dba_objects o
     WHERE o.object_name="DBMS_CLOUD"
      AND o.status="VALID"
     DETAIL
      IF (o.owner="PUBLIC"
       AND o.object_type="SYNONYM")
       dvdc_syn_pub_cnt = 1
      ELSEIF (o.owner="C##CLOUD$SERVICE"
       AND o.object_type="SYNONYM")
       dvdc_syn_priv_cnt = 1
      ELSEIF (o.owner="C##CLOUD$SERVICE"
       AND o.object_type="PACKAGE")
       dvdc_pkg_cnt = 1
      ELSEIF (o.owner="C##CLOUD$SERVICE"
       AND o.object_type="PACKAGE BODY")
       dvdc_pkg_body_cnt = 1
      ENDIF
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dvdc_adb_ind=1)
     IF (((dvdc_syn_pub_cnt=0) OR (dvdc_syn_priv_cnt=0)) )
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("DBMS_CLOUD synonym is missing on ADB ",currdbname)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ELSE
     IF (((dvdc_pkg_cnt=0) OR (dvdc_pkg_body_cnt=0)) )
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("DBMS_CLOUD package is not valid on database ",currdbname)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSEIF (dvdc_syn_pub_cnt=0)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("DBMS_CLOUD synonym is missing on non-ADB ",currdbname)
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    SET dm_err->eproc = concat("Validate DBMS_CLOUD execute grant on database ",currdbname)
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT
     IF (dvdc_adb_ind=1)
      WHERE table_name="DBMS_CLOUD$*"
       AND grantee="V500"
     ELSE
      WHERE table_name="DBMS_CLOUD"
       AND grantee="V500"
     ENDIF
     INTO ":nl"
     FROM dba_tab_privs
     DETAIL
      dvdc_priv_fnd = (dvdc_priv_fnd+ 1)
     WITH nocounter
    ;end select
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("dvdc_priv_fnd = ",dvdc_priv_fnd))
    ENDIF
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dvdc_priv_fnd=0)
     SET dm_err->eproc = "Grant execute on DBMS_CLOUD to V500 user."
     CALL disp_msg("",dm_err->logfile,0)
     SET dvdc_tmp_str = concat("rdb grant execute on DBMS_CLOUD to V500 go")
     IF (dm2_push_cmd(dvdc_tmp_str,1)=0)
      RETURN(0)
     ENDIF
    ENDIF
    SET dm_err->eproc = "Re-Connect to Target after successful validation for DBMS_CLOUD."
    IF ((dm_err->debug_flag > 0))
     CALL disp_msg("",dm_err->logfile,0)
    ENDIF
    CALL dm2_push_cmd("free define oraclesystem go",1)
    SET dvdc_tmp_str = concat("define oraclesystem 'V500/",dm2_install_schema->v500_p_word,"@",
     dm2_install_schema->v500_connect_str,"' go")
    IF (dm2_push_cmd(dvdc_tmp_str,1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE der_compile_oos_pkg(dcop_src_ind)
   DECLARE dcop_obj_cnt = i2 WITH protect, noconstant(0)
   DECLARE dcop_tmp_str = vc WITH protect, noconstant("")
   DECLARE dcop_connect_str = vc WITH protect, noconstant("")
   DECLARE dcop_file = vc WITH protect, noconstant("")
   DECLARE dcop_obj_name = vc WITH protect, noconstant("")
   DECLARE dcop_obj_type = vc WITH protect, noconstant("")
   IF (validate(drrr_responsefile_in_use,0)=1)
    IF (dcop_src_ind=1)
     SET dcop_connect_str = concat(drrr_rf_data->src_db_user,"/",drrr_rf_data->src_db_user_pwd,"@",
      drrr_rf_data->src_db_cnct_str)
    ELSE
     SET dcop_connect_str = concat(drrr_rf_data->tgt_db_user,"/",drrr_rf_data->tgt_db_user_pwd,"@",
      drrr_rf_data->tgt_db_cnct_str)
    ENDIF
    SET dcop_file = "$cer_install/dm2_manage_oos_header.sql"
    SET dcop_obj_name = "DM2_MANAGE_OOS"
    SET dcop_obj_type = "PACKAGE"
    SET dm_err->eproc = concat("Compile ",dcop_obj_type," ",dcop_obj_name)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dcop_tmp_str = concat("exit | $ORACLE_HOME/bin/sqlplus ",dcop_connect_str," @",dcop_file)
    IF ((dm_err->debug_flag > 0))
     CALL echo(dcop_tmp_str)
    ENDIF
    IF (dm2_push_dcl(dcop_tmp_str)=0)
     RETURN(0)
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (((findstring("SP2-",cnvtupper(dm_err->errtext),1,0) > 0) OR (findstring("ORA-",cnvtupper(
      dm_err->errtext),1,0) > 0)) )
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Compilation error found. ",dm_err->errtext)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dcop_file = "$cer_install/dm2_manage_oos_body.sql"
    SET dcop_obj_name = "DM2_MANAGE_OOS"
    SET dcop_obj_type = "PACKAGE BODY"
    SET dm_err->eproc = concat("Compile ",dcop_obj_type," ",dcop_obj_name)
    CALL disp_msg(" ",dm_err->logfile,0)
    SET dcop_tmp_str = concat("exit | $ORACLE_HOME/bin/sqlplus ",dcop_connect_str," @",dcop_file)
    IF ((dm_err->debug_flag > 0))
     CALL echo(dcop_tmp_str)
    ENDIF
    IF (dm2_push_dcl(dcop_tmp_str)=0)
     RETURN(0)
    ENDIF
    IF (parse_errfile(dm_err->errfile)=0)
     RETURN(0)
    ENDIF
    IF (((findstring("SP2-",cnvtupper(dm_err->errtext),1,0) > 0) OR (findstring("ORA-",cnvtupper(
      dm_err->errtext),1,0) > 0)) )
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Compilation error found. ",dm_err->errtext)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dcop_tmp_str = concat("define oraclesystem '",dcop_connect_str,"' go")
    CALL dm2_push_cmd("free define oraclesystem go",1)
    IF (dm2_push_cmd(dcop_tmp_str,1)=0)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = concat("Validate DM2_MANAGE_OOS Package.")
    CALL disp_msg(" ",dm_err->logfile,0)
    SELECT INTO "nl:"
     FROM dba_objects o
     WHERE owner="V500"
      AND o.object_name=dcop_obj_name
      AND o.object_type IN ("PACKAGE BODY", "PACKAGE")
      AND o.status="VALID"
     DETAIL
      dcop_obj_cnt = (dcop_obj_cnt+ 1)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dcop_obj_cnt != 2)
     SET dm_err->err_ind = 1
     SET dm_err->emsg = concat("Missing or Invalid ",dcop_obj_name)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE dcl_check_lang(null) = i2
 SUBROUTINE dcl_check_lang(null)
   DECLARE ddrd_cur_lang = vc WITH protect, noconstant("DM2_NOT_SET")
   DECLARE ddrd_lang_str = vc WITH protect, noconstant("DM2_NOT_SET")
   DECLARE ddrd_idx = i4 WITH protect, noconstant(0)
   IF ((validate(dm2_bypass_lang_check,- (1))=- (1)))
    FREE RECORD ddrd_lang
    RECORD ddrd_lang(
      1 cnt = i4
      1 qual[*]
        2 lang_value = vc
    )
    SET ddrd_lang->cnt = 0
    SET dm_err->eproc = "Read dm2_tools_valid_lang.txt from cer_install"
    CALL disp_msg(" ",dm_err->logfile,0)
    FREE DEFINE rtl2
    SET logical file_name value(concat("CER_INSTALL:","dm2_tools_valid_lang.txt"))
    DEFINE rtl2 "file_name"  WITH nomodify
    SELECT INTO "nl:"
     t.line
     FROM rtl2t t
     WHERE t.line > " "
     DETAIL
      IF ((ddrd_lang->cnt=0))
       ddrd_lang_str = trim(cnvtupper(t.line))
      ELSE
       ddrd_lang_str = concat(ddrd_lang_str,", ",trim(cnvtupper(t.line)))
      ENDIF
      ddrd_lang->cnt = (ddrd_lang->cnt+ 1), stat = alterlist(ddrd_lang->qual,ddrd_lang->cnt),
      ddrd_lang->qual[ddrd_lang->cnt].lang_value = trim(cnvtupper(t.line))
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(ddrd_lang)
    ENDIF
    SET ddrd_cur_lang = cnvtupper(logical("LANG"))
    IF (ddrd_cur_lang > "")
     IF (locateval(ddrd_idx,1,ddrd_lang->cnt,ddrd_cur_lang,ddrd_lang->qual[ddrd_idx].lang_value)=0)
      SET dm_err->err_ind = 1
      SET dm_err->emsg = concat("Current LANG setting (",ddrd_cur_lang,") is not supported")
      SET dm_err->user_action = concat("Please exit CCL, alter the O/S session value of LANG ",
       "to one of the following supported values <",ddrd_lang_str,">",
       ", re-enter CCL and re-execute dm2_domain_refresh_driver")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 DECLARE dm2_ping(host_name=vc) = i2
 SUBROUTINE dm2_ping(host_name)
  SET dm_err->eproc = concat("Ping host ",host_name)
  IF ((dm2_sys_misc->cur_os IN ("LNX", "AIX")))
   RETURN(dm2_push_dcl(concat("ping -c 1 ",host_name)))
  ELSEIF ((dm2_sys_misc->cur_os="AXP"))
   RETURN(dm2_push_dcl(concat("tcpip ping /number_packets=1 ",host_name)))
  ELSEIF ((dm2_sys_misc->cur_os="HPX"))
   RETURN(dm2_push_dcl(concat("ping ",host_name," -n 1")))
  ELSE
   SET dm_err->err_ind = 1
   SET dm_err->emsg = "Operating System not supported."
   RETURN(0)
  ENDIF
 END ;Subroutine
 DECLARE drrr_initialize_rf_data_rs(null) = null
 DECLARE drrr_initialize_misc_data_rs(null) = null
 DECLARE drrr_create_text_file(dctf_in_fname=vc) = i2
 DECLARE drrr_load_rf_data_rs(dldr_file=vc,dldr_mode=vc) = i2
 DECLARE drrr_val_rf_status_file(dvrsf_status_file_in) = i2
 DECLARE drrr_val_rf_version(null) = i2
 DECLARE drrr_add_text(dat_in_text=vc,dat_in_reset_ind=i2) = null
 DECLARE drrr_val_rf_client_mnemonic(null) = i2
 DECLARE drrr_val_rf_target_refresh(null) = i2
 DECLARE drrr_val_rf_adm_cnnct_data(dvracd_in_cnct_to_db_ind=i2) = i2
 DECLARE drrr_val_rf_src_cnnct_data(dvrscd_in_cnct_to_db_ind=i2) = i2
 DECLARE drrr_val_rf_tgt_cnnct_data(dvrtcd_in_cnct_to_db_ind=i2) = i2
 DECLARE drrr_val_rf_tgt_sys_cnnct_data(dvrtscd_in_cnct_to_db_ind=i2) = i2
 DECLARE drrr_val_rf_src_env_name(null) = i2
 DECLARE drrr_val_rf_src_domain_name(null) = i2
 DECLARE drrr_val_rf_src_high_priv_user(null) = i2
 DECLARE drrr_val_rf_src_app_temp_dir(null) = i2
 DECLARE drrr_val_rf_src_app_node_list(null) = i2
 DECLARE drrr_val_rf_tgt_env_name(null) = i2
 DECLARE drrr_val_rf_tgt_domain_name(null) = i2
 DECLARE drrr_val_rf_tgt_high_priv_user(null) = i2
 DECLARE drrr_val_rf_tgt_app_node_list(null) = i2
 DECLARE drrr_val_rf_tgt_app_temp_dir(null) = i2
 DECLARE drrr_val_rf_tgt_app_prim_temp_dir(null) = i2
 DECLARE drrr_val_rf_tgt_backup_warehouse(null) = i2
 DECLARE drrr_val_rf_tgt_backup_ccluserdir(null) = i2
 DECLARE drrr_val_rf_tgt_preserve_data(null) = i2
 DECLARE drrr_val_rf_tgt_redo_preserve_on_restart(null) = i2
 DECLARE drrr_val_rf_restore_preserve_data(null) = i2
 DECLARE drrr_val_rf_tgt_capture_schema_date(null) = i2
 DECLARE drrr_val_rf_tgt_tspace_increase_pct(null) = i2
 DECLARE drrr_val_write_privs(drvwp_full_dir=vc) = i4
 DECLARE drrr_val_rf_tgt_tspace_dg_list(null) = i2
 DECLARE drrr_val_rf_tgt_server_set_names(null) = i2
 DECLARE drrr_val_email_list(null) = i2
 DECLARE drrr_val_rf_tgt_background_runners(null) = i2
 DECLARE drrr_val_rf_ads(null) = i2
 DECLARE drrr_val_rf_tgt_opsexec_node_mapping(null) = i2
 DECLARE drrr_val_rf_drop_tablespaces(null) = i2
 DECLARE drrr_val_rf_tgt_retain_db_user_list(null) = i2
 DECLARE drrr_val_rf_tgt_database_users(null) = i2
 DECLARE drrr_val_rf_tgt_expimp_runners(null) = i2
 DECLARE drrr_val_rf_src_sys_cnnct_data(dvrsscd_in_cnct_to_db_ind=i2) = i2
 DECLARE drrr_val_rf_tgt_db_temp_dir(null) = i2
 DECLARE drrr_val_rf_src_db_temp_dir(null) = i2
 DECLARE drrr_val_rf_tgt_db_oracle_misc(null) = i2
 DECLARE drrr_val_rf_tgt_db_node(null) = i2
 DECLARE drrr_val_rf_tgt_db_shell_misc(null) = i2
 DECLARE drrr_val_rf_tgt_solution_chks(null) = i2
 DECLARE drrr_val_rf_tgt_apply_src_ed_registry(null) = i2
 DECLARE drrr_val_rf_tgt_registry_set_name(null) = i2
 DECLARE drrr_val_rf_tgt_wh(null) = i2
 DECLARE drrr_val_rf_tgt_ibus_env_mapping(null) = i2
 DECLARE drrr_val_rf_tgt_db_user_pwd_mapping(null) = i2
 DECLARE drrr_val_rf_datapump(null) = i2
 DECLARE drrr_val_rf_restore_list(null) = i2
 DECLARE drrr_val_rf_restore_groups(null) = i2
 DECLARE drrr_val_rf_drr_shadow_tables(null) = i2
 DECLARE drrr_val_rf_mode(null) = i2
 DECLARE drrr_val_rf_isolated_mode(null) = i2
 DECLARE drrr_val_rf_ping_nodes(dvrpn_in_src_ind=i2,dvrpn_in_tgt_ind=i2,dvrpn_in_adm_ind=i2,
  dvrpn_in_local=vc) = i2
 DECLARE drrr_val_rf_tgt_drop_db_links(null) = i2
 DECLARE drrr_val_rf_deploy_configs(null) = i2
 DECLARE drrr_val_rf_tgt_tns_mapping(null) = i2
 DECLARE drrr_load_default_tns_map(dldtm_tns_entry=vc) = i2
 DECLARE drrr_val_rf_tgt_default_tspaces(null) = i2
 DECLARE drrr_val_rf_cred_link_data(null) = i2
 IF ((validate(drrr_responsefile_in_use,- (1))=- (1))
  AND (validate(drrr_responsefile_in_use,- (2))=- (2)))
  DECLARE drrr_responsefile_in_use = i2 WITH public, noconstant(0)
 ENDIF
 IF (validate(drrr_rf_data->responsefile_version,"X")="X"
  AND validate(drrr_rf_data->responsefile_version,"Z")="Z")
  FREE RECORD drrr_rf_data
  RECORD drrr_rf_data(
    1 responsefile_version = vc
    1 client_mnemonic = vc
    1 status_file = vc
    1 target_refresh = vc
    1 adm_db_user = vc
    1 adm_db_user_pwd = vc
    1 adm_db_cnct_str = vc
    1 adm_db_oracle_ver = vc
    1 src_env_name = vc
    1 src_domain_name = vc
    1 src_db_user = vc
    1 src_db_user_pwd = vc
    1 src_db_cnct_str = vc
    1 src_db_name = vc
    1 src_high_priv_user = vc
    1 src_high_priv_user_pwd = vc
    1 src_app_temp_dir = vc
    1 src_app_node_list = vc
    1 tgt_env_name = vc
    1 tgt_domain_name = vc
    1 tgt_sys_user = vc
    1 tgt_sys_pwd = vc
    1 tgt_db_user = vc
    1 tgt_db_user_pwd = vc
    1 tgt_db_cnct_str = vc
    1 tgt_db_name = vc
    1 tgt_cdb_name = vc
    1 tgt_cdb_cnct_str = vc
    1 tgt_high_priv_user = vc
    1 tgt_high_priv_user_pwd = vc
    1 tgt_app_temp_dir = vc
    1 tgt_app_prim_temp_dir = vc
    1 tgt_app_node_list = vc
    1 tgt_primary_app_node = vc
    1 tgt_preserve_data = vc
    1 tgt_redo_preserve_on_restart = vc
    1 tgt_backup_ccluserdir = vc
    1 tgt_backup_warehouse = vc
    1 tgt_db_copy_type = vc
    1 tgt_capture_schema_date = vc
    1 tgt_tspace_increase_pct = i2
    1 tgt_tspace_dg_list = vc
    1 tgt_restore_preserve_data = vc
    1 tgt_restore_autotester = vc
    1 tgt_restore_rrd = vc
    1 tgt_restore_printers = vc
    1 tgt_restore_interfaces = vc
    1 tgt_prim_server_set_name = vc
    1 tgt_sec_server_set_name = vc
    1 email_list = vc
    1 tgt_background_runners = i2
    1 src_ads_domain_ind = i2
    1 ads_config_name = vc
    1 ads_sort_field = vc
    1 ads_sort_value = vc
    1 tgt_opsexec_node_mapping = vc
    1 tgt_drop_tablespaces = vc
    1 tgt_retain_db_user_list = vc
    1 tgt_expimp_runners = i2
    1 src_sys_user = vc
    1 src_sys_pwd = vc
    1 tgt_db_temp_dir = vc
    1 src_db_temp_dir = vc
    1 tgt_db_oracle_home = vc
    1 tgt_system_pwd = vc
    1 tgt_db_oracle_ver = vc
    1 tgt_db_oracle_base = vc
    1 tgt_db_node = vc
    1 tgt_db_env_name = vc
    1 tgt_env_desc = vc
    1 tgt_storage_dg = vc
    1 tgt_recovery_dg = vc
    1 tgt_archive_dest1 = vc
    1 tgt_asm_sysdba_pwd = vc
    1 tgt_tns_host_name = vc
    1 tgt_tns_port = vc
    1 adm_tns_port = vc
    1 tgt_shell_ignorable_error_list = vc
    1 tgt_reapply_sched_templates = vc
    1 tgt_reapply_sched_templates_range = i4
    1 tgt_reapply_sched_templates_reset = vc
    1 tgt_apply_src_ed_registry = vc
    1 tgt_reg_ed_set_name = vc
    1 tgt_top_dir = vc
    1 tgt_cer_mgr_dir = vc
    1 tgt_cer_mgr_exe_dir = vc
    1 tgt_cer_mgr_log_dir = vc
    1 tgt_cer_reg_dir = vc
    1 tgt_cer_fifo_dir = vc
    1 tgt_cer_usock_dir = vc
    1 tgt_cer_lock_dir = vc
    1 tgt_wh_name = vc
    1 tgt_wh_dir = vc
    1 tgt_user_name = vc
    1 common_to_tgt = vc
    1 tgt_copy_interrogator = vc
    1 tgt_interrogator_tmp_dir = vc
    1 tgt_shared_pool_size = vc
    1 tgt_db_node_os = vc
    1 tgt_ibus_env_mapping = vc
    1 tgt_db_user_pwd_mapping = vc
    1 tgt_dp_dir_name = vc
    1 tgt_dp_dir_path = vc
    1 src_dp_dir_setup = vc
    1 src_dp_dir_name = vc
    1 src_dp_dir_path = vc
    1 tgt_restore_list = vc
    1 tgt_expimp_drr_shadow_tables = vc
    1 mode = vc
    1 src_db_env_name = vc
    1 tgt_db_create_type = vc
    1 tgt_dbca_template = vc
    1 tgt_case_sens_logon = vc
    1 tgt_sql92_security = vc
    1 tgt_characterset = vc
    1 tgt_error_prefix_list = vc
    1 adm_db_node = vc
    1 adm_storage_dg = vc
    1 adm_recovery_dg = vc
    1 tgt_drop_db_links = vc
    1 tgt_drop_expimp_dir = vc
    1 src_drop_expimp_dir = vc
    1 src_db_deploy_config = vc
    1 tgt_db_deploy_config = vc
    1 adm_db_deploy_config = vc
    1 tgt_tns_cnct_str = vc
    1 tgt_tns_mapping = vc
    1 tgt_tns_svc_name = vc
    1 tgt_default_misc_ts = vc
    1 tgt_default_temp_ts = vc
    1 adm_db_cred_nm = vc
    1 adm_db_link_host = vc
    1 adm_db_link_port = vc
    1 adm_db_link_svc_nm = vc
    1 adm_db_link_cnct_desc = vc
    1 tgt_db_adm_db_link_name = vc
    1 tgt_db_cred_nm = vc
    1 tgt_db_link_host = vc
    1 tgt_db_link_port = vc
    1 tgt_db_link_svc_nm = vc
    1 tgt_db_link_cnct_desc = vc
    1 src_db_cred_nm = vc
    1 src_db_link_host = vc
    1 src_db_link_port = vc
    1 src_db_link_svc_nm = vc
    1 src_db_link_cnct_desc = vc
    1 tgt_app_oracle_home = vc
    1 tgt_app_oracle_client_ver = vc
    1 tgt_app_dp_temp_dir = vc
    1 tgt_app_dp_node = vc
    1 dp_cred_name = vc
    1 dp_user = vc
    1 dp_user_pwd = vc
    1 dp_oos_dir_path = vc
  )
  CALL drrr_initialize_rf_data_rs(null)
 ENDIF
 IF (validate(drrr_misc_data->status_dir,"X")="X"
  AND validate(drrr_misc_data->status_dir,"Z")="Z")
  FREE RECORD drrr_misc_data
  RECORD drrr_misc_data(
    1 status_dir = vc
    1 status_file = vc
    1 response_file_dir = vc
    1 response_file_name = vc
    1 src_app_node_cnt = i4
    1 src_app_nodes[*]
      2 node_name = vc
    1 tgt_app_node_cnt = i4
    1 tgt_app_nodes[*]
      2 node_name = vc
    1 active_dir = vc
    1 process_mode = vc
    1 process_type = vc
    1 tgt_tspace_dg_cnt = i4
    1 tgt_tspace_dg[*]
      2 disk_group = vc
    1 tgt_opsexec_map_cnt = i4
    1 tgt_opsexec_map[*]
      2 src_node = vc
      2 tgt_node = vc
    1 tgt_retain_db_user_cnt = i4
    1 tgt_retain_db_users[*]
      2 user_name = vc
    1 tgt_shell_ign_error_cnt = i4
    1 tgt_shell_ign_errors[*]
      2 error_cd = vc
    1 process_id = f8
    1 event_id = f8
    1 tgt_ibus_env_map_cnt = i4
    1 tgt_ibus_env_map[*]
      2 src_ibus_env = vc
      2 tgt_ibus_env = vc
    1 tgt_db_user_pwd_map_cnt = i4
    1 tgt_db_user_pwd_map[*]
      2 user = vc
      2 pwd = vc
    1 tgt_restore_list_cnt = i4
    1 tgt_restore_list[*]
      2 restore_group = vc
      2 restore_ind = i2
    1 tgt_tns_map_cnt = i4
    1 tgt_tns_map[*]
      2 tns_entry = vc
      2 service_name = vc
      2 host = vc
      2 port = vc
  )
  CALL drrr_initialize_misc_data_rs(null)
 ENDIF
 IF ((validate(drrr_ftxt->txt_cnt,- (1))=- (1))
  AND (validate(drrr_ftxt->txt_cnt,- (2))=- (2)))
  FREE RECORD drrr_ftxt
  RECORD drrr_ftxt(
    1 txt_cnt = i4
    1 txt[*]
      2 txt_line = vc
  )
 ENDIF
 FREE RECORD drrr_raw_data
 RECORD drrr_raw_data(
   1 qual[*]
     2 item = vc
     2 itemx = vc
     2 type = vc
     2 item_value = vc
 )
 SUBROUTINE drrr_initialize_rf_data_rs(null)
   SET drrr_rf_data->responsefile_version = "DM2NOTSET"
   SET drrr_rf_data->client_mnemonic = "DM2NOTSET"
   SET drrr_rf_data->status_file = "DM2NOTSET"
   SET drrr_rf_data->target_refresh = "DM2NOTSET"
   SET drrr_rf_data->adm_db_user = "DM2NOTSET"
   SET drrr_rf_data->adm_db_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->adm_db_cnct_str = "DM2NOTSET"
   SET drrr_rf_data->adm_db_oracle_ver = "DM2NOTSET"
   SET drrr_rf_data->src_env_name = "DM2NOTSET"
   SET drrr_rf_data->src_domain_name = "DM2NOTSET"
   SET drrr_rf_data->src_db_user = "DM2NOTSET"
   SET drrr_rf_data->src_db_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->src_db_cnct_str = "DM2NOTSET"
   SET drrr_rf_data->src_db_name = "DM2NOTSET"
   SET drrr_rf_data->src_high_priv_user = "DM2NOTSET"
   SET drrr_rf_data->src_high_priv_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->src_app_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->src_app_node_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_copy_type = "DM2NOTSET"
   SET drrr_rf_data->tgt_env_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_domain_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_sys_user = "DM2NOTSET"
   SET drrr_rf_data->tgt_sys_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_user = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_cnct_str = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_cdb_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_cdb_cnct_str = "DM2NOTSET"
   SET drrr_rf_data->tgt_high_priv_user = "DM2NOTSET"
   SET drrr_rf_data->tgt_high_priv_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_prim_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_node_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_primary_app_node = "DM2NOTSET"
   SET drrr_rf_data->tgt_preserve_data = "DM2NOTSET"
   SET drrr_rf_data->tgt_backup_ccluserdir = "DM2NOTSET"
   SET drrr_rf_data->tgt_backup_warehouse = "DM2NOTSET"
   SET drrr_rf_data->tgt_capture_schema_date = "DM2NOTSET"
   SET drrr_rf_data->tgt_tspace_increase_pct = - (999)
   SET drrr_rf_data->tgt_tspace_dg_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_prim_server_set_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_sec_server_set_name = "DM2NOTSET"
   SET drrr_rf_data->email_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_background_runners = - (999)
   SET drrr_rf_data->src_ads_domain_ind = - (999)
   SET drrr_rf_data->ads_config_name = "DM2NOTSET"
   SET drrr_rf_data->ads_sort_field = "DM2NOTSET"
   SET drrr_rf_data->ads_sort_value = "DM2NOTSET"
   SET drrr_rf_data->tgt_opsexec_node_mapping = "DM2NOTSET"
   SET drrr_rf_data->tgt_drop_tablespaces = "DM2NOTSET"
   SET drrr_rf_data->tgt_retain_db_user_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_expimp_runners = - (999)
   SET drrr_rf_data->src_sys_user = "DM2NOTSET"
   SET drrr_rf_data->src_sys_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->src_db_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_oracle_home = "DM2NOTSET"
   SET drrr_rf_data->tgt_system_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_oracle_ver = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_oracle_base = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_node = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_env_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_env_desc = "DM2NOTSET"
   SET drrr_rf_data->tgt_storage_dg = "DM2NOTSET"
   SET drrr_rf_data->tgt_recovery_dg = "DM2NOTSET"
   SET drrr_rf_data->tgt_archive_dest1 = "DM2NOTSET"
   SET drrr_rf_data->tgt_asm_sysdba_pwd = "DM2NOTSET"
   SET drrr_rf_data->tgt_tns_host_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_tns_port = "DM2NOTSET"
   SET drrr_rf_data->adm_tns_port = "DM2NOTSET"
   SET drrr_rf_data->tgt_shell_ignorable_error_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_reapply_sched_templates = "DM2NOTSET"
   SET drrr_rf_data->tgt_reapply_sched_templates_range = - (999)
   SET drrr_rf_data->tgt_reapply_sched_templates_reset = "DM2NOTSET"
   SET drrr_rf_data->tgt_apply_src_ed_registry = "DM2NOTSET"
   SET drrr_rf_data->tgt_reg_ed_set_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_top_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_mgr_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_mgr_exe_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_mgr_log_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_reg_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_fifo_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_usock_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_cer_lock_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_wh_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_wh_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_user_name = "DM2NOTSET"
   SET drrr_rf_data->common_to_tgt = "DM2NOTSET"
   SET drrr_rf_data->tgt_shared_pool_size = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_node_os = "DM2NOTSET"
   SET drrr_rf_data->tgt_ibus_env_mapping = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_user_pwd_mapping = "DM2NOTSET"
   SET drrr_rf_data->tgt_dp_dir_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_dp_dir_path = "DM2NOTSET"
   SET drrr_rf_data->src_dp_dir_setup = "DM2NOTSET"
   SET drrr_rf_data->src_dp_dir_name = "DM2NOTSET"
   SET drrr_rf_data->src_dp_dir_path = "DM2NOTSET"
   SET drrr_rf_data->tgt_restore_list = "DM2NOTSET"
   SET drrr_rf_data->tgt_expimp_drr_shadow_tables = "DM2NOTSET"
   SET drrr_rf_data->mode = "DM2NOTSET"
   SET drrr_rf_data->src_db_env_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_create_type = "DM2NOTSET"
   SET drrr_rf_data->tgt_dbca_template = "DM2NOTSET"
   SET drrr_rf_data->tgt_case_sens_logon = "DM2NOTSET"
   SET drrr_rf_data->tgt_sql92_security = "DM2NOTSET"
   SET drrr_rf_data->tgt_characterset = "DM2NOTSET"
   SET drrr_rf_data->tgt_error_prefix_list = "DM2NOTSET"
   SET drrr_rf_data->adm_db_node = "DM2NOTSET"
   SET drrr_rf_data->adm_storage_dg = "DM2NOTSET"
   SET drrr_rf_data->adm_recovery_dg = "DM2NOTSET"
   SET drrr_rf_data->tgt_drop_db_links = "DM2NOTSET"
   SET drrr_rf_data->tgt_drop_expimp_dir = "DM2NOTSET"
   SET drrr_rf_data->src_drop_expimp_dir = "DM2NOTSET"
   SET drrr_rf_data->src_db_deploy_config = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_deploy_config = "DM2NOTSET"
   SET drrr_rf_data->adm_db_deploy_config = "DM2NOTSET"
   SET drrr_rf_data->tgt_tns_mapping = "DM2NOTSET"
   SET drrr_rf_data->tgt_tns_cnct_str = "DM2NOTSET"
   SET drrr_rf_data->tgt_tns_svc_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_default_misc_ts = "DM2NOTSET"
   SET drrr_rf_data->tgt_default_temp_ts = "DM2NOTSET"
   SET drrr_rf_data->adm_db_cred_nm = "DM2NOTSET"
   SET drrr_rf_data->adm_db_link_host = "DM2NOTSET"
   SET drrr_rf_data->adm_db_link_port = "DM2NOTSET"
   SET drrr_rf_data->adm_db_link_svc_nm = "DM2NOTSET"
   SET drrr_rf_data->adm_db_link_cnct_desc = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_adm_db_link_name = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_cred_nm = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_link_host = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_link_port = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_link_svc_nm = "DM2NOTSET"
   SET drrr_rf_data->tgt_db_link_cnct_desc = "DM2NOTSET"
   SET drrr_rf_data->src_db_cred_nm = "DM2NOTSET"
   SET drrr_rf_data->src_db_link_host = "DM2NOTSET"
   SET drrr_rf_data->src_db_link_port = "DM2NOTSET"
   SET drrr_rf_data->src_db_link_svc_nm = "DM2NOTSET"
   SET drrr_rf_data->src_db_link_cnct_desc = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_oracle_home = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_oracle_client_ver = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_dp_temp_dir = "DM2NOTSET"
   SET drrr_rf_data->tgt_app_dp_node = "DM2NOTSET"
   SET drrr_rf_data->dp_cred_name = "DM2NOTSET"
   SET drrr_rf_data->dp_user = "DM2NOTSET"
   SET drrr_rf_data->dp_user_pwd = "DM2NOTSET"
   SET drrr_rf_data->dp_oos_dir_path = "DM2NOTSET"
 END ;Subroutine
 SUBROUTINE drrr_initialize_misc_data_rs(null)
   SET drrr_misc_data->status_dir = "DM2NOTSET"
   SET drrr_misc_data->status_file = "DM2NOTSET"
   SET drrr_misc_data->response_file_dir = "DM2NOTSET"
   SET drrr_misc_data->response_file_name = "DM2NOTSET"
   SET drrr_misc_data->src_app_node_cnt = 0
   SET stat = alterlist(drrr_misc_data->src_app_nodes,0)
   SET drrr_misc_data->tgt_app_node_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_app_nodes,0)
   SET drrr_misc_data->active_dir = "DM2NOTSET"
   SET drrr_misc_data->process_mode = "DM2NOTSET"
   SET drrr_misc_data->process_type = "DM2NOTSET"
   SET drrr_misc_data->tgt_tspace_dg_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_tspace_dg,0)
   SET drrr_misc_data->tgt_opsexec_map_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_opsexec_map,0)
   SET drrr_misc_data->tgt_retain_db_user_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_retain_db_users,0)
   SET drrr_misc_data->tgt_shell_ign_error_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_shell_ign_errors,0)
   SET drrr_misc_data->process_id = 0.0
   SET drrr_misc_data->event_id = 0.0
   SET drrr_misc_data->tgt_ibus_env_map_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_ibus_env_map,0)
   SET drrr_misc_data->tgt_db_user_pwd_map_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_db_user_pwd_map,0)
   SET drrr_misc_data->tgt_restore_list_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_restore_list,0)
   SET drrr_misc_data->tgt_tns_map_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_tns_map,0)
 END ;Subroutine
 SUBROUTINE drrr_load_rf_data_rs(dldr_in_file,dldr_mode)
   DECLARE dldr_cnt = i4 WITH protect, noconstant(0)
   DECLARE dldr_rf_dir = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dldr_rf_name = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dldr_dir_found_ind = i2 WITH protect, noconstant(0)
   DECLARE dldr_tmp_rs_item = vc WITH protect, noconstant("")
   DECLARE dldr_tmp_rs_item_value = vc WITH protect, noconstant("")
   DECLARE dldr_item_name = vc WITH protect, noconstant("")
   DECLARE dldr_process_item = i2 WITH protect, noconstant(0)
   SET drrr_misc_data->response_file_dir = "DM2NOTSET"
   SET drrr_misc_data->response_file_name = "DM2NOTSET"
   IF (dm2_findfile(dldr_in_file)=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file exists:  ",dldr_in_file)
    SET dm_err->emsg = "Response file not found."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (findstring("/",dldr_in_file,1,0)=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file: ",dldr_in_file)
    SET dm_err->emsg = "Response file requires both directory and file name."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET dldr_rf_dir = build(cnvtlower(substring(1,(findstring("/",dldr_in_file,1,1) - 1),dldr_in_file
       )),"/")
    SET dldr_rf_name = cnvtlower(trim(substring((findstring("/",dldr_in_file,1,1)+ 1),(size(
        dldr_in_file) - findstring("=",dldr_in_file,1,0)),dldr_in_file),3))
    SET dldr_dir_found_ind = 0
    SET dldr_dir_found_ind = dm2_find_dir(dldr_rf_dir)
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
    IF (dldr_dir_found_ind=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file : ",dldr_in_file)
     SET dm_err->emsg = concat("Response file directory (",trim(dldr_rf_dir,3),") not found.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((dldr_rf_name="DM2NOTSET") OR (size(trim(dldr_rf_name,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file : ",dldr_in_file)
     SET dm_err->emsg = concat("Response file name (",trim(dldr_rf_name,3),") not set.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_misc_data->response_file_dir = dldr_rf_dir
    SET drrr_misc_data->response_file_name = dldr_rf_name
   ENDIF
   SET dm_err->eproc = "Accessing response file..."
   CALL disp_msg(" ",dm_err->logfile,0)
   FREE SET dldr_response_file
   SET logical dldr_response_file dldr_in_file
   FREE DEFINE rtl3
   DEFINE rtl3 "dldr_response_file"
   SELECT INTO "nl:"
    t.line
    FROM rtl3t t
    WHERE t.line > " "
    DETAIL
     IF (trim(t.line) > ""
      AND trim(substring(1,1,trim(t.line)),3) != "#")
      dldr_tmp_rs_item = trim(cnvtlower(substring(1,(findstring("=",t.line,1,0) - 1),t.line)),3),
      dldr_tmp_rs_item_value = trim(substring((findstring("=",t.line,1,0)+ 1),(size(t.line) -
        findstring("=",t.line,1,0)),t.line),3)
      IF (substring(1,3,dldr_tmp_rs_item)="sl_")
       IF (findstring("{",dldr_tmp_rs_item_value,1,0) > 0
        AND findstring("}",dldr_tmp_rs_item_value,1,0) > 0
        AND findstring('"',dldr_tmp_rs_item_value,1,0) > 0
        AND findstring('"',dldr_tmp_rs_item_value,1,0) != findstring('"',dldr_tmp_rs_item_value,1,1))
        dldr_cnt = (dldr_cnt+ 1), stat = alterlist(drrr_raw_data->qual,dldr_cnt), drrr_raw_data->
        qual[dldr_cnt].item = dldr_tmp_rs_item,
        drrr_raw_data->qual[dldr_cnt].item_value = dldr_tmp_rs_item_value, drrr_raw_data->qual[
        dldr_cnt].type = "STRINGLIST", drrr_raw_data->qual[dldr_cnt].item_value = replace(
         drrr_raw_data->qual[dldr_cnt].item_value,"{","^",0),
        drrr_raw_data->qual[dldr_cnt].item_value = replace(drrr_raw_data->qual[dldr_cnt].item_value,
         "}","^",0), drrr_raw_data->qual[dldr_cnt].itemx = trim(replace(drrr_raw_data->qual[dldr_cnt]
          .item,"sl_","",1),3)
       ENDIF
      ELSEIF (substring(1,4,dldr_tmp_rs_item)="slp_")
       IF (findstring('"',dldr_tmp_rs_item_value,1,0) > 0)
        dldr_cnt = (dldr_cnt+ 1), stat = alterlist(drrr_raw_data->qual,dldr_cnt), drrr_raw_data->
        qual[dldr_cnt].item = dldr_tmp_rs_item,
        drrr_raw_data->qual[dldr_cnt].item_value = dldr_tmp_rs_item_value, drrr_raw_data->qual[
        dldr_cnt].type = "STRINGLIST", drrr_raw_data->qual[dldr_cnt].item_value = replace(
         drrr_raw_data->qual[dldr_cnt].item_value,'"'," <=CERNd=>",0),
        drrr_raw_data->qual[dldr_cnt].item_value = build('"',drrr_raw_data->qual[dldr_cnt].item_value,
         '"'), drrr_raw_data->qual[dldr_cnt].itemx = trim(replace(drrr_raw_data->qual[dldr_cnt].item,
          "slp_","",1),3)
       ENDIF
      ELSEIF (((substring(1,2,dldr_tmp_rs_item)="s_") OR (substring(1,5,dldr_tmp_rs_item)="clog_")) )
       IF (findstring('"',dldr_tmp_rs_item_value,1,0) > 0
        AND findstring('"',dldr_tmp_rs_item_value,1,0) != findstring('"',dldr_tmp_rs_item_value,1,1))
        dldr_cnt = (dldr_cnt+ 1), stat = alterlist(drrr_raw_data->qual,dldr_cnt), drrr_raw_data->
        qual[dldr_cnt].item = dldr_tmp_rs_item,
        drrr_raw_data->qual[dldr_cnt].item_value = dldr_tmp_rs_item_value, drrr_raw_data->qual[
        dldr_cnt].type = "STRING", drrr_raw_data->qual[dldr_cnt].itemx = trim(replace(drrr_raw_data->
          qual[dldr_cnt].item,"s_","",1),3)
       ENDIF
      ELSEIF (substring(1,2,dldr_tmp_rs_item)="n_")
       dldr_cnt = (dldr_cnt+ 1), stat = alterlist(drrr_raw_data->qual,dldr_cnt), drrr_raw_data->qual[
       dldr_cnt].item = dldr_tmp_rs_item,
       drrr_raw_data->qual[dldr_cnt].item_value = dldr_tmp_rs_item_value, drrr_raw_data->qual[
       dldr_cnt].type = "NUMBER", drrr_raw_data->qual[dldr_cnt].itemx = trim(replace(drrr_raw_data->
         qual[dldr_cnt].item,"n_","",1),3)
      ELSEIF (substring(1,2,dldr_tmp_rs_item)="b_")
       dldr_cnt = (dldr_cnt+ 1), stat = alterlist(drrr_raw_data->qual,dldr_cnt), drrr_raw_data->qual[
       dldr_cnt].item = dldr_tmp_rs_item,
       drrr_raw_data->qual[dldr_cnt].item_value = dldr_tmp_rs_item_value, drrr_raw_data->qual[
       dldr_cnt].type = "BOOLEAN", drrr_raw_data->qual[dldr_cnt].itemx = trim(replace(drrr_raw_data->
         qual[dldr_cnt].item,"b_","",1),3)
      ENDIF
     ENDIF
    WITH nocounter
   ;end select
   FREE SET dldr_response_file
   FREE DEFINE rtl3
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drrr_raw_data)
   ENDIF
   IF (dldr_cnt=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file content:  ",dldr_in_file)
    SET dm_err->emsg = "Response file does not contain any data."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dldr_mode="INITIAL_LOAD")
    RETURN(1)
   ENDIF
   SET dldr_cnt = 0
   FOR (dldr_cnt = 1 TO size(drrr_raw_data->qual,5))
     SET dldr_item_name = build("drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx)
     SET dldr_process_item = 1
     IF ((drrr_raw_data->qual[dldr_cnt].type IN ("STRINGLIST", "STRING")))
      IF (validate(parser(dldr_item_name),"X")="X"
       AND validate(parser(dldr_item_name),"Z")="Z")
       SET dldr_process_item = 0
       IF ((dm_err->debug_flag > 0))
        CALL echo(concat("Record item ",build(dldr_item_name)," not found in structure.  Skipping."))
       ENDIF
      ENDIF
     ELSE
      IF (validate(parser(dldr_item_name),1)=1
       AND validate(parser(dldr_item_name),2)=2)
       SET dldr_process_item = 0
       IF ((dm_err->debug_flag > 0))
        CALL echo(concat("Record item ",build(dldr_item_name)," not found in structure.  Skipping."))
       ENDIF
      ENDIF
     ENDIF
     IF (dldr_process_item=1)
      IF ((drrr_raw_data->qual[dldr_cnt].type="BOOLEAN"))
       IF (cnvtupper(drrr_raw_data->qual[dldr_cnt].item_value)="TRUE")
        IF ((dm_err->debug_flag > 0))
         CALL echo(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = 1 go"))
        ENDIF
        CALL parser(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].temx," = 1 go"),1)
       ELSEIF (cnvtupper(drrr_raw_data->qual[dldr_cnt].item_value)="FALSE")
        IF ((dm_err->debug_flag > 0))
         CALL echo(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = 0 go"))
        ENDIF
        CALL parser(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = 0 go"),1)
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file data:  ",drrr_raw_data->qual[dldr_cnt].
         item)
        SET dm_err->emsg = "Token is BOOLEAN data_type but does not have value of true/false."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        SET dldr_cnt = size(drrr_raw_data->qual,5)
       ENDIF
      ELSEIF ((drrr_raw_data->qual[dldr_cnt].type="NUMBER"))
       IF ((dm_err->debug_flag > 0))
        CALL echo(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = ",drrr_raw_data
          ->qual[dldr_cnt].item_value," go"))
       ENDIF
       IF (isnumeric(drrr_raw_data->qual[dldr_cnt].item_value) != 1
        AND cnvtupper(drrr_raw_data->qual[dldr_cnt].item_value) != "*VALUE*UNSPECIFIED*")
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file data:  ",drrr_raw_data->qual[dldr_cnt].
         item)
        SET dm_err->emsg =
        "Token is NUMBER data_type but does not have numeric token value (token required)."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        SET dldr_cnt = size(drrr_raw_data->qual,5)
       ENDIF
       IF (cnvtupper(drrr_raw_data->qual[dldr_cnt].item_value)="*VALUE*UNSPECIFIED*")
        CALL parser(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = -999 go"),1)
       ELSE
        CALL parser(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = ",
          drrr_raw_data->qual[dldr_cnt].item_value," go"),1)
       ENDIF
      ELSE
       IF ((dm_err->debug_flag > 0))
        CALL echo(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = ",drrr_raw_data
          ->qual[dldr_cnt].item_value," go"))
       ENDIF
       CALL parser(concat("set drrr_rf_data->",drrr_raw_data->qual[dldr_cnt].itemx," = ",
         drrr_raw_data->qual[dldr_cnt].item_value," go"),1)
      ENDIF
     ENDIF
   ENDFOR
   IF (check_error(dm_err->eproc) != 0)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drrr_rf_data)
    CALL echorecord(drrr_misc_data)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_version(null)
   DECLARE dvrv_rf_template_name = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dvrv_rf_template_version = vc WITH protect, noconstant("DM2NOTSET")
   IF ((((drrr_rf_data->responsefile_version="DM2NOTSET")) OR (size(trim(drrr_rf_data->
     responsefile_version,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file version: ",drrr_rf_data->
     responsefile_version)
    SET dm_err->emsg = "Response file version not set."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET dvrv_rf_template_name = build(dm2_install_schema->cer_install,"dm2_rr_resp_file_template.txt"
     )
    IF (dm2_findfile(dvrv_rf_template_name)=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file template exists:  ",dvrv_rf_template_name)
     SET dm_err->emsg = "Response file template not found."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dm_err->eproc = "Accessing response file template to retrieve version..."
    CALL disp_msg(" ",dm_err->logfile,0)
    FREE SET dldr_rf_template
    SET logical dldr_rf_template dvrv_rf_template_name
    FREE DEFINE rtl3
    DEFINE rtl3 "dldr_rf_template"
    SELECT INTO "nl:"
     t.line
     FROM rtl3t t
     WHERE t.line="*RESPONSEFILE_VERSION*"
     DETAIL
      IF (cnvtupper(substring(1,22,trim(t.line)))="S_RESPONSEFILE_VERSION")
       dvrv_rf_template_version = trim(substring((findstring("=",t.line,1,0)+ 1),(size(t.line) -
         findstring("=",t.line,1,0)),t.line),3), dvrv_rf_template_version = replace(
        dvrv_rf_template_version,'"',"",0)
      ENDIF
     WITH nocounter
    ;end select
    FREE SET dldr_rp_template
    FREE DEFINE rtl3
    IF (check_error(dm_err->eproc) != 0)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("Template version:  ",dvrv_rf_template_version))
    ENDIF
    IF (((dvrv_rf_template_version="DM2NOTSET") OR (size(trim(dvrv_rf_template_version,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file template version: ",
      dvrv_rf_template_version)
     SET dm_err->emsg = "Response file template version not set."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ELSEIF ((drrr_rf_data->responsefile_version != dvrv_rf_template_version))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file template version: ",
      dvrv_rf_template_version)
     SET dm_err->emsg = concat("Response file version (",trim(drrr_rf_data->responsefile_version,3),
      ") does not match template version (",trim(dvrv_rf_template_version,3),").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_status_file(dvrsf_status_file_in)
   DECLARE dvrsf_status_dir = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dvrsf_status_file = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dvrsf_dir_found_ind = i2 WITH protect, noconstant(0)
   SET drrr_misc_data->status_dir = "DM2NOTSET"
   SET drrr_misc_data->status_file = "DM2NOTSET"
   IF (((dvrsf_status_file_in="DM2NOTSET") OR (size(trim(dvrsf_status_file_in,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating STATUS_FILE: ",dvrsf_status_file_in)
    SET dm_err->emsg = "Response file status directory/file not set."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF (findstring("/",dvrsf_status_file_in,1,0)=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating STATUS_FILE: ",dvrsf_status_file_in)
    SET dm_err->emsg = "Status file requires both directory and file name."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    IF (textlen(dvrsf_status_file_in) > 200)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating STATUS_FILE: ",dvrsf_status_file_in)
     SET dm_err->emsg = concat("Full path of status file should not exceed 200 characters.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dvrsf_status_dir = build(cnvtlower(substring(1,(findstring("/",dvrsf_status_file_in,1,1) - 1),
       dvrsf_status_file_in)),"/")
    SET dvrsf_status_file = cnvtlower(trim(substring((findstring("/",dvrsf_status_file_in,1,1)+ 1),(
       size(dvrsf_status_file_in) - findstring("=",dvrsf_status_file_in,1,0)),dvrsf_status_file_in),3
      ))
    SET dvrsf_dir_found_ind = 0
    SET dvrsf_dir_found_ind = dm2_find_dir(dvrsf_status_dir)
    IF ((dm_err->err_ind > 0))
     RETURN(0)
    ENDIF
    IF (dvrsf_dir_found_ind=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating STATUS_FILE: ",dvrsf_status_file_in)
     SET dm_err->emsg = concat("STATUS_FILE directory (",trim(dvrsf_status_dir,3),") not found.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((dvrsf_status_file="DM2NOTSET") OR (size(trim(dvrsf_status_file,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating STATUS_FILE: ",dvrsf_status_file_in)
     SET dm_err->emsg = concat("STATUS_FILE name (",trim(dvrsf_status_file,3),") not set.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (dm2_findfile(dvrsf_status_file_in) > 0)
     SET dm_err->eproc = concat("Remove: ",dvrsf_status_file_in)
     IF ((dm_err->debug_flag > 0))
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
     IF (dm2_push_dcl(concat("rm ",dvrsf_status_file_in))=0)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   SET drrr_misc_data->status_dir = dvrsf_status_dir
   SET drrr_misc_data->status_file = dvrsf_status_file
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_add_text(dat_in_txt,dat_in_reset_ind)
   IF (dat_in_reset_ind=1)
    SET drrr_ftxt->txt_cnt = 1
    SET stat = alterlist(drrr_ftxt->txt,1)
    SET drrr_ftxt->txt[drrr_ftxt->txt_cnt].txt_line = dat_in_txt
   ELSE
    SET drrr_ftxt->txt_cnt = (drrr_ftxt->txt_cnt+ 1)
    SET stat = alterlist(drrr_ftxt->txt,drrr_ftxt->txt_cnt)
    SET drrr_ftxt->txt[drrr_ftxt->txt_cnt].txt_line = dat_in_txt
   ENDIF
 END ;Subroutine
 SUBROUTINE drrr_create_text_file(dctf_in_fname)
   DECLARE dctf_cnt = i4 WITH protect, noconstant(0)
   SET dm_err->eproc = concat("Writing ",trim(dctf_in_fname)," file.")
   CALL disp_msg(" ",dm_err->logfile,0)
   SELECT INTO value(dctf_in_fname)
    FROM (dummyt d  WITH seq = value(drrr_ftxt->txt_cnt))
    DETAIL
     CALL print(substring(1,4000,drrr_ftxt->txt[d.seq].txt_line)), row + 1
    WITH nocounter, format = variable, formfeed = none,
     maxrow = 1, maxcol = 5000
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,dm_err->err_ind)
    RETURN(0)
   ENDIF
   CALL drrr_add_text(" ",1)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_client_mnemonic(null)
  IF (((cnvtupper(drrr_rf_data->client_mnemonic) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
  "DM2NOTSET")) OR (size(trim(drrr_rf_data->client_mnemonic,3))=0)) )
   SET dm_err->err_ind = 1
   SET dm_err->eproc = concat("Validating response file CLIENT_MNEMONIC: ",drrr_rf_data->
    client_mnemonic)
   SET dm_err->emsg = "Response file CLIENT_MNEMONIC must be set to a specific value."
   CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
   RETURN(0)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_target_refresh(null)
   IF ( NOT (cnvtupper(drrr_rf_data->target_refresh) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file TARGET_REFRESH: ",drrr_rf_data->
     target_refresh)
    SET dm_err->emsg = 'Response file TARGET_REFRESH must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->target_refresh = cnvtupper(drrr_rf_data->target_refresh)
   SET drrr_misc_data->process_type = evaluate(drrr_rf_data->target_refresh,"YES","REFRESH",
    "REPLICATE")
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_copy_type(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_db_copy_type) IN ("ALTERNATE", "REFERENCE", "ALL", "ADS")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file TGT_DB_COPY_TYPE: ",drrr_rf_data->
     tgt_db_copy_type)
    SET dm_err->emsg =
    'Response file TGT_DB_COPY_TYPE must be equal to "ALTERNATE", "REFERENCE", "ALL" or "ADS".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_db_copy_type = cnvtupper(drrr_rf_data->tgt_db_copy_type)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_ads(null)
   IF ( NOT (cnvtupper(drrr_rf_data->ads_sort_field) IN ("TABLE NAME", "DRIVER TABLE NAME",
   "SAMPLE METHOD", "TABLESPACE NAME", "SOURCE NUM ROWS",
   "TARGET NUM ROWS", "TGT/SRC PERCENT")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file ADS_SORT_FIELD: ",drrr_rf_data->
     ads_sort_field)
    SET dm_err->emsg = "Response file ADS_SORT_FIELD is not valid."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->ads_sort_field = cnvtupper(drrr_rf_data->ads_sort_field)
   IF ( NOT (cnvtupper(drrr_rf_data->ads_sort_value) IN ("ASC", "DESC")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file ADS_SORT_VALUE: ",drrr_rf_data->
     ads_sort_value)
    SET dm_err->emsg = "Response file ADS_SORT_VALUE is not valid."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->ads_sort_value = cnvtupper(drrr_rf_data->ads_sort_value)
   IF ( NOT ((drrr_rf_data->src_ads_domain_ind IN (0, 1))))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = build("Validating response file SRC_ADS_DOMAIN_IND: ",drrr_rf_data->
     src_ads_domain_ind)
    SET dm_err->emsg = "Response file SRC_ADS_DOMAIN_IND is not valid."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->ads_config_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->ads_config_name,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file ADS config name: ",drrr_rf_data->
     ads_config_name)
    SET dm_err->emsg =
    "Response file ADS config name (ADS_CONFIG_NAME) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_adm_cnnct_data(dvracd_in_cnct_to_db_ind)
   IF (cnvtupper(drrr_rf_data->adm_db_user) != "CDBA")
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file admin database user: ",drrr_rf_data->
     adm_db_user)
    SET dm_err->emsg = "Response file admin database user (ADM_DB_USER) must be set to CDBA."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_user_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_user_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file admin database user password: ",drrr_rf_data
     ->adm_db_user_pwd)
    SET dm_err->emsg =
    "Response file admin database user password (ADM_DB_USER_PWD) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_cnct_str,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file admin database connect string: ",
     drrr_rf_data->adm_db_cnct_str)
    SET dm_err->emsg =
    "Response file admin database connect string (ADM_DB_CNCT_STR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_oracle_ver) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_oracle_ver,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file admin database oracle version: ",
     drrr_rf_data->adm_db_oracle_ver)
    SET dm_err->emsg =
    "Response file admin database oracle version (ADM_DB_ORACLE_VER) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dvracd_in_cnct_to_db_ind=1)
    SET dm2_install_schema->u_name = drrr_rf_data->adm_db_user
    SET dm2_install_schema->p_word = drrr_rf_data->adm_db_user_pwd
    SET dm2_install_schema->connect_str = drrr_rf_data->adm_db_cnct_str
    SET dm2_install_schema->dbase_name = '"ADMIN"'
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_cnnct_data(dvrscd_in_cnct_to_db_ind)
   IF (cnvtupper(drrr_rf_data->src_db_user) != "V500")
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source database user: ",drrr_rf_data->
     src_db_user)
    SET dm_err->emsg = "Response file source database user (SRC_DB_USER) must be set to V500."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_user_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_user_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source database user password: ",
     drrr_rf_data->src_db_user_pwd)
    SET dm_err->emsg =
    "Response file source database user password (SRC_DB_USER_PWD) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_cnct_str,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source database connect string: ",
     drrr_rf_data->src_db_cnct_str)
    SET dm_err->emsg =
    "Response file source database connect string (SRC_DB_CNCT_STR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_name,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source database name: ",drrr_rf_data->
     src_db_name)
    SET dm_err->emsg =
    "Response file source database name (SRC_DB_NAME) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dvrscd_in_cnct_to_db_ind=1)
    SET dm2_install_schema->u_name = drrr_rf_data->src_db_user
    SET dm2_install_schema->p_word = drrr_rf_data->src_db_user_pwd
    SET dm2_install_schema->connect_str = drrr_rf_data->src_db_cnct_str
    SET dm2_install_schema->dbase_name = '"SOURCE"'
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (cnvtupper(currdbname) != cnvtupper(drrr_rf_data->src_db_name))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file source database name: ",drrr_rf_data->
      src_db_name)
     SET dm_err->emsg = concat(
      "Response file source database name (SRC_DB_NAME) does not match db name after connection (",
      trim(currdbname,3),").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_high_priv_user(null)
   IF (((cnvtupper(drrr_rf_data->src_high_priv_user) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_high_priv_user,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source high priv user: ",drrr_rf_data->
     src_high_priv_user)
    SET dm_err->emsg =
    "Response file source high priv user (SRC_HIGH_PRIV_USER) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_high_priv_user_pwd) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_high_priv_user_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source high priv user password: ",
     drrr_rf_data->src_high_priv_user_pwd)
    SET dm_err->emsg =
    "Response file source high priv user password (SRC_HIGH_PRIV_USER_PWD) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_env_name(null)
  IF (((cnvtupper(drrr_rf_data->src_env_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
  "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_env_name,3))=0)) )
   SET dm_err->err_ind = 1
   SET dm_err->eproc = concat("Validating response file source environment name: ",drrr_rf_data->
    src_env_name)
   SET dm_err->emsg =
   "Response file source environment name (SRC_ENV_NAME) must be set to a specific value."
   CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
   RETURN(0)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_domain_name(null)
  IF (((cnvtupper(drrr_rf_data->src_domain_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
  "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_domain_name,3))=0)) )
   SET dm_err->err_ind = 1
   SET dm_err->eproc = concat("Validating response file source domain name: ",drrr_rf_data->
    src_domain_name)
   SET dm_err->emsg =
   "Response file source domain name (SRC_DOMAIN_NAME) must be set to a specific value."
   CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
   RETURN(0)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_app_node_list(null)
   DECLARE dvrsanl_str = vc WITH protect, noconstant("")
   DECLARE dvrsanl_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrsanl_num = i4 WITH protect, noconstant(1)
   DECLARE dvrsanl_tmp_node = vc WITH protect, noconstant("")
   SET drrr_misc_data->src_app_node_cnt = 0
   SET stat = alterlist(drrr_misc_data->src_app_nodes,0)
   IF (((cnvtupper(drrr_rf_data->src_app_node_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_app_node_list,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source app node list: ",drrr_rf_data->
     src_app_node_list)
    SET dm_err->emsg =
    "Response file source app node list (SRC_APP_NODE_LIST) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    WHILE (dvrsanl_str != dvrsanl_notfnd)
     SET dvrsanl_str = piece(drrr_rf_data->src_app_node_list,",",dvrsanl_num,dvrsanl_notfnd)
     IF (dvrsanl_str != dvrsanl_notfnd)
      IF (findstring('"',dvrsanl_str,1,0) != findstring('"',dvrsanl_str,1,1))
       SET dvrsanl_tmp_node = cnvtlower(trim(replace(dvrsanl_str,'"',"",0),3))
       IF (size(trim(dvrsanl_tmp_node,3)) > 0)
        SET drrr_misc_data->src_app_node_cnt = (drrr_misc_data->src_app_node_cnt+ 1)
        SET stat = alterlist(drrr_misc_data->src_app_nodes,drrr_misc_data->src_app_node_cnt)
        SET drrr_misc_data->src_app_nodes[drrr_misc_data->src_app_node_cnt].node_name =
        dvrsanl_tmp_node
        SET dvrsanl_num = (dvrsanl_num+ 1)
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file source app node list (SRC_APP_NODE_LIST): ",drrr_rf_data->
         src_app_node_list)
        SET dm_err->emsg = concat("Individual node name in position ",trim(cnvtstring(dvrsanl_num),3),
         " not properly set.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file source app node list (SRC_APP_NODE_LIST): ",drrr_rf_data->
        src_app_node_list)
       SET dm_err->emsg = concat("Individual node name (",trim(dvrsanl_str,3),
        ") not wrapped in double-quotes.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDWHILE
    IF ((drrr_misc_data->src_app_node_cnt=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file source app node list (SRC_APP_NODE_LIST): ",
      drrr_rf_data->src_app_node_list)
     SET dm_err->emsg = "Node name(s) not loaded into memory."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_sys_cnnct_data(dvrtscd_in_cnct_to_db_ind)
   IF (((cnvtupper(drrr_rf_data->tgt_sys_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_sys_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target SYS password: ",drrr_rf_data->
     tgt_sys_pwd)
    SET dm_err->emsg = "Response file target SYS password must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_system_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_system_pwd,3))=0
    AND (drrr_rf_data->tgt_db_deploy_config != "ADB"))) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target SYSTEM password: ",drrr_rf_data->
     tgt_system_pwd)
    SET dm_err->emsg = "Response file target SYSTEM password must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_cnct_str,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database connect string: ",
     drrr_rf_data->tgt_db_cnct_str)
    SET dm_err->emsg =
    "Response file target database connect string must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_name,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database name: ",drrr_rf_data->
     tgt_db_name)
    SET dm_err->emsg = "Response file target database name must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_db_deploy_config) IN ("OP", "OCI"))
    SET drrr_rf_data->tgt_sys_user = "SYS"
   ELSE
    SET drrr_rf_data->tgt_sys_user = "ADMIN"
   ENDIF
   IF (dvrtscd_in_cnct_to_db_ind=1)
    SET dm2_install_schema->u_name = drrr_rf_data->tgt_sys_user
    SET dm2_install_schema->p_word = drrr_rf_data->tgt_sys_pwd
    SET dm2_install_schema->connect_str = drrr_rf_data->tgt_db_cnct_str
    SET dm2_install_schema->dbase_name = '"TARGET"'
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (cnvtupper(currdbname) != cnvtupper(drrr_rf_data->tgt_db_name))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target database name: ",drrr_rf_data->
      tgt_db_name)
     SET dm_err->emsg = concat(
      "Response file target database name does not match db name after connection (",trim(currdbname,
       3),") using SYS user.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_db_deploy_config != "ADB"))
     SET dm2_install_schema->u_name = "SYSTEM"
     SET dm2_install_schema->p_word = drrr_rf_data->tgt_system_pwd
     SET dm2_install_schema->connect_str = drrr_rf_data->tgt_db_cnct_str
     SET dm2_install_schema->dbase_name = '"TARGET"'
     EXECUTE dm2_connect_to_dbase "CO"
     IF ((dm_err->err_ind=1))
      RETURN(0)
     ENDIF
     IF (cnvtupper(currdbname) != cnvtupper(drrr_rf_data->tgt_db_name))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating response file target database name: ",drrr_rf_data->
       tgt_db_name)
      SET dm_err->emsg = concat(
       "Response file target database name does not match db name after connection (",trim(currdbname,
        3),") using SYSTEM user.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_cnnct_data(dvrtcd_in_cnct_to_db_ind)
   IF (cnvtupper(drrr_rf_data->tgt_db_user) != "V500")
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database user: ",drrr_rf_data->
     tgt_db_user)
    SET dm_err->emsg = "Response file target database user must be set to V500."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_user_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_user_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database user password: ",
     drrr_rf_data->tgt_db_user_pwd)
    SET dm_err->emsg = "Response file target database user password must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_cnct_str,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database connect string: ",
     drrr_rf_data->tgt_db_cnct_str)
    SET dm_err->emsg =
    "Response file target database connect string must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_name,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target database name: ",drrr_rf_data->
     tgt_db_name)
    SET dm_err->emsg = "Response file target database name must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((((drrr_rf_data->tgt_db_oracle_ver=patstring("12.*"))) OR ((drrr_rf_data->tgt_db_oracle_ver=
   patstring("19*")))) )
    IF (((cnvtupper(drrr_rf_data->tgt_cdb_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cdb_name,3))=0))
     AND (drrr_rf_data->tgt_db_deploy_config != "ADB"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target cdb name: ",drrr_rf_data->
      tgt_cdb_name)
     SET dm_err->emsg = "Response file target cdb name must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF ((((drrr_rf_data->tgt_db_oracle_ver=patstring("12.*"))) OR ((drrr_rf_data->tgt_db_oracle_ver=
   patstring("19*")))) )
    IF (((cnvtupper(drrr_rf_data->tgt_cdb_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cdb_cnct_str,3))=0))
     AND (drrr_rf_data->tgt_db_deploy_config != "ADB"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target container database connect string: ",
      drrr_rf_data->tgt_cdb_cnct_str)
     SET dm_err->emsg =
     "Response file target container database connect string must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (dvrtcd_in_cnct_to_db_ind=1)
    SET dm2_install_schema->u_name = drrr_rf_data->tgt_db_user
    SET dm2_install_schema->p_word = drrr_rf_data->tgt_db_user_pwd
    SET dm2_install_schema->connect_str = drrr_rf_data->tgt_db_cnct_str
    SET dm2_install_schema->dbase_name = '"TARGET"'
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (cnvtupper(currdbname) != cnvtupper(drrr_rf_data->tgt_db_name))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target database name: ",drrr_rf_data->
      tgt_db_name)
     SET dm_err->emsg = concat(
      "Response file target database name does not match db name after connection (",trim(currdbname,
       3),").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_high_priv_user(null)
   IF (((cnvtupper(drrr_rf_data->tgt_high_priv_user) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_high_priv_user,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target high priv user: ",drrr_rf_data->
     tgt_high_priv_user)
    SET dm_err->emsg =
    "Response file target high priv user (TGT_HIGH_PRIV_USER) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_high_priv_user_pwd) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_high_priv_user_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target high priv user password: ",
     drrr_rf_data->tgt_high_priv_user_pwd)
    SET dm_err->emsg =
    "Response file target high priv user password (TGT_HIGH_PRIV_USER_PWD) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_high_priv_user) != cnvtupper(drrr_rf_data->src_high_priv_user))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target high priv user: ",drrr_rf_data->
     tgt_high_priv_user)
    SET dm_err->emsg = concat(
     "Response file target high priv user (TGT_HIGH_PRIV_USER) must be equal to the source ",
     "high priv user (SRC_HIGH_PRIV_USER) value (",drrr_rf_data->src_high_priv_user,").")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_env_name(null)
   IF (((cnvtupper(drrr_rf_data->tgt_env_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_env_name,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target environment name: ",drrr_rf_data->
     tgt_env_name)
    SET dm_err->emsg =
    "Response file target environment name (TGT_ENV_NAME) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_env_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_env_name,3))=0)) )
    SET drrr_rf_data->tgt_db_env_name = cnvtupper(drrr_rf_data->tgt_env_name)
   ELSE
    SET drrr_rf_data->tgt_db_env_name = cnvtupper(drrr_rf_data->tgt_db_env_name)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_env_desc) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_env_desc,3))=0)) )
    SET drrr_rf_data->tgt_env_desc = concat(drrr_rf_data->tgt_db_env_name," environment")
   ENDIF
   SET drrr_rf_data->tgt_env_desc = cnvtupper(drrr_rf_data->tgt_env_desc)
   IF (textlen(drrr_rf_data->tgt_env_desc) > 60)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target environment description: ",
     drrr_rf_data->tgt_env_desc)
    SET dm_err->emsg = concat(
     "Target environment description (TGT_ENV_DESC) should not exceed 60 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_domain_name(null)
  IF (((cnvtupper(drrr_rf_data->tgt_domain_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
  "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_domain_name,3))=0)) )
   SET dm_err->err_ind = 1
   SET dm_err->eproc = concat("Validating response file target dmain name: ",drrr_rf_data->
    tgt_domain_name)
   SET dm_err->emsg =
   "Response file target domain name (TGT_DOMAIN_NAME) must be set to a specific value."
   CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
   RETURN(0)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_app_node_list(null)
   DECLARE dvrtanl_str = vc WITH protect, noconstant("")
   DECLARE dvrtanl_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtanl_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtanl_tmp_node = vc WITH protect, noconstant("")
   DECLARE dvrtanl_idx = i4 WITH protect, noconstant(0)
   SET drrr_misc_data->tgt_app_node_cnt = 0
   SET stat = alterlist(drrr_misc_data->tgt_app_nodes,0)
   IF (((cnvtupper(drrr_rf_data->tgt_app_node_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_node_list,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target app node list: ",drrr_rf_data->
     tgt_app_node_list)
    SET dm_err->emsg =
    "Response file target app node list (TGT_APP_NODE_LIST) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    WHILE (dvrtanl_str != dvrtanl_notfnd)
     SET dvrtanl_str = piece(drrr_rf_data->tgt_app_node_list,",",dvrtanl_num,dvrtanl_notfnd)
     IF (dvrtanl_str != dvrtanl_notfnd)
      IF (findstring('"',dvrtanl_str,1,0) != findstring('"',dvrtanl_str,1,1))
       SET dvrtanl_tmp_node = cnvtlower(trim(replace(dvrtanl_str,'"',"",0),3))
       IF (size(trim(dvrtanl_tmp_node,3)) > 0)
        SET drrr_misc_data->tgt_app_node_cnt = (drrr_misc_data->tgt_app_node_cnt+ 1)
        SET stat = alterlist(drrr_misc_data->tgt_app_nodes,drrr_misc_data->tgt_app_node_cnt)
        SET drrr_misc_data->tgt_app_nodes[drrr_misc_data->tgt_app_node_cnt].node_name =
        dvrtanl_tmp_node
        SET dvrtanl_num = (dvrtanl_num+ 1)
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target app node list (TGT_APP_NODE_LIST): ",drrr_rf_data->
         tgt_app_node_list)
        SET dm_err->emsg = concat("Individual node name in position ",trim(cnvtstring(dvrtanl_num),3),
         " not properly set.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target app node list (tgt_APP_NODE_LIST): ",drrr_rf_data->
        tgt_app_node_list)
       SET dm_err->emsg = concat("Individual node name (",trim(dvrtanl_str,3),
        ") not wrapped in double-quotes.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDWHILE
    IF ((drrr_misc_data->tgt_app_node_cnt=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app node list (tgt_APP_NODE_LIST): ",
      drrr_rf_data->tgt_app_node_list)
     SET dm_err->emsg = "Node name(s) not loaded into memory."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_primary_app_node) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_primary_app_node,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target primary app node: ",drrr_rf_data->
     tgt_primary_app_node)
    SET dm_err->emsg =
    "Response file target primary app node (TGT_PRIMARY_APP_NODE) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET drrr_rf_data->tgt_primary_app_node = cnvtlower(trim(drrr_rf_data->tgt_primary_app_node,3))
    SET dvrtanl_idx = locateval(dvrtanl_idx,1,drrr_misc_data->tgt_app_node_cnt,drrr_rf_data->
     tgt_primary_app_node,drrr_misc_data->tgt_app_nodes[dvrtanl_idx].node_name)
    IF (dvrtanl_idx=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target primary app node: ",drrr_rf_data->
      tgt_primary_app_node)
     SET dm_err->emsg = concat(
      "Response file target primary app node (TGT_PRIMARY_APP_NODE) not found in target ",
      "app node list (TGT_APP_NODE_LIST).")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_app_temp_dir(null)
   IF (((cnvtupper(drrr_rf_data->src_app_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_app_temp_dir,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source app temp directory: ",drrr_rf_data->
     src_app_temp_dir)
    SET dm_err->emsg =
    "Response file source app temp directory (SRC_APP_TEMP_DIR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->src_app_temp_dir) != "/")
    SET drrr_rf_data->src_app_temp_dir = concat("/",drrr_rf_data->src_app_temp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->src_app_temp_dir),1,1) != size(trim(drrr_rf_data->
     src_app_temp_dir)))
    SET drrr_rf_data->src_app_temp_dir = concat(trim(drrr_rf_data->src_app_temp_dir),"/")
   ENDIF
   IF ( NOT (dm2_find_dir(drrr_rf_data->src_app_temp_dir)))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source app temp directory: ",drrr_rf_data->
     src_app_temp_dir)
    SET dm_err->emsg = "Failed to find source app temp directory (SRC_APP_TEMP_DIR). "
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (textlen(drrr_rf_data->src_app_temp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source app temp directory: ",drrr_rf_data->
     src_app_temp_dir)
    SET dm_err->emsg = concat(
     "Full path of source app temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drrr_val_write_privs(drrr_rf_data->src_app_temp_dir)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_app_temp_dir(null)
   IF (((cnvtupper(drrr_rf_data->tgt_app_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_temp_dir,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target app temp directory: ",drrr_rf_data->
     tgt_app_temp_dir)
    SET dm_err->emsg =
    "Response file target app temp directory (tgt_APP_TEMP_DIR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_app_temp_dir) != "/")
    SET drrr_rf_data->tgt_app_temp_dir = concat("/",drrr_rf_data->tgt_app_temp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_app_temp_dir),1,1) != size(trim(drrr_rf_data->
     tgt_app_temp_dir)))
    SET drrr_rf_data->tgt_app_temp_dir = concat(trim(drrr_rf_data->tgt_app_temp_dir),"/")
   ENDIF
   IF ( NOT (dm2_find_dir(drrr_rf_data->tgt_app_temp_dir)))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target app temp directory: ",drrr_rf_data->
     tgt_app_temp_dir)
    SET dm_err->emsg = "Failed to find target app temp directory (tgt_APP_TEMP_DIR). "
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (textlen(drrr_rf_data->tgt_app_temp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target app temp directory: ",drrr_rf_data->
     tgt_app_temp_dir)
    SET dm_err->emsg = concat(
     "Full path of target app temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (drrr_val_write_privs(drrr_rf_data->tgt_app_temp_dir)=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_app_prim_temp_dir(null)
   IF (((cnvtupper(drrr_rf_data->tgt_app_prim_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_prim_temp_dir,3))=0)) )
    SET drrr_rf_data->tgt_app_prim_temp_dir = concat(drrr_rf_data->tgt_app_temp_dir,"/",drrr_rf_data
     ->tgt_primary_app_node,"/",drrr_rf_data->tgt_env_name,
     "/")
    RETURN(1)
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_app_prim_temp_dir) != "/")
    SET drrr_rf_data->tgt_app_prim_temp_dir = concat("/",drrr_rf_data->tgt_app_prim_temp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_app_prim_temp_dir),1,1) != size(trim(drrr_rf_data->
     tgt_app_prim_temp_dir)))
    SET drrr_rf_data->tgt_app_prim_temp_dir = concat(trim(drrr_rf_data->tgt_app_prim_temp_dir),"/")
   ENDIF
   IF (textlen(drrr_rf_data->tgt_app_prim_temp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target app primary temp directory: ",
     drrr_rf_data->tgt_app_prim_temp_dir)
    SET dm_err->emsg = concat(
     "Full path of target app primary temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_preserve_data(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_preserve_data) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file TGT_PRESERVE_DATA: ",drrr_rf_data->
     tgt_preserve_data)
    SET dm_err->emsg = 'Response file TGT_PRESERVE_DATA must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_preserve_data = cnvtupper(drrr_rf_data->tgt_preserve_data)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_backup_ccluserdir(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_backup_ccluserdir) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file tgt_backup_ccluserdir: ",drrr_rf_data->
     tgt_backup_ccluserdir)
    SET dm_err->emsg = 'Response file tgt_backup_ccluserdir must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_backup_ccluserdir = cnvtupper(drrr_rf_data->tgt_backup_ccluserdir)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_backup_warehouse(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_backup_warehouse) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file tgt_backup_warehouse: ",drrr_rf_data->
     tgt_backup_warehouse)
    SET dm_err->emsg = 'Response file tgt_backup_warehouse must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_backup_warehouse = cnvtupper(drrr_rf_data->tgt_backup_warehouse)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_capture_schema_date(null)
   DECLARE dvrtcsd_dt = vc WITH protect, noconstant("")
   IF (validate(dm2_skip_tgt_schema_date,- (1))=1)
    SET dm_err->eproc = "Bypassing response file target capture schema date limit."
    CALL disp_msg(" ",dm_err->logfile,0)
    RETURN(1)
   ENDIF
   SET dvrtcsd_dt = trim(drrr_rf_data->tgt_capture_schema_date,3)
   IF (((cnvtupper(dvrtcsd_dt) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (((
   size(dvrtcsd_dt)=0) OR (((format(cnvtdate(cnvtalphanum(dvrtcsd_dt)),"MM-DD-YYYY;;D") != dvrtcsd_dt
   ) OR (datetimeadd(cnvtdatetime(format(cnvtdate2(dvrtcsd_dt,"MM-DD-YYYY"),"DD-MMM-YYYY;;D")),30) <
   cnvtdatetime(curdate,curtime3))) )) )) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target capture schema date: ",drrr_rf_data->
     tgt_capture_schema_date)
    SET dm_err->emsg = concat(
     "Response file target capture schema date (TGT_CAPTURE_SCHEMA_DATE) must be ",
     "set to a specific value (format of MM-DD-YYYY) and date should be within the last 30 days.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_tspace_increase_pct(null)
  IF ((((drrr_rf_data->tgt_tspace_increase_pct <= - (100))) OR ((drrr_rf_data->
  tgt_tspace_increase_pct >= 100))) )
   SET drrr_rf_data->tgt_tspace_increase_pct = 10
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_write_privs(drvwp_full_dir)
   DECLARE drvwp_full_fname = vc WITH protect
   IF (get_unique_file("dm2wrtprvtst",".dat")=0)
    RETURN(0)
   ENDIF
   SET drvwp_full_fname = build(drvwp_full_dir,cnvtlower(dm_err->unique_fname))
   SET dm_err->eproc = concat("Validating write privs to directory: ",drvwp_full_dir)
   SELECT INTO value(drvwp_full_fname)
    d.seq
    FROM (dummyt d  WITH seq = 1)
    DETAIL
     row + 1, "This is a test of writing to ", drvwp_full_dir
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dm2_push_dcl(concat("rm ",drvwp_full_fname))=0)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_tspace_dg_list(null)
   DECLARE dvrttdl_str = vc WITH protect, noconstant("")
   DECLARE dvrttdl_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrttdl_num = i4 WITH protect, noconstant(1)
   DECLARE dvrttdl_tmp_dg = vc WITH protect, noconstant("")
   IF (((cnvtupper(drrr_rf_data->tgt_tspace_dg_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_tspace_dg_list,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target tspace diskgroup list: ",drrr_rf_data
     ->tgt_tspace_dg_list)
    SET dm_err->emsg =
    "Response file target tspace diskgroup list (TGT_TSPACE_DG_LIST) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    WHILE (dvrttdl_str != dvrttdl_notfnd)
     SET dvrttdl_str = piece(drrr_rf_data->tgt_tspace_dg_list,",",dvrttdl_num,dvrttdl_notfnd)
     IF (dvrttdl_str != dvrttdl_notfnd)
      IF (findstring('"',dvrttdl_str,1,0) != findstring('"',dvrttdl_str,1,1))
       SET dvrttdl_tmp_dg = cnvtupper(trim(replace(dvrttdl_str,'"',"",0),3))
       IF (size(dvrttdl_tmp_dg) > 0)
        SELECT INTO "nl:"
         FROM v$asm_diskgroup v
         WHERE v.state IN ("CONNECTED", "MOUNTED")
          AND v.name=dvrttdl_tmp_dg
         WITH nocounter
        ;end select
        IF (check_error(concat("Verify disk group (",dvrttdl_tmp_dg,") exists.")) != 0)
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ELSEIF (curqual=0)
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat(
          "Validating response file target tspace diskgroup list (TGT_TSPACE_DG_LIST): ",drrr_rf_data
          ->tgt_tspace_dg_list)
         SET dm_err->emsg = concat("Individual diskgroup (",dvrttdl_str,
          ") not found or not valid state.")
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
        SET drrr_misc_data->tgt_tspace_dg_cnt = (drrr_misc_data->tgt_tspace_dg_cnt+ 1)
        SET stat = alterlist(drrr_misc_data->tgt_tspace_dg,drrr_misc_data->tgt_tspace_dg_cnt)
        SET drrr_misc_data->tgt_tspace_dg[drrr_misc_data->tgt_tspace_dg_cnt].disk_group =
        dvrttdl_tmp_dg
        SET dvrttdl_num = (dvrttdl_num+ 1)
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target tspace diskgroup list (TGT_TSPACE_DG_LIST): ",drrr_rf_data
         ->tgt_tspace_dg_list)
        SET dm_err->emsg = concat("Individual diskgroup in position ",trim(cnvtstring(dvrttdl_num),3),
         " not properly set.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target tspace diskgroup list (TGT_TSPACE_DG_LIST): ",drrr_rf_data->
        tgt_tspace_dg_list)
       SET dm_err->emsg = concat("Individual diskgroup (",trim(dvrttdl_str,3),
        ") not wrapped in double-quotes.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDWHILE
    IF ((drrr_misc_data->tgt_tspace_dg_cnt=0))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target tspace diskgroup list (TGT_TSPACE_DG_LIST): ",drrr_rf_data->
      tgt_tspace_dg_list)
     SET dm_err->emsg = "Diskgroup(s) not loaded into memory."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_restore_preserve_data(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_preserve_data) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file RESTORE PRESERVE DATA: ",drrr_rf_data->
     tgt_restore_preserve_data)
    SET dm_err->emsg = 'Response file RESTORE PRESERVE DATA must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_restore_preserve_data = cnvtupper(drrr_rf_data->tgt_restore_preserve_data)
   IF ((drrr_rf_data->tgt_preserve_data="NO")
    AND (drrr_rf_data->tgt_restore_preserve_data="YES"))
    SET dm_err->err_ind = 1
    SET dm_err->eproc =
    'Validating response file restore preserve data indicator (TGT_RESTORE_PRESERVE_DATA) can be set to "YES".'
    SET dm_err->emsg = concat("Response file target preserve data (TGT_PRESERVE_DATA) must ",
     'be equal to "YES" in order to restore preserve data.')
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((drrr_rf_data->tgt_restore_preserve_data="YES"))
    IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_autotester) IN ("YES", "NO")))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file RESTORE AUTOTESTER: ",drrr_rf_data->
      tgt_restore_autotester)
     SET dm_err->emsg = 'Response file RESTORE AUTOTESTER must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_restore_autotester = cnvtupper(drrr_rf_data->tgt_restore_autotester)
    IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_rrd) IN ("YES", "NO")))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file RESTORE RRD: ",drrr_rf_data->
      tgt_restore_rrd)
     SET dm_err->emsg = 'Response file RESTORE RRD must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_restore_rrd = cnvtupper(drrr_rf_data->tgt_restore_rrd)
    IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_printers) IN ("YES", "NO")))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file RESTORE PRINTERS: ",drrr_rf_data->
      tgt_restore_printers)
     SET dm_err->emsg = 'Response file RESTORE PRINTERS must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_restore_printers = cnvtupper(drrr_rf_data->tgt_restore_printers)
    IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_interfaces) IN ("YES", "NO")))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file RESTORE INTERFACES: ",drrr_rf_data->
      tgt_restore_interfaces)
     SET dm_err->emsg = 'Response file RESTORE INTERFACES must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_restore_interfaces = cnvtupper(drrr_rf_data->tgt_restore_interfaces)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_email_list(null)
   DECLARE dvel_email = vc WITH protect, noconstant("")
   DECLARE dvel_level = i2 WITH protect, noconstant(0)
   DECLARE dvel_beg = i2 WITH protect, noconstant(1)
   DECLARE dvel_end = i2 WITH protect, noconstant(1)
   DECLARE dvel_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvel_str = vc WITH protect, noconstant("")
   DECLARE dvel_level_idx = i2 WITH protect, noconstant(0)
   DECLARE dvel_email_idx = i2 WITH protect, noconstant(0)
   DECLARE dvel_finish = i2 WITH protect, noconstant(0)
   IF (((cnvtupper(drrr_rf_data->email_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->email_list,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file email list: ",drrr_rf_data->email_list)
    SET dm_err->emsg = "Response file email list (EMAIL_LIST) must be set."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvel_str = build(trim(cnvtlower(replace(drrr_rf_data->email_list,'"',"",0)),4))
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("dvel_str = ",dvel_str))
   ENDIF
   IF (dvel_str > "")
    WHILE ( NOT (dvel_finish))
      SET dvel_cnt = (dvel_cnt+ 1)
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("cnt = ",dvel_cnt))
      ENDIF
      SET dvel_beg = dvel_end
      SET dvel_end = findstring(",",dvel_str,(dvel_beg+ 1),0)
      IF (dvel_end=0)
       SET dvel_end = (size(dvel_str)+ 1)
       SET dvel_finish = 1
      ENDIF
      IF (even(dvel_cnt)=1)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("beg = ",dvel_beg))
        CALL echo(build("end = ",dvel_end))
        CALL echo(substring((dvel_beg+ 1),((dvel_end - dvel_beg) - 1),dvel_str))
       ENDIF
       SET dvel_level = cnvtint(substring((dvel_beg+ 1),((dvel_end - dvel_beg) - 1),dvel_str))
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dvel_level = ",dvel_level))
       ENDIF
       IF (((dvel_level=0) OR ((dvel_level > drer_email_list->max_email_level))) )
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file Email List: ",drrr_rf_data->email_list)
        SET dm_err->emsg = concat("Response file Email level must be greater than 0 and less than ",
         trim(cnvtstring(drer_email_list->max_email_level)))
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       SET drer_email_list->email[drer_email_list->email_cnt].level = dvel_level
      ELSE
       IF (dvel_beg=1)
        SET dvel_email = substring(dvel_beg,(dvel_end - dvel_beg),dvel_str)
       ELSE
        SET dvel_email = substring((dvel_beg+ 1),((dvel_end - dvel_beg) - 1),dvel_str)
       ENDIF
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("dvel_email = ",dvel_email))
       ENDIF
       IF (((findstring("@",dvel_email,1)=0) OR (findstring(".",dvel_email,1)=0)) )
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file Email List: ",drrr_rf_data->email_list)
        SET dm_err->emsg = "Response file Email address must have '@' and '.' ."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
       SET dvel_email_idx = locateval(dvel_email_idx,1,drer_email_list->email_cnt,dvel_email,
        drer_email_list->email[dvel_email_idx].address)
       IF (dvel_email_idx=0)
        SET drer_email_list->email_cnt = (drer_email_list->email_cnt+ 1)
        SET stat = alterlist(drer_email_list->email,drer_email_list->email_cnt)
        SET drer_email_list->email[drer_email_list->email_cnt].address = dvel_email
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file Email List: ",drrr_rf_data->email_list)
        SET dm_err->emsg = "Find duplicate email addresses in the response file."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
    ENDWHILE
    IF (even(dvel_cnt) != 1)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file Email List: ",drrr_rf_data->email_list)
     SET dm_err->emsg = "Failed to find email level for all email addresses."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    FOR (dvel_level = 1 TO drer_email_list->max_email_level)
      SET dvel_beg = 1
      SET dvel_level_idx = 0
      SET dvel_level_idx = locateval(dvel_level_idx,dvel_beg,drer_email_list->email_cnt,dvel_level,
       drer_email_list->email[dvel_level_idx].level)
      IF ((dm_err->debug_flag > 0))
       CALL echo(build("dvel_level = ",dvel_level))
       CALL echo(build("dvel_level_idx = ",dvel_level_idx))
      ENDIF
      IF (dvel_level_idx != 0)
       SET drer_email_list->level_cnt = (drer_email_list->level_cnt+ 1)
       SET stat = alterlist(drer_email_list->email_level,drer_email_list->level_cnt)
       SET drer_email_list->email_level[drer_email_list->level_cnt].level = drer_email_list->email[
       dvel_level_idx].level
       SET drer_email_list->email_level[drer_email_list->level_cnt].email_list = drer_email_list->
       email[dvel_level_idx].address
      ENDIF
      WHILE (dvel_level_idx != 0)
        SET dvel_beg = (dvel_level_idx+ 1)
        SET dvel_level_idx = 0
        SET dvel_level_idx = locateval(dvel_level_idx,dvel_beg,drer_email_list->email_cnt,dvel_level,
         drer_email_list->email[dvel_level_idx].level)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dvel_level_idx = ",dvel_level_idx))
        ENDIF
        IF (dvel_level_idx != 0)
         SET drer_email_list->email_level[drer_email_list->level_cnt].email_list = concat(
          drer_email_list->email_level[drer_email_list->level_cnt].email_list,",",drer_email_list->
          email[dvel_level_idx].address)
        ENDIF
      ENDWHILE
    ENDFOR
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drer_email_list)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_server_set_names(null)
   IF (((cnvtupper(drrr_rf_data->tgt_prim_server_set_name) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_prim_server_set_name,3))=0))
   )
    SET drrr_rf_data->tgt_prim_server_set_name = "CERNER_SHIPPED_DEFAULT"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_sec_server_set_name) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_sec_server_set_name,3))=0)) )
    SET drrr_rf_data->tgt_sec_server_set_name = "CERNER_SHIPPED_DEFAULT"
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_background_runners(null)
  IF (validate(dm2_rrr_force_interactive_runners,0)=1)
   SET drrr_rf_data->tgt_background_runners = 0
  ELSE
   IF ((drrr_rf_data->tgt_background_runners=- (999)))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating response file target background runners: <not specified>"
    SET dm_err->emsg = concat(
     "Response file target background runners (TGT_BACKGROUND_RUNNERS) must be specified with ",
     "a numeric value of 1 - 10.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSEIF ((((drrr_rf_data->tgt_background_runners < 1)) OR ((drrr_rf_data->tgt_background_runners
    >= 11))) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target background runners: ",cnvtstring(
      drrr_rf_data->tgt_background_runners))
    SET dm_err->emsg = concat(
     "Response file target background runners (TGT_BACKGROUND_RUNNERS) must be ",
     "numeric value of 1 - 10.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_opsexec_node_mapping(null)
   DECLARE dvtonm_num = i2 WITH protect, noconstant(1)
   DECLARE dvtonm_str = vc WITH protect, noconstant("")
   DECLARE dvtonm_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvtonm_tmp_str = vc WITH protect, noconstant("")
   IF (((cnvtupper(drrr_rf_data->tgt_opsexec_node_mapping) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_opsexec_node_mapping,3))=0))
   )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file OpsExec Node Mapping: ",drrr_rf_data->
     tgt_opsexec_node_mapping)
    SET dm_err->emsg = "Response file OpsExec Node Mapping (tgt_opsexec_node_mapping) must be set."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvtonm_str = build(cnvtlower(drrr_rf_data->tgt_opsexec_node_mapping))
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("dvtonm_str = ",dvtonm_str))
   ENDIF
   WHILE (dvtonm_str != dvtonm_notfnd)
     SET dvtonm_str = piece(drrr_rf_data->tgt_opsexec_node_mapping,",",dvtonm_num,dvtonm_notfnd)
     CALL echo(dvtonm_str)
     IF (dvtonm_num=1
      AND dvtonm_str=dvtonm_notfnd)
      SET dvtonm_str = drrr_rf_data->tgt_opsexec_node_mapping
     ENDIF
     IF (dvtonm_str != dvtonm_notfnd)
      IF (findstring('"',dvtonm_str,1,0) != findstring('"',dvtonm_str,1,1))
       SET dvtonm_tmp_str = cnvtlower(trim(replace(dvtonm_str,'"',"",0),3))
       IF (size(trim(dvtonm_tmp_str,3)) > 0)
        IF (findstring(":",dvtonm_tmp_str,1,0) > 1
         AND findstring(":",dvtonm_tmp_str,1,0) < size(trim(dvtonm_tmp_str,3)))
         SET drrr_misc_data->tgt_opsexec_map_cnt = (drrr_misc_data->tgt_opsexec_map_cnt+ 1)
         SET stat = alterlist(drrr_misc_data->tgt_opsexec_map,drrr_misc_data->tgt_opsexec_map_cnt)
         SET drrr_misc_data->tgt_opsexec_map[drrr_misc_data->tgt_opsexec_map_cnt].src_node =
         cnvtupper(value(piece(dvtonm_tmp_str,":",1,dvtonm_notfnd)))
         SET drrr_misc_data->tgt_opsexec_map[drrr_misc_data->tgt_opsexec_map_cnt].tgt_node =
         cnvtupper(value(piece(dvtonm_tmp_str,":",2,dvtonm_notfnd)))
         SET dvtonm_num = (dvtonm_num+ 1)
        ELSE
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat(
          "Validating response file target opsexec node mapping (tgt_OPSEXEC_NODE_MAPPING): ",
          drrr_rf_data->tgt_opsexec_node_mapping)
         SET dm_err->emsg = concat("Node mapping in position ",trim(cnvtstring(dvtonm_num),3),
          " not properly set.")
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target opsexec node mapping (tgt_OPSEXEC_NODE_MAPPING): ",
         drrr_rf_data->tgt_opsexec_node_mapping)
        SET dm_err->emsg = concat("Node mapping in position ",trim(cnvtstring(dvtonm_num),3),
         " not properly set.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target opsexec node mapping (tgt_OPSEXEC_NODE_MAPPING): ",
        drrr_rf_data->tgt_opsexec_node_mapping)
       SET dm_err->emsg = concat("Node mapping (",trim(dvtonm_str,3),
        ") not wrapped in double-quotes.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
   ENDWHILE
   CALL echorecord(drrr_misc_data)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_drop_tablespaces(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_drop_tablespaces) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file TGT_DROP_TABLESPACES: ",drrr_rf_data->
     tgt_drop_tablespaces)
    SET dm_err->emsg = 'Response file TGT_DROP_TABLESPACES must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_drop_tablespaces = cnvtupper(drrr_rf_data->tgt_drop_tablespaces)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_retain_db_user_list(null)
   DECLARE dvrtrdul_str = vc WITH protect, noconstant("")
   DECLARE dvrtrdul_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtrdul_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtrdul_tmp_user = vc WITH protect, noconstant("")
   DECLARE dvrtrdul_idx = i4 WITH protect, noconstant(0)
   DECLARE dvrtrdul_tmp_str = vc WITH protect, noconstant("")
   IF (((cnvtupper(drrr_rf_data->tgt_retain_db_user_list) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_retain_db_user_list,3))=0)) )
    SET drrr_rf_data->tgt_retain_db_user_list = "DM2NOTSET"
    RETURN(1)
   ELSE
    IF ((drrr_rf_data->target_refresh != "YES"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",drrr_rf_data
      ->tgt_retain_db_user_list)
     SET dm_err->emsg = concat("Response file target refresh indicator (TARGET_REFRESH) must ",
      'be equal to "YES" in order to retain database users.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_db_copy_type != "ALTERNATE"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",drrr_rf_data
      ->tgt_retain_db_user_list)
     SET dm_err->emsg = concat("Response file target db copy type (TGT_DB_COPY_TYPE) must ",
      'be equal to "ALTERNATE" in order to retain database users.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    WHILE (dvrtrdul_str != dvrtrdul_notfnd)
     SET dvrtrdul_str = piece(drrr_rf_data->tgt_retain_db_user_list,",",dvrtrdul_num,dvrtrdul_notfnd)
     IF (dvrtrdul_str != dvrtrdul_notfnd)
      IF (findstring('"',dvrtrdul_str,1,0) != findstring('"',dvrtrdul_str,1,1))
       SET dvrtrdul_tmp_user = cnvtupper(trim(replace(dvrtrdul_str,'"',"",0),3))
       IF (size(trim(dvrtrdul_tmp_user,3)) > 0)
        IF (trim(dvrtrdul_tmp_user,3) IN ("V500", "CDBA"))
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat(
          "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",
          drrr_rf_data->tgt_retain_db_user_list)
         SET dm_err->emsg = "V500/CDBA cannot be included in list of database users to be retained."
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ELSE
         IF (cnvtalphanum(trim(dvrtrdul_tmp_user,3)) != replace(trim(dvrtrdul_tmp_user,3),"_","",0))
          SET dm_err->err_ind = 1
          SET dm_err->eproc = concat(
           "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",
           drrr_rf_data->tgt_retain_db_user_list)
          SET dm_err->emsg =
          "One or more database users contains invalid characters (only allowing alphanumerics and underscores)."
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ELSE
          SET drrr_misc_data->tgt_retain_db_user_cnt = (drrr_misc_data->tgt_retain_db_user_cnt+ 1)
          SET stat = alterlist(drrr_misc_data->tgt_retain_db_users,drrr_misc_data->
           tgt_retain_db_user_cnt)
          SET drrr_misc_data->tgt_retain_db_users[drrr_misc_data->tgt_retain_db_user_cnt].user_name
           = dvrtrdul_tmp_user
          SET dvrtrdul_num = (dvrtrdul_num+ 1)
         ENDIF
        ENDIF
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",
         drrr_rf_data->tgt_retain_db_user_list)
        SET dm_err->emsg = concat("Individual database user name in position ",trim(cnvtstring(
           dvrtrdul_num),3)," not properly set.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",
        drrr_rf_data->tgt_retain_db_user_list)
       SET dm_err->emsg = concat("Individual database user name (",trim(dvrtrdul_str,3),
        ") not wrapped in double-quotes.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
    ENDWHILE
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_database_users(null)
   DECLARE dvrtdu_num = i4 WITH protect, noconstant(0)
   DECLARE dvrtdu_missing_users = vc WITH protect, noconstant("")
   DECLARE dvrtdu_reserve_users = vc WITH protect, noconstant("")
   DECLARE dvrtdu_invalid_pres_users = vc WITH protect, noconstant("")
   DECLARE dvrtdu_user_name = vc WITH protect, noconstant("")
   DECLARE dvrtdu_user_name_exists_ind = i2 WITH protect, noconstant(0)
   DECLARE dvrtdu_iter = i4 WITH protect, noconstant(0)
   FREE RECORD dvrtdu_preserve_users
   RECORD dvrtdu_preserve_users(
     1 cnt = i4
     1 user[*]
       2 user_name = vc
   )
   IF ((drrr_misc_data->tgt_retain_db_user_cnt > 0))
    SET dm_err->eproc = "Selecting list of users to be preserved from dm_info."
    SELECT INTO "nl:"
     FROM dm_info di
     WHERE "DM2_CERN_CUST_USER"=di.info_domain
     HEAD REPORT
      dvrtdu_preserve_users->cnt = 0, stat = alterlist(dvrtdu_preserve_users->user,0)
     DETAIL
      dvrtdu_preserve_users->cnt = (dvrtdu_preserve_users->cnt+ 1), stat = alterlist(
       dvrtdu_preserve_users->user,dvrtdu_preserve_users->cnt), dvrtdu_preserve_users->user[
      dvrtdu_preserve_users->cnt].user_name = trim(di.info_name)
     WITH nocounter
    ;end select
    IF (check_error(dm_err->eproc)=1)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echorecord(dvrtdu_preserve_users)
    ENDIF
    FOR (dvrtdu_num = 1 TO drrr_misc_data->tgt_retain_db_user_cnt)
      SET dvrtdu_user_name = drrr_misc_data->tgt_retain_db_users[dvrtdu_num].user_name
      SET dm_err->eproc = "Validating retain database user exists in database."
      SELECT INTO "nl:"
       FROM dba_users u
       WHERE (u.username=drrr_misc_data->tgt_retain_db_users[dvrtdu_num].user_name)
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ELSEIF (curqual=0)
       SET dvrtdu_missing_users = build(dvrtdu_missing_users,dvrtdu_user_name,",")
      ENDIF
      SET dm_err->eproc =
      "Validating retain database user is not a Cerner shipped or Oracle database user."
      SELECT INTO "nl:"
       FROM dm_info d
       WHERE d.info_name=dvrtdu_user_name
        AND d.info_domain IN ("DM2_CERNER_USER", "DM2_ORACLE_USER")
        AND d.info_number=1
       WITH nocounter
      ;end select
      IF (check_error(dm_err->eproc)=1)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ELSEIF (curqual > 0)
       SET dvrtdu_reserve_users = build(dvrtdu_reserve_users,dvrtdu_user_name,",")
      ENDIF
      SET dm_err->eproc = concat("Validating retain database user ",dvrtdu_user_name,
       " is a custom user from the users list to be preserved.")
      CALL disp_msg("",dm_err->logfile,0)
      SET dvrtdu_user_name_exists_ind = 0
      FOR (dvrtdu_iter = 1 TO dvrtdu_preserve_users->cnt)
        IF (dvrtdu_user_name=patstring(dvrtdu_preserve_users->user[dvrtdu_iter].user_name,0))
         SET dvrtdu_user_name_exists_ind = 1
         SET dvrtdu_iter = (dvrtdu_preserve_users->cnt+ 1)
        ENDIF
      ENDFOR
      IF (dvrtdu_user_name_exists_ind=0)
       SET dvrtdu_invalid_pres_users = build(dvrtdu_invalid_pres_users,dvrtdu_user_name,",")
      ENDIF
    ENDFOR
    IF (((size(trim(dvrtdu_missing_users,3)) > 0) OR (((size(trim(dvrtdu_reserve_users,3)) > 0) OR (
    size(trim(dvrtdu_invalid_pres_users,3)) > 0)) )) )
     SET dm_err->emsg = ""
     IF (size(trim(dvrtdu_missing_users,3)) > 0)
      SET dvrtdu_missing_users = concat("Individual database users not found (",trim(replace(
         dvrtdu_missing_users,",","",2),3),").")
     ENDIF
     IF (size(trim(dvrtdu_reserve_users,3)) > 0)
      SET dvrtdu_reserve_users = concat("Individual database users marked as Cerner/Oracle users (",
       trim(replace(dvrtdu_reserve_users,",","",2),3),").")
     ENDIF
     IF (size(trim(dvrtdu_invalid_pres_users,3)) > 0)
      SET dvrtdu_invalid_pres_users = concat(
       "Individual database users are not valid preserve users (",trim(replace(
         dvrtdu_invalid_pres_users,",","",2),3),").")
     ENDIF
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target retain db user list (tgt_RETAIN_DB_USER_LIST): ",drrr_rf_data
      ->tgt_retain_db_user_list)
     IF (size(trim(dvrtdu_missing_users,3)) > 0)
      SET dm_err->emsg = trim(dvrtdu_missing_users,3)
     ENDIF
     IF (size(trim(dvrtdu_reserve_users,3)) > 0)
      SET dm_err->emsg = trim(concat(dm_err->emsg,"  ",trim(dvrtdu_reserve_users,3)),3)
     ENDIF
     IF (size(trim(dvrtdu_invalid_pres_users,3)) > 0)
      SET dm_err->emsg = trim(concat(dm_err->emsg,"  ",trim(dvrtdu_invalid_pres_users,3)),3)
     ENDIF
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_expimp_runners(null)
  IF ((((drrr_rf_data->tgt_expimp_runners < 0)) OR ((drrr_rf_data->tgt_expimp_runners > 10))) )
   SET drrr_rf_data->tgt_expimp_runners = 5
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_sys_cnnct_data(dvrsscd_in_cnct_to_db_ind)
   IF (((cnvtupper(drrr_rf_data->src_sys_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_sys_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source SYS password: ",drrr_rf_data->
     src_sys_pwd)
    SET dm_err->emsg = "Response file source SYS password must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (dvrsscd_in_cnct_to_db_ind=1)
    IF (((cnvtupper(drrr_rf_data->src_db_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_cnct_str,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file source database connect string: ",
      drrr_rf_data->src_db_cnct_str)
     SET dm_err->emsg =
     "Response file source database connect string must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((cnvtupper(drrr_rf_data->src_db_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_name,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file source database name: ",drrr_rf_data->
      src_db_name)
     SET dm_err->emsg = "Response file source database name must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (cnvtupper(drrr_rf_data->src_db_deploy_config) IN ("OP", "OCI"))
     SET drrr_rf_data->src_sys_user = "SYS"
    ELSE
     SET drrr_rf_data->src_sys_user = "ADMIN"
    ENDIF
    SET dm2_install_schema->u_name = drrr_rf_data->src_sys_user
    SET dm2_install_schema->p_word = drrr_rf_data->src_sys_pwd
    SET dm2_install_schema->connect_str = drrr_rf_data->src_db_cnct_str
    SET dm2_install_schema->dbase_name = '"SOURCE"'
    EXECUTE dm2_connect_to_dbase "CO"
    IF ((dm_err->err_ind=1))
     RETURN(0)
    ENDIF
    IF (cnvtupper(currdbname) != cnvtupper(drrr_rf_data->src_db_name))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file source database name: ",drrr_rf_data->
      src_db_name)
     SET dm_err->emsg = concat(
      "Response file source database name does not match db name after connection (",trim(currdbname,
       3),").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_temp_dir(null)
   IF (((cnvtupper(drrr_rf_data->tgt_db_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_temp_dir,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db temp directory: ",drrr_rf_data->
     tgt_db_temp_dir)
    SET dm_err->emsg =
    "Response file target db temp directory (tgt_DB_TEMP_DIR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_db_temp_dir) != "/")
    SET drrr_rf_data->tgt_db_temp_dir = concat("/",drrr_rf_data->tgt_db_temp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_db_temp_dir),1,1) != size(trim(drrr_rf_data->
     tgt_db_temp_dir)))
    SET drrr_rf_data->tgt_db_temp_dir = concat(trim(drrr_rf_data->tgt_db_temp_dir),"/")
   ENDIF
   IF (textlen(drrr_rf_data->tgt_db_temp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db temp directory: ",drrr_rf_data->
     tgt_db_temp_dir)
    SET dm_err->emsg = concat(
     "Full path of target db temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_src_db_temp_dir(null)
   IF (((cnvtupper(drrr_rf_data->src_db_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_temp_dir,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source db temp directory: ",drrr_rf_data->
     src_db_temp_dir)
    SET dm_err->emsg =
    "Response file source db temp directory (src_DB_TEMP_DIR) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->src_db_temp_dir) != "/")
    SET drrr_rf_data->src_db_temp_dir = concat("/",drrr_rf_data->src_db_temp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->src_db_temp_dir),1,1) != size(trim(drrr_rf_data->
     src_db_temp_dir)))
    SET drrr_rf_data->src_db_temp_dir = concat(trim(drrr_rf_data->src_db_temp_dir),"/")
   ENDIF
   IF (textlen(drrr_rf_data->src_db_temp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file source db temp directory: ",drrr_rf_data->
     src_db_temp_dir)
    SET dm_err->emsg = concat(
     "Full path of source db temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_oracle_misc(null)
   DECLARE dvrt_shared_pool_size_1 = vc WITH protect, noconstant("536870912")
   DECLARE dvrt_shared_pool_size_2 = vc WITH protect, noconstant("1241513984")
   IF (((cnvtupper(drrr_rf_data->tgt_db_oracle_ver) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_oracle_ver,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle version: ",drrr_rf_data->
     tgt_db_oracle_ver)
    SET dm_err->emsg =
    "Response file target db oracle version (tgt_DB_ORACLE_VER) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((drrr_rf_data->tgt_db_oracle_ver != patstring("10.*"))
    AND (drrr_rf_data->tgt_db_oracle_ver != patstring("11.*"))
    AND (drrr_rf_data->tgt_db_oracle_ver != patstring("12.*"))
    AND (drrr_rf_data->tgt_db_oracle_ver != patstring("19*")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle version: ",drrr_rf_data->
     tgt_db_oracle_ver)
    SET dm_err->emsg =
    "Response file target db oracle version (tgt_DB_ORACLE_VER) must be set to supported version (10.x,11.x,12.x,19)."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_oracle_home) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_oracle_home,3))=0)) )
    IF ((drrr_rf_data->tgt_db_oracle_ver="10.1"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/10.1.0.5/db/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="10.2"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/10.2.0.3/db/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="11.1"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/11.1.0.7/db/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="11.2"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/11.2.0.3/db/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="12.2"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/12.2.0.1/db"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="19"))
     SET drrr_rf_data->tgt_db_oracle_home = "/u01/oracle/product/19/db"
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_oracle_home) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_oracle_home,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle home: ",drrr_rf_data->
     tgt_db_oracle_home)
    SET dm_err->emsg =
    "Response file target db oracle home (tgt_DB_ORACLE_HOME) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_db_oracle_home) != "/")
    SET drrr_rf_data->tgt_db_oracle_home = concat("/",drrr_rf_data->tgt_db_oracle_home)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_db_oracle_home),1,1) != size(trim(drrr_rf_data->
     tgt_db_oracle_home)))
    SET drrr_rf_data->tgt_db_oracle_home = concat(trim(drrr_rf_data->tgt_db_oracle_home),"/")
   ENDIF
   IF (textlen(drrr_rf_data->tgt_db_oracle_home) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle home: ",drrr_rf_data->
     tgt_db_oracle_home)
    SET dm_err->emsg = concat("Full path of target db oracle home should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_oracle_base) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_oracle_base,3))=0)) )
    IF ((drrr_rf_data->tgt_db_oracle_ver IN ("10.1", "10.2")))
     SET drrr_rf_data->tgt_db_oracle_base = "/u02/oracle/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="11.1"))
     SET drrr_rf_data->tgt_db_oracle_base = "/u02/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="11.2"))
     SET drrr_rf_data->tgt_db_oracle_base = "/u02/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="12.2"))
     SET drrr_rf_data->tgt_db_oracle_base = "/u02/"
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver="19"))
     SET drrr_rf_data->tgt_db_oracle_base = "/u01/oracle/product"
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_oracle_base) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_oracle_base,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle base: ",drrr_rf_data->
     tgt_db_oracle_base)
    SET dm_err->emsg =
    "Response file target db oracle base (tgt_DB_ORACLE_BASE) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_db_oracle_base) != "/")
    SET drrr_rf_data->tgt_db_oracle_base = concat("/",drrr_rf_data->tgt_db_oracle_base)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_db_oracle_base),1,1) != size(trim(drrr_rf_data->
     tgt_db_oracle_base)))
    SET drrr_rf_data->tgt_db_oracle_base = concat(trim(drrr_rf_data->tgt_db_oracle_base),"/")
   ENDIF
   IF (textlen(drrr_rf_data->tgt_db_oracle_base) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db oracle base: ",drrr_rf_data->
     tgt_db_oracle_base)
    SET dm_err->emsg = concat("Target db oracle base should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_shared_pool_size) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET"))
    IF ((drrr_rf_data->tgt_db_oracle_ver="11.1"))
     SET drrr_rf_data->tgt_shared_pool_size = dvrt_shared_pool_size_1
    ELSEIF ((drrr_rf_data->tgt_db_oracle_ver IN ("11.2", "12.2", "19")))
     SET drrr_rf_data->tgt_shared_pool_size = dvrt_shared_pool_size_2
    ENDIF
   ENDIF
   IF ((drrr_rf_data->tgt_db_oracle_ver="11.1")
    AND cnvtreal(drrr_rf_data->tgt_shared_pool_size) < cnvtreal(dvrt_shared_pool_size_1))
    SET drrr_rf_data->tgt_shared_pool_size = dvrt_shared_pool_size_1
   ELSEIF ((drrr_rf_data->tgt_db_oracle_ver IN ("11.2", "12.2", "19"))
    AND cnvtreal(drrr_rf_data->tgt_shared_pool_size) < cnvtreal(dvrt_shared_pool_size_2))
    SET drrr_rf_data->tgt_shared_pool_size = dvrt_shared_pool_size_2
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_node(null)
   DECLARE dvrtanl_str = vc WITH protect, noconstant("")
   DECLARE dvrtanl_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtanl_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtanl_tmp_node = vc WITH protect, noconstant("")
   DECLARE dvrtanl_idx = i4 WITH protect, noconstant(0)
   IF (((cnvtupper(drrr_rf_data->tgt_db_node) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_node,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db node: ",drrr_rf_data->tgt_db_node)
    SET dm_err->emsg = "Response file target db node (TGT_DB_NODE) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_node_os) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_node_os,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target db node os: ",drrr_rf_data->
     tgt_db_node_os)
    SET dm_err->emsg =
    "Response file target db node os (TGT_DB_NODE_OS) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_db_node_os) IN ("LNX", "AIX", "HPX", "HPUX", "LINUX")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating target db node os is UNIX."
    SET dm_err->emsg = "Target db node os (TGT_DB_NODE_OS) should be LNX/AIX/HPX."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_db_node_os)="HPUX")
    SET drrr_rf_data->tgt_db_node_os = "HPX"
   ELSEIF (cnvtupper(drrr_rf_data->tgt_db_node_os)="LINUX")
    SET drrr_rf_data->tgt_db_node_os = "LNX"
   ENDIF
   SET drrr_rf_data->tgt_db_node_os = cnvtupper(drrr_rf_data->tgt_db_node_os)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_shell_misc(null)
   DECLARE dvrtdsm_str = vc WITH protect, noconstant("")
   DECLARE dvrtdsm_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtdsm_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtdsm_error_cd = vc WITH protect, noconstant("")
   DECLARE dvrtdsm_idx = i4 WITH protect, noconstant(0)
   IF (((cnvtupper(drrr_rf_data->tgt_storage_dg) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_storage_dg,3))=0)) )
    SET drrr_rf_data->tgt_storage_dg = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_recovery_dg) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_recovery_dg,3))=0)) )
    SET drrr_rf_data->tgt_recovery_dg = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_archive_dest1) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_archive_dest1,3))=0)) )
    SET drrr_rf_data->tgt_archive_dest1 = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_asm_sysdba_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_asm_sysdba_pwd,3))=0)) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target asm sysdba password: ",drrr_rf_data->
     tgt_asm_sysdba_pwd)
    SET dm_err->emsg =
    "Response file target asm sysdba password (TGT_ASM_SYSDBA_PWD) must be set to a specific value."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_tns_host_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_tns_host_name,3))=0)) )
    SET drrr_rf_data->tgt_tns_host_name = drrr_rf_data->tgt_db_node
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_tns_port) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_tns_port,3))=0)) )
    SET drrr_rf_data->tgt_tns_port = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_tns_port) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_tns_port,3))=0)) )
    SET drrr_rf_data->adm_tns_port = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_shell_ignorable_error_list) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_shell_ignorable_error_list,3)
    )=0)) )
    SET drrr_rf_data->tgt_shell_ignorable_error_list = '"ORA-01921","ORA-00959"'
   ELSE
    IF (findstring("ORA-01921",drrr_rf_data->tgt_shell_ignorable_error_list,1,0)=0)
     SET drrr_rf_data->tgt_shell_ignorable_error_list = build(drrr_rf_data->
      tgt_shell_ignorable_error_list,',"ORA-01921"')
    ENDIF
    IF (findstring("ORA-00959",drrr_rf_data->tgt_shell_ignorable_error_list,1,0)=0)
     SET drrr_rf_data->tgt_shell_ignorable_error_list = build(drrr_rf_data->
      tgt_shell_ignorable_error_list,',"ORA-00959"')
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_tns_cnct_str) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_tns_cnct_str,3))=0)) )
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
     SET drrr_rf_data->tgt_tns_cnct_str = concat(drrr_rf_data->tgt_db_cnct_str,".world")
    ELSE
     SET drrr_rf_data->tgt_tns_cnct_str = drrr_rf_data->tgt_db_cnct_str
    ENDIF
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_tns_mapping) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET"))
    SET drrr_rf_data->tgt_tns_mapping = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_tns_svc_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_tns_svc_name,3))=0)) )
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
     SET drrr_rf_data->tgt_tns_svc_name = concat("s",drrr_rf_data->tgt_db_name,".world")
    ELSEIF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
     IF ((drrr_rf_data->tgt_tns_mapping="DM2NOTSET"))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat(
       "Validating response file target TNS service name (TGT_TNS_SVC_NAME): ",drrr_rf_data->
       tgt_tns_svc_name)
      SET dm_err->emsg = "TNS service name required for connecting to Target ADB is NOT provided."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ELSE
      SET drrr_rf_data->tgt_tns_svc_name = "DM2NOTSET"
     ENDIF
    ENDIF
   ENDIF
   IF (drrr_val_rf_tgt_tns_mapping(null)=0)
    RETURN(0)
   ENDIF
   WHILE (dvrtdsm_str != dvrtdsm_notfnd)
    SET dvrtdsm_str = piece(drrr_rf_data->tgt_shell_ignorable_error_list,",",dvrtdsm_num,
     dvrtdsm_notfnd)
    IF (dvrtdsm_str != dvrtdsm_notfnd)
     IF (findstring('"',dvrtdsm_str,1,0) != findstring('"',dvrtdsm_str,1,1))
      SET dvrtdsm_error_cd = trim(replace(dvrtdsm_str,'"',"",0),3)
      IF (size(trim(dvrtdsm_error_cd,3)) > 0)
       IF (cnvtalphanum(cnvtupper(dvrtdsm_error_cd)) != cnvtupper(replace(replace(dvrtdsm_error_cd,
          ",","",0),"-","",0)))
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target shell ignorable error list (TGT_SHELL_IGNORABLE_ERROR_LIST): ",
         drrr_rf_data->tgt_shell_ignorable_error_list)
        SET dm_err->emsg = "Error codes can only contain alphanumeric characters and hyphens."
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ELSE
        SET drrr_misc_data->tgt_shell_ign_error_cnt = (drrr_misc_data->tgt_shell_ign_error_cnt+ 1)
        SET stat = alterlist(drrr_misc_data->tgt_shell_ign_errors,drrr_misc_data->
         tgt_shell_ign_error_cnt)
        SET drrr_misc_data->tgt_shell_ign_errors[drrr_misc_data->tgt_shell_ign_error_cnt].error_cd =
        dvrtdsm_error_cd
        SET dvrtdsm_num = (dvrtdsm_num+ 1)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target shell ignorable error list (TGT_SHELL_IGNORABLE_ERROR_LIST): ",
        drrr_rf_data->tgt_shell_ignorable_error_list)
       SET dm_err->emsg = concat("Individual ignorable error in position ",trim(cnvtstring(
          dvrtdsm_num),3)," not properly set.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ELSE
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat(
       "Validating response file target shell ignorable error list (TGT_SHELL_IGNORABLE_ERROR_LIST): ",
       drrr_rf_data->tgt_shell_ignorable_error_list)
      SET dm_err->emsg = concat("Individual ignorable error (",trim(dvrtdsm_str,3),
       ") not wrapped in double-quotes.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDWHILE
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_solution_chks(null)
   DECLARE dvrtdsm_str = vc WITH protect, noconstant("")
   DECLARE dvrtdsm_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtdsm_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtdsm_error_cd = vc WITH protect, noconstant("")
   DECLARE dvrtdsm_idx = i4 WITH protect, noconstant(0)
   IF ((drrr_rf_data->tgt_db_copy_type="REFERENCE"))
    IF ( NOT (cnvtupper(drrr_rf_data->tgt_reapply_sched_templates) IN ("YES", "NO")))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target reapply scheduling templates (TGT_REAPPLY_SCHED_TEMPLATES): ",
      drrr_rf_data->tgt_reapply_sched_templates)
     SET dm_err->emsg =
     'Response file target reapply scheduling templates must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_reapply_sched_templates = cnvtupper(drrr_rf_data->
     tgt_reapply_sched_templates)
    IF ((drrr_rf_data->tgt_reapply_sched_templates="YES"))
     IF ((drrr_rf_data->tgt_reapply_sched_templates_range < 1))
      SET drrr_rf_data->tgt_reapply_sched_templates_range = 90
     ENDIF
     IF (((cnvtupper(drrr_rf_data->tgt_reapply_sched_templates_reset) IN ("*VALUE*REQUIRED*",
     "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->
       tgt_reapply_sched_templates_reset,3))=0)) )
      SET drrr_rf_data->tgt_reapply_sched_templates_reset = "YES"
     ELSEIF ( NOT (cnvtupper(drrr_rf_data->tgt_reapply_sched_templates_reset) IN ("YES", "NO")))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat(
       "Validating response file target reapply scheduling templates reset ",
       "(TGT_REAPPLY_SCHED_TEMPLATES_RESET): ",drrr_rf_data->tgt_reapply_sched_templates_reset)
      SET dm_err->emsg =
      'Response file target reapply scheduling templates reset must be equal to "YES" or "NO" if specified (defaults to YES).'
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET drrr_rf_data->tgt_reapply_sched_templates_reset = cnvtupper(drrr_rf_data->
      tgt_reapply_sched_templates_reset)
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_copy_interrogator) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_copy_interrogator,3))=0)) )
    SET drrr_rf_data->tgt_copy_interrogator = "NO"
   ELSEIF ( NOT (cnvtupper(drrr_rf_data->tgt_copy_interrogator) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file (TGT_COPY_INTERROGATOR): ",drrr_rf_data->
     tgt_copy_interrogator)
    SET dm_err->emsg = concat("Response file target copy interrogator value must be equal ",
     ' to "YES" or "NO" if specified (defaults to NO).')
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_copy_interrogator = cnvtupper(drrr_rf_data->tgt_copy_interrogator)
   IF (((cnvtupper(drrr_rf_data->tgt_interrogator_tmp_dir) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_interrogator_tmp_dir,3))=0))
   )
    SET drrr_rf_data->tgt_interrogator_tmp_dir = "/tmp/"
   ENDIF
   IF (substring(1,1,drrr_rf_data->tgt_interrogator_tmp_dir) != "/")
    SET drrr_rf_data->tgt_interrogator_tmp_dir = concat("/",drrr_rf_data->tgt_interrogator_tmp_dir)
   ENDIF
   IF (findstring("/",trim(drrr_rf_data->tgt_interrogator_tmp_dir),1,1) != size(trim(drrr_rf_data->
     tgt_interrogator_tmp_dir)))
    SET drrr_rf_data->tgt_interrogator_tmp_dir = concat(trim(drrr_rf_data->tgt_interrogator_tmp_dir),
     "/")
   ENDIF
   IF (textlen(drrr_rf_data->tgt_interrogator_tmp_dir) > 175)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file target interrogator temp directory: ",
     drrr_rf_data->tgt_interrogator_tmp_dir)
    SET dm_err->emsg = concat(
     "Full path of target interrogator temp directory should not exceed 175 characters.")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_apply_src_ed_registry(null)
   IF (((cnvtupper(drrr_rf_data->tgt_apply_src_ed_registry) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_apply_src_ed_registry,3))=0
   )) )
    SET drrr_rf_data->tgt_apply_src_ed_registry = "NO"
   ELSEIF ( NOT (cnvtupper(drrr_rf_data->tgt_apply_src_ed_registry) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat(
     "Validating response file target apply source environment definitions registry ",
     "(TGT_APPLY_SRC_ED_REGISTRY): ",drrr_rf_data->tgt_apply_src_ed_registry)
    SET dm_err->emsg = concat(
     "Response file target apply source environment definitions registry must be equal ",
     ' to "YES" or "NO" if specified (defaults to NO).')
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_apply_src_ed_registry = cnvtupper(drrr_rf_data->tgt_apply_src_ed_registry)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_registry_set_name(null)
   IF (((cnvtupper(drrr_rf_data->tgt_reg_ed_set_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_reg_ed_set_name,3))=0)) )
    SET drrr_rf_data->tgt_reg_ed_set_name = "DM2NOTSET"
   ENDIF
   SET drrr_rf_data->tgt_reg_ed_set_name = cnvtupper(drrr_rf_data->tgt_reg_ed_set_name)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_wh(null)
   IF (((cnvtupper(drrr_rf_data->tgt_top_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_top_dir,3))=0)) )
    SET drrr_rf_data->tgt_top_dir = "/cerner"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_mgr_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_mgr_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_mgr_dir = build(drrr_rf_data->tgt_top_dir,"/mgr")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_mgr_log_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_mgr_log_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_mgr_log_dir = build(drrr_rf_data->tgt_cer_mgr_dir,"/log")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_mgr_exe_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_mgr_exe_dir,3))=0)) )
    CASE (dm2_sys_misc->cur_os)
     OF "AIX":
      SET drrr_rf_data->tgt_cer_mgr_exe_dir = build(drrr_rf_data->tgt_cer_mgr_dir,"/aixrs6000")
     OF "HPX":
      SET drrr_rf_data->tgt_cer_mgr_exe_dir = build(drrr_rf_data->tgt_cer_mgr_dir,"/hpuxia64")
     OF "LNX":
      SET drrr_rf_data->tgt_cer_mgr_exe_dir = build(drrr_rf_data->tgt_cer_mgr_dir,"/linuxx86-64")
    ENDCASE
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_reg_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_reg_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_reg_dir = build(drrr_rf_data->tgt_top_dir,"/reg/`hostname`")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_fifo_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_fifo_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_fifo_dir = build(drrr_rf_data->tgt_top_dir,"/fifo")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_usock_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_usock_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_usock_dir = build(drrr_rf_data->tgt_top_dir,"/usock")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_cer_lock_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_cer_lock_dir,3))=0)) )
    SET drrr_rf_data->tgt_cer_lock_dir = build(drrr_rf_data->tgt_top_dir,"/lock")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_wh_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_wh_name,3))=0)) )
    SET drrr_rf_data->tgt_wh_name = build(drrr_rf_data->tgt_domain_name,"_wh")
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_wh_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_wh_dir,3))=0)) )
    SET drrr_rf_data->tgt_wh_dir = build("/cerner/w_standard/",drrr_rf_data->tgt_wh_name)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_user_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_user_name,3))=0)) )
    SET drrr_rf_data->tgt_user_name = build("d_",cnvtlower(drrr_rf_data->tgt_domain_name))
   ENDIF
   IF ( NOT (cnvtupper(drrr_rf_data->common_to_tgt) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file common_to_tgt: ",drrr_rf_data->common_to_tgt
     )
    SET dm_err->emsg = 'Response file common_to_tgt must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_ibus_env_mapping(null)
   DECLARE dvtiem_num = i2 WITH protect, noconstant(1)
   DECLARE dvtiem_str = vc WITH protect, noconstant("")
   DECLARE dvtiem_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvtiem_tmp_str = vc WITH protect, noconstant("")
   DECLARE dvtiem_src_idx = i2 WITH protect, noconstant(0)
   DECLARE dvtiem_src_str = vc WITH protect, noconstant("")
   DECLARE dvtiem_tgt_str = vc WITH protect, noconstant("")
   IF (((cnvtupper(drrr_rf_data->tgt_ibus_env_mapping) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_ibus_env_mapping,3))=0)) )
    SET drrr_rf_data->tgt_ibus_env_mapping = "DM2NOTSET"
    RETURN(1)
   ENDIF
   SET dvtiem_str = build(drrr_rf_data->tgt_ibus_env_mapping)
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("dvtiem_str = ",dvtiem_str))
   ENDIF
   WHILE (dvtiem_str != dvtiem_notfnd)
     SET dvtiem_str = piece(drrr_rf_data->tgt_ibus_env_mapping,",",dvtiem_num,dvtiem_notfnd)
     IF (dvtiem_num=1
      AND dvtiem_str=dvtiem_notfnd)
      SET dvtiem_str = drrr_rf_data->tgt_ibus_env_mapping
     ENDIF
     IF (dvtiem_str != dvtiem_notfnd)
      IF (dvtiem_num <= 50)
       IF (findstring('"',dvtiem_str,1,0) != findstring('"',dvtiem_str,1,1))
        SET dvtiem_tmp_str = trim(replace(dvtiem_str,'"',"",0),3)
        IF (size(trim(dvtiem_tmp_str,3)) > 0)
         IF (findstring(":",dvtiem_tmp_str,1,0) > 1
          AND findstring(":",dvtiem_tmp_str,1,0) < size(trim(dvtiem_tmp_str,3)))
          SET dvtiem_src_str = value(piece(dvtiem_tmp_str,":",1,dvtiem_notfnd))
          SET dvtiem_tgt_str = value(piece(dvtiem_tmp_str,":",2,dvtiem_notfnd))
          IF (((size(dvtiem_src_str) > 256) OR (size(dvtiem_tgt_str) > 256)) )
           SET dm_err->err_ind = 1
           SET dm_err->eproc = concat(
            "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
            drrr_rf_data->tgt_ibus_env_mapping)
           SET dm_err->emsg = concat("iBus environment mapping in position ",trim(cnvtstring(
              dvtiem_num),3)," for both Source and Target should be less than 256 characters")
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           RETURN(0)
          ENDIF
          SET dvtiem_src_idx = 0
          IF (locateval(dvtiem_src_idx,1,drrr_misc_data->tgt_ibus_env_map_cnt,cnvtupper(
            dvtiem_src_str),cnvtupper(drrr_misc_data->tgt_ibus_env_map[dvtiem_src_idx].src_ibus_env))
          =0)
           SET drrr_misc_data->tgt_ibus_env_map_cnt = (drrr_misc_data->tgt_ibus_env_map_cnt+ 1)
           SET stat = alterlist(drrr_misc_data->tgt_ibus_env_map,drrr_misc_data->tgt_ibus_env_map_cnt
            )
           SET drrr_misc_data->tgt_ibus_env_map[drrr_misc_data->tgt_ibus_env_map_cnt].src_ibus_env =
           dvtiem_src_str
           SET drrr_misc_data->tgt_ibus_env_map[drrr_misc_data->tgt_ibus_env_map_cnt].tgt_ibus_env =
           dvtiem_tgt_str
          ELSE
           SET dm_err->err_ind = 1
           SET dm_err->eproc = concat(
            "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
            drrr_rf_data->tgt_ibus_env_mapping)
           SET dm_err->emsg = concat("Source environment in position ",trim(cnvtstring(dvtiem_num),3),
            " should be unique.")
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           RETURN(0)
          ENDIF
          SET dvtiem_num = (dvtiem_num+ 1)
         ELSE
          SET dm_err->err_ind = 1
          SET dm_err->eproc = concat(
           "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
           drrr_rf_data->tgt_ibus_env_mapping)
          SET dm_err->emsg = concat("iBus environment mapping in position ",trim(cnvtstring(
             dvtiem_num),3)," not properly set.")
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
        ELSE
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat(
          "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
          drrr_rf_data->tgt_ibus_env_mapping)
         SET dm_err->emsg = concat("iBus environment mapping in position ",trim(cnvtstring(dvtiem_num
            ),3)," not properly set.")
         SET dm_err->user_action =
         "Please specify iBus environment mappings wrapped in double qotes."
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat(
         "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
         drrr_rf_data->tgt_ibus_env_mapping)
        SET dm_err->emsg = concat("iBus environment mapping (",trim(dvtiem_str,3),
         ") not wrapped in double-quotes.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ELSE
       SET dm_err->err_ind = 1
       SET dm_err->eproc = concat(
        "Validating response file target iBus environment mapping (tgt_IBUS_ENV_MAPPING): ",
        drrr_rf_data->tgt_ibus_env_mapping)
       SET dm_err->emsg = concat("iBus environment mappings should not be more than 50.")
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
     ENDIF
   ENDWHILE
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_db_user_pwd_mapping(null)
   DECLARE dvrtdup_pwd = vc WITH protect, noconstant("")
   DECLARE dvrtdup_user = vc WITH protect, noconstant("")
   DECLARE dvrtdup_str = vc WITH protect, noconstant("")
   DECLARE dvrtdup_user_idx = i2 WITH protect, noconstant(0)
   DECLARE dvrtdup_piece = vc WITH protect, noconstant("")
   DECLARE dvrtdup_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtdup_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtdup_str_cnt = i4 WITH protect, noconstant(0)
   IF (((cnvtupper(drrr_rf_data->tgt_db_user_pwd_mapping) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_user_pwd_mapping,3))=0)) )
    IF ((drrr_misc_data->process_mode="COMPLETE COPY OF DATABASE"))
     SET drrr_rf_data->tgt_db_user_pwd_mapping = "DM2NOTSET"
     RETURN(1)
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validating Target database user/password mapping from response file"
     SET dm_err->emsg = concat(
      "The database user/password mapping is required.  The database user/password mapping must",
      ' be set using a single double-quote delimiter in format of <user>"<pwd>"<user>"<pwd>"<user>"<pwd>'
      )
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET dvrtdup_str = build(drrr_rf_data->tgt_db_user_pwd_mapping)
   IF ((dm_err->debug_flag > 5))
    CALL echo(build("dvrtdup_str = ",dvrtdup_str))
   ENDIF
   SET dvrtdup_str = replace(dvrtdup_str,"<=CERNd=>",'"',0)
   IF ((dm_err->debug_flag > 5))
    CALL echo(build("dvrtdup_str = ",dvrtdup_str))
   ENDIF
   IF (dvrtdup_str > "")
    SET dvrtdup_str_cnt = ((size(trim(dvrtdup_str,1)) - size(trim(replace(dvrtdup_str,'"',""),1)))/
    size('"'))
    IF ((dm_err->debug_flag > 5))
     CALL echo(build("dvrtdup_str_cnt = ",dvrtdup_str_cnt))
    ENDIF
    IF (dvrtdup_str_cnt > 0
     AND even(dvrtdup_str_cnt) != 1)
     WHILE (dvrtdup_piece != dvrtdup_notfnd)
       SET dvrtdup_piece = piece(dvrtdup_str,'"',dvrtdup_num,dvrtdup_notfnd)
       SET dvrtdup_num = (dvrtdup_num+ 1)
       IF (((size(dvrtdup_piece)=0) OR (trim(dvrtdup_piece,3)="")) )
        SET dm_err->err_ind = 1
        SET dm_err->eproc = "Validating Target database user/password mapping from response file"
        SET dm_err->emsg = concat(
         "Response file has empty entry.  The database user/password mapping must be set using",
         ' a single double-quote delimiter in format of <user>"<pwd>"<user>"<pwd>"<user>"<pwd>')
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
     ENDWHILE
     IF (even(dvrtdup_num) != 1)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = "Validating Target database user/password mapping from response file"
      SET dm_err->emsg = concat(
       "Response file entry is not valid - missing user/password pairing.  The database user/password",
       ' mapping must be set using a single double-quote delimiter in format of <user>"<pwd>"<user>"<pwd>"<user>"<pwd>'
       )
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dvrtdup_piece = ""
     SET dvrtdup_num = 1
     WHILE (dvrtdup_piece != dvrtdup_notfnd)
       SET dvrtdup_piece = ""
       SET dvrtdup_piece = piece(dvrtdup_str,'"',dvrtdup_num,dvrtdup_notfnd)
       IF (dvrtdup_piece != dvrtdup_notfnd)
        IF (even(dvrtdup_num)=1)
         SET dvrtdup_pwd = trim(dvrtdup_piece,3)
         IF (dvrtdup_pwd="<pwd>")
          SET dm_err->err_ind = 1
          SET dm_err->eproc = "Validating Target database user/password mapping from response file"
          SET dm_err->emsg = "Found user password still set to <pwd> placeholder."
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
         SET dvrtdup_num = (dvrtdup_num+ 1)
         SET drrr_misc_data->tgt_db_user_pwd_map[drrr_misc_data->tgt_db_user_pwd_map_cnt].pwd =
         dvrtdup_pwd
        ELSE
         SET dvrtdup_user = cnvtupper(trim(dvrtdup_piece,3))
         SET dvrtdup_num = (dvrtdup_num+ 1)
         SET dvrtdup_user_idx = 0
         SET dvrtdup_user_idx = locateval(dvrtdup_user_idx,1,drrr_misc_data->tgt_db_user_pwd_map_cnt,
          dvrtdup_user,drrr_misc_data->tgt_db_user_pwd_map[dvrtdup_user_idx].user)
         IF (dvrtdup_user_idx=0)
          SET drrr_misc_data->tgt_db_user_pwd_map_cnt = (drrr_misc_data->tgt_db_user_pwd_map_cnt+ 1)
          SET stat = alterlist(drrr_misc_data->tgt_db_user_pwd_map,drrr_misc_data->
           tgt_db_user_pwd_map_cnt)
          SET drrr_misc_data->tgt_db_user_pwd_map[drrr_misc_data->tgt_db_user_pwd_map_cnt].user =
          dvrtdup_user
         ELSE
          SET dm_err->err_ind = 1
          SET dm_err->eproc = "Validating Target database user/password mapping from response file"
          SET dm_err->emsg = "Found duplicate user in the response file."
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
        ENDIF
       ENDIF
     ENDWHILE
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validating Target database user/password mapping from response file"
     SET dm_err->emsg = concat(
      "The database user/password mapping is not properly delimited or syntax incorrect.  The database",
      " user/password mapping must be set using a single double-quote delimiter in format of",
      ' <user>"<pwd>"<user>"<pwd>"<user>"<pwd>')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSE
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating Target database user/password mapping from response file"
    SET dm_err->emsg = concat(
     "No target database user/password mapping was specified.  The database user/password mapping must",
     ' be set using a single double-quote delimiter in format of <user>"<pwd>"<user>"<pwd>"<user>"<pwd>'
     )
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvrtdup_user_idx = 0
   SET dvrtdup_user_idx = locateval(dvrtdup_user_idx,1,drrr_misc_data->tgt_db_user_pwd_map_cnt,
    "V500_READ",drrr_misc_data->tgt_db_user_pwd_map[dvrtdup_user_idx].user)
   IF (dvrtdup_user_idx=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating Target database user/password mapping from response file"
    SET dm_err->emsg = "Response file missing V500_READ user/password."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvrtdup_user_idx = 0
   SET dvrtdup_user_idx = locateval(dvrtdup_user_idx,1,drrr_misc_data->tgt_db_user_pwd_map_cnt,
    "V500_EVENT",drrr_misc_data->tgt_db_user_pwd_map[dvrtdup_user_idx].user)
   IF (dvrtdup_user_idx=0)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating Target database user/password mapping from response file"
    SET dm_err->emsg = "Response file missing V500_EVENT user/password."
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET dvrtdup_user_idx = 0
   SET dvrtdup_user_idx = locateval(dvrtdup_user_idx,1,drrr_misc_data->tgt_db_user_pwd_map_cnt,
    drrr_rf_data->tgt_db_user,drrr_misc_data->tgt_db_user_pwd_map[dvrtdup_user_idx].user)
   IF (dvrtdup_user_idx=0)
    SET drrr_misc_data->tgt_db_user_pwd_map_cnt = (drrr_misc_data->tgt_db_user_pwd_map_cnt+ 1)
    SET stat = alterlist(drrr_misc_data->tgt_db_user_pwd_map,drrr_misc_data->tgt_db_user_pwd_map_cnt)
    SET drrr_misc_data->tgt_db_user_pwd_map[drrr_misc_data->tgt_db_user_pwd_map_cnt].user = cnvtupper
    (drrr_rf_data->tgt_db_user)
    SET drrr_misc_data->tgt_db_user_pwd_map[drrr_misc_data->tgt_db_user_pwd_map_cnt].pwd =
    drrr_rf_data->tgt_db_user_pwd
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_datapump(null)
   DECLARE dvra_db_name = vc WITH protect, noconstant("DM2NOTSET")
   DECLARE dvra_ora_client_ver_lvl1 = i2 WITH protect, noconstant(0)
   DECLARE dvra_ora_client_ver_lvl2 = i2 WITH protect, noconstant(0)
   DECLARE dvra_loc = i2 WITH protect, noconstant(0)
   DECLARE dvra_len = i2 WITH protect, noconstant(0)
   DECLARE dvra_dp_log_dir = vc WITH protect, noconstant("")
   SET dvra_db_name = drrr_rf_data->tgt_db_name
   IF ( NOT (cnvtupper(drrr_rf_data->src_dp_dir_setup) IN ("YES", "NO")))
    SET drrr_rf_data->src_dp_dir_setup = "YES"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_dp_dir_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_dp_dir_name,3))=0)) )
    SET drrr_rf_data->tgt_dp_dir_name = cnvtupper(concat(dvra_db_name,"_EXPORT_IMPORT"))
   ELSE
    SET drrr_rf_data->tgt_dp_dir_name = cnvtupper(drrr_rf_data->tgt_dp_dir_name)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_dp_dir_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_dp_dir_name,3))=0)) )
    SET drrr_rf_data->src_dp_dir_name = cnvtupper(concat(dvra_db_name,"_EXPORT_IMPORT"))
   ELSE
    SET drrr_rf_data->src_dp_dir_name = cnvtupper(drrr_rf_data->src_dp_dir_name)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_dp_dir_path) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_dp_dir_path,3))=0)) )
    SET drrr_rf_data->tgt_dp_dir_path = concat(drrr_rf_data->tgt_db_temp_dir,cnvtlower(dvra_db_name),
     "_exp")
   ENDIF
   IF ((drrr_rf_data->tgt_db_deploy_config != "ADB"))
    IF (substring(1,1,drrr_rf_data->tgt_dp_dir_path) != "/")
     SET drrr_rf_data->tgt_dp_dir_path = concat("/",drrr_rf_data->tgt_dp_dir_path)
    ENDIF
   ELSE
    IF (substring(1,1,drrr_rf_data->tgt_dp_dir_path)="/")
     SET drrr_rf_data->tgt_dp_dir_path = replace(drrr_rf_data->tgt_dp_dir_path,"/","",1)
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_dp_dir_path) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_dp_dir_path,3))=0)) )
    SET drrr_rf_data->src_dp_dir_path = concat(drrr_rf_data->src_db_temp_dir,cnvtlower(dvra_db_name),
     "_exp")
   ENDIF
   IF ((drrr_rf_data->src_db_deploy_config != "ADB"))
    IF (substring(1,1,drrr_rf_data->src_dp_dir_path) != "/")
     SET drrr_rf_data->src_dp_dir_path = concat("/",drrr_rf_data->src_dp_dir_path)
    ENDIF
   ELSE
    IF (substring(1,1,drrr_rf_data->src_dp_dir_path)="/")
     SET drrr_rf_data->src_dp_dir_path = replace(drrr_rf_data->src_dp_dir_path,"/","",1)
    ENDIF
   ENDIF
   IF (cnvtupper(drrr_rf_data->src_dp_dir_setup)="YES")
    IF (drrr_val_rf_src_sys_cnnct_data(1)=0)
     RETURN(0)
    ENDIF
   ENDIF
   IF ( NOT (cnvtupper(drrr_rf_data->src_drop_expimp_dir) IN ("YES", "NO")))
    SET drrr_rf_data->src_drop_expimp_dir = "YES"
   ELSE
    SET drrr_rf_data->src_drop_expimp_dir = cnvtupper(drrr_rf_data->src_drop_expimp_dir)
   ENDIF
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_drop_expimp_dir) IN ("YES", "NO")))
    SET drrr_rf_data->tgt_drop_expimp_dir = "YES"
   ELSE
    SET drrr_rf_data->tgt_drop_expimp_dir = cnvtupper(drrr_rf_data->tgt_drop_expimp_dir)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_deploy_config) IN ("OCI", "ADB")) OR (cnvtupper(drrr_rf_data
    ->tgt_db_deploy_config) IN ("OCI", "ADB"))) )
    IF (((cnvtupper(drrr_rf_data->tgt_app_oracle_home) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_oracle_home,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app oracle home: ",drrr_rf_data->
      tgt_app_oracle_home)
     SET dm_err->emsg =
     "Response file target app oracle home (tgt_APP_ORACLE_HOME) must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (substring(1,1,drrr_rf_data->tgt_app_oracle_home) != "/")
     SET drrr_rf_data->tgt_app_oracle_home = concat("/",drrr_rf_data->tgt_app_oracle_home)
    ENDIF
    IF (findstring("/",trim(drrr_rf_data->tgt_app_oracle_home),1,1) != size(trim(drrr_rf_data->
      tgt_app_oracle_home)))
     SET drrr_rf_data->tgt_app_oracle_home = concat(trim(drrr_rf_data->tgt_app_oracle_home),"/")
    ENDIF
    IF (textlen(drrr_rf_data->tgt_app_oracle_home) > 175)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app oracle home: ",drrr_rf_data->
      tgt_app_oracle_home)
     SET dm_err->emsg = concat(
      "Full path of target app oracle home should not exceed 175 characters.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((cnvtupper(drrr_rf_data->tgt_app_oracle_client_ver) IN ("*VALUE*REQUIRED*",
    "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_oracle_client_ver,3))=0
    )) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app oracle client version: ",
      drrr_rf_data->tgt_app_oracle_client_ver)
     SET dm_err->emsg =
     "Response file target app oracle client version (tgt_APP_ORACLE_CLIENT_VER) must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dvra_loc = findstring(".",drrr_rf_data->tgt_app_oracle_client_ver,1,0)
    IF (dvra_loc > 0)
     SET dvra_len = (dvra_loc - 1)
     IF ((dm_err->debug_flag > 0))
      CALL echo(build("dvra_loc = ",dvra_loc))
      CALL echo(build("dvra_len = ",dvra_len))
     ENDIF
     SET dvra_ora_client_ver_lvl1 = cnvtint(substring(1,dvra_len,drrr_rf_data->
       tgt_app_oracle_client_ver))
     SET dvra_prev_loc = dvra_loc
     SET dvra_len = (textlen(drrr_rf_data->tgt_app_oracle_client_ver) - dvra_prev_loc)
     SET dvra_loc = findstring(".",drrr_rf_data->tgt_app_oracle_client_ver,(dvra_prev_loc+ 1),0)
     IF (dvra_loc > 0)
      SET dvra_ora_client_ver_lvl2 = cnvtint(substring((dvra_prev_loc+ 1),((dvra_loc - dvra_prev_loc)
         - 1),drrr_rf_data->tgt_app_oracle_client_ver))
     ELSE
      SET dvra_ora_client_ver_lvl2 = cnvtint(substring((dvra_prev_loc+ 1),dvra_len,drrr_rf_data->
        tgt_app_oracle_client_ver))
     ENDIF
    ENDIF
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("dvra_new_loc = ",dvra_loc))
     CALL echo(build("dvra_len = ",dvra_len))
     CALL echo(build("dvra_ora_client_ver_lvl1 = ",dvra_ora_client_ver_lvl1))
     CALL echo(build("dvra_ora_client_ver_lvl2 = ",dvra_ora_client_ver_lvl2))
    ENDIF
    IF (((dvra_ora_client_ver_lvl1 < 19) OR (dvra_ora_client_ver_lvl1=19
     AND dvra_ora_client_ver_lvl2 < 14)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app oracle client version: ",
      drrr_rf_data->tgt_app_oracle_client_ver)
     SET dm_err->emsg = concat(
      "Response file target app oracle client version (tgt_APP_ORACLE_CLIENT_VER) must be set to ",
      "supported version equal or greater than 19.14.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (((cnvtupper(drrr_rf_data->tgt_app_dp_temp_dir) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_app_dp_temp_dir,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app datapump temp directory: ",
      drrr_rf_data->tgt_app_dp_temp_dir)
     SET dm_err->emsg =
     "Response file target app datapump temp directory must be set to a specific value."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (substring(1,1,drrr_rf_data->tgt_app_dp_temp_dir) != "/")
     SET drrr_rf_data->tgt_app_dp_temp_dir = concat("/",drrr_rf_data->tgt_app_dp_temp_dir)
    ENDIF
    IF (findstring("/",trim(drrr_rf_data->tgt_app_dp_temp_dir),1,1) != size(trim(drrr_rf_data->
      tgt_app_dp_temp_dir)))
     SET drrr_rf_data->tgt_app_dp_temp_dir = concat(trim(drrr_rf_data->tgt_app_dp_temp_dir),"/")
    ENDIF
    IF ( NOT (dm2_find_dir(drrr_rf_data->tgt_app_dp_temp_dir)))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app datapump temp directory: ",
      drrr_rf_data->tgt_app_dp_temp_dir)
     SET dm_err->emsg = "Failed to find target app datapump temp directory. "
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (textlen(drrr_rf_data->tgt_app_dp_temp_dir) > 175)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target app datapump temp directory: ",
      drrr_rf_data->tgt_app_dp_temp_dir)
     SET dm_err->emsg = concat(
      "Full path of target app datapump temp directory should not exceed 175 characters.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (drrr_val_write_privs(drrr_rf_data->tgt_app_dp_temp_dir)=0)
     RETURN(0)
    ENDIF
    SET dvra_dp_log_dir = concat(drrr_rf_data->tgt_app_dp_temp_dir,cnvtlower(dvra_db_name),"_exp")
    IF ( NOT (dm2_find_dir(dvra_dp_log_dir)))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating target app datapump log directory on the app node: ",
      dvra_dp_log_dir)
     SET dm_err->emsg = "Failed to find target app datapump log directory. "
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (drrr_val_write_privs(dvra_dp_log_dir)=0)
     RETURN(0)
    ENDIF
    SET drrr_rf_data->tgt_app_dp_node = drrr_rf_data->tgt_primary_app_node
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_deploy_config) IN ("OCI", "ADB")) OR (cnvtupper(drrr_rf_data
    ->tgt_db_deploy_config) IN ("OCI", "ADB"))) )
    IF ((validate(dm2_bypass_dp_oos,- (1))=- (1)))
     IF (((cnvtupper(drrr_rf_data->dp_cred_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
     "DM2NOTSET")) OR (size(trim(drrr_rf_data->dp_cred_name,3))=0)) )
      SET drrr_rf_data->dp_cred_name = "DP_CRED_NAME"
     ELSE
      SET drrr_rf_data->dp_cred_name = cnvtupper(drrr_rf_data->dp_cred_name)
     ENDIF
     IF (((findstring("-",drrr_rf_data->dp_cred_name,1,0) > 0) OR (findstring(" ",drrr_rf_data->
      dp_cred_name,1,0) > 0)) )
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating datapump credential name: ",drrr_rf_data->dp_cred_name)
      SET dm_err->emsg = "Credential name do not allow spaces or hyphens. "
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (((cnvtupper(drrr_rf_data->dp_user) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
     "DM2NOTSET")) OR (size(trim(drrr_rf_data->dp_user,3))=0)) )
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating datapump user used for credential ",drrr_rf_data->
       dp_user)
      SET dm_err->emsg = "A valid user is required to create datapump credential."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (((cnvtupper(drrr_rf_data->dp_user_pwd) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
     "DM2NOTSET")) OR (size(trim(drrr_rf_data->dp_user_pwd,3))=0)) )
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating datapump user password used for credential ",
       drrr_rf_data->dp_user_pwd)
      SET dm_err->emsg = "A valid user password is required to create datapump credential."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (((cnvtupper(drrr_rf_data->dp_oos_dir_path) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
     "DM2NOTSET")) OR (size(trim(drrr_rf_data->dp_oos_dir_path,3))=0)) )
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating datapump object storage directory path: ",drrr_rf_data->
       dp_oos_dir_path)
      SET dm_err->emsg = "Datapump object storage directory path must be set to a specific value."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (findstring("https://swiftobjectstorage",drrr_rf_data->dp_oos_dir_path,1,0)=0)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating datapump object storage directory path: ",drrr_rf_data->
       dp_oos_dir_path)
      SET dm_err->emsg = "The datapump object storage directory path is not in Swift URI."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     IF (findstring("/",trim(drrr_rf_data->dp_oos_dir_path),1,1) != size(trim(drrr_rf_data->
       dp_oos_dir_path)))
      SET drrr_rf_data->dp_oos_dir_path = concat(trim(drrr_rf_data->dp_oos_dir_path),"/")
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_restore_list(null)
   DECLARE dvrrl_group = vc WITH protect, noconstant("")
   DECLARE dvrrl_value = vc WITH protect, noconstant("")
   DECLARE dvrrl_ind = i2 WITH protect, noconstant(0)
   DECLARE dvrrl_beg = i2 WITH protect, noconstant(1)
   DECLARE dvrrl_end = i2 WITH protect, noconstant(1)
   DECLARE dvrrl_cnt = i2 WITH protect, noconstant(0)
   DECLARE dvrrl_str = vc WITH protect, noconstant("")
   DECLARE dvrrl_group_idx = i2 WITH protect, noconstant(0)
   DECLARE dvrrl_finish = i2 WITH protect, noconstant(0)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_restore_preserve_data) IN ("YES", "NO")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file RESTORE PRESERVE DATA: ",drrr_rf_data->
     tgt_restore_preserve_data)
    SET dm_err->emsg = 'Response file RESTORE PRESERVE DATA must be equal to "YES" or "NO".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   SET drrr_rf_data->tgt_restore_preserve_data = cnvtupper(drrr_rf_data->tgt_restore_preserve_data)
   IF ((drrr_rf_data->tgt_preserve_data="NO")
    AND (drrr_rf_data->tgt_restore_preserve_data="YES"))
    SET dm_err->err_ind = 1
    SET dm_err->eproc =
    'Validating response file restore preserve data indicator (TGT_RESTORE_PRESERVE_DATA) can be set to "YES".'
    SET dm_err->emsg = concat("Response file target preserve data (TGT_PRESERVE_DATA) must ",
     'be equal to "YES" in order to restore preserve data.')
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((drrr_rf_data->tgt_restore_preserve_data="YES"))
    IF (((cnvtupper(drrr_rf_data->tgt_restore_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
    "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_restore_list,3))=0)) )
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target restore list: ",drrr_rf_data->
      tgt_restore_list)
     SET dm_err->emsg = "Response file target restore list list (TGT_RESTORE_LIST) must be set."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    SET dvrrl_str = build(trim(cnvtupper(replace(drrr_rf_data->tgt_restore_list,'"',"",0)),4))
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("dvrrl_str = ",dvrrl_str))
    ENDIF
    IF (dvrrl_str > "")
     WHILE ( NOT (dvrrl_finish))
       SET dvrrl_cnt = (dvrrl_cnt+ 1)
       IF ((dm_err->debug_flag > 0))
        CALL echo(build("cnt = ",dvrrl_cnt))
       ENDIF
       SET dvrrl_beg = dvrrl_end
       SET dvrrl_end = findstring(",",dvrrl_str,(dvrrl_beg+ 1),0)
       IF (dvrrl_end=0)
        SET dvrrl_end = (size(dvrrl_str)+ 1)
        SET dvrrl_finish = 1
       ENDIF
       IF (even(dvrrl_cnt)=1)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("beg = ",dvrrl_beg))
         CALL echo(build("end = ",dvrrl_end))
         CALL echo(substring((dvrrl_beg+ 1),((dvrrl_end - dvrrl_beg) - 1),dvrrl_str))
        ENDIF
        SET dvrrl_value = substring((dvrrl_beg+ 1),((dvrrl_end - dvrrl_beg) - 1),dvrrl_str)
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dvrrl_value = ",dvrrl_value))
        ENDIF
        IF ( NOT (cnvtupper(dvrrl_value) IN ("Y", "N")))
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat("Validating response file Target Restore List: ",drrr_rf_data->
          tgt_restore_list)
         SET dm_err->emsg = 'Response file Target Restore value must be equal to "Y" or "N".'
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
        IF (dvrrl_value="Y")
         SET dvrrl_ind = 1
        ELSE
         SET dvrrl_ind = 0
        ENDIF
        SET drrr_misc_data->tgt_restore_list[drrr_misc_data->tgt_restore_list_cnt].restore_ind =
        dvrrl_ind
       ELSE
        IF (dvrrl_beg=1)
         SET dvrrl_group = substring(dvrrl_beg,(dvrrl_end - dvrrl_beg),dvrrl_str)
        ELSE
         SET dvrrl_group = substring((dvrrl_beg+ 1),((dvrrl_end - dvrrl_beg) - 1),dvrrl_str)
        ENDIF
        IF ((dm_err->debug_flag > 0))
         CALL echo(build("dvrrl_group = ",dvrrl_group))
        ENDIF
        SET dvrrl_group_idx = locateval(dvrrl_group_idx,1,drrr_misc_data->tgt_restore_list_cnt,
         dvrrl_group,drrr_misc_data->tgt_restore_list[dvrrl_group_idx].restore_group)
        IF (dvrrl_group_idx=0)
         SET drrr_misc_data->tgt_restore_list_cnt = (drrr_misc_data->tgt_restore_list_cnt+ 1)
         SET stat = alterlist(drrr_misc_data->tgt_restore_list,drrr_misc_data->tgt_restore_list_cnt)
         SET drrr_misc_data->tgt_restore_list[drrr_misc_data->tgt_restore_list_cnt].restore_group =
         dvrrl_group
        ELSE
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat("Validating response file Target Restore List: ",drrr_rf_data->
          tgt_restore_list)
         SET dm_err->emsg = "Found duplicate restore group in the response file."
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ENDIF
     ENDWHILE
     IF (even(dvrrl_cnt) != 1)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating response file Target Restore List: ",drrr_rf_data->
       tgt_restore_list)
      SET dm_err->emsg = concat(
       "The Target restore list is not properly delimited or syntax is incorrect. ",
       ' The restore list must be in <group>,<y/n> pairings and comma-delimited (i.e. "printers","y","rrd","y").'
       )
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dvrrl_group_idx = 0
     IF (locateval(dvrrl_group_idx,1,drrr_misc_data->tgt_restore_list_cnt,"AUTOTESTER",drrr_misc_data
      ->tgt_restore_list[dvrrl_group_idx].restore_group)=0)
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating response file Target Restore List: ",drrr_rf_data->
       tgt_restore_list)
      SET dm_err->emsg = concat(
       'Group "AUTOTESTER" is missing from the Target restore list. This group is required.')
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_restore_groups(null)
   DECLARE dvrrg_ndx = i4 WITH protect, noconstant(0)
   DECLARE dvrrg_idx = i4 WITH protect, noconstant(0)
   DECLARE dvrrg_no_match = i4 WITH protect, noconstant(0)
   IF ((validate(dvrrg_group->cnt,- (1))=- (1))
    AND (validate(dvrrg_group->cnt,- (2))=- (2)))
    FREE RECORD dvrrg_group
    RECORD dvrrg_group(
      1 cnt = i2
      1 group[*]
        2 group_name = vc
    )
   ENDIF
   IF ((((drrr_rf_data->target_refresh="NO")) OR ((drrr_rf_data->target_refresh="YES")
    AND (drrr_rf_data->tgt_restore_preserve_data="NO"))) )
    RETURN(1)
   ENDIF
   SET dm_err->eproc = "Get preserved group names from dm_info."
   SELECT DISTINCT INTO "nl:"
    di.info_domain
    FROM dm_info di
    WHERE di.info_domain="DM2_PRESERVED_TABLE-*"
     AND di.info_domain != "DM2_PRESERVED_TABLE-NOPROMPT"
     AND di.info_number=1
    DETAIL
     pos = 0, pos = findstring("-",di.info_domain), dvrrg_group->cnt = (dvrrg_group->cnt+ 1),
     stat = alterlist(dvrrg_group->group,dvrrg_group->cnt), dvrrg_group->group[dvrrg_group->cnt].
     group_name = cnvtupper(substring((pos+ 1),size(di.info_domain),di.info_domain))
    WITH nocounter
   ;end select
   IF (check_error(dm_err->eproc)=1)
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   FOR (dvrrg_idx = 1 TO dvrrg_group->cnt)
     SET dvrrg_ndx = 0
     SET dvrrg_ndx = locateval(dvrrg_ndx,1,drrr_misc_data->tgt_restore_list_cnt,dvrrg_group->group[
      dvrrg_idx].group_name,drrr_misc_data->tgt_restore_list[dvrrg_ndx].restore_group)
     IF (dvrrg_ndx=0)
      SET dvrrg_no_match = 1
      SET dm_err->eproc = concat("Response file is missing PRESERVED group: ",dvrrg_group->group[
       dvrrg_idx].group_name)
      CALL disp_msg("",dm_err->logfile,0)
     ENDIF
   ENDFOR
   FOR (dvrrg_idx = 1 TO drrr_misc_data->tgt_restore_list_cnt)
     IF ((drrr_misc_data->tgt_restore_list[dvrrg_idx].restore_group != "AUTOTESTER"))
      SET dvrrg_ndx = 0
      SET dvrrg_ndx = locateval(dvrrg_ndx,1,dvrrg_group->cnt,drrr_misc_data->tgt_restore_list[
       dvrrg_idx].restore_group,dvrrg_group->group[dvrrg_ndx].group_name)
      IF (dvrrg_ndx=0)
       SET dvrrg_no_match = 1
       SET dm_err->eproc = concat("DM_INFO table is missing PRESERVED group: ",drrr_misc_data->
        tgt_restore_list[dvrrg_idx].restore_group)
       CALL disp_msg("",dm_err->logfile,0)
      ENDIF
     ENDIF
   ENDFOR
   IF (dvrrg_no_match=1)
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Matching up dm_info PRESERVED groups with response file."
    SET dm_err->emsg = concat(
     "PRESERVED groups in the response file and DM_INFO table do not match up.",
     " Please verify that all PRESERVED groups in the response file have a matching DM_INFO row and vice versa."
     )
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_drr_shadow_tables(null)
   IF ( NOT (cnvtupper(drrr_rf_data->tgt_expimp_drr_shadow_tables) IN ("YES", "NO")))
    IF ((drrr_rf_data->tgt_expimp_drr_shadow_tables="DM2NOTSET"))
     SET drrr_rf_data->tgt_expimp_drr_shadow_tables = "NO"
    ELSE
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file TGT_EXPIMP_DRR_SHADOW_TABLES: ",
      drrr_rf_data->tgt_expimp_drr_shadow_tables)
     SET dm_err->emsg =
     'Response file token TGT_EXPIMP_DRR_SHADOW_TABLES must be equal to "YES" or "NO".'
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ELSEIF (cnvtupper(drrr_rf_data->tgt_expimp_drr_shadow_tables)="YES")
    IF (cnvtupper(drrr_rf_data->tgt_restore_preserve_data)="YES")
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file TGT_EXPIMP_DRR_SHADOW_TABLES: ",
      drrr_rf_data->tgt_expimp_drr_shadow_tables)
     SET dm_err->emsg =
     "TGT_EXPIMP_DRR_SHADOW_TABLES cannot be turned on when TGT_RESTORE_PRESERVE_DATA is set to YES."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   SET drrr_rf_data->tgt_expimp_drr_shadow_tables = cnvtupper(drrr_rf_data->
    tgt_expimp_drr_shadow_tables)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_mode(null)
   IF (((cnvtupper(drrr_rf_data->mode) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*", "DM2NOTSET"))
    OR (size(trim(drrr_rf_data->mode,3))=0)) )
    SET drrr_rf_data->mode = "DM2NOTSET"
   ENDIF
   SET drrr_rf_data->mode = cnvtupper(drrr_rf_data->mode)
   IF ((drrr_rf_data->mode != "DM2NOTSET"))
    IF ((drrr_rf_data->mode != "ISOLATED"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file MODE: ",drrr_rf_data->mode)
     SET dm_err->emsg = "MODE must be set to ISOLATED if valued."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_create_type) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_create_type,3))=0)) )
    SET drrr_rf_data->tgt_db_create_type = "SHELL"
   ENDIF
   SET drrr_rf_data->tgt_db_create_type = cnvtupper(drrr_rf_data->tgt_db_create_type)
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_isolated_mode(null)
   DECLARE dvrtdct_str = vc WITH protect, noconstant("")
   DECLARE dvrtdct_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvrtdct_num = i4 WITH protect, noconstant(1)
   DECLARE dvrtdct_error_prefix = vc WITH protect, noconstant("")
   DECLARE dvrtdct_local_node_sn = vc WITH protect, noconstant("")
   DECLARE dvrtdct_db_node = vc WITH protect, noconstant("")
   DECLARE dvrtdct_db_node_sn = vc WITH protect, noconstant("")
   FREE RECORD dvrtdct_error_pref_rs
   RECORD dvrtdct_error_pref_rs(
     1 cnt = i4
     1 qual[*]
       2 prefix = vc
   )
   SET dvrtdct_error_pref_rs->cnt = 0
   SET stat = alterlist(dvrtdct_error_pref_rs->qual,0)
   IF (((cnvtupper(drrr_rf_data->src_db_env_name) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_env_name,3))=0)) )
    SET drrr_rf_data->src_db_env_name = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_dbca_template) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_dbca_template,3))=0)) )
    SET drrr_rf_data->tgt_dbca_template = "DM2NOTSET"
   ENDIF
   SET drrr_rf_data->tgt_dbca_template = cnvtlower(drrr_rf_data->tgt_dbca_template)
   IF (((cnvtupper(drrr_rf_data->tgt_case_sens_logon) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_case_sens_logon,3))=0)) )
    SET drrr_rf_data->tgt_case_sens_logon = "DM2NOTSET"
   ENDIF
   SET drrr_rf_data->tgt_case_sens_logon = cnvtupper(drrr_rf_data->tgt_case_sens_logon)
   IF (((cnvtupper(drrr_rf_data->tgt_sql92_security) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_sql92_security,3))=0)) )
    SET drrr_rf_data->tgt_sql92_security = "DM2NOTSET"
   ENDIF
   SET drrr_rf_data->tgt_sql92_security = cnvtupper(drrr_rf_data->tgt_sql92_security)
   IF (((cnvtupper(drrr_rf_data->tgt_characterset) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_characterset,3))=0)) )
    SET drrr_rf_data->tgt_characterset = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_error_prefix_list) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_error_prefix_list,3))=0)) )
    SET drrr_rf_data->tgt_error_prefix_list = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_node) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_node,3))=0)) )
    SET drrr_rf_data->adm_db_node = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_storage_dg) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_storage_dg,3))=0)) )
    SET drrr_rf_data->adm_storage_dg = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_recovery_dg) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_recovery_dg,3))=0)) )
    SET drrr_rf_data->adm_recovery_dg = "DM2NOTSET"
   ENDIF
   IF ((drrr_rf_data->mode="ISOLATED"))
    IF ((drrr_rf_data->tgt_db_create_type="SHELL"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target database create type (TGT_DB_CREATE_TYPE): ",drrr_rf_data->
      tgt_db_create_type)
     SET dm_err->emsg = "TGT_DB_CREATE_TYPE must be valued based on clinical dbca template."
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->target_refresh != "NO"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file mode (MODE): ",drrr_rf_data->mode)
     SET dm_err->emsg = concat("Response file target refresh indicator (TARGET_REFRESH) must ",
      'be equal to "NO" for "ISOLATED" mode.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_db_copy_type != "ALTERNATE"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file mode (MODE): ",drrr_rf_data->mode)
     SET dm_err->emsg = concat("Response file target db copy type (TGT_DB_COPY_TYPE) must ",
      'be equal to "ALTERNATE" for "ISOLATED" mode.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->src_db_env_name="DM2NOTSET"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file mode (MODE): ",drrr_rf_data->mode)
     SET dm_err->emsg = concat("Response file source database environment name (SRC_DB_ENV_NAME) ",
      'must be valued for "ISOLATED" mode.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_db_oracle_ver != "19"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file mode (MODE): ",drrr_rf_data->mode)
     SET dm_err->emsg = concat(
      "Response file target database oracle version (TGT_DB_ORACLE_VER) must ",
      'be 19 for "ISOLATED" mode.')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_dbca_template != "dm2_dbca_seeded_*.dbc"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target dbca template (TGT_DBCA_TEMPLATE): ",
      drrr_rf_data->tgt_dbca_template)
     SET dm_err->emsg = concat(
      'TGT_DBCA_TEMPLATE must be in format of "dm2_dbca_seeded_<tgt_db_create_type>.dbc".')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF (findstring(cnvtlower(drrr_rf_data->tgt_db_create_type),drrr_rf_data->tgt_dbca_template)=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target database create type (TGT_DB_CREATE_TYPE): ",drrr_rf_data->
      tgt_db_create_type)
     SET dm_err->emsg = concat("TGT_DB_CREATE_TYPE must be contained in the target dbca template (",
      drrr_rf_data->tgt_dbca_template,").")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ( NOT ((drrr_rf_data->tgt_case_sens_logon IN ("FALSE", "TRUE"))))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target case sensitive logon (TGT_CASE_SENS_LOGON): ",drrr_rf_data->
      tgt_case_sens_logon)
     SET dm_err->emsg = concat('TGT_CASE_SENS_LOGON must be equal to "TRUE" or "FALSE".')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ( NOT ((drrr_rf_data->tgt_sql92_security IN ("FALSE", "TRUE"))))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat(
      "Validating response file target sql92 security (TGT_SQL92_SECURITY): ",drrr_rf_data->
      tgt_sql92_security)
     SET dm_err->emsg = concat('TGT_SQL92_SECURITY must be equal to "TRUE" or "FALSE".')
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_characterset="DM2NOTSET"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file target characterset (TGT_CHARACTERSET): ",
      drrr_rf_data->tgt_characterset)
     SET dm_err->emsg = concat("TGT_CHARACTERSET must be valued.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->adm_db_node="DM2NOTSET"))
     SET dm_err->err_ind = 1
     SET dm_err->eproc = concat("Validating response file admin database node (ADM_DB_NODE): ",
      drrr_rf_data->adm_db_node)
     SET dm_err->emsg = concat("ADM_DB_NODE must be valued.")
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
    IF ((drrr_rf_data->tgt_error_prefix_list != "DM2NOTSET"))
     IF (findstring('"',drrr_rf_data->tgt_error_prefix_list,1,0) > 0
      AND findstring('"',drrr_rf_data->tgt_error_prefix_list,1,0) != findstring('"',drrr_rf_data->
      tgt_error_prefix_list,1,1))
      WHILE (dvrtdct_str != dvrtdct_notfnd)
       SET dvrtdct_str = piece(drrr_rf_data->tgt_error_prefix_list,",",dvrtdct_num,dvrtdct_notfnd)
       IF (dvrtdct_str != dvrtdct_notfnd)
        IF (findstring('"',dvrtdct_str,1,0) != findstring('"',dvrtdct_str,1,1))
         SET dvrtdct_error_prefix = trim(replace(dvrtdct_str,'"',"",0),3)
         IF (size(trim(dvrtdct_error_prefix,3)) > 0)
          SET dvrtdct_error_pref_rs->cnt = (dvrtdct_error_pref_rs->cnt+ 1)
          SET stat = alterlist(dvrtdct_error_pref_rs->qual,dvrtdct_error_pref_rs->cnt)
          SET dvrtdct_error_pref_rs->qual[dvrtdct_error_pref_rs->cnt].prefix = dvrtdct_error_prefix
          SET dvrtdct_num = (dvrtdct_num+ 1)
         ELSE
          SET dm_err->err_ind = 1
          SET dm_err->eproc = concat("Validating override error prefixes: ",drrr_rf_data->
           tgt_error_prefix_list)
          SET dm_err->emsg = concat("Individual override error prefix in position ",trim(cnvtstring(
             dvrtdct_num),3)," not properly set.")
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
        ELSE
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat("Validating override error prefixes: ",drrr_rf_data->
          tgt_error_prefix_list)
         SET dm_err->emsg = concat("Individual override error prefix (",trim(dvrtdct_str,3),
          ") not wrapped in double-quotes.")
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ENDIF
      ENDWHILE
     ELSE
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating override error prefixes: ",drrr_rf_data->
       tgt_error_prefix_list)
      SET dm_err->emsg = concat(
       "Individual override error prefixes does not contain any double-quotes or pairs.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
    IF ((drrr_misc_data->process_mode IN ("ADMIN DATABASE CREATION", "CLINICAL DATABASE CREATION")))
     SET dvrtdct_local_node_sn = build(curnode)
     SET dvrtdct_db_node = drrr_rf_data->tgt_db_node
     SET dvrtdct_db_node_sn = dvrtdct_db_node
     IF (validate(dm2_skip_db_shell_fqdn_check,0)=1)
      IF (findstring(".",dvrtdct_db_node,1,0) > 0)
       SET dvrtdct_db_node_sn = substring(1,(findstring(".",dvrtdct_db_node,1,0) - 1),dvrtdct_db_node
        )
      ENDIF
     ENDIF
     IF (cnvtupper(dvrtdct_db_node_sn)=cnvtupper(dvrtdct_local_node_sn))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating response file target db node: ",drrr_rf_data->
       tgt_db_node)
      SET dm_err->emsg = "Target db node (TGT_DB_NODE) cannot be local node."
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
     SET dvrtdct_db_node = drrr_rf_data->adm_db_node
     SET dvrtdct_db_node_sn = dvrtdct_db_node
     IF (validate(dm2_skip_db_shell_fqdn_check,0)=1)
      IF (findstring(".",dvrtdct_db_node,1,0) > 0)
       SET dvrtdct_db_node_sn = substring(1,(findstring(".",dvrtdct_db_node,1,0) - 1),dvrtdct_db_node
        )
      ENDIF
     ENDIF
     IF (cnvtupper(dvrtdct_db_node_sn)=cnvtupper(dvrtdct_local_node_sn))
      SET dm_err->err_ind = 1
      SET dm_err->eproc = concat("Validating response file admin database node (ADM_DB_NODE): ",
       drrr_rf_data->adm_db_node)
      SET dm_err->emsg = concat("Admin db node (ADM_DB_NODE) cannot be local node.")
      CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
      RETURN(0)
     ENDIF
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_ping_nodes(dvrpn_in_src_ind,dvrpn_in_tgt_ind,dvrpn_in_adm_ind,dvrpn_in_local)
   IF (validate(dm2_bypass_rr_all_pings,0)=1)
    RETURN(1)
   ENDIF
   DECLARE dvrpn_num = i4 WITH protect, noconstant(1)
   IF (dvrpn_in_src_ind=1)
    IF (dvrpn_in_local="TARGET"
     AND (drrr_rf_data->mode != "ISOLATED"))
     IF ((((drrr_rf_data->src_db_deploy_config IN ("OCI", "ADB"))) OR ((drrr_rf_data->
     tgt_db_deploy_config IN ("OCI", "ADB")))) )
      SET dm_err->eproc = "Skips pinging all SOURCE nodes"
      CALL disp_msg("",dm_err->logfile,0)
     ELSE
      FOR (dvrpn_num = 1 TO drrr_misc_data->src_app_node_cnt)
        IF (dm2_ping(drrr_misc_data->src_app_nodes[dvrpn_num].node_name)=0)
         SET dm_err->err_ind = 1
         SET dm_err->eproc = "Validating connectivity to all source nodes"
         SET dm_err->emsg = concat("Unable to ping source node: ",drrr_misc_data->src_app_nodes[
          dvrpn_num].node_name)
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
      ENDFOR
     ENDIF
    ENDIF
   ENDIF
   IF (dvrpn_in_tgt_ind=1)
    IF (dvrpn_in_local="SOURCE"
     AND (drrr_rf_data->mode != "ISOLATED"))
     IF ((((drrr_rf_data->src_db_deploy_config IN ("OCI", "ADB"))) OR ((drrr_rf_data->
     tgt_db_deploy_config IN ("OCI", "ADB")))) )
      SET dm_err->eproc = "Skips pinging all TARGET nodes"
      CALL disp_msg("",dm_err->logfile,0)
     ELSE
      FOR (dvrpn_num = 1 TO drrr_misc_data->tgt_app_node_cnt)
        IF (dm2_ping(drrr_misc_data->tgt_app_nodes[dvrpn_num].node_name)=0)
         SET dm_err->err_ind = 1
         SET dm_err->eproc = "Validating connectivity to all target nodes"
         SET dm_err->emsg = concat("Unable to ping target node: ",drrr_misc_data->tgt_app_nodes[
          dvrpn_num].node_name)
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
      ENDFOR
     ENDIF
    ENDIF
    IF (dvrpn_in_local="TARGET"
     AND (drrr_rf_data->mode != "ISOLATED"))
     IF ((drrr_rf_data->tgt_db_deploy_config IN ("OCI", "ADB")))
      SET dm_err->eproc = "Skips pinging the TARGET database node."
      CALL disp_msg("",dm_err->logfile,0)
     ELSE
      IF (dm2_ping(drrr_rf_data->tgt_db_node)=0)
       SET dm_err->err_ind = 1
       SET dm_err->eproc = "Validating connectivity to target db node"
       SET dm_err->emsg = concat("Unable to ping target db node (TGT_DB_NODE): ",drrr_rf_data->
        tgt_db_node)
       CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
       RETURN(0)
      ENDIF
      IF (cnvtupper(drrr_rf_data->tgt_tns_host_name) != cnvtupper(drrr_rf_data->tgt_db_node)
       AND (drrr_rf_data->target_refresh="NO"))
       IF (dm2_ping(drrr_rf_data->tgt_tns_host_name)=0)
        SET dm_err->err_ind = 1
        SET dm_err->eproc = "Validating connectivity to target tns host name."
        SET dm_err->emsg = concat("Unable to ping target tns host name (TGT_TNS_HOST_NAME): ",
         drrr_rf_data->tgt_tns_host_name)
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
   IF (dvrpn_in_adm_ind=1)
    IF (dm2_ping(drrr_rf_data->adm_db_node)=0)
     SET dm_err->err_ind = 1
     SET dm_err->eproc = "Validating connectivity to admin db node"
     SET dm_err->emsg = concat("Unable to ping admin db node (ADM_DB_NODE): ",drrr_rf_data->
      adm_db_node)
     CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
     RETURN(0)
    ENDIF
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_drop_db_links(null)
  IF ( NOT (cnvtupper(drrr_rf_data->tgt_drop_db_links) IN ("YES", "NO")))
   SET drrr_rf_data->tgt_drop_db_links = "YES"
  ELSE
   SET drrr_rf_data->tgt_drop_db_links = cnvtupper(drrr_rf_data->tgt_drop_db_links)
  ENDIF
  RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_deploy_configs(null)
   IF (((cnvtupper(drrr_rf_data->src_db_deploy_config) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_deploy_config,3))=0)) )
    SET drrr_rf_data->src_db_deploy_config = "DM2NOTSET"
   ENDIF
   IF (cnvtupper(drrr_rf_data->src_db_deploy_config)="DM2NOTSET")
    SET drrr_rf_data->src_db_deploy_config = "OP"
   ELSEIF ( NOT (cnvtupper(drrr_rf_data->src_db_deploy_config) IN ("OP", "OCI", "ADB")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file SRC_DB_DEPLOY_CONFIG: ",drrr_rf_data->
     src_db_deploy_config)
    SET dm_err->emsg = 'Response file SRC_DB_DEPLOY_CONFIG must be equal to "OP", "OCI" or "ADB".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET drrr_rf_data->src_db_deploy_config = cnvtupper(drrr_rf_data->src_db_deploy_config)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_deploy_config) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_deploy_config,3))=0)) )
    SET drrr_rf_data->tgt_db_deploy_config = "DM2NOTSET"
   ENDIF
   IF (cnvtupper(drrr_rf_data->tgt_db_deploy_config)="DM2NOTSET")
    SET drrr_rf_data->tgt_db_deploy_config = "OP"
   ELSEIF ( NOT (cnvtupper(drrr_rf_data->tgt_db_deploy_config) IN ("OP", "OCI", "ADB")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file TGT_DB_DEPLOY_CONFIG: ",drrr_rf_data->
     tgt_db_deploy_config)
    SET dm_err->emsg = 'Response file TGT_DB_DEPLOY_CONFIG must be equal to "OP", "OCI" or "ADB".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET drrr_rf_data->tgt_db_deploy_config = cnvtupper(drrr_rf_data->tgt_db_deploy_config)
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_deploy_config) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_deploy_config,3))=0)) )
    SET drrr_rf_data->adm_db_deploy_config = "DM2NOTSET"
   ENDIF
   IF (cnvtupper(drrr_rf_data->adm_db_deploy_config)="DM2NOTSET")
    SET drrr_rf_data->adm_db_deploy_config = "OP"
   ELSEIF ( NOT (cnvtupper(drrr_rf_data->adm_db_deploy_config) IN ("OP", "OCI", "ADB")))
    SET dm_err->err_ind = 1
    SET dm_err->eproc = concat("Validating response file ADM_DB_DEPLOY_CONFIG: ",drrr_rf_data->
     adm_db_deploy_config)
    SET dm_err->emsg = 'Response file ADM_DB_DEPLOY_CONFIG must be equal to "OP", "OCI" or "ADB".'
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ELSE
    SET drrr_rf_data->adm_db_deploy_config = cnvtupper(drrr_rf_data->adm_db_deploy_config)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_tns_mapping(null)
   DECLARE dvtonm_num = i2 WITH protect, noconstant(1)
   DECLARE dvtonm_str = vc WITH protect, noconstant("")
   DECLARE dvtonm_notfnd = vc WITH protect, constant("<not_found>")
   DECLARE dvtonm_tmp_str = vc WITH protect, noconstant("")
   DECLARE dvrttsm_tns_idx = i4 WITH protect, noconstant(0)
   DECLARE dvrttsm_db_cnct_str = vc WITH protect, noconstant("")
   DECLARE dvrttsm_world_idx = i2 WITH protect, noconstant(0)
   SET dvtonm_str = drrr_rf_data->tgt_tns_mapping
   IF ((dm_err->debug_flag > 0))
    CALL echo(build("dvtonm_str = ",dvtonm_str))
   ENDIF
   IF ((drrr_rf_data->tgt_tns_mapping != "DM2NOTSET"))
    WHILE (dvtonm_str != dvtonm_notfnd)
      SET dvtonm_str = piece(drrr_rf_data->tgt_tns_mapping,",",dvtonm_num,dvtonm_notfnd)
      IF (dvtonm_num=1
       AND dvtonm_str=dvtonm_notfnd)
       SET dvtonm_str = drrr_rf_data->tgt_tns_mapping
      ENDIF
      IF (dvtonm_str != dvtonm_notfnd)
       IF (findstring('"',dvtonm_str,1,0) != findstring('"',dvtonm_str,1,1))
        SET dvtonm_tmp_str = cnvtlower(trim(replace(dvtonm_str,'"',"",0),3))
        IF (size(trim(dvtonm_tmp_str,3)) > 0)
         IF (findstring(":",dvtonm_tmp_str,1,0) > 1
          AND findstring(":",dvtonm_tmp_str,1,0) < size(trim(dvtonm_tmp_str,3)))
          SET dvrttsm_list_tns_entry = piece(dvtonm_tmp_str,":",1,dvtonm_notfnd)
          SET dvrttsm_list_svc_name = piece(dvtonm_tmp_str,":",2,dvtonm_notfnd)
          SET dvrttsm_tns_idx = 0
          IF (locateval(dvrttsm_tns_idx,1,drrr_misc_data->tgt_tns_map_cnt,dvrttsm_list_tns_entry,
           drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].tns_entry)=0)
           SET drrr_misc_data->tgt_tns_map_cnt = (drrr_misc_data->tgt_tns_map_cnt+ 1)
           SET stat = alterlist(drrr_misc_data->tgt_tns_map,drrr_misc_data->tgt_tns_map_cnt)
           SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].tns_entry =
           dvrttsm_list_tns_entry
           SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].service_name =
           dvrttsm_list_svc_name
           SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].host = drrr_rf_data->
           tgt_tns_host_name
           SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].port = drrr_rf_data->
           tgt_tns_port
           SET dvtonm_num = (dvtonm_num+ 1)
          ELSE
           SET dm_err->err_ind = 1
           SET dm_err->eproc = concat(
            "Validating response file Target TNS cnct str name and TNS service name list: ",
            drrr_rf_data->tgt_tns_mapping)
           SET dm_err->emsg = concat("Found duplicate TNS entry in the response file. Remove (",
            drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].tns_entry,") entry and try again.")
           CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
           RETURN(0)
          ENDIF
         ELSE
          SET dm_err->err_ind = 1
          SET dm_err->eproc = concat("Validating response file target TNS cnct str name and ",
           "TNS service name mapping (tgt_tns_mapping): ",drrr_rf_data->tgt_tns_mapping)
          SET dm_err->emsg = concat("TNS entry and service name mapping in position ",trim(cnvtstring
            (dvtonm_num),3)," not properly set.")
          CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
          RETURN(0)
         ENDIF
        ELSE
         SET dm_err->err_ind = 1
         SET dm_err->eproc = concat("Validating response file target TNS cnct str name and ",
          "TNS service name mapping (tgt_tns_mapping): ",drrr_rf_data->tgt_tns_mapping)
         SET dm_err->emsg = concat("TNS entry and service name mapping in position ",trim(cnvtstring(
            dvtonm_num),3)," not properly set.")
         CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
         RETURN(0)
        ENDIF
       ELSE
        SET dm_err->err_ind = 1
        SET dm_err->eproc = concat("Validating response file target TNS cnct str name and ",
         "TNS service name mapping (tgt_tns_mapping): ",drrr_rf_data->tgt_tns_mapping)
        SET dm_err->emsg = concat("TNS entry and service name mapping (",trim(dvtonm_str,3),
         ") not wrapped in double-quotes.")
        CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
        RETURN(0)
       ENDIF
      ENDIF
    ENDWHILE
   ENDIF
   IF ((drrr_misc_data->tgt_tns_map_cnt=0)
    AND (drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
    IF (drrr_load_default_tns_map(concat(drrr_rf_data->tgt_db_name,".world"))=0)
     RETURN(0)
    ENDIF
    IF (drrr_load_default_tns_map(concat(drrr_rf_data->tgt_db_name,"1.world"))=0)
     RETURN(0)
    ENDIF
   ENDIF
   SET dvrttsm_tns_idx = 0
   IF ((drrr_misc_data->tgt_tns_map_cnt > 0))
    SET dvrttsm_tns_idx = locateval(dvrttsm_tns_idx,1,drrr_misc_data->tgt_tns_map_cnt,cnvtlower(
      drrr_rf_data->tgt_tns_cnct_str),cnvtlower(drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].
      tns_entry))
    IF ((drrr_rf_data->tgt_db_deploy_config="ADB")
     AND (drrr_rf_data->tgt_tns_svc_name="DM2NOTSET"))
     SET drrr_rf_data->tgt_tns_svc_name = drrr_misc_data->tgt_tns_map[1].service_name
    ENDIF
   ENDIF
   IF (dvrttsm_tns_idx=0)
    IF (drrr_load_default_tns_map(drrr_rf_data->tgt_tns_cnct_str)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("TNS entry (",drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].tns_entry,
       ") already exists."))
    ENDIF
   ENDIF
   SET dvrttsm_tns_idx = 0
   IF ((drrr_misc_data->tgt_tns_map_cnt > 0))
    SET dvrttsm_world_idx = 0
    SET dvrttsm_world_idx = findstring(".world",cnvtlower(drrr_misc_data->tgt_tns_map[1].tns_entry),1,
     0)
    IF ((dm_err->debug_flag > 0))
     CALL echo(build("dvrttsm_world_idx:",dvrttsm_world_idx))
    ENDIF
    SET dvrttsm_tns_idx = locateval(dvrttsm_tns_idx,1,drrr_misc_data->tgt_tns_map_cnt,evaluate(
      dvrttsm_world_idx,0,cnvtlower(drrr_rf_data->tgt_db_cnct_str),concat(cnvtlower(drrr_rf_data->
        tgt_db_cnct_str),".world")),cnvtlower(drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].tns_entry)
     )
   ENDIF
   IF (dvrttsm_tns_idx=0)
    IF (drrr_load_default_tns_map(drrr_rf_data->tgt_db_cnct_str)=0)
     RETURN(0)
    ENDIF
   ELSE
    IF ((dm_err->debug_flag > 0))
     CALL echo(concat("TNS entry (",drrr_misc_data->tgt_tns_map[dvrttsm_tns_idx].tns_entry,
       ") already exists."))
    ENDIF
   ENDIF
   IF ((dm_err->debug_flag > 0))
    CALL echorecord(drrr_misc_data)
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_load_default_tns_map(dldtm_tns_entry)
   SET dm_err->eproc = concat("Loading TNS entry ",dldtm_tns_entry," into target TNS map.")
   IF ((dm_err->debug_flag > 0))
    CALL disp_msg("",dm_err->logfile,0)
   ENDIF
   SET drrr_misc_data->tgt_tns_map_cnt = (drrr_misc_data->tgt_tns_map_cnt+ 1)
   SET stat = alterlist(drrr_misc_data->tgt_tns_map,drrr_misc_data->tgt_tns_map_cnt)
   SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].tns_entry = dldtm_tns_entry
   SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].service_name = drrr_rf_data->
   tgt_tns_svc_name
   SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].host = drrr_rf_data->
   tgt_tns_host_name
   SET drrr_misc_data->tgt_tns_map[drrr_misc_data->tgt_tns_map_cnt].port = drrr_rf_data->tgt_tns_port
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_tgt_default_tspaces(null)
   IF (((cnvtupper(drrr_rf_data->tgt_default_misc_ts) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_default_misc_ts,3))=0)) )
    SET drrr_rf_data->tgt_default_misc_ts = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_default_temp_ts) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_default_temp_ts,3))=0)) )
    SET drrr_rf_data->tgt_default_temp_ts = "DM2NOTSET"
   ENDIF
   RETURN(1)
 END ;Subroutine
 SUBROUTINE drrr_val_rf_cred_link_data(null)
   IF (((cnvtupper(drrr_rf_data->tgt_db_adm_db_link_name) IN ("*VALUE*REQUIRED*",
   "*VALUE*UNSPECIFIED*", "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_adm_db_link_name,3))=0)) )
    SET drrr_rf_data->tgt_db_adm_db_link_name = "ADMIN1"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_cred_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_cred_nm,3))=0)) )
    SET drrr_rf_data->adm_db_cred_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_link_host) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_link_host,3))=0)) )
    SET drrr_rf_data->adm_db_link_host = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_link_port) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_link_port,3))=0)) )
    SET drrr_rf_data->adm_db_link_port = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_link_svc_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_link_svc_nm,3))=0)) )
    SET drrr_rf_data->adm_db_link_svc_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->adm_db_link_cnct_desc) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->adm_db_link_cnct_desc,3))=0)) )
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
     IF ((drrr_rf_data->adm_db_link_host="DM2NOTSET")
      AND (drrr_rf_data->adm_db_link_port="DM2NOTSET")
      AND (drrr_rf_data->adm_db_link_svc_nm="DM2NOTSET"))
      SET drrr_rf_data->adm_db_link_cnct_desc = drrr_rf_data->adm_db_cnct_str
     ELSE
      SET drrr_rf_data->adm_db_link_cnct_desc = "DM2NOTSET"
     ENDIF
    ELSEIF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
     SET drrr_rf_data->adm_db_link_cnct_desc = "DM2NOTSET"
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_cred_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_cred_nm,3))=0)) )
    SET drrr_rf_data->tgt_db_cred_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_link_host) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_link_host,3))=0)) )
    SET drrr_rf_data->tgt_db_link_host = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_link_port) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_link_port,3))=0)) )
    SET drrr_rf_data->tgt_db_link_port = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_link_svc_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_link_svc_nm,3))=0)) )
    SET drrr_rf_data->tgt_db_link_svc_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->tgt_db_link_cnct_desc) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->tgt_db_link_cnct_desc,3))=0)) )
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
     IF ((drrr_rf_data->tgt_db_link_host="DM2NOTSET")
      AND (drrr_rf_data->tgt_db_link_port="DM2NOTSET")
      AND (drrr_rf_data->tgt_db_link_svc_nm="DM2NOTSET"))
      SET drrr_rf_data->tgt_db_link_cnct_desc = drrr_rf_data->tgt_db_cnct_str
     ELSE
      SET drrr_rf_data->tgt_db_link_cnct_desc = "DM2NOTSET"
     ENDIF
    ELSEIF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
     SET drrr_rf_data->tgt_db_link_cnct_desc = "DM2NOTSET"
    ENDIF
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_cred_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_cred_nm,3))=0)) )
    SET drrr_rf_data->src_db_cred_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_link_host) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_link_host,3))=0)) )
    SET drrr_rf_data->src_db_link_host = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_link_port) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_link_port,3))=0)) )
    SET drrr_rf_data->src_db_link_port = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_link_svc_nm) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_link_svc_nm,3))=0)) )
    SET drrr_rf_data->src_db_link_svc_nm = "DM2NOTSET"
   ENDIF
   IF (((cnvtupper(drrr_rf_data->src_db_link_cnct_desc) IN ("*VALUE*REQUIRED*", "*VALUE*UNSPECIFIED*",
   "DM2NOTSET")) OR (size(trim(drrr_rf_data->src_db_link_cnct_desc,3))=0)) )
    SET drrr_rf_data->src_db_link_cnct_desc = "DM2NOTSET"
    IF ((drrr_rf_data->tgt_db_deploy_config IN ("OP", "OCI")))
     IF ((drrr_rf_data->src_db_link_host="DM2NOTSET")
      AND (drrr_rf_data->src_db_link_port="DM2NOTSET")
      AND (drrr_rf_data->src_db_link_svc_nm="DM2NOTSET"))
      SET drrr_rf_data->src_db_link_cnct_desc = drrr_rf_data->src_db_cnct_str
     ELSE
      SET drrr_rf_data->src_db_link_cnct_desc = "DM2NOTSET"
     ENDIF
    ELSEIF ((drrr_rf_data->tgt_db_deploy_config="ADB"))
     SET drrr_rf_data->src_db_link_cnct_desc = "DM2NOTSET"
    ENDIF
   ENDIF
   IF ((drrr_rf_data->tgt_db_deploy_config="ADB")
    AND (((drrr_rf_data->adm_db_cred_nm="DM2NOTSET")) OR ((((drrr_rf_data->adm_db_link_host=
   "DM2NOTSET")) OR ((((drrr_rf_data->adm_db_link_port="DM2NOTSET")) OR ((drrr_rf_data->
   adm_db_link_svc_nm="DM2NOTSET"))) )) )) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating response file admin database credential/link data."
    SET dm_err->emsg = trim(evaluate(drrr_rf_data->adm_db_cred_nm,"DM2NOTSET","ADM_DB_CRED_NM,"," "),
     3)
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->adm_db_link_host,"DM2NOTSET",
       "ADM_DB_LINK_HOST,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->adm_db_link_port,"DM2NOTSET",
       "ADM_DB_LINK_PORT,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->adm_db_link_svc_nm,"DM2NOTSET",
       "ADM_DB_LINK_SVC_NM,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->adm_db_link_cnct_desc,
       "DM2NOTSET","ADM_DB_LINK_CNCT_DESC,"," "),3))
    SET dm_err->emsg = trim(replace(dm_err->emsg,",","",2),3)
    SET dm_err->emsg = concat("Response file admin database credential/link data must be set ",
     "when Target (",drrr_rf_data->tgt_db_deploy_config,
     ") is autonomous database (ADB).  Token(s) not set: ",dm_err->emsg,
     ".")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((drrr_rf_data->src_db_deploy_config="ADB")
    AND (((drrr_rf_data->tgt_db_cred_nm="DM2NOTSET")) OR ((((drrr_rf_data->tgt_db_link_host=
   "DM2NOTSET")) OR ((((drrr_rf_data->tgt_db_link_port="DM2NOTSET")) OR ((drrr_rf_data->
   tgt_db_link_svc_nm="DM2NOTSET"))) )) )) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating response file target database credential/link data."
    SET dm_err->emsg = trim(evaluate(drrr_rf_data->tgt_db_cred_nm,"DM2NOTSET","TGT_DB_CRED_NM,"," "),
     3)
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->tgt_db_link_host,"DM2NOTSET",
       "TGT_DB_LINK_HOST,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->tgt_db_link_port,"DM2NOTSET",
       "TGT_DB_LINK_PORT,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->tgt_db_link_svc_nm,"DM2NOTSET",
       "TGT_DB_LINK_SVC_NM,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->tgt_db_link_cnct_desc,
       "DM2NOTSET","TGT_DB_LINK_CNCT_DESC,"," "),3))
    SET dm_err->emsg = trim(replace(dm_err->emsg,",","",2),3)
    SET dm_err->emsg = concat("Response file target database credential/link data must be set ",
     "when Source (",drrr_rf_data->src_db_deploy_config,
     ") is autonomous database (ADB).  Token(s) not set: ",dm_err->emsg,
     ".")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
   IF ((((drrr_rf_data->src_db_deploy_config="ADB")) OR ((drrr_rf_data->tgt_db_deploy_config="ADB")
   ))
    AND (((drrr_rf_data->src_db_cred_nm="DM2NOTSET")) OR ((((drrr_rf_data->src_db_link_host=
   "DM2NOTSET")) OR ((((drrr_rf_data->src_db_link_port="DM2NOTSET")) OR ((drrr_rf_data->
   src_db_link_svc_nm="DM2NOTSET"))) )) )) )
    SET dm_err->err_ind = 1
    SET dm_err->eproc = "Validating response file source database credential/link data."
    SET dm_err->emsg = trim(evaluate(drrr_rf_data->src_db_cred_nm,"DM2NOTSET","SRC_DB_CRED_NM,"," "),
     3)
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->src_db_link_host,"DM2NOTSET",
       "SRC_DB_LINK_HOST,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->src_db_link_port,"DM2NOTSET",
       "SRC_DB_LINK_PORT,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->src_db_link_svc_nm,"DM2NOTSET",
       "SRC_DB_LINK_SVC_NM,"," "),3))
    SET dm_err->emsg = concat(dm_err->emsg,trim(evaluate(drrr_rf_data->src_db_link_cnct_desc,
       "DM2NOTSET","SRC_DB_LINK_CNCT_DESC,"," "),3))
    SET dm_err->emsg = trim(replace(dm_err->emsg,",","",2),3)
    SET dm_err->emsg = concat("Response file source database credential/link data must be set ",
     "when Source (",drrr_rf_data->src_db_deploy_config,") or Target (",drrr_rf_data->
     tgt_db_deploy_config,
     ") is autonomous database (ADB).  Token(s) not set: ",dm_err->emsg,".")
    CALL disp_msg(dm_err->emsg,dm_err->logfile,1)
    RETURN(0)
   ENDIF
 END ;Subroutine
 DECLARE ddrd_cont_rep = i2 WITH protect, noconstant(1)
 IF (check_logfile("dm2_dom_ref_drv",".log","dm2_domain_refresh_driver")=0)
  GO TO exit_program
 ENDIF
 IF (dcl_check_lang(null)=0)
  GO TO exit_program
 ENDIF
 IF ((dm_err->debug_flag=722))
  SET message = nowindow
 ELSE
  SET message = window
 ENDIF
 SET width = 132
 SET ddr_domain_data->process = "REFRESH"
 WHILE (ddrd_cont_rep=1)
   SET message = window
   CALL clear(1,1)
   CALL box(1,1,24,131)
   CALL text(2,2,"Domain Refresh Menu")
   CALL text(4,10,"1. TARGET Data Collection")
   CALL text(6,10,"2. SOURCE Data Collection")
   CALL text(8,10,"3. TARGET Domain Refresh")
   CALL text(10,10,"4. TARGET Registry Sync Up")
   CALL text(18,10,"Your Selection (0 to Exit)?")
   CALL accept(18,38,"9;",0
    WHERE curaccept IN (0, 1, 2, 3, 4))
   CASE (curaccept)
    OF 0:
     SET ddrd_cont_rep = 0
    OF 1:
     SET message = nowindow
     EXECUTE dm2_get_tgt_domain_data ddr_domain_data->process
     IF ((dm_err->err_ind > 0))
      GO TO exit_program
     ENDIF
    OF 2:
     SET message = nowindow
     EXECUTE dm2_get_src_domain_data ddr_domain_data->process
     IF ((dm_err->err_ind > 0))
      GO TO exit_program
     ENDIF
    OF 3:
     SET message = nowindow
     EXECUTE dm2_domain_refresh ddr_domain_data->process
     IF ((dm_err->err_ind > 0))
      GO TO exit_program
     ENDIF
    OF 4:
     SET message = nowindow
     EXECUTE dm2_reg_sync_up
     IF ((dm_err->err_ind > 0))
      GO TO exit_program
     ENDIF
   ENDCASE
 ENDWHILE
#exit_program
 CALL clear(1,1)
 SET message = nowindow
 IF ((dm_err->debug_flag > 0))
  CALL echorecord(ddr_domain_data)
 ENDIF
 IF ((dm_err->err_ind=0))
  SET dm_err->eproc = "Dm2_domain_refresh_driver has completed"
 ENDIF
 CALL final_disp_msg("dm2_dom_ref_drv")
END GO
